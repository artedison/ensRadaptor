!
!=====================================================================
! Kinetics Network Ensemble Monte Carlo Code "ens.f90"
!=====================================================================
! H.-B. Schuttler
! Department of Physics and Astronomy
! University of Georgia
! Athens, GA 30602
! E-Mail hbs@physast.uga.edu
!=====================================================================
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      program mp_ens
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! Performs Monte Carlo simulation over an ensemble of
! kinetic rate equation models for arbitrary fixed-topology
! reaction networks
! 
! NEXT:
! 1) Add better ATOL for DLSODES, based on initial deriv *(time1-time0)
! Likewise for ARK if poss?
! 
! 2) Add options to suppress read-in of "dead" inp. in "idat" esp. 
! in move sched.
! 
! 3) Tabulate jfunc for all dependency names by name look-up, 
! prior to  MC / ODE execution.  Then use only tabltd. num. jfunc-values
! during MC / ODE execution.
!
!
! VERSION/' V. 190527-2227'/
! Correct bug(?) in ark_ksol count.
!
! VERSION/' V. 190526-1704'/
! Added bypass of ODE solver calls in "adodes" when rate fct call limit is 
! exceeded (n_drv > nlim_drv).
!
! Also corrected zero initialization of k_drv, in "adodes"
!
! Also added ith_upd output for Min ChiSq output blocks and
! added marker "End Of Sweep"" for end-of--sweep output blocks 
! in o02, etc.
!
!
! VERSION/' V. 190526-1325'/
! Corrected storage error for "nplimd" in move_cs1, move_rk1,
! move_thu, move_cs1_blk, move_rk1_blk, move_thu_blk, move_ham.
! (was already implemented at 190525-2337).
!
!
! VERSION/' V. 190524-2244'/
! Add rate fct call limit = max number of allowed "drivs"-calls
! per ODE soln, "nlim_drv", with MC rejection of proposed theta, 
! if "nlim_drv" is exceeded. Add "nlim_drv" as new input in i01,
! by setting new input nlim_all=-1, then read in nstp_ark & nlim_drv
! from a new input line.
! 
! Add "jo_th_lmdrv" as new input in i01, to enable more detailed
! output stats for rate fct call limit events (n_drv>nlim_drv).
!
! Also corrected error of missed "jo_th_mchi==1" option install,
! in "odat_acc", from V190516-1747.
!
! Also consolidated V181020-1414 with divergent code versions 
! genetared after V181009-1743, incl.:
!    190219-1941, 190503-2139, 190516-1747, 190517-1459, 
! see below.
!
!
! VERSION/' V. 190517-1459'/
! Corr. error in funcdpen, jfunc==43, from V190503-2139: 
! added goto 990 (Y.Wu)
!
!
! VERSION/' V. 190516-1747'/
! Add ODE solver stats output, to enable ODE solver stats output for
! all iout_th blocks, incl. Min-ChiSq-blocks,  with jo_th_mchi==1. 
!
!
! VERSION/' V. 190503-2139'/
! Added dep. fct DO_HILL_REG
!
!
! VERSION/' V. 190219-1941'/
! Added dep. fct DO_CUTLIN
!
!
! VERSION/' V. 181020-2142'/
!:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
! Add variable topology options for allosteric regulatory links
!:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
! UNDER CONSTRUCTION/LATER>
!
! Strategy:
! 
! 1) Define single dep'cy, e.g.,  DO_REG_ALLO,  w/ inputs:
!    nRegPool, nRegAct
! and:
!    E0 = bare (unreg) enzyme conc., 
!    alpha_k=reg exponent,  
!    x_k= integer (binary) on/off variable for reg. link 
!    c0_k = regulator reference (e.g. initial) conc.
! for each regulator k=1,...,nRegPool
! 
! 2) Make topology move subrt: move_top_switch
!    to switch reg link on->off, off->on between a pair of active and inactive regs,
!    so as to keep total no. of active reg links in the pool constant at nRegAct
! 
! 3) Declare all x_k as "topology" theta variables (=integer) by 
!    jctspec=2
! 
! 4) For all x_k (theta w/ jctspec=2) provide ipm inputs in i01 for ivpm=1,2,3,4,6,7:
!    ivpm=1: theta_lo
!    ivpm=2: theta_hi
!    ivpm=3: theta_step
!    ivpm=4: theta_ini
!    ivpm=5: theta_tru
!    ivpm=6: id_theta_pool
!    ivpm=7: nRegAct_theta
! 
! Use id_theta_pool to identify all members of the pool.
! 
! Use nRegAct_theta to limit number of active reg pool members (:= having active link to regulee)
! 
! Allowed range of integer x_k comprises all integers from interval [theta_lo, theta_hi].
! So, for binary, 
!    x_k = 0, 1, 
! set, e.g.:
!    theta_lo = -0.3,    theta_hi = +1.6.
! 
! 5) If any alpha_k or c0_k is declared as theta-variable, exclude it
! from MC moves, i.e., "freeze" its value, while link to reg. #k is tuned off.
! 
! <UNDER CONSTRUCTION/LATER
!:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
!
!
! VERSION/' V. 181020-1414'/
! Syntax errors corrected in V181009 by Yue Wu in
! subr. func_dpen_lo for jfunc.eq.35 and jfunc.eq.36
!
!
! VERSION/' V. 181009-1743'/
! Added dep. fct DO_YPOS; y=x *Theta(x):   y = x if x>0, else y=0
! Added dep. fct DO_YNEG; y=x *Theta(-x):  y = x if x<0, else y=0
! Added dep. fct DO_MINUS; y=-x
!
!
! VERSION/' V. 180810-0051'/
! Added option jfix=-110 for t-evol dependent species to be used
! as reactants in rate fct "drivs". The t-evol dependent species
! with jfix=-110 are evaluated on the fly by new subr. "get_rdpen"
! and "get_rparn", called from inside "drivs".
!
! Split "func_dpen" into "func_dpen_lo" and "func_dpen_hi" so that
! "func_dpen_lo" includes instantaneous fct'nal dependencies (jfunc<500);
! "func_dpen_hi" includes non-instantaneous dependencies (jfunc>=500).
! Only "func_dpen_lo" is called from "drivs" via "get_rdpen".
! Thus non-instantaneous dependencies (jfunc>=500) are not allowed
! for t-evol dependents with jfix=-110; jfunc>=500 only allowed for jfix=-100.
!
! Added additional consistency checks of dependency declarations
! in "set_fix_dpen".
!
! Added option for rational fct dependency in "func_dpen_lo":
! DO_RATFUNC((PM1-PM2)/PM3).
!
!
! VERSION/' V. 091228-1838'/
! Installed in "func_dpen" first-order linear integral (FOL) ODE soln
! for dependent no-feedback first-order linear rate eq. species;
! implemented for: (a) generic FOL; (b) two-state gene regulation with
! Multiplicative-AND (MAND) logic; (c) transcription/translation (S/L)
! with Additive-OR (AOR) logic for production and degradation.
!
!
! VERSION/' V. 091029-1758'/
! Including changes from recent divergent code updates:
! From V. 091029-1725:
! changed subrt. "accp_move" to unconditionally force one call
! to RNG "randx" for each call to "accp_move", regardless of
! the sign of proposed energy (chisq) change dE. This is
! done in order to eliminate previous RNG-state- and
! MC-trajectory-sensitivity to rounding errors for
! "nearly energy-neutral" (NEN) updating events where dE
! is of order of, or less than, the energy rounding error and
! hence the sign of dE is rounding-error-dependent. [History Note:
! this change was originally already included and documented
! in V. 090908-1801, but for unknown reasons (perhaps accidentally?)
! was later reversed again, resulting in code with prior version's
! NEN/rounding-sensitive RNG call sequences.]
! DONE!
! From V. 091001-2225
! Changed all MPI_SEND to MPI_SSEND for "safe programming"
! i.e. to force synchronized communications without use of buffering
! DONE!
!
! VERSION/' V. 090927-2050'/
! Added option to jmvsched=100, jrpwgt=2 for Boltzmann-weighting
! MC repeats, with weight factors
!   amwgt_rep=exp[-(am_chisq_th-am_chisq_min)/temp_repav]
! with am_chisq_min=min[am_chisq_th(imc_rep)] and averaging
! temperature temp_repav
! DONE!
!
! Added MC sim. temperature factors (temp_mc, etc.) in
! phi-matrix and psi-vector in "move_dconv"/"get_mat_dcon",
! to allow for non-unit sim. temperature
! DONE!
!
! VERSION/' V. 090926-0257'/
! Added option jmvsched=100, jrpwgt=1 to select/suppress MC
! repeats from overall MC averages if their am_chisq_th is
! out of a specified range am_chisq_[lo,hi]
!
! Added option for hi-precision (18 signif. digits) output
! of theta-vars (cspec_th, rreac_th) into o02-file, by
! setting input jo_th_dprec=1 where jo_th_dprec is entered
! as 100-digit=3rd digit of jo_th_opt2, e.g.
! jo_th_opt2=123 sets jo_th_dprec=1; jo_th_opt2=011 sets jo_th_dprec=0
!
! VERSION/' V. 090912-1320'/
! Added option to turn on/off e-vector/e-value quality checks in
! "store_pbarev_dcon" for speed-up, with input option parameter
! "jdcckev" added in i01; jdcckev=0:all off, =111: all on
!
! VERSION/' V. 090911-2013'/
! Added read-control "mp_qini/mp_qfin" at end of "form_xpt", to
! avoid fatal I/O conflict from multiple Svs reading/writing
! from/to o09.
!
! Moved i02-read-control calls to "mp_qini/mp_qfin" inside
! "idat_xpt", instead of "get_xpt", to speed up formatting
! of i02-data with parallel execution of "form_xpt"
! (reason: execution of "form_xpt" can take sev. minutes
! for large data sets, i.e., hours when done serially
! by each Sv process).
!
! Fixed bug in expanded storage array access for iexpt-dep.
! children; introduced separate array dimension "mdpen_tot_x"
! for such exp.-exp. stortage "lcrdp" arrays:
!   crdpen, am_crdpen, ar_crdpen, dr_crdpen, iexpt_crdp(renamed)
! large array size "mdpen_tot_x" is then needed only for
! for these lcrdp-arrays; all other idpen-arrays can be sized with
! smaller dim. "ndpen_tot_x"
!
! Deactivated all "xd"/"xdi"-related arrays/array access and
! reduced all their array-dims to "1:1" in ens.def, to save storage
!
! VERSION/' V. 090911-0044'/
! Fixed/removed several non-fatal illegal continuation line markers
! (apparently ignored by xlf90 on pcluster, but detected by OpenMPI
! mpif90 on rcluster).
!
! VERSION/' V. 090910-0259'/
! Fixed fatal bug in array "jmp_isend" and "ens.def": ireq-dimension
! must be set to "mp_nreq_x*mp_nproc_x"; "jmp_isend" was erroneously
! dimensioned only to "mp_nreq_x" which caused array boundary violations
! of "jmp_isend", using "ireq=mp_ireq(mp_svid,namreq)"-function output.
! Also, "jmp_isend" is then used as 1-dim. array: "mp_iproc"-dimension
! is not needed, since "mp_ireq"-output already combines index
! "mp_isid==mp_iproc-1" and "namreq" into a single 1-dim. index.
! Bug was conditionally fatal only if no. of processors mp_nproc
! exceeded mp_nreq_x/2.
!
! VERSION/' V. 090908-1801'/
! Fixed fatal bug in "move_rk1_blk" in ith_up-drawing: added new
! random no. assignment "r1=randx(x)" which had been erroneously
! omitted, resulting in severely distorted distribution of
! ith_upd-draws [skewed towards very last reac.-theta; since
! prior r1-value is randx()*mthb_tot>1].
!
! VERSION/' V. 090907-1833'/
! Added deconvolution amplitude updating along e-vector directions
! directions of the restoring-force-matrix of chi^2:
! jmt_amd==jmty_ampdc=18
!
! VERSION/' V. 090831-0232'/
! Added Gaussian pulse train options jfix=30,31,5030,5031
!
! VERSION/' V. 090826-1440'/
! Inserted into last finished V.090615-0132 (ens_070.009.002.006)
! all new code segments from previously unfinished V.081109-2205
! (ens_070.009.003) in order to:
!--- add long-format expanded control jmty-entry from i01 in idat;
!--- add select-theta-block MC updating, via long-format jmty entry;
!--- add Gibbs sampler Gaussian updating of linear NMR spectral
!    deconvolution amplitudes as new move type jmty=20;
!--- add Gaussian randomization of scale factors.
!ALL DONE:
!---------------------------------------------------------------------
!-- Check+finish missing coding in
!       idat, move_***_blk
!DONE!!
!-- Add lin. SF (and later log. SF) gaussian randomization option
!   Add check in set_fix_rasf so that each SFC consists purely
!   either *only log-ims-species* or *only lin-ims-species*
!   (i.e. must not have mixed log-ims and lin-ims data pts in same SFC)
!DONE!!
!-- Add SF randdmzn calls (to: sum_chi_[u,w], store_chi)
!   at start and fin. of all "move_..." subrts.  if
!   jrasf_ctl=2 set for that jmvty;
!   Also jrasf_freez=1 must then be set during get_chi for
!   proposed new Theta, so SFs are kept fixed during MC move of Theta;
!   then reset jrasf_freez=0 after accept/reject completed.
!DONE!!
!-- Also add check: if jrasf_ctl=2 is used in *any* jmvty,
!   then jrasf_ctl=1 or 2 must be used in *all* MC-type moves;
!   oth/wise ensemble prob. would be different/inconsistent
!   in diff. move types (b/c sxplin_avg|=sxplin_chi).
!DONE!!
!-- Add calls to gen. theta-block moves and to Gibbs moves
!   into mc_mvtype
!DONE!!
!-- Add output of iexpt-expanded child var. counts to o02-header:
!      mdpen_tot, mdpen_reac, mdpen_spec
!DONE!!
!-- Add ouput of all new theta block and Gibbs move control array sizes:
!   lblkth_tot, kthblk_tot, kpmblk_tot, lrasf_tot
!   ldconr_tot, ldconp_tot, ldconfz_tot, kampdv_tot, kampdu_tot, ...
!   to o02-header
!DONE!!
!-- Add arrray-lim error checks for "difference label" variabs like
!   idconr, iampdu, ...etc.
!DONE!!
!-- Correct: Re-store xspec_tsxdc!!
!   Note: real species ispec may not be declared "observed" species
!   [jmsspec(irspec)>0] and/or may not be calculated in kin_xpt
!   at exactly the same obs. times txpt, as corresp. pseudo-species ipspec,
!   for which xspec(ispec, itxpt) is needed at times time_xpt(itxpt).
!DONE!!
!-- Replace "mth_spec,_reac,_tot" by "mthb_spec,_reac,_tot"
!   in "mc_mvtype, for local and random-unit-sphere global moves
!   (move_cs1,_rk2,_thu)
!DONE!!
!-- Chg. input line order for stride ctrl to:
!     ipm_str jipm_str ispre_str jispre_str
!DONE!!
!-- Chg. randx-call pattern in "accp_move" to 1 randx-call per
!   accept/reject step, regardless of chisq-up- or chisq-down-move
!   so that rand.no. usage in proposal steps becomes indep. of accpt/reject
!   of prior moves. This will stabilize MC trajectory against very small
!   rounding error fluct in chisq-calc, for all move types using "accp".
!   This will allow  for easier comparison of new code vs. old code in
!   debugging applications.
!DONE!!
!--Fixed bug: missing factor "-2.d0" for chisq_g1t-coeff in "chi_accu"
!DONE!!
!--Fixed fatal bug in "kin_noi" in virt. expt. data generation:
!  added calc. of xspec_wid from yspec_wid in "kin_noi".
!DONE! 090811-1802
!--Fixed fatal bug in "set_vxpt" in virt expt. obs. time tabulation:
!  In virt. expt. simulations, i.e., for 100=<jxpt<200,
!  array "itxpt_tmx(itmx)" was (erroneously) not tabulated.
!  Installation of this tabulation was apparently forgotten
!  in "set_vxpt" when itmx-labels were introduced in serial
!  version 050611-0040 (ens_54). This bug would manifest itself
!  if/when "xspec_chi" was stored in subprg. "kin_xpt".
!  For virt. expt. simulations with
!    jmsspec_px(ispec)|=0
!    OR
!    ((jtime=11,19,21,111,119,121,211,219 OR 221)
!    AND jfix(ispec)|=-100
!    ),
!  see subprg. "kin_xpt", this bug had no effect, since "itxpt_tmx"
!  was not accessed, e.g., b/c obs. times txpt were embedded in ODE
!  solver time-grid and therefore not used in "kin_xpt".
!  For real expt. simulations (jxpt=1) this bug also had no effect,
!  since "itxpt_tmx" was correctly  tabulated in "form_xpt".
!DONE! 090812-2355
!--Re-inserted missing prior version comments, from
!   version 050326-1840 thru version 050611-0040.
! The re-inserted prior version comments below were still
! present in
!    serial version 050803-2045 (ens_59),
! but inexplicably absent from all subsequent serial and
! parallel versions, starting with 051216-1205 (ens_60).
! Re-inserted comments below are copied from 050803-2045 (ens_59).
!DONE! 090813-0134
! To Do:
! ------
!-- Test lin. NMR spectral deconvolution amplitude updating jmty=20 !!!
!-- Add ascending ordering option for kpmb-blocks!!!
!
! VERSION/' V. 090615-0132'/
! corrected bug in subprgr. "drivs": fmm was declared real*8 twice,
! due to modification from prev.version (earlier versions not affected)
!
! VERSION/' V. 090419-1930'/
! Installed generalized higher order (multinary) enzyme-reactant
! MM kinetics option jkin=41, with multiple competing enzyme-reactant
! complexes.
!
! VERSION/' V. 081225-1429'/
! --Installed itime-storage option jsto_itsib to control whether
! DOSIB ouput value is stored in child species xspec(...,itime)
! for all time grid points itime. Available now for all DOSIB
! functions: jsto_itsib=pmfunc(2) will be set for each sibling
! w/ mparn>=2, else use jsto_itsib from previous sibling. Default
! starting value (isib=1) is jsto_itsib=1.
! jsto_itsib=0: itime-storage off, store value only in crdpen;
! jsto_itsib=1: itime-storage oon, store value both in crdpen
!               and in xspec(...,itime) for all itime.
! --Modified pmfunc assignment for DOSIB oscillation
! analyzer with increased mparn=13 to accommodate
! itime storage control for iparn=2; all other pmfunc-inputs
! moveed to next higher iparn=3,4,...13.
! --Added option to vary lower integration limit in
! DOSIB_INTEGRATE_... functions by setting mparn>=4;
! it will then use
!   t_lo==pmfunc(3) as lower integration limit;
!   t_hi==pmfunc(4) as upper integration limit.
! Also added option to calculate time average, instead of
! just time integral, over interval [tint_lo,tint_hi],
! by setting mparn>=5 and pmfunc(5)==1.
! Definite time integral or time avg. over interval [tint_lo,tint_hi],
! will be calculated for and stored in crdpen only, whereas t-dependent
! child species xspec(...,itime) will store the integral over
! [time0,time_itim(itime)], regardless of mparn and pmfunc(3)-pmfunc(5),
! provided jsto_itsib=1 is specified by pmfunc(2) or by default.
!
! VERSION/' V. 081121-2310'/
! added DOSIB options to calculate oscillation period,
! damping, amplitude and phase shift from t-dep. species conc.
! xspec within a specified time interval.
! added depedency DO_FOURGD to evaluate generalized damped
! finite Fourier sum
! corrected coding error in get_xdpen: use jfunc_sib, not jfunc
!
! VERSION/' V. 081108-1105'/
! inclusion from branch V.080526-0116:
! added new leaking ribosome translation model version as
! DO_LRIBO_L_V2, DO_LRIBO_S_V2 functions by X.Tang.
! These funtions do not normalize total translation probability
! to unity, i.e., they allow for finite probability of
! "no-translation" events where ribosome passes both translation
! initiation sites (L and S) without beginning translation.
! inclusion from branch V.081018-1547:
! changed output format in odat_ar to get 10 sign.-digit
! outputs for ar_yspec and ar_xspec
!
! VERSION/' V. 081004-1823'/
! Corrected bug in restart control when jmc_eql>=10:
! after completion of restart read-in from o02,
! jmc_inir needs to be re-set to i01-input value
! and mc_ini_m etc. to be re-executed if restart
! read-in is completed on last sweep of a repeat
!
! VERSION/' V. 081003-1804'/
! corrected bug in "DO_ABSOLUTE" function in func_dpen
!
! VERSION/' V. 080116-0947'/
! fixed input data rescaling (xtx=,wtx=) in cprs_accu
! to include glob_scal-factor, along with zscal, so
! that re-scaling in cprs_accu is consistent with
! re-scaling done in form_xpt.
!
! VERSION/' V. 080113-2219'/
! add reaction rate and integrated flux calc. as possible
! dependents for t-evol. child functions (jctspre=20)
!
! VERSION/' V. 080112-0300'/
! added non-coop MM kinetics with multiple competing
! substrates for NMR metabolomics simulations;
! fixed small compile bug ")" in func_dpen, jfunc=191, 192
! fixed bugs from/deactivated "xdi"-related code;
!
! VERSION/' V. 071204-1455'/
! added abs-value(s) and rounding error handling
! into DO_LRIBO_L, DO_LRIBO_S functions
!
! VERSION/' V. 071113-1335'/
! add functions for calculating Temp-dependent
! translation rate coeff. in leaking ribosome model.
!
! VERSION/' V. 070609-1405'/
! Quick fix of jmp_kin=2 bug:
! Fixed by calling get_chi in mc_accu_m with jmp_kin=1
! to calculate and return to Mr all chisq-related arrays,
! then calling mpm_getkin with jmp_kin=2, as before,
! to calculate and return to Mr xspec-related array.
! This fix still requires 2 kin-solutions per mc_accu_m.
!
! Better fix, later: fix the Sv's packing dims. and packing ops.
! so that both chisq- and xspec-related arrays are sent to Mr
! for jmp_kin=2. This will then require only 1 kin-sol. / mc_accu_m.
!
! VERSION/' V. 070324-1025'/
! Fixed MPI memory exhaustion error:
! 1) Inserted debug stmts and mofidied mp_DB_fx
! to produce 4 cycling diagnostics output files
! ens.o09<-->ens.p09<-->ens.q09<-->ens.r09<-->ens.o09
! to force runtime sync of the diagnostic output
! w/out re-read/write of growing diagn. output file
! 2) Added send/recv counting + comm stats output
! 3) Changed all calls of MPI_SSEND to MPI_SEND: has no effect
! 4) Fixed MPI memory exhaustion error by adding
! MPI_WAIT calls for each posted MPI_ISEND:
! by installing calls to new subpgrs. mp_wait_isend, mp_count_isend
! mp_ini_isend, mp_fin_isend
! required to free up MPI resources tied up by MPI_ISEND ops.
! 5) Fixed o09-output/efile bug for mp_myid>=1, nproc>=2.
! 6) Commented out debug stmts.
!
! VERSION/' V. 070313-1335'/
! Removed systematically all instances of "status='new'"
! from all "open" stmts.
!
! VERSION/' V. 070207-1745'/
! Removed "status='new'" from one "open(31,...status='new')
! as suggested by Shy-Xia Zhang(SXZ),UMN, to get rid of
! runtime crash due to file opening error (errmsg. re "unit 31")
! Cause of this error -- or its remedy -- currently
! not understood. See line(s) bracketed w/
!  "!BLADE:...!:BLADE"
! for modifications made
!
! VERSION/' V. 070205-1538'/
! added own random number generator (RNG) subprgs.
! to improve code portability, w/ options
! jrand=1: Fibonacci+Arithmetic RNG (Marsaglia et al.)
! jrand=2: Mersenne Twister RNG (Matsumoto et al.)
!
! VERSION/' V. 061210-1407'/
! Code conversion from F77 to F90, maintaining easy
! back-convertibility to F77: all lines have
! max. 72 char length; 6 char line prefix; line
! continuation pre-marks set in 6th char-position to '&';
! max. 4-digit stmt. labels set in 2nd-5th char-positions;
! full-line comment marks set in 1st char-position to '!'.
!
! MPI paralleliztn of iexpt-loop in KinSolver, as queued
! Master/Slave (Mr/Sv) algorithm. Former serial KinSolver
! get_kin renamed to mpm_getkin in Master (Mr) code
! and mps_getkin in Slave (Sv) code. Mr code mpm_getkin
! (+subs) does both work-to-Sv assignmt+retrieval (W2SAR) and
! Sv-type kinsolver processing, to maximize CPU utiliztn
! of the Mr processor on low-processor systems where
!     no. of processors "mp_nproc" =< no. of expts. "nexpt".
! W2SAR is queued 1st-come-1st-serve w/ priority to non-busy
! Svs: Mr does kinsolver work only when all Svs are busy.
! Ideal processor no. for ~linear parallel speed-up is
!     mp_nproc = nexpt or nexpt+1.
! No further speed-up achieved by using mp_nproc>nexpt+1.
! Maintaining easy re-serializtn by out-commenting
! all calls to subpgs. named "MPI_..." and "use mpi" stmt.
! in ens.def
!
! Naming Rules:
! MPI-related user-supplied subpgs are named
! "mp_..."   if jointly executed in Mr+Sv code
! "mpm_..."  if executed only in Mr code
! "mps_..."  if executed only in Sv code
! "MPI_u..." if subpg. to be out-commented in re-serializtn.,
!            regardless of execution status (Mr,Sv,Mr+Sv)
! MPI-related control+communication vars and arrays are named
! "mp_..." or "jmp_..." or "lmp_..."
!
!
! VERSION/' V. 060911-2016'/
! added option jwwgt_dtspec>0 and subprgs. wwgt_xpt etc.
! to window-reweight exptl. i02-data pts. from input
! data density to a user-spec. target data density
! (data/time interval)times user-spec. window-reweight factor;
! added option jcprs_win=-1 in exptl. data compression
! routine "cprs_xpt" to exclude all data pts in any window
! of any species input block from local (single-block) or
! global (all-block) data compression; same exclusion
! option jwwgt_win=-1 available for data reweighting;
!
!cc NEXT:
!cc   Implement selected other new options from ens_69a,b
!
! VERSION/' V. 060813-1455'/
!  2nd minor change in idat (see "goto 590") to get i01-compatible
!  o01-output if iexpt=9999999 in nsegft input block
!  added deactivation of pre-existing ens.stop-file in ostart
!
! VERSION/' V. 060811-2022'/
!  minor change in idat (see "goto 590") to get i01-compatible
!  o01-output if iexpt=9999999 in nsegft input block
!
! VERSION/' V. 060805-1335'/
!  added option iexpt=9999999 in idat nsegft-input
!  block to skip nsegft input block read-in
!  and modified output to o01 if nsegft block is skipped
!
! VERSION/' V. 060803-1652'/
!  added absolute-value function in func_dpen
!
! VERSION/' V. 060801-1522'/
!  fixed bug in move_rk1 to use "stepreac" (not "stepspec"!)
!  for reaction-dtheta calc.; bug was first introduced
!  in V.040806-1830; affects MC equil. only if
!    mth_reac>mth_spec;
!  if so: reaction-Theta variabs. with ith_reac>mth_spec
!  will not be updated (dtheta=0) and ahve raccp=1.
!
! VERSION/' V. 060730-0832'/
!  fixed minor array boundary violation bug in odat_acc
!
! VERSION/' V. 060419-2257'/
!  improved error diagnostic output from "upd_tifodes";
!  fixed non-fatal minor bug in "ini_tifodes";
!  added accumulation record output "odat_acc",
!  written during score accumulation into "ens.o05"
!
! VERSION/' V. 060206-0737'/
!  added output option "jo_th_mine" to generate "o02"-output
!  of model parameters required as input by MINE code; consists
!  of nexpt lists of direct kinsolver input species and reaction
!  ipm-variables, collated to include both theta-variables
!  and dependent variables, in order of increasing ipm, exluding
!  all ipm-variables that are not direct kinsolver input and
!  excluding jctspre=100 or jctspre=200 control parameters.
!
!  added "o02-re-write" option jmc_ini=361 to read a complete,
!  old ens.o02-file, copied to ens.i12, and re-write it, in
!  a new format (jo_th_...=...) into new ens.o02.
!  without performing any kinsolver, MC or accumulation
!  operations
!
! VERSION/' V. 051220-2355'/
!  added opion jkin=30 to do Poisson polymerization kinetics
!
! VERSION/' V. 051216-1205'/
!  added 3 new dependency options "LOOK4_PM_IEXPT",
!  "LOOK4_PM_ICLASS_FIX_IEXPT" and "LOOK4_PM_ICLASS_VAR_IEXPT",
!  to assign value of parent no. "iexpt" as the value of the child
!  or value of parent no. "iclass(iexpt)" as the value of the child;
!  added option for automatic construction of "ipm"-lists,
!  "iparn"-lists and "jdokin"-vector-lists, using "short-hand blocks"
!  in ens.i01.
!
! VERSION/' V. 050803-2045'/
!  corrected fatal bug in skip/do-kinsolver
!  control mechanism in get_kin, kin_ini, kin_run,
!  by installing new subprg. "reset_yspec_expt"
!
! VERSION/' V. 050802-0055'/
!  added polynomial and exponential of polynomial
!  dependency function options in "func_dpen":
!  DO_POLYNOM((PM1-PM2)/PM3), DO_PM4*EXP_POLYNOM((PM1-PM2)/PM3);
!  added "skip/do kinsolver" option for Theta parameters not
!  affecting the kin-solution for all expts. "iexpt";
!  added option ipm=-217 in "get_xdpen":
!    pmfunc(iparn)=time1-time0 ;
!  removed special options for 10000=<nperiod=<19999, jfix=0
!  see V. 050629-1850: not useful/practical;
!
! VERSION/' V. 050726-2255'/
!  changed call to "XSETF" in all kin_sol_... routines
!  to suppress all DLSODES error output. Note: DLSODES
!  error output to ens.o01 after "call efile" can seriously
!  slow down the code when ens.o01 becomes very large.
!  ALso, DLSODES error output is not needed by user;
!  output of "abd..." diagnostic in "ens.o02" is sufficient
!  to check on performance;
!  corrected error message output in "func_dpen"
!
! VERSION/' V. 050629-1850'/
!  added options for alternative input format dot-product
!  in "func_dpen";
!  added option to have iexpt-dependent species initial
!  concentrations (if 10000=<nperiod=<19999 for jfix=0)
!  in "idat" and "kin_ini"
!
! VERSION/' V. 050624-1850'/
!  changed cspec_th,rreac_th read-in from ens.i12 in "idat_inipm"
!  to allow over-reading of excess trailing cspec_th or rreac_th
!  values (due to model Theta reduction)
!
! VERSION/' V. 050623-1050'/
!  added option jwgt_wd=1 to reweight exptl. data pts. in chi^2
!  with separate user-specified weight factors: by expt. (iexpt)
!  and meas. species (ims) and time range (itxpt)
!
!  added option to calculate partial chi^2 and output results
!  to o02 via odat_th (setting jo_th_wg=2 or 3), with
!  chi^2 partioned as follows:
!    by expt.: chisq_xp
!    by meas. species: chisq_ms
!    by meas. species+expt: chisq_msxp
!    by exptl.time: chisq_tx
!
!  added counter "mdtin_raw" to count all non-excluded "raw"
!  exptl. data pts. read in from "ens.i02" by "idat_xpt", prior
!  to exptl. data binning+averaging (if any) in "cprs_xpt";
!  output of "mdtin_raw" is written into "ens.o01+2": needed
!  to count "raw" data pts. when binning+averaging is turned on
!
! ------------------------------------------------------------------
! Re-insertion of missing prior version comments>>>
! ------------------------------------------------------------------
! The re-inserted prior version comments below were still present in
!    serial version 050803-2045 (ens_59),
! but inexplicably absent from all subsequent serial and
! parallel versions, starting with version 051216-1205 (ens_60).
! Re-inserted comments below are copied from version 050803-2045
! ------------------------------------------------------------------
!
!c VERSION/' V. 050611-0040'/
!c  re-defined exptl. data arrays "xspec_xpt(ims,itxpt,iexpt)" etc.
!c  with single integer label reference, e.g. "itmx-->xspec_xpt(itmx)"
!c  where "itmx=itmx_xpt(ims,itxpt,iexpt)" to save memory +
!c  cpu-time during chi^2-evaluation for large exptl. data sets;
!c
!c  added option jmsspec_px=1, for exptl. data set pre-summation
!c  to save more cpu-time during chi^2-evaluation for large
!c  exptl. data sets; to be used with exptl. t-pt.-linear
!c  interpolation (jtime=1,2,10,20,110,120,210,220); fastest
!c  pre-summation option: jmsspec=111--> _px=1, _ip=1, _ch=1
!c  (format: jmsspec=1000*_ft+100*_px+10*_ip+1*_ch)
!c
!c VERSION/' V. 050608-2300'/
!c  added option parameter jmsspec_ip=1, for linear interpolation of
!c  log-conc. values at exptl. t-pts.; changed input format of jmssspec
!c  to: jmsspec=1000*_ft+10*_ip+1*_ch; changed weights for
!c  lin-conc. exptl. data pts. (jmsspec_ch=2) in chi_accu[u,w,t] to
!c  1/xspec_wid**2
!c
!c VERSION/' V. 050524-2200'/
!c  added options jtime=20,21,120,121,220,221 to merge "tpulse"
!c  t-points into  ODE solver grid and force continuous linear
!c  inter/extrapolation of t-dep. fixed species (jfix>1) across
!c  tpulse-intervall boundaries inside ODE solver to prevent
!c  discontinuity integration errors at tpulse;
!c  also allowed jtime=18,118,218 (former:10,110,210)
!c  and allowed jtime=19,119,219 (former:11,111,211) for debug;
!c  also modified/corrected fspec_ti for trapez. pulse train
!c  (jfix=10,11,5010,5011) so that pulse train is continuous
!c  at end of periodicity intervals (allow poss.
!c  discontinuity at end of periodic train);
!c  also fixed minor silent bug at end of "fixspec" and modified
!c  "fspec_ti" and "fixspec" to enable handling of jfix=1 species
!c
!c VERSION/' V. 050520-0155'/
!c  added LSODES ODE-solver and log-transform of species conc.
!c  variables w/ added options jtime=110,111 (= adaptive Adams)
!c  and jtime=210,211 (=adaptive backw. diff. ABD)
!c
!c VERSION/' V. 050430-1055'/
!c  built "jo_xspec" option to reduce no_time_x array size
!c  by omitting exptl. t-points from averaging and
!c  output arrays for t-dep. model species conc.
!c
!c VERSION/' V. 050427-1355'/
!c  fixed read-in bug in "idat_inipm" to force "ens.i12" read-in
!c  to continue to end-of-file, even if there are intervening
!c  corrupted output blocks.
!c
!c VERSION/' V. 050417-2120'/
!c  added "use ifport" stmt. in "ens.def" for compilation
!c  w/ Altix "ifort" compiler;
!c  changed "kin_xspec_o" to get more accurate avg. species
!c  conc. output when jfix>=5000 (as needed, e.g., for sharp,
!c  very-short-duration pulses).
!c
!c VERSION/' V. 050407-1750'/
!c  added exptl. data compression option and subprgr "cprs_xpt"
!c  to average exptl. data sets of high exptl. time (txpt) density
!c  over short txpt-intervals and then use those averages as
!c  "effective data pts." in ensemble chisq-calculation;
!c  also split off subprg. "form_xpt" from "idat_xpt" and changed
!c  "xspec_wid" calculation for jzwid=3 option, to avoid dexp-overflow
!c
!c VERSION/' V. 050404-1240'/
!c  added stride option for read-in from "o02" or "i12"
!c  for restart or rerun, using jmc_inii>100000
!c
!c VERSION/' V. 050403-1640'/
!c  fixed bug in "get_xdpen" created in V.050401-2140.
!c  added option jmc_ini=350 when using frmr. "o02" file from complete
!c  MC accumulation run as "i12" file to skip over all old "o02"
!c  data except for chisq_th and cspec_th and rreac_th; useful if
!c  other data in frmr. "o02" (e.g. no. and type of SFCs) are not
!c  compatible with the new run.
!c
!c VERSION/' V. 050401-2140'/
!c  added options ipm_parn=-205,-206,-207 for selecting
!c  parents of dep. species with jctspec=20, in "get_xdpen"
!c  corrected comments re pulsing schedule in "fspec_ti"
!c
!c VERSION/' V. 050326-1840'/
!c  modified jfix-code for jfix=10:
!c     now:    c=cpulse(0) for t=<tpulse(0) both for jfix=10 or 20
!c     before: c="near zero" for t=<tpulse(0) only for jfix=20;
!c  added option for exact calc. of ext. fixed t-dep. species
!c  conc. inside "drivs" subprg., as needed for short ext. pulses,
!c  for jfix>=5000;
!c  added option to limit no. of periods for ext. fixed t-dep.
!c  species to "nperiod", for jfix=11,21,5011,5021
!c
! ------------------------------------------------------------------
! <<<End of re-insertion of missing prior version comments
! ------------------------------------------------------------------
!
! VERSION/' V. 050215-1855'/
!  added capability to merge multiple t-dep. data lists for same
!  species (ispec) in same expt. (iexpt) which have been entered
!  as separate lists in "ens.i02" (e.g. when generated in  multiple
!  replicas of same expt.); fixed/added some error checks in ens.i02,
!  incl. e.g. non-recognition of exptl. input species names
!
! VERSION/' V. 050204-1156'/
!  fixed get_odpen to skip calculating exptl. output data values
!  for species w/ real exptl. input from "ens.i02";
!  built in read-in format error check+termination in "idat" for
!  "ens.i01" and in "idat_xpt" for "ens.i02";
!  fixed bug in jzwid=3 option in "idat_xpt"
!
! VERSION/' V. 041212-1555'/
!  added option jzwid=3 to enter abs. error for log-conc.
!  in "ens.i02"
!
! VERSION/' V. 041206-2355'/
!  added option for output list of final species conc.
!  at "time1" into "ens.o02" if jo_cfi=1
!
! VERSION/' V. 041119-1720'/
!  fixed bug in "idat_start" etc.: inconsistent read-in
!  of "chisq_th_min" and/or initilization of imove, after
!  re-start from prior "ens.o02" files for mixed PGE runs
!  (jmty=3000 ... 4999) with PST mutations: see test runs
!  w/ re-starts "PGE/r02" and "PGE/r03" on "pub1,2", by:
!  a) initializing chisq_th_min0=chisq_th_min already in
!     "idat_rstart"
!  b) re-setting ihtot_pst_ini=0 in "move_pst" if
!     jmtp_en=4 is set for the move
!  fixed bugs in "odat_tr_i": re-ordering of population
!  restart files after restart
!
! VERSION/' V. 040825-0010'/
!  fixed bug in "imove"-dependence of move-loop-variable
!  MC control parameters (like ftmp_imv, fstp_imv,...) in
!  all scheduling sch_..." subprgs.: now all such params.
!  are varied as fctn. of
!      "kmove=1,...nmove"
!  rather than "imove", since "imove" in gen. counts multiples
!  of nmove.
!
! VERSION/' V. 040824-0130'/
!  added population genetic+evolutionary (PGE) moves
!  "move_pge", move type options jmty=3000-4999;
!  added options raccp_lo=111, 112 in "mc_swopt":
!  will calculate accpt.ratios w/out updating fstp_swo,
!  and, if raccp_lo=112, will zero SWO accpt. counters;
!  introduced separate "inner" and "outer" move-loop
!  counters "imove" and "kmove" in "mc_mvsequ"
!  w/ "kmove=1...nmove" (strictly) and "imove" counting
!  each inner component separately, in a nested/multi-repeat
!  compound loops -- for simple compound loops imove=kmove.
!
! VERSION/' V. 040811-2150'/
!  fixed bug in rst_pst: initialization of npopst_sin
!  (only affects runs w/ inconsistent PST restart input)
!
! VERSION/' V. 040808-1550'/
!  fixed restart I/O bugs in
!  "idat_rstart"/"mc_mvtype" and "idat_tr_i,f"
!
! VERSION/' V. 040806-1830'/
!  added parallel sim. tempering (PST) updating moves;
!  using simultaneous Theta replicas at different temperatures;
!  added/changed restart I/O procedures for Theta-replicas;
!  changed/expanded move scheduling to allow for multiply nested
!  loops and multiply executed, sequential move sequences;
!  added multi-ipm inputs in "idat" for pmspec, pmreac etc.
!
! VERSION/' V. 040215-0051'/
!  changed code structure in "main", "mc_ini_r", mc_accu_r"
!  "mc_accu_m" to delay MC accumulation (incl. kin-solution for
!  MC accumulation of averages) until MC sample output
!  in "ens.o02" has been completed
!
! VERSION/' V. 040213-0051'/
!  fixed "idat" and "set_fix_dpen" and added "get_odpen"
!  to allow for dependent t-evolving exptl. output
!  species;
!
!  changed jctspec-labeling of t-evol. dep. species
!   jctspec(ispec,ipm)=20 <--> calc. avg.dep.model spcs.xspec, yspec
!   jctspec(ispec,ipm)=30 <--> calc. dep.exptl.species xspec_xpt
!   jctspec(ispec,ipm)=40 <--> calc. dep.exptl.species yspec_xpt
!  and now using parent labels
!   ipm_parn=-200...-299 for t-evol. model xspec-parent,jctspec=20
!   ipm_parn=-300...-399 for t-evol. xspec_xpt-parent,jctspec=30,40
!   ipm_parn=-400...-499 for t-evol. yspec_xpt-parent,jctspec=30,40
!
! VERSION/' V. 040208-1825'/
!  fixed "idat", "set_fix_dpen" and "get_xdpen"
!  to allow for dependent t-evolving model species
!  (with parent labels "ipm_parn=<-100").
!
!  added option for re-accumulation "jmc_inir=340+", using
!  prior "o02"-data to be read from "ens.i12", and new
!  "o02"-file to be written during execution.
!
! VERSION/' V. 040201-1355'/
!  fixed "idat_rstart" and "move_amb" so that "ihtot_amb"
!  counter gets initialed to last value before restart
!
! VERSION/' V. 040126-1705'/
!  changed MC accumulation and output of t-dependent
!  species so that _all_ species are averaged and
!  t-dependent average species concentrations are
!  written to "ens.o01", incl. those with jfix|=0
!
!  fixed bug in final Theta returned by "move_amb"
!  (missing Theta-reflection at lo-/hi boundaries)
!  and in chisq_msin checking in "htot_amlr"
!
!  added option jfix=-100 and "get_xdpen" for t-evol.
!  species concentration being a algegraic dependent
!  of other t-evol. species concentrations and/or
!  other pmspec and pmreac-parameters
!
!  changed input algorithm in "idat_rstart" to get proper
!  read-in from "ens.o02" at restart (jmc_inir=240+)
!  when Amoeba moves have been used.
!
! VERSION/' V. 031209-2330'/
!  updated Amoeba routines to do Theta-reflections of
!  at hi- and lo-boundaries, to avoid out-of-bounds
!  Theta being passed to chisq-routines;
!  added "DO_SUBTRACT_LIN,_LOG",  "DO_DIVIDE", and
!  "DO_POWER" options for parameter dependences;
!  added positivity enforcement for "vfor" and "vbak" in "drivs"
!  added xspec_[min,max] enforcement after ARK in "kin_sol_ads11".
!
! VERSION/' V. 031123-0130'/
!  added jct[spec,reac]=10: allow for dependent parameters;
!  changed j[fix,kin] input to
!    jpm[spec,reac]=npx[spec,reac]*10000+j[fix,kin]
!  to allow for extra ("npx....")species+reaction parameters,
!  e.g. to serve as parents for dependents;
!  also added ouput of code version no. into "ens.o01"
!
! VERSION/' V. 031123-0030'/
!  combined "rkfor", "rkbak", "rkfor2", "rkbak2"
!  into single array "rreac";
!  added jkin=2,3 options: allow for reactions
!  with non-integer multiplicity and/or non-integer
!  cooperativity
! VERSION/' V. 031113-1215'/
!  changed normalizations of outputs "ark_kstp(itime)"
!  etc. in "sum_arkabd"; added program interrupt command
!  calls "ck_stop_now" and "ck_stop_swp" to allow
!  user to send signals for controlled termination
! VERSION/' V. 031110-1855'/
!  fixed minor error in xspec_min,max limit checking
!  in "idat"
! VERSION/' V. 030713-1455'/
!  changed observed species conc. output
!  in "odat_ar" to suppress output of negative
!  species conc. (xspec=-1) for txpt w/out exptl. data;
!  built in error check for \Theta-lo-limit and -hi-limit
!  \Theta-ini and \Theta-tru inputs from "ens.i01"
! VERSION/' V. 030707-1830'/
!  modified rate limitation factors in "drivs" to allow for
!  proper handling of out-of-bounds species concentrations
!  (which can occur in  ARK solver);
!  modified ARK integration to include exptl. time pts.
!  as terminal grid points: eliminates need to
!  interpolate to exptl. time pts.;
!  corrected jkrxdi-assgnmnt. for XDI-fit at (re)start;
!  added option jmsspec=2 for ensemble weight with
!  lin.-conc. \chi^2-function
! VERSION/' V. 030703-0103'/
!  added adaptive Runge-Kutta (ARK) ODE-solver option;
!  fixed addressing bug in "set_four"
!  (tabulation of "isegxd_sft(is_ft,isegft,iexpt)")
! VERSION/' V. 030616-2320'/
!  modified FT-freq. filtering (FFF) to include
!  freq.-dep. filter reweighting "wfour_sfil",
!  species pair force-term "efour" to enforce uniformity
!  of FFF weights among different species, and
!  single-species and species-pair FFF contributions
!  "hfous" and "hfout" to "hfour";
!  fixed dimensioning bug in "xxdi"
!  fixed argument-list bug in call to "rkck"
! VERSION/' V. 030612-2230'/
!  added FT-freq. filtering / weighting
! VERSION/' V. 030525-0210'/
!  added interpolated exptl. data insertion in kin-solver to
!  get better (???) fitting capability
! VERSION/' V. 030515-2150'/
!  added xspec_max,_min boundary contact rejection (BCR) energies into
!  the MC weight function, with separate BCR force for each species
! VERSION/' V. 030511-2320'/
! fixed/added missing "anorm_r"-factors in calc. of
!  std.dev.  "dr_..."  inside  "mc_fin_r"
! VERSION/' V. 030320-2120'/
!  fixed bug in accumulation of avg. t-dep. species concentration
!  in "mc_accu_m"
! VERSION/' V. 020729-1920'/
!  added version "jmc_inir=142,143":
!  start with non-zero dos/histogram initialization
!  from "ens.i14" and Theta-initialization from "ens.i12"
! +added output "htot_ei_min,max", "iei_min,max" to "ens.o04"
! VERSION/' V. 020726-0020'/
!  added/corrected calls to "zero_dos"
! VERSION/' V. 020711-1814'/
!  added option "jfix=20" for rectangular conc. pulse
!  sequences
! VERSION/' V. 020711-1325'/
!  fixed major bug in reaction Theta-initialization
!  in "setpm_th"
!  ("jctreac" was incorrectly addressed with "ispec")
! VERSION/' V. 020608-0225'/
!  corrected minor bug in output "ar_xspec" etc.
!  added more \Theta-labeling output in "ens.o02"
! VERSION/' V. 020604-0035'/
!  added option for multiple-trapeze
!  (npwgt(0,...)=,4*ntrapz, ntrapz>1)
!  superposition for re-weight funtion "fwgt";
!  added comment line insertion capab. in "idat"/"ens.i01"
! VERSION/' V. 020531-2335'/
!  corrected read-error bug in "idat_rst" for multiple restarts
! VERSION/' V. 020524-1535'/
!  added "chisq_tx" and "chisq_uth_min" output in "odat_th";
!  changed name+implem. of global re-scaling factor "glob_scal"
! VERSION/' V. 020520-1835'/
!  changed file open/close for faster output to "ens.o02"
! VERSION/' V. 020516-1635'/
!  added MC-time-dep. exptl. data re-weighting
! VERSION/' V. 020511-1335'/
!  added CAT kinetics "jkin=22"
!  added MC restart option "jmc_inir=240,241"
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! intialize message passing interface (MPI)
      call MPI_INIT(mp_ierr)
!
      mp_myid=0
      mp_nproc=1
      ierrtag=-1
      jerrtag=-1
      errtag=' '
!
! designate Mr process ID mp_mrid: default Mr ID=0;
! other choices: not yet implemented!
      mp_mrid=0
!
! establish processor identity and processor count
      call MPI_COMM_RANK(MPI_COMM_WORLD,mp_myid,mp_ierr)
      call MPI_COMM_SIZE(MPI_COMM_WORLD,mp_nproc,mp_ierr)
!
      if(mp_nproc.gt.mp_nproc_x) then
        errtag='mr+sv:mp_ens:mp_nproc'
        call err_term
      endif
!
! prepare and check message tag name lists and
! request handle name lists for use by
! fctns. mp_itag and mp_ireq
!
      call mp_cktag(mp_ntag,mp_myid,mp_mrid,namtag_it)
!
!!    call MPI_uCK_NTAG_X
!
      call mp_ckreq(mp_nreq,mp_myid,mp_mrid,mp_nproc,namreq_ir)
!
      if(mp_ntag.gt.mp_ntag_x.or.mp_nreq.gt.mp_nreq_x) then
        errtag='mr+sv:mp_ens:mp_ntag,mp_nreq'
        call err_term
      endif
!
      call mp_ini_isend
!!    call mp_DB_fx_ini
!!    call mp_DB_commstat_zero
!
      if(mp_myid.eq.mp_mrid) then
! Mr main:
        call mpm_main
      else
! Sv main:
        call mps_main
      endif
!
!
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mp_DB_fx
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! Cyclically closes, re-opens 4 debug diagnostic output files
! under same unit number, iun=39, e.g. for Mr:
!   ens.o09<-->ens.p09<-->ens.q09<-->ens.r09<-->ens.o09
! in order to force immediate (runtime-synched)
! debug diagnostic write-out to one of the 4 diagnostic files.
! Can be used for Mr and up to 8 additional Svs, with
! Sv output files named ens.[o,p,q,r]09."n" where n=1,2,3...8
!
      k_fxcount=k_fxcount+1
      k_fxh=k_fxcount/4
      k_fxo=k_fxcount-4*k_fxh
      if(k_fxcount.eq.1000000) k_fxcount=0
!
      if(k_fxo.eq.1) then
        close(39)
        if(mp_myid.eq.mp_mrid) then
! Mr Code:
          open(39,file='ens.o09.0',status='old')
        else
! Sv Code:
          if(mp_myid.eq.1) open(39,file='ens.o09.1',status='old')
          if(mp_myid.eq.2) open(39,file='ens.o09.2',status='old')
          if(mp_myid.eq.3) open(39,file='ens.o09.3',status='old')
          if(mp_myid.eq.4) open(39,file='ens.o09.4',status='old')
          if(mp_myid.eq.5) open(39,file='ens.o09.5',status='old')
          if(mp_myid.eq.6) open(39,file='ens.o09.6',status='old')
          if(mp_myid.eq.7) open(39,file='ens.o09.7',status='old')
          if(mp_myid.eq.8) open(39,file='ens.o09.8',status='old')
        endif
!
        iun39=39
        rewind(39)
!
!!!     call efile(iun39)
!
        write(39,*) ' .............................................'
        write(39,*) ' k_fxcount=',k_fxcount
        write(39,*) '  '
      endif
!
!
      if(k_fxo.eq.2) then
        close(39)
        if(mp_myid.eq.mp_mrid) then
! Mr Code:
          open(39,file='ens.p09.0',status='old')
        else
! Sv Code:
          if(mp_myid.eq.1) open(39,file='ens.p09.1',status='old')
          if(mp_myid.eq.2) open(39,file='ens.p09.2',status='old')
          if(mp_myid.eq.3) open(39,file='ens.p09.3',status='old')
          if(mp_myid.eq.4) open(39,file='ens.p09.4',status='old')
          if(mp_myid.eq.5) open(39,file='ens.p09.5',status='old')
          if(mp_myid.eq.6) open(39,file='ens.p09.6',status='old')
          if(mp_myid.eq.7) open(39,file='ens.p09.7',status='old')
          if(mp_myid.eq.8) open(39,file='ens.p09.8',status='old')
        endif
!
        iun39=39
        rewind(39)
!
!!!     call efile(iun39)
!
        write(39,*) ' .............................................'
        write(39,*) ' k_fxcount=',k_fxcount
        write(39,*) '  '
      endif
!
!
      if(k_fxo.eq.3) then
        close(39)
        if(mp_myid.eq.mp_mrid) then
! Mr Code:
          open(39,file='ens.q09.0',status='old')
        else
! Sv Code:
          if(mp_myid.eq.1) open(39,file='ens.q09.1',status='old')
          if(mp_myid.eq.2) open(39,file='ens.q09.2',status='old')
          if(mp_myid.eq.3) open(39,file='ens.q09.3',status='old')
          if(mp_myid.eq.4) open(39,file='ens.q09.4',status='old')
          if(mp_myid.eq.5) open(39,file='ens.q09.5',status='old')
          if(mp_myid.eq.6) open(39,file='ens.q09.6',status='old')
          if(mp_myid.eq.7) open(39,file='ens.q09.7',status='old')
          if(mp_myid.eq.8) open(39,file='ens.q09.8',status='old')
        endif
!
        iun39=39
        rewind(39)
!
!!!     call efile(iun39)
!
        write(39,*) ' .............................................'
        write(39,*) ' k_fxcount=',k_fxcount
        write(39,*) '  '
      endif
!
!
      if(k_fxo.eq.0) then
        close(39)
        if(mp_myid.eq.mp_mrid) then
! Mr Code:
          open(39,file='ens.r09.0',status='old')
        else
! Sv Code:
          if(mp_myid.eq.1) open(39,file='ens.r09.1',status='old')
          if(mp_myid.eq.2) open(39,file='ens.r09.2',status='old')
          if(mp_myid.eq.3) open(39,file='ens.r09.3',status='old')
          if(mp_myid.eq.4) open(39,file='ens.r09.4',status='old')
          if(mp_myid.eq.5) open(39,file='ens.r09.5',status='old')
          if(mp_myid.eq.6) open(39,file='ens.r09.6',status='old')
          if(mp_myid.eq.7) open(39,file='ens.r09.7',status='old')
          if(mp_myid.eq.8) open(39,file='ens.r09.8',status='old')
        endif
!
        iun39=39
        rewind(39)
!
!!!     call efile(iun39)
!
        write(39,*) ' .............................................'
        write(39,*) ' k_fxcount=',k_fxcount
        write(39,*) '  '
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mp_DB_fx_ini
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! closes, re-opens and and reads debug output files
! to EOF, in order to force immediate debug write-out
! to file
!
      k_fxcount=0
!
! Declare+open "r09" debug output files
!
      close(39)
      if(mp_myid.eq.mp_mrid) then
! Mr Code:
!BLADE:
!       open(39,file='ens.r09',status='new')
        open(39,file='ens.r09.0')
      else
! Sv Code:
!       if(mp_myid.eq.1) open(39,file='ens.r09.1',status='new')
!       if(mp_myid.eq.2) open(39,file='ens.r09.2',status='new')
!       if(mp_myid.eq.3) open(39,file='ens.r09.3',status='new')
!       if(mp_myid.eq.4) open(39,file='ens.r09.4',status='new')
!       if(mp_myid.eq.5) open(39,file='ens.r09.5',status='new')
!       if(mp_myid.eq.6) open(39,file='ens.r09.6',status='new')
!       if(mp_myid.eq.7) open(39,file='ens.r09.7',status='new')
!       if(mp_myid.eq.8) open(39,file='ens.r09.8',status='new')
        if(mp_myid.eq.1) open(39,file='ens.r09.1')
        if(mp_myid.eq.2) open(39,file='ens.r09.2')
        if(mp_myid.eq.3) open(39,file='ens.r09.3')
        if(mp_myid.eq.4) open(39,file='ens.r09.4')
        if(mp_myid.eq.5) open(39,file='ens.r09.5')
        if(mp_myid.eq.6) open(39,file='ens.r09.6')
        if(mp_myid.eq.7) open(39,file='ens.r09.7')
        if(mp_myid.eq.8) open(39,file='ens.r09.8')
!:BLADE
      endif
!
      iun39=39
      rewind(39)
      call efile(iun39)
!
      write(39,*) '  '
!
! Declare+open "q09" debug output files
!
      close(39)
      if(mp_myid.eq.mp_mrid) then
! Mr Code:
!BLADE:
!       open(39,file='ens.q09',status='new')
        open(39,file='ens.q09.0')
      else
! Sv Code:
!       if(mp_myid.eq.1) open(39,file='ens.q09.1',status='new')
!       if(mp_myid.eq.2) open(39,file='ens.q09.2',status='new')
!       if(mp_myid.eq.3) open(39,file='ens.q09.3',status='new')
!       if(mp_myid.eq.4) open(39,file='ens.q09.4',status='new')
!       if(mp_myid.eq.5) open(39,file='ens.q09.5',status='new')
!       if(mp_myid.eq.6) open(39,file='ens.q09.6',status='new')
!       if(mp_myid.eq.7) open(39,file='ens.q09.7',status='new')
!       if(mp_myid.eq.8) open(39,file='ens.q09.8',status='new')
        if(mp_myid.eq.1) open(39,file='ens.q09.1')
        if(mp_myid.eq.2) open(39,file='ens.q09.2')
        if(mp_myid.eq.3) open(39,file='ens.q09.3')
        if(mp_myid.eq.4) open(39,file='ens.q09.4')
        if(mp_myid.eq.5) open(39,file='ens.q09.5')
        if(mp_myid.eq.6) open(39,file='ens.q09.6')
        if(mp_myid.eq.7) open(39,file='ens.q09.7')
        if(mp_myid.eq.8) open(39,file='ens.q09.8')
!:BLADE
      endif
!
      iun39=39
      rewind(39)
      call efile(iun39)
!
      write(39,*) '  '
!
! Declare+open "p09" debug output files
!
      close(39)
      if(mp_myid.eq.mp_mrid) then
! Mr Code:
!BLADE:
!       open(39,file='ens.p09',status='new')
        open(39,file='ens.p09.0')
      else
! Sv Code:
!       if(mp_myid.eq.1) open(39,file='ens.p09.1',status='new')
!       if(mp_myid.eq.2) open(39,file='ens.p09.2',status='new')
!       if(mp_myid.eq.3) open(39,file='ens.p09.3',status='new')
!       if(mp_myid.eq.4) open(39,file='ens.p09.4',status='new')
!       if(mp_myid.eq.5) open(39,file='ens.p09.5',status='new')
!       if(mp_myid.eq.6) open(39,file='ens.p09.6',status='new')
!       if(mp_myid.eq.7) open(39,file='ens.p09.7',status='new')
!       if(mp_myid.eq.8) open(39,file='ens.p09.8',status='new')
        if(mp_myid.eq.1) open(39,file='ens.p09.1')
        if(mp_myid.eq.2) open(39,file='ens.p09.2')
        if(mp_myid.eq.3) open(39,file='ens.p09.3')
        if(mp_myid.eq.4) open(39,file='ens.p09.4')
        if(mp_myid.eq.5) open(39,file='ens.p09.5')
        if(mp_myid.eq.6) open(39,file='ens.p09.6')
        if(mp_myid.eq.7) open(39,file='ens.p09.7')
        if(mp_myid.eq.8) open(39,file='ens.p09.8')
!:BLADE
      endif
!
      iun39=39
      rewind(39)
      call efile(iun39)
!
      write(39,*) '  '
!
! Declare+open "o09" debug output files
!
      close(39)
      if(mp_myid.eq.mp_mrid) then
! Mr Code:
!BLADE:
!       open(39,file='ens.o09',status='new')
        open(39,file='ens.o09.0')
      else
! Sv Code:
!       if(mp_myid.eq.1) open(39,file='ens.o09.1',status='new')
!       if(mp_myid.eq.2) open(39,file='ens.o09.2',status='new')
!       if(mp_myid.eq.3) open(39,file='ens.o09.3',status='new')
!       if(mp_myid.eq.4) open(39,file='ens.o09.4',status='new')
!       if(mp_myid.eq.5) open(39,file='ens.o09.5',status='new')
!       if(mp_myid.eq.6) open(39,file='ens.o09.6',status='new')
!       if(mp_myid.eq.7) open(39,file='ens.o09.7',status='new')
!       if(mp_myid.eq.8) open(39,file='ens.o09.8',status='new')
        if(mp_myid.eq.1) open(39,file='ens.o09.1')
        if(mp_myid.eq.2) open(39,file='ens.o09.2')
        if(mp_myid.eq.3) open(39,file='ens.o09.3')
        if(mp_myid.eq.4) open(39,file='ens.o09.4')
        if(mp_myid.eq.5) open(39,file='ens.o09.5')
        if(mp_myid.eq.6) open(39,file='ens.o09.6')
        if(mp_myid.eq.7) open(39,file='ens.o09.7')
        if(mp_myid.eq.8) open(39,file='ens.o09.8')
!:BLADE
      endif
!
      iun39=39
      rewind(39)
      call efile(iun39)
!
      write(39,*) '  '
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mp_DB_fx_long
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! closes, re-opens and and reads debug output files
! to EOF, in order to force immediate debug write-out
! to file
!
      close(39)
      if(mp_myid.eq.mp_mrid) then
! Mr Code:
        open(39,file='ens.o09.0',status='old')
      else
! Sv Code:
        if(mp_myid.eq.1) open(39,file='ens.o09.1',status='old')
        if(mp_myid.eq.2) open(39,file='ens.o09.2',status='old')
        if(mp_myid.eq.3) open(39,file='ens.o09.3',status='old')
        if(mp_myid.eq.4) open(39,file='ens.o09.4',status='old')
        if(mp_myid.eq.5) open(39,file='ens.o09.5',status='old')
        if(mp_myid.eq.6) open(39,file='ens.o09.6',status='old')
        if(mp_myid.eq.7) open(39,file='ens.o09.7',status='old')
        if(mp_myid.eq.8) open(39,file='ens.o09.8',status='old')
      endif
!
      iun39=39
      rewind(39)
      call efile(iun39)
!
      write(39,*) '  '
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mp_DB_fx_old01
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! closes, re-opens and and reads debug output files
! to EOF, in order to force immediate debug write-out
! to file
!
      close(39)
      if(mp_myid.eq.mp_mrid) then
! Mr Code:
        open(39,file='ens.o09.0',status='old')
      else
! Sv Code:
        if(mp_myid.eq.1) open(39,file='ens.o09.1',status='old')
        if(mp_myid.eq.2) open(39,file='ens.o09.2',status='old')
        if(mp_myid.eq.3) open(39,file='ens.o09.3',status='old')
        if(mp_myid.eq.4) open(39,file='ens.o09.4',status='old')
        if(mp_myid.eq.5) open(39,file='ens.o09.5',status='old')
        if(mp_myid.eq.6) open(39,file='ens.o09.6',status='old')
        if(mp_myid.eq.7) open(39,file='ens.o09.7',status='old')
        if(mp_myid.eq.8) open(39,file='ens.o09.8',status='old')
      endif
!
      iun39=39
      rewind(39)
      call efile(iun39)
!
      write(39,*) '  '
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mp_DB_fx_ini_old01
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! closes, re-opens and and reads debug output files
! to EOF, in order to force immediate debug write-out
! to file
!
      close(39)
      if(mp_myid.eq.mp_mrid) then
! Mr Code:
!BLADE:
!       open(39,file='ens.o09',status='new')
        open(39,file='ens.o09.0')
      else
! Sv Code:
!       if(mp_myid.eq.1) open(39,file='ens.o09.1',status='new')
!       if(mp_myid.eq.2) open(39,file='ens.o09.2',status='new')
!       if(mp_myid.eq.3) open(39,file='ens.o09.3',status='new')
!       if(mp_myid.eq.4) open(39,file='ens.o09.4',status='new')
!       if(mp_myid.eq.5) open(39,file='ens.o09.5',status='new')
!       if(mp_myid.eq.6) open(39,file='ens.o09.6',status='new')
!       if(mp_myid.eq.7) open(39,file='ens.o09.7',status='new')
!       if(mp_myid.eq.8) open(39,file='ens.o09.8',status='new')
        if(mp_myid.eq.1) open(39,file='ens.o09.1')
        if(mp_myid.eq.2) open(39,file='ens.o09.2')
        if(mp_myid.eq.3) open(39,file='ens.o09.3')
        if(mp_myid.eq.4) open(39,file='ens.o09.4')
        if(mp_myid.eq.5) open(39,file='ens.o09.5')
        if(mp_myid.eq.6) open(39,file='ens.o09.6')
        if(mp_myid.eq.7) open(39,file='ens.o09.7')
        if(mp_myid.eq.8) open(39,file='ens.o09.8')
!:BLADE
      endif
!
      iun39=39
      rewind(39)
      call efile(iun39)
!
      write(39,*) '  '
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mp_DB_commstat_send
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! accumulates MPI send count and writes out MPI communication stats
!
! Select processor(s)to execute comm stats
!
!  jmp_stat_procs=-2: Use user-supplied comm stats counter, Option 2
!
!  jmp_stat_procs=0: Mr only
!  jmp_stat_procs=1,2,...mp_nproc-1: Mr  and all Svs
!  jmp_stat_procs=mp_nproc: Mr  and all Svs
!
      jmp_stat_procs=-2
      if(jmp_stat_procs.eq.-2) goto 90
!
! Option 1:
!
      if(                                       &
     &jmp_stat_procs.eq.mp_nproc                &
     &.or.                                      &
     &jmp_stat_procs.eq.mp_myid                 &
     &)then
        write(*,*) '  '
        write(*,*) '------------------------------------'
        write(*,*) '  namtag='
        write(*,2010) namtag
 2010   format(a80)
!
        istat_ofile=1
!!! COMMENT OUT for non-IBM machines:
!!!     call MP_STATISTICS_WRITE(istat_ofile,istat_rc)
      endif
!
      goto 190
!
!
   90 continue
!
! Option 2:
!
!
      mp_nsend(mp_itag(namtag))=                           &
     &mp_nsend(mp_itag(namtag))+1
!
      if(mp_myid.ne.mp_mrid) goto 190
!
      call mp_DB_fx
!
      if(imvsequ.ge.1.and.jmvloop.ge.1) then
        write(39,3010)                                                &
     &   jmvloop,imc_rep,imc_eql,imc_acc,imc_upd                      &
     &  ,imvsequ,jmty(imvsequ,jmvloop),imove,kmove                    &
     &  ,kmvsequ,ith_cs,ith_rk
 3010   format(                                                       &
     &  /' jmvloop imc_rep imc_eql'                                   &
     &  ,' imc_acc imc_upd imvsequ    jmty   imove   kmove'           &
     &  /9i8                                                          &
     &  /' kmvsequ  ith_cs  ith_rk'                                   &
     &  /3i8)
      endif
!
      write(39,3011) mp_ntag, mp_myid, namtag
 3011 format(' mp_ntag mp_myid'                                       &
     &      /2i8                                                      &
     &      /'        namtag(at send/recv ck.pt.)'                    &
     &      /a80                                                      &
     &      /'                  namtag(sender)'                       &
     &      ,'itag      nsend   nrecv(1)   nrecv(2)    nrec(3)')
!
      do itag=1,mp_ntag
        aline=namtag_it(itag)
        write(39,3012)                                                &
     &  aline(1:35), itag, mp_nsend(itag)                              &
     &  , (mp_nrecv(itag,idum),idum=1,3)
 3012   format(a32,i4,4i11)
      enddo
!
!
  190 continue
!
!
! Usage Details:
!
! Option 1:
! ---------
! Using IBM Parallel Environment (PE) routine
! MP_STATISTICS_WRITE(stat_ofile, stat_rc)
!
! Sample:
!     integer LUNIT, stat_ofile, stat_rc, getfd
!     stat_ofile = 1 if output is to go to stdout
!     stat_ofile = 2 if output is to go to stderr
!     If output is to go a file do the following
!     LUNIT = 4
!     OPEN (LUNIT, FILE="/tmp/mpi_stat.out")
!     CALL FLUSH_(LUNIT)
!     stat_ofile = getfd(LUNIT)
!     call MP_STATISTICS_WRITE(stat_ofile, stat_rc)
!     call MPI_FINALIZE(ierror)
!
! Then, on IBM Pcluster, run MPI code w/  "-statistics=yes"
! option:
!    poe -$EXEC_CODE -statistics=yes
! to produce comm stat output
!
! Fur further details, see email from SHTsai 070316 and
! IBM PE doc web site:
!   http://publib.boulder.ibm.com/infocenter/clresctr/vxrx/\->
!   ->\index.jsp?topic=/com.ibm.cluster.pe.doc/pe_422/am10600496.html
!
!
! Option 2:
! ---------
! User supplied comm stats counter, using "namtag"
! and/or mp_itag(namtag), to identify and sort the
! comms being counted.
! Also requires a receive counter routine, to be
! called after each MPI_*RECV call.
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mp_DB_commstat_recv
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! accumulates MPI recv count and writes out MPI communication stats
!
      mp_nrecv(mp_itag(namtag),jmp_comid)=                           &
     &mp_nrecv(mp_itag(namtag),jmp_comid)+1
!
!
      if(mp_myid.eq.mp_mrid) goto 190
!
      call mp_DB_fx
!
      if(imvsequ.ge.1.and.jmvloop.ge.1) then
        write(39,3010)                                                &
     &   jmvloop,imc_rep,imc_eql,imc_acc,imc_upd                      &
     &  ,imvsequ,jmty(imvsequ,jmvloop),imove,kmove                    &
     &  ,kmvsequ,ith_cs,ith_rk
 3010   format(                                                       &
     &  /' jmvloop imc_rep imc_eql'                                   &
     &  ,' imc_acc imc_upd imvsequ    jmty   imove   kmove'           &
     &  /9i8                                                          &
     &  /' kmvsequ  ith_cs  ith_rk'                                   &
     &  /3i8)
      endif
!
!
      write(39,3011) mp_ntag, mp_myid, namtag
 3011 format(' mp_ntag mp_myid'                                       &
     &      /2i8                                                      &
     &      /'        namtag(at send/recv ck.pt.)'                    &
     &      /a80                                                      &
     &      /'                  namtag(sender)'                       &
     &      ,'itag      nsend   nrecv(1)   nrecv(2)    nrec(3)')
!
      do itag=1,mp_ntag
        aline=namtag_it(itag)
        write(39,3012)                                                &
     &  aline(1:35), itag, mp_nsend(itag)                             &
     &  , (mp_nrecv(itag,idum),idum=1,3)
 3012   format(a32,i4,4i11)
      enddo
!
      jmp_comid=1
!
  190 continue
!
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mp_DB_commstat_zero
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! accumulates MPI recv count
!
!
      do jmp_comid=1,3
        do itag=1,mp_ntag
          mp_nsend(itag)=0
          mp_nrecv(itag,jmp_comid)=0
        enddo
      enddo
!
      jmp_comid=1
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mp_ini_isend
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!V090909:
!Fixed Bug 090909:
!!!   do mp_iproc=1,mp_nproc
      do ireq=1,mp_nreq*mp_nproc
!!!   do ireq=1,mp_nreq
        jmp_isend(ireq)=0
!!!     jmp_isend(mp_iproc,ireq)=0
      enddo
!!!   enddo
!V090909
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mp_fin_isend
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
!V090909:
!Fixed Bug 090909:
      do mp_iproc=1,mp_nproc
        mp_isid=mp_iproc-1
        do kreq=1,mp_nreq
          namreq=namreq_ir(kreq)
          ireq=mp_ireq(mp_isid,namreq)
          if(jmp_isend(ireq).gt.0) then
!!!       if(jmp_isend(mp_iproc,ireq).gt.0) then
            call MPI_WAIT(                                            &
     &         mp_hand(mp_ireq(mp_isid,namreq))                       &
     &        ,mp_status                                              &
     &        ,mp_ierr)
            jmp_isend(ireq)=0
!!!         jmp_isend(mp_iproc,ireq)=0
          endif
        enddo
!:V090909
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mp_wait_isend
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! waits for completion of previously posted "isend"
! of same processor no. mp_iproc and isend request name namreq
! as impending "isend" to follow
! Inputs:
!  processor no. mp_iproc
!  "isend" request name namreq
!
!V090909:
!Fixed Bug 090909:
      mp_isid=mp_iproc-1
      ireq=mp_ireq(mp_isid,namreq)
      if(jmp_isend(ireq).gt.0) then
!!!   if(jmp_isend(mp_iproc,ireq).gt.0) then
        call MPI_WAIT(                                            &
     &     mp_hand(mp_ireq(mp_isid,namreq))                       &
     &    ,mp_status                                              &
     &    ,mp_ierr)
        jmp_isend(ireq)=0
!!!     jmp_isend(mp_iproc,ireq)=0
      endif
!:V090909
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mp_count_isend
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! counts "isend" just posted
! with processor no. mp_iproc and isend request name namreq
! Inputs:
!  processor no. mp_iproc
!  "isend" request name namreq
!
!
      mp_isid=mp_iproc-1
      ireq=mp_ireq(mp_isid,namreq)
!V090909:
!Fixed Bug 090909:
      jmp_isend(ireq)=jmp_isend(ireq)+1
!!!   jmp_isend(mp_iproc,ireq)=jmp_isend(mp_iproc,ireq)+1
!:V090909
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mpm_main
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! runs master (Mr) process
!
! read in parameters from i01-file; do fixed tabulations;
! read in and pre-process exptl. data
!
! broadcast flag jmp_task for parallel KinSolver
! execution to Sv
!
! then execute ensemble MC simulation consisting of
! equilibration and/or accumulation
!
!
      nset=0
      vcode=VERSION
      call ostart
!
! read input parameters from i01
      call idat
!
! tabulate fixed arrays
      call set_fix
!
! get and format exptl. data
      call get_xpt
!
! start up all Sv as kinsolvers and initilaize
! data packing for Mr-Sv shipments
!!!   jmp_task=1
      call mpm_task_send
      call mp_kin_pki
      call mpm_pki_o_dim
!
! run MC equil. + accum.
      do imc_smp=1,nmc_smp
        jmp_kin=imc_smp
!
        call mc_ini_r
        call mc_zero_r
        call mc_run_r
      enddo
      imc_smp=-1
!
! finalize MC results
      call mc_fin_r
!
! write out MC results
      call odat_ar
!
! shut down all Sv kinsolvers and terminate run
      jmp_kin=0
      call mpm_kin_send_theta
      jmp_task=0
      call mpm_task_send
!
!
      call mp_fin_isend
!
      call mp_stopfin
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mps_main
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! runs all slave processes
!
! read in parameters from i01-file; do fixed tabulations;
! read in and pre-process exptl. data
!
! receive flag jmp_task
! if jmp_task=0:
!   terminate MPI; due to input errors in i01- or i02-file
!   found by Mr code
! if jmp_task=1:
!   receive and execute KinSolver jobs from master
!
      nset=0
      call idat
!
      call set_fix
!
      call get_xpt
!
   10 continue
      call mps_task_recv
      if(jmp_task.eq.0) goto 990
!
      if(jmp_task.eq.1) then
        call mp_kin_pki
        call mps_getkin
      endif
!
!     no other tasks implemented yet
      goto 10
!
  990 continue
!
!
      call mp_fin_isend
!
      call mp_stopfin
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mpm_task_send
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! Mr Code:
!
      if(mp_nproc.eq.1) return
      if(mp_myid.ne.mp_mrid) return
!                                                                       !
      do mp_iproc=1,mp_nproc
        mp_svid=mp_iproc-1
        if(mp_svid.ne.mp_mrid) then
          namtag='mr:mpm_task_send:jmp_task:000'
          call MPI_SSEND(                                               &
     &          jmp_task,1                                              &
     &         ,MPI_INTEGER                                             &
     &         ,mp_svid                                                 &
     &         ,mp_itag(namtag)    &
     &         ,MPI_COMM_WORLD                                          &
     &         ,mp_ierr)
!!        call mp_DB_commstat_send
        endif
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mps_task_recv
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! Sv Code:
!                                                                       !
      namtag='mr:mpm_task_send:jmp_task:000'
      call MPI_RECV(                                                    &
     &      jmp_task,1                                                  &
     &     ,MPI_INTEGER                                                 &
     &     ,mp_mrid                                                     &
     &     ,mp_itag(namtag)    &
     &     ,MPI_COMM_WORLD                                              &
     &     ,mp_status                                                   &
     &     ,mp_ierr)
!!    call mp_DB_commstat_recv
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mp_qini
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! Mr: no action
! Sv: receives start cue for queued Sv action
!                                                                       !
!                                                                       !
! Mr Code:
!
      if(mp_myid.eq.mp_mrid) then
        return
      endif
!                                                                       !
! SV Code:
!
      if(mp_myid.ne.mp_mrid) then
        namtag='mr:mp_qfin:mp_qiniid:000'
        call MPI_RECV(                                                  &
     &        mp_qiniid,1                                               &
     &       ,MPI_INTEGER                                               &
     &       ,mp_mrid                                                   &
     &       ,mp_itag(namtag)    &
     &       ,MPI_COMM_WORLD                                            &
     &       ,mp_status                                                 &
     &       ,mp_ierr)
!!      call mp_DB_commstat_recv
!
        if(mp_qiniid.ne.mp_myid) then
          errtag='sv:mp_qini:mp_qiniid'
          call err_term
        endif
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mp_qfin
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! Mr: sends start cues for queued Sv action
!     receives completion cues for queued Sv action
! Sv: sends completion cue for queued Sv action
!                                                                       !
! Mr Code:
!                                                                       !
      if(mp_myid.eq.mp_mrid) then
        do mp_iproc=1,mp_nproc
          mp_svid=mp_iproc-1
          mp_qiniid=mp_svid
          if(mp_svid.ne.mp_mrid) then
            namtag='mr:mp_qfin:mp_qiniid:000'
            call MPI_SSEND(                                             &
     &            mp_qiniid,1                                           &
     &           ,MPI_INTEGER                                           &
     &           ,mp_svid                                               &
     &           ,mp_itag(namtag)    &
     &           ,MPI_COMM_WORLD                                        &
     &           ,mp_ierr)
!!          call mp_DB_commstat_send
!
            namtag='sv:mp_qfin:mp_qfinid:000'
            call MPI_RECV(                                              &
     &            mp_qfinid,1                                           &
     &           ,MPI_INTEGER                                           &
     &           ,mp_svid                                               &
     &           ,mp_itag(namtag)    &
     &           ,MPI_COMM_WORLD                                        &
     &           ,mp_status                                             &
     &           ,mp_ierr)
!!          call mp_DB_commstat_recv
!
            if(mp_qfinid.ne.mp_qiniid) then
              errtag='mr:mp_qfin:mp_qfinid'
              call err_term
            endif
          endif
        enddo
      endif
!                                                                       !
! Sv Code:
!                                                                       !
      if(mp_myid.ne.mp_mrid) then
        mp_qfinid=mp_myid
        namtag='sv:mp_qfin:mp_qfinid:000'
        call MPI_SSEND(                                                 &
     &        mp_qfinid,1                                               &
     &       ,MPI_INTEGER                                               &
     &       ,mp_mrid                                                   &
     &       ,mp_itag(namtag)    &
     &       ,MPI_COMM_WORLD                                            &
     &       ,mp_ierr)
!!      call mp_DB_commstat_send
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mpm_getkin
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! calculate new chisq, chi2, chi1 for proposed MC move
!
! Mr ISENDs out input param set theta and then all iexpt
! for new/next kin-soln. assignmts to available Sv; then
! initiates handshake protocol to RECV solns from Svs,
! as follows:
!
! 1) Mr: ISEND next "theta" input param. set
!        to all Sv
!    Subprg: mpm_kin_send_theta
!
! 2) Sv: wait for 1), then RECV new/next theta from Mr
!    Subprg: mps_kin_recv_theta
!
! 3) Mr: find 1st unsolved iexpt requiring new kin soln.
!    Subprg: mpm_kin_ini_iexpt
!
! 4) Mr: ISEND 1st/next unsolved iexpt to Sv, then
!        post IRECV for handshake signal jmp_fin_yspec
!        from Sv
!    Subprg: mpm_kin_send_iexpt
!
! 5) Sv: RECV new/next iexpt from Mr,
!        >if 1=<iexpt=<nexpt: goto 6),
!        >if    iexpt >nexpt: goto 12)
!    Subprg: mpm_kin_recv_iexpt<-mps_getkin
!
! 6) Sv: do kinsoln, then SSEND short handshake signal
!        jmp_fin_yspec to Mr: Sv ready for yspec_pk-send
!    Subprg: mps_getkin, mps_kin_send_yspec
!
! 7) Mr: TEST for receipt of signal jmp_fin_yspec from Sv;
!        upon receipt send reply signal jmp_fin_yspec to Sv
!    Subprg: mpm_kin_chek_yspec, mpm_kin_recv_yspec
!
! 8) Sv: upon RECV of handshake reply jmp_fin_yspec from Mr,
!        SSEND yspec_pk to Mr
!    Subprg: mps_kin_send_yspec
!
! 9) Mr: unpack yspec immdiately after RECV of yspec_pk
!        completes, to prevent overwrite of yspec_pk data
!        during later yspec_pk recv.
!    Subprg: mpm_kin_recv_yspec<-mpm_kin_chek_yspec
!
!10) Mr: >if unsolved iexpt remain: goto  4)
!        >else:                     goto 11)
!    Subprg: mpm_kin_send_iexpt<-mpm_kin_w2sv, mpm_getkin
!
!11) Mr: send an iexpt w/ iexpt>nexpt to Sv to close
!        current Sv kinsolvers and start new Sv kinsolvers
!
!12) Sv: has recv'd iexpt>nexpt: send arkabd counts to Mr,
!        using handshake jmp_fin_arkabd analogous to
!        handshake jmp_fin_yspec for yspec; then goto 2).
!
!13) Mr: recv+unpack arkabd counts from Sv, then exit
!        kinsolver mpm_get_kin, leaving all Sv in
!        wait state at 2)
!
! jmp_busy(mp_svid):
!   tracks busy status of Sv processor no. "mp_svid"
!
! jmp_busy(mp_svid) =< 0:
!   Sv processor "mp_svid" is ready to receive next
!   "iexpt" assignment from Mr; Sv already has the
!   current "theta" input param. set.
!   jmp_busy(mp_svid) = 0:
!     Sv "mp_svid" has just revc'd new "theta", but no
!     new assignmt "iexptW" to work on yet.
!   jmp_busy(mp_svid) :=: -iexptL < 0:
!     Sv "mp_svid" has just completed last assignmt "iexptL"
! jmp_busy(mp_svid) :=: iexptW,  1 =< iexptW =< nexpt:
!   Sv processor "mp_svid" is currently working on
!   assignment "iexptW"; Mr has already posted IRECV
!   for signal "jmp_fin_yspec" to check for completion
!   of this assignment "iexptW". Value of "iexptW"
!   is stored by Mr either as "iexpt_bgun" at send to Sv
!   or as "iexpt_upk" at recv from Sv.
! jmp_busy(mp_svid) > nexpt:
!   All "iexpt" assignmts and "yspec_pk" shipments are
!   completed;  after sending "arkabd_pk" counts to Mr,
!   Sv "mp_svid" will jump to top of "mps_getkin" and
!   enter mps_recv_theta, to wait for the new "theta"
!   input param. set for next "mps_getkin" cycle
!
      if(mp_myid.ne.mp_mrid) return
!
!
!CHG190527-2223:
      ark_ksolxp=ark_ksolxp+1.d0
!:CHG190527-2223
!
!c    call store_sfxdi
!c    call get_xdi
!
!    Send first batch of "iexpt"s to Svs for kin ODE soln.
      call setdokin
      call mpm_kin_send_theta
      call mpm_kin_ini_iexpt
      call mpm_kin_send_iexpt
!
      time_w2sv=time1+dtime
      call mpm_kin_w2sv
!
!    Do next "iexpt", if any, on Mr for kin ODE soln., while
!    also sending additional "iexpt"s to Svs for kin ODE soln.
      do iexpt=1,nexpt
        call ck_stop_now
        if(iexpt_bgun.ge.nexpt) goto 210
!
!       kin. soln. for this iexpt already done by Sv:
        if(jdokin(iexpt).eq.-1) goto 110
!
        if(jdokin(iexpt).eq.1) then
          iexpt_bgun=iexpt
!
          jmp_busy(mp_mrid)=iexpt_bgun
          jdokin(iexpt_bgun)=-1
          mp_mexpt_done=mp_mexpt_done+1
!
          ivpm_uv=iexpt
          call setpm_uv
          call kin_ini
          call kin_run ! mpm_getkin-01
!DRLIM190524-2244:
          n_drv_xp(iexpt)=n_drv
!:DRLIM190524-2244
!
!!        call odat_xspec  !need to fix communictn. to Sv
!
!       need [x,y]spec for chisq, htot only in
!       MC updating: store [x,y]spec--> [x,y]spec_chi
!
          if(jmp_kin.eq.1) then
            call kin_xpt
            call kin_qbx
            call kin_four
          endif
!
!         need [x,y]spec for all t-dep. species conc. in
!         MC scoring: store [x,y]spec-->[x,y]spec_o
!
          if(jmp_kin.eq.2) then
            call kin_xspec_o
          endif
!
!         need [x,y]spec only for direct yspec_o output in
!         MC trajectory of yspec: store [x,y]spec-->[x,y]spec_o
!
          if(jmp_kin.eq.3) then
            call kin_xspec_o
          endif
!
!         need [x,y]spec for true-theta solution in
!         virt. expt.: store [x,y]spec-->[x,y]spec_tru
!
          if(jmp_kin.eq.4) then
            call kin_xpt
            call kin_qbx
            call kin_four
            call kin_truv
          endif
!
          jmp_busy(mp_mrid)=-jmp_busy(mp_mrid)
        endif
!
        if(jdokin(iexpt).eq.0) then
          call reset_yspec_expt
        endif
!
  110   continue
        time_w2sv=time1+dtime
        call mpm_kin_w2sv
      enddo
  210 continue
      iexpt=-1
!
      call mpm_kin_wait_yspec ! mpm_getkin-01
      call mpm_kin_send_iexpt
      call mpm_kin_wait_arkabd
!
      do iexpt=1,nexpt
        jdokin(iexpt)=1
!
        if(jmp_kin.eq.4) then
          ivpm_uv=iexpt
          call setpm_uv
          call get_pdpen
          call kin_dptru
        endif
      enddo
      iexpt=-1
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mpm_kin_w2sv
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! Mr Code:
!
      if(mp_nproc.eq.1) return
      if(mp_myid.ne.mp_mrid) return
!
      time_w2sv_chek=mp_w2sv*(time_w2sv-time_w2sv_last)
      if(time_w2sv_chek.lt.dtime10.and.time_w2sv.lt.time1) return
!
      time_w2sv_last=time_w2sv
      if(time_w2sv.ge.time1) time_w2sv_last=time0
!
      if(mp_mexpt_done.lt.mp_mexpt_dokin) then
        call mpm_kin_chek_yspec ! mpm_kin_w2sv-01
      endif
!
      if(iexpt_bgun.lt.nexpt) then
        call mpm_kin_send_iexpt
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mpm_kin_send_theta
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! Mr Code:
!
      if(mp_nproc.eq.1) return
      if(mp_myid.ne.mp_mrid) return
!
      mp_mexpt_done=0
!
      theta_pk(1)=jmp_kin
      call mpm_pak_theta
!
      do mp_iproc=1,mp_nproc
        mp_svid=mp_iproc-1
        jmp_busy(mp_svid)=0
        jmp_fin_yspec(mp_svid)=-1
        jmp_fin_arkabd(mp_svid)=-1
!
!
        if(mp_svid.ne.mp_mrid) then
          namtag='mr:mpm_kin_send_theta:theta_pk:000'
          namreq='mr:mpm_kin_send_theta:theta_pk:000'
          call mp_wait_isend
          call MPI_ISEND(                                               &
     &     theta_pk,mp_dim_theta                                        &
     &    ,MPI_REAL8                                                    &
     &    ,mp_svid                                                      &
     &    ,mp_itag(namtag)                                              &
     &    ,MPI_COMM_WORLD                                               &
     &    ,mp_hand(mp_ireq(mp_svid,namreq))                             &
     &    ,mp_ierr)
          call mp_count_isend
!Note:  Needs MPI_TEST/WAIT for MPI_ISEND
!         call MPI_WAIT(                                                &
!    &         mp_hand(mp_ireq(mp_svid,namreq))                         &
!    &        ,mp_status                                                &
!    &        ,mp_ierr)
!:Note
!!        call mp_DB_commstat_send
        endif
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mpm_DB_kin_recv_theta
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! Mr Code:
!
! Mr receives theta_pk back from "1st" Sv, for debug purposes
!
      do mp_iproc=1,mp_nproc
        mp_svid=mp_iproc-1
!
        if(mp_svid.ne.mp_mrid) then
          namreq='mr:mpm_kin_send_theta:theta_pk:000'
          call MPI_WAIT(                                              &
     &         mp_hand(mp_ireq(mp_svid,namreq))                       &
     &        ,mp_status                                              &
     &        ,mp_ierr)
        endif
      enddo
!
      mp_svid=mp_mrid+1
      if(mp_svid.ge.mp_nproc) mp_svid=mp_svid-mp_nproc
!
      if(                                          &
     &mp_svid.ge.0.and.                            &
     &mp_svid.lt.mp_nproc.and.                     &
     &mp_svid.ne.mp_mrid                           &
     &)then
        namtag='sv:mps_DB_kin_send_theta:theta_pk:000'
        call MPI_RECV(                                                  &
     &      theta_pk,mp_dim_theta                                       &
     &     ,MPI_REAL8                                                   &
     &     ,mp_svid                                                     &
     &     ,mp_itag(namtag)                                             &
     &     ,MPI_COMM_WORLD                                              &
     &     ,mp_status                                                   &
     &     ,mp_ierr)
!!      call mp_DB_commstat_recv
!
        call mps_upk_theta
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mpm_kin_ini_iexpt
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! Mr Code:
!
      do iexpt=1,nexpt
        if(jdokin(iexpt).eq.1) then
          iexpt_bgun=iexpt-1
          goto 10
        endif
      enddo
!
   10 continue
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mpm_kin_send_iexpt
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! Mr Code:
!
! send next iexpt assignmts for kinsolver processing
! to all available Svs
!
! jmp_busy(mp_svid):
!   tracks busy status of Sv processor no. "mp_svid"
!
! jmp_busy(mp_svid) =< 0:
!   Sv processor "mp_svid" is ready to receive next
!   "iexpt" assignment from Mr; Sv already has the
!   current "theta" input param. set.
!   jmp_busy(mp_svid) = 0:
!     Sv "mp_svid" has just revc'd new "theta", but no
!     new assignmt "iexptW" to work on yet.
!   jmp_busy(mp_svid) :=: -iexptL < 0:
!     Sv "mp_svid" has just completed last assignmt "iexptL"
! jmp_busy(mp_svid) :=: iexptW,  1 =< iexptW =< nexpt:
!   Sv processor "mp_svid" is currently working on
!   assignment "iexptW"; Mr has already posted IRECV
!   for signal "jmp_fin_yspec" to check for completion
!   of this assignment "iexptW". Value of "iexptW"
!   is stored by Mr either as "iexpt_bgun" at send to Sv
!   or as "iexpt_upk" at recv from Sv.
! jmp_busy(mp_svid) > nexpt:
!   All "iexpt" assignmts and "yspec_pk" shipments are
!   completed;  after send "arkabd_pk" counts to Mr,
!   Sv "mp_svid" will jump to top of "mps_getkin" and
!   enter mps_recv_theta, to wait for the new "theta"
!   input param. set for next "mps_getkin" cycle
!
      if(mp_nproc.eq.1) return
      if(mp_myid.ne.mp_mrid) return
!
      do mp_iproc=1,mp_nproc
        mp_svid=mp_iproc-1
!
        if(mp_svid.ne.mp_mrid) then
          if(jmp_busy(mp_svid).le.0) then
   10       continue
            iexpt_bgun=iexpt_bgun+1
!
            if(iexpt_bgun.le.nexpt) then
              if(jdokin(iexpt_bgun).le.0) then
                goto 10
              else
                jdokin(iexpt_bgun)=-1
              endif
            endif
!
            jmp_busy(mp_svid)=iexpt_bgun
            mp_iexpt_sbuf(mp_svid)=iexpt_bgun
!
            namtag='mr:mpm_kin_send_iexpt:iexpt:000'
            namreq='mr:mpm_kin_send_iexpt:iexpt:000'
            call mp_wait_isend
            call MPI_ISEND(                                             &
     &       mp_iexpt_sbuf(mp_svid),1                                   &
     &      ,MPI_INTEGER                                                &
     &      ,mp_svid                                                    &
     &      ,mp_itag(namtag)                                            &
     &      ,MPI_COMM_WORLD                                             &
     &      ,mp_hand(mp_ireq(mp_svid,namreq))                           &
     &      ,mp_ierr)
            call mp_count_isend
!Note:  Needs MPI_TEST/WAIT for MPI_ISEND
!           call MPI_WAIT(                                            &
!    &         mp_hand(mp_ireq(mp_svid,namreq))                       &
!    &        ,mp_status                                              &
!    &        ,mp_ierr)
!:Note
!!          call mp_DB_commstat_send
!
!           post non-block receive Sv handshake signal jmp_fin_yspec
!           when Sv's kin-solution is ready to be sent by Sv
!
            if(iexpt_bgun.le.nexpt) then
              namtag='sv:mps_kin_send_yspec:jmp_fin_yspec:000'
              namreq='sv:mps_kin_send_yspec:jmp_fin_yspec:000'
              call MPI_IRECV(                                           &
     &        jmp_fin_yspec(mp_svid),1                                  &
     &        ,MPI_INTEGER                                              &
     &        ,mp_svid                                                  &
     &        ,mp_itag(namtag)    &
     &        ,MPI_COMM_WORLD                                           &
     &        ,mp_hand(mp_ireq(mp_svid,namreq))                     &
     &        ,mp_ierr)
!
!!            jmp_comid=2
!!            call mp_DB_commstat_recv
!!            jmp_comid=1
            endif
          endif
        endif
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mpm_kin_chek_yspec
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! Mr Code:
!
! checks for completion signal "jmp_fin_yspec",
! from all busy Svs and, upon signal, receives their
! MC results during iexpt-cycle of "mpm_getkin"
! by call to "mpm_kin_recv_yspec" which also
! re-sets Sv's "jmp_busy" flag to value < 0
!
! jmp_busy(mp_svid):
!   tracks busy status of Sv processor no. "mp_svid"
!
! jmp_busy(mp_svid) =< 0:
!   Sv processor "mp_svid" is ready to receive next
!   "iexpt" assignment from Mr; Sv already has the
!   current "theta" input param. set.
!   jmp_busy(mp_svid) = 0:
!     Sv "mp_svid" has just revc'd new "theta", but no
!     new assignmt "iexptW" to work on yet.
!   jmp_busy(mp_svid) :=: -iexptL < 0:
!     Sv "mp_svid" has just completed last assignmt "iexptL"
! jmp_busy(mp_svid) :=: iexptW,  1 =< iexptW =< nexpt:
!   Sv processor "mp_svid" is currently working on
!   assignment "iexptW"; Mr has already posted IRECV
!   for signal "jmp_fin_yspec" to check for completion
!   of this assignment "iexptW". Value of "iexptW"
!   is stored by Mr either as "iexpt_bgun" at send to Sv
!   or as "iexpt_upk" at recv from Sv.
! jmp_busy(mp_svid) > nexpt:
!   All "iexpt" assignmts and "yspec_pk" shipments are
!   completed;  after send "arkabd_pk" counts to Mr,
!   Sv "mp_svid" will jump to top of "mps_getkin" and
!   enter mps_recv_theta, to wait for the new "theta"
!   input param. set for next "mps_getkin" cycle
!
!
      if(mp_nproc.eq.1) return
      if(mp_myid.ne.mp_mrid) return
!
      do mp_iproc=1,mp_nproc
        mp_svid=mp_iproc-1
        if(mp_svid.ne.mp_mrid) then
          iexpt_upk=jmp_busy(mp_svid)
!
          if(1.le.iexpt_upk.and.iexpt_upk.le.nexpt) then
!
!           test for handshake jmp_fin_yspec: Sv-->Mr
!           to check if Sv is ready to send yspec_pk
!
            lmp_done=.false.
            namreq='sv:mps_kin_send_yspec:jmp_fin_yspec:000'
            call MPI_TEST(                                              &
     &           mp_hand(mp_ireq(mp_svid,namreq))                       &
     &          ,lmp_done                                      &
     &          ,mp_status                                              &
     &          ,mp_ierr)
!!          if(lmp_done) then
!!            namtag=namreq
!!            jmp_comid=3
!!            call mp_DB_commstat_recv
!!            jmp_comid=1
!!          endif
!
!           if Sv is ready, then recv yspec:
!
            if(lmp_done) then
              call mpm_kin_recv_yspec ! mpm_kin_chek_yspec-01
            endif
          endif
        endif
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mpm_kin_wait_yspec
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! Mr Code:
!
! waits for outstanding completion flags "jmp_fin_yspec"
! and receives MC results from straggling Svs, after
! all "iexpt" assignments have been sent out or, in part,
! completed by Mr and Svs
!
! jmp_busy(mp_svid):
!   tracks busy status of Sv processor no. "mp_svid"
!
! jmp_busy(mp_svid) =< 0:
!   Sv processor "mp_svid" is ready to receive next
!   "iexpt" assignment from Mr; Sv already has the
!   current "theta" input param. set.
!   jmp_busy(mp_svid) = 0:
!     Sv "mp_svid" has just revc'd new "theta", but no
!     new assignmt "iexptW" to work on yet.
!   jmp_busy(mp_svid) :=: -iexptL < 0:
!     Sv "mp_svid" has just completed last assignmt "iexptL"
! jmp_busy(mp_svid) :=: iexptW,  1 =< iexptW =< nexpt:
!   Sv processor "mp_svid" is currently working on
!   assignment "iexptW"; Mr has already posted IRECV
!   for signal "jmp_fin_yspec" to check for completion
!   of this assignment "iexptW". Value of "iexptW"
!   is stored by Mr either as "iexpt_bgun" at send to Sv
!   or as "iexpt_upk" at recv from Sv.
! jmp_busy(mp_svid) > nexpt:
!   All "iexpt" assignmts and "yspec_pk" shipments are
!   completed;  after send "arkabd_pk" counts to Mr,
!   Sv "mp_svid" will jump to top of "mps_getkin" and
!   enter mps_recv_theta, to wait for the new "theta"
!   input param. set for next "mps_getkin" cycle
!
!
      if(mp_nproc.eq.1) return
      if(mp_myid.ne.mp_mrid) return
!
   10 continue
      mp_mproc_busy=0
!
      do mp_iproc=1,mp_nproc
        mp_svid=mp_iproc-1
        if(mp_svid.ne.mp_mrid) then
          iexpt_upk=jmp_busy(mp_svid)
!
          if(1.le.iexpt_upk.and.iexpt_upk.le.nexpt) then
!
!           wait for handshake jmp_fin_yspec: Sv-->Mr
!           to check if Sv is ready to send yspec_pk
!
            lmp_done=.false.
            namreq='sv:mps_kin_send_yspec:jmp_fin_yspec:000'
            call MPI_TEST(                                              &
     &           mp_hand(mp_ireq(mp_svid,namreq))                   &
     &          ,lmp_done                                      &
     &          ,mp_status                                              &
     &          ,mp_ierr)
!!          if(lmp_done) then
!!            namtag=namreq
!!            jmp_comid=3
!!            call mp_DB_commstat_recv
!!            jmp_comid=1
!!          endif
!
            if(lmp_done) then
              call mpm_kin_recv_yspec ! mpm_kin_wait_yspec-01
            else
              mp_mproc_busy=mp_mproc_busy+1
            endif
          endif
        endif
      enddo
!
      if(mp_mproc_busy.gt.0) goto 10
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mpm_kin_recv_yspec
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! Mr Code:
!
      if(mp_nproc.eq.1) return
      if(mp_myid.ne.mp_mrid) return
!
      mp_mexpt_done=mp_mexpt_done+1
      jmp_busy(mp_svid)=-iexpt_upk
!
      if(jmp_fin_yspec(mp_svid).ne.iexpt_upk) then
        errtag='mr:mpm_kin_recv_yspec:jmp_fin_yspec'
        call err_term
      endif
!
!     complete handshake jmp_fin_yspec: Mr-->Sv
!     to signal that Mr is ready to receive yspec_pk
!
      namtag='mr:mpm_kin_recv_yspec:jmp_fin_yspec:000'
      call MPI_SSEND(                                           &
     & jmp_fin_yspec(mp_svid),1                                 &
     &,MPI_INTEGER                                              &
     &,mp_svid                                                  &
     &,mp_itag(namtag)    &
     &,MPI_COMM_WORLD                                           &
     &,mp_ierr)
!!    call mp_DB_commstat_send
!
!     set yspec_pk shipping dimension
!
      if(jmp_kin.eq.1)                                                  &
     & mp_dim_yspec(iexpt_upk)=mp_dim_yspec1(iexpt_upk)
!
      if(jmp_kin.eq.2.or.jmp_kin.eq.3)                                  &
     & mp_dim_yspec(iexpt_upk)=mp_dim_yspec2(iexpt_upk)
!
      if(jmp_kin.eq.4)                                                  &
     & mp_dim_yspec(iexpt_upk)=mp_dim_yspec4(iexpt_upk)
!
!     receive and immediately unpack yspec_pk
!     to avoid yspec_pk buffer overwrite
!
      namtag='sv:mps_kin_send_yspec:yspec_pk:000'
      call MPI_RECV(                                             &
     & yspec_pk(1),mp_dim_yspec(iexpt_upk)                   &
     &,MPI_REAL8                                                    &
     &,mp_svid                                                      &
     &,mp_itag(namtag)    &
     &,MPI_COMM_WORLD                                               &
     &,mp_status                                                    &
     &,mp_ierr)
!!     call mp_DB_commstat_recv
!
      iexpt_pak=iexpt_upk
      call mpm_upk_yspec ! mpm_kin_recv_yspec-01
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mpm_kin_wait_arkabd
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! Mr Code:
!
! waits for outstanding completion flags "jmp_fin_arkabd"
! and receives MC results from Svs
!
      if(mp_nproc.eq.1) return
      if(mp_myid.ne.mp_mrid) return
      if(jo_th_ark.lt.1) return
!
!
      do mp_iproc=1,mp_nproc
        mp_svid=mp_iproc-1
        if(mp_svid.ne.mp_mrid) then
          jmp_recv(mp_svid)=0
          jmp_fin_arkabd(mp_svid)=0
!
          namtag='sv:mps_kin_send_arkabd:jmp_fin_arkabd:000'
          namreq='sv:mps_kin_send_arkabd:jmp_fin_arkabd:000'
          call MPI_IRECV(                                           &
     &    jmp_fin_arkabd(mp_svid),1                                 &
     &    ,MPI_INTEGER                                              &
     &    ,mp_svid                                                  &
     &    ,mp_itag(namtag)                                       &
     &    ,MPI_COMM_WORLD                                           &
     &    ,mp_hand(mp_ireq(mp_svid,namreq))                     &
     &    ,mp_ierr)
!
!!        jmp_comid=2
!!        call mp_DB_commstat_recv
!!        jmp_comid=1
        endif
      enddo
!
!
   10 continue
      mp_mproc_busy=0
!
      do mp_iproc=1,mp_nproc
        mp_svid=mp_iproc-1
        if(mp_svid.ne.mp_mrid) then
!
          if(jmp_recv(mp_svid).eq.0) then
!
!           wait for handshake jmp_fin_arkabd: Sv-->Mr
!           to check if Sv is ready to send arkabd_pk
!
            lmp_done=.false.
            namreq='sv:mps_kin_send_arkabd:jmp_fin_arkabd:000'
            call MPI_TEST(                                              &
     &           mp_hand(mp_ireq(mp_svid,namreq))                   &
     &          ,lmp_done                                      &
     &          ,mp_status                                              &
     &          ,mp_ierr)
!!          if(lmp_done) then
!!            namtag=namreq
!!            jmp_comid=3
!!            call mp_DB_commstat_recv
!!            jmp_comid=1
!!          endif
!
            if(lmp_done) then
              call mpm_kin_recv_arkabd
              jmp_recv(mp_svid)=1
            else
              mp_mproc_busy=mp_mproc_busy+1
            endif
          endif
        endif
      enddo
!
      if(mp_mproc_busy.gt.0) goto 10
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mpm_kin_recv_arkabd
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! Mr Code:
!
      if(mp_nproc.eq.1) return
      if(mp_myid.ne.mp_mrid) return
!
      if(jmp_fin_arkabd(mp_svid).ne.(mp_svid+1)) then
        errtag='mr:mpm_kin_recv_arkabd:jmp_fin_arkabd'
        call err_term
      endif
!
!     complete handshake jmp_fin_arkabd: Mr-->Sv
!     to signal that Mr is ready to receive arkabd_pk
!
      namtag='mr:mpm_kin_recv_arkabd:jmp_fin_arkabd:000'
      call MPI_SSEND(                                           &
     & jmp_fin_arkabd(mp_svid),1                                 &
     &,MPI_INTEGER                                              &
     &,mp_svid                                                  &
     &,mp_itag(namtag)    &
     &,MPI_COMM_WORLD                                           &
     &,mp_ierr)
!!    call mp_DB_commstat_send
!
!
      namtag='sv:mps_kin_send_arkabd:arkabd_pk:000'
      call MPI_RECV(                                                &
     & arkabd_pk(1),mp_dim_arkabd                                   &
     &,MPI_REAL8                                                    &
     &,mp_svid                                                      &
     &,mp_itag(namtag)    &
     &,MPI_COMM_WORLD                                               &
     &,mp_status                                                    &
     &,mp_ierr)
!!    call mp_DB_commstat_recv
!
      call mpm_upk_arkabd
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mps_getkin
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! Sv Code:
!
   10 continue
      jmp_kin=-11
      iexpt=-11
!
      call mps_kin_recv_theta
!
      ivpm_uf=1
      call setpm_uf
      if(jmp_kin.eq.0) goto 90
!
      call zero_arkabd ! mps_getkin-01
!
!c    call store_sfxdi
!c    call get_xdi
!
   20 continue
!
      call mps_kin_recv_iexpt
!
      if(iexpt.gt.nexpt) then
        call mps_kin_send_arkabd ! mps_getkin-01
        goto 10
      endif
!
!     solve kinetics eqs. for given iexpt, jdokin(iexpt)=1
!
      ivpm_uv=iexpt
      call setpm_uv
      call kin_ini
      call kin_run ! mps_getkin-01
!
!     need [x,y]spec for chisq, htot only in
!     MC updating: store [x,y]spec--> [x,y]spec_chi
!
      if(jmp_kin.eq.1) then
        call kin_xpt
        call kin_qbx
        call kin_four
      endif
!
!     need [x,y]spec for all t-dep. species conc. in
!     MC scoring: store [x,y]spec-->[x,y]spec_o
!
      if(jmp_kin.eq.2) then
        call kin_xspec_o
      endif
!
!     need [x,y]spec only for direct yspec_o output in
!     MC trajectory of yspec: store [x,y]spec-->[x,y]spec_o
!
      if(jmp_kin.eq.3) then
        call kin_xspec_o
      endif
!
!     need [x,y]spec for true-theta solution in
!     virt. expt.: store [x,y]spec-->[x,y]spec_tru
!
      if(jmp_kin.eq.4) then
        call kin_xpt
        call kin_qbx
        call kin_four
        call kin_truv
      endif
!
      call mps_kin_send_yspec ! mps_getkin-01
      goto 20
!
   90 continue
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mps_kin_recv_theta
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! Sv Code:
!
      namtag='mr:mpm_kin_send_theta:theta_pk:000'
      call MPI_RECV(                                                    &
     &      theta_pk,mp_dim_theta                                       &
     &     ,MPI_REAL8                                                   &
     &     ,mp_mrid                                                     &
     &     ,mp_itag(namtag)    &
     &     ,MPI_COMM_WORLD     &
     &     ,mp_status          &
     &     ,mp_ierr)
!!    call mp_DB_commstat_recv
!
      jmp_kin=myint(theta_pk(1))
      if(jmp_kin.eq.0) goto 90
!
      call mps_upk_theta
!
!
   90 continue
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mps_DB_kin_send_theta
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! Sv Code:
!
! "1st" Sv sends theta_pk back to Mr, for debug purposes
!
      mp_svid=mp_mrid+1
      if(mp_svid.ge.mp_nproc) mp_svid=mp_svid-mp_nproc
!
      if(mp_myid.eq.mp_svid) then
        namtag='sv:mps_DB_kin_send_theta:theta_pk:000'
        call MPI_SSEND(                                                 &
     &      theta_pk,mp_dim_theta                                       &
     &     ,MPI_REAL8                                                   &
     &     ,mp_mrid                                                     &
     &     ,mp_itag(namtag)    &
     &     ,MPI_COMM_WORLD     &
     &     ,mp_ierr)
!!      call mp_DB_commstat_send
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mps_kin_recv_iexpt
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! Sv Code:
!
        namtag='mr:mpm_kin_send_iexpt:iexpt:000'
        call MPI_RECV(                                                  &
     &        iexpt,1                                                   &
     &       ,MPI_INTEGER                                               &
     &       ,mp_mrid                                                   &
     &       ,mp_itag(namtag)    &
     &       ,MPI_COMM_WORLD     &
     &       ,mp_status          &
     &       ,mp_ierr)
!!      call mp_DB_commstat_recv
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mps_kin_send_yspec
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! Sv Code:
!
      iexpt_pak=iexpt
      call mps_pak_yspec ! mps_kin_send_yspec-01
!
!     send handshake signal jmp_fin_yspec: Sv-->Mr
!     to signal that Sv is ready to send yspec_pk
!
      jmp_fin_yspec(mp_myid)=iexpt
!
      namtag='sv:mps_kin_send_yspec:jmp_fin_yspec:000'
      call MPI_SSEND(                                           &
     &   jmp_fin_yspec(mp_myid),1                                 &
     &  ,MPI_INTEGER                                              &
     &  ,mp_mrid                                                  &
     &  ,mp_itag(namtag)    &
     &  ,MPI_COMM_WORLD                                           &
     &  ,mp_ierr)
!!    call mp_DB_commstat_send
!
!     await receive handshake reply signal jmp_fin_yspec: Mr-->Sv
!
      namtag='mr:mpm_kin_recv_yspec:jmp_fin_yspec:000'
      call MPI_RECV(                                             &
     &   jmp_fin_yspec(mp_myid),1                                 &
     &  ,MPI_INTEGER                                              &
     &  ,mp_mrid                                                      &
     &  ,mp_itag(namtag)    &
     &  ,MPI_COMM_WORLD                                               &
     &  ,mp_status                                                    &
     &  ,mp_ierr)
!!      call mp_DB_commstat_recv
!
!
      if(jmp_fin_yspec(mp_myid).ne.iexpt) then
        errtag='sv:mps_kin_send_yspec:jmp_fin_yspec'
        call err_term
      endif
!
!
      namtag='sv:mps_kin_send_yspec:yspec_pk:000'
      call MPI_SSEND(                                                   &
     &      yspec_pk(1),mp_dim_yspec(iexpt)                          &
     &     ,MPI_REAL8                                                   &
     &     ,mp_mrid                                                     &
     &     ,mp_itag(namtag)    &
     &     ,MPI_COMM_WORLD                                              &
     &     ,mp_ierr)
!!    call mp_DB_commstat_send
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mps_kin_send_arkabd
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! Sv Code:
!
      if(jo_th_ark.lt.1) return
!
      call mps_pak_arkabd ! mps_kin_send_arkabd-01
!
!     send handshake signal jmp_fin_arkabd: Sv-->Mr
!     to signal that Sv is ready to send arkabd_pk
!
      jmp_fin_arkabd(mp_myid)=mp_myid+1
!
      namtag='sv:mps_kin_send_arkabd:jmp_fin_arkabd:000'
      call MPI_SSEND(                                           &
     &   jmp_fin_arkabd(mp_myid),1                                 &
     &  ,MPI_INTEGER                                              &
     &  ,mp_mrid                                                  &
     &  ,mp_itag(namtag)    &
     &  ,MPI_COMM_WORLD                                           &
     &  ,mp_ierr)
!!    call mp_DB_commstat_send
!
!     await receive handshake reply signal jmp_fin_arkabd: Mr-->Sv
!
      namtag='mr:mpm_kin_recv_arkabd:jmp_fin_arkabd:000'
      call MPI_RECV(                                             &
     &   jmp_fin_arkabd(mp_myid),1                                 &
     &  ,MPI_INTEGER                                              &
     &  ,mp_mrid                                                      &
     &  ,mp_itag(namtag)    &
     &  ,MPI_COMM_WORLD                                               &
     &  ,mp_status                                                    &
     &  ,mp_ierr)
!!      call mp_DB_commstat_recv
!
      if(jmp_fin_arkabd(mp_myid).ne.(mp_myid+1)) then
        errtag='sv:mps_kin_send_arkabd:jmp_fin_arkabd'
        call err_term
      endif
!
      namtag='sv:mps_kin_send_arkabd:arkabd_pk:000'
      call MPI_SSEND(                                                 &
     &arkabd_pk(1),mp_dim_arkabd                                     &
     &,MPI_REAL8                                                      &
     &,mp_mrid                                                        &
     &,mp_itag(namtag)    &
     &,MPI_COMM_WORLD                                                 &
     &,mp_ierr)
!!    call mp_DB_commstat_send
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mp_stopfin
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! terminates MPI and stops execution for any processor
!
! Sv+Mr Code:
!                                                                       !
      call MPI_FINALIZE(mp_ierr)
!
!
      stop
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mp_stopabort
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! aborts MPI and stops execution on all processors
!
! Sv+Mr Code:
!                                                                       !
      call MPI_ABORT(MPI_COMM_WORLD,mp_errcode,mp_ierr)
      call MPI_FINALIZE(mp_ierr)
!
!
      stop
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mp_kin_pki
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! initialize mp packing array dimensions
! by counting up all packing array elements
      call mp_pki_theta
      call mp_pki_yspec
      call mp_pki_arkabd
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mpm_pki_o_dim
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
      if(mp_myid.ne.mp_mrid) return
      if(mp_nproc.eq.1) return
!
        open(31,file='ens.o01',status='old')
        iun=31
        call efile(iun)
!
        write(31,*)  ' '
        write(31,*)  ' '
        write(31,*)  ' mp-packing array dimensions'
!
        write(31,3010)   &
     &   mp_dim_theta, mp_dim_theta_x   &
     &  ,mp_dim_arkabd, mp_dim_arkabd_x
!
 3010   format(/                                  &
     &  /'    mp_dim_theta  mp_dim_theta_x'       &
     &  / 2i16                                    &
     &  /'   mp_dim_arkabd mp_dim_arkabd_x'       &
     &  / 2i16                                    &
     &  /                                         &
     &  /' iexpt   mp_dim_yspec1   mp_dim_yspec2' &
     &        ,'   mp_dim_yspec4  mp_dim_yspec_x' &
     &  )
!
!
        write(31,3012)               &
     &  (iexpt                       &
     &  ,mp_dim_yspec1(iexpt)        &
     &  ,mp_dim_yspec2(iexpt)        &
     &  ,mp_dim_yspec4(iexpt)        &
     &  ,mp_dim_yspec_x              &
     &  ,iexpt=1,nexpt)
!
 3012   format(                      &
     &  i6, 4i16                     &
     &  )
!
        close(31)
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mp_pki_theta
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! counts packing array dimension to ship theta Mr->Sv
!
! Mr+Sv Code:
!
! initial mp_ipak=1 b/c already theta_pk(1)=jmp_kin
      mp_ipak=1
!
! theta variables
!
      do ispec=1,nspec
        do ipm=1,npmspec(ispec)
          if(jctspec(ispec,ipm).le.9) then
            mp_ipak=mp_ipak+1
!c          theta_pk(mp_ipak)=cspec(ispec,ipm)
          endif
        enddo
      enddo
!
      do ireac=1,nreac
        do ipm=1,npmreac(ireac)
          if(jctreac(ireac,ipm).le.9) then
            mp_ipak=mp_ipak+1
!c          theta_pk(mp_ipak)=rreac(ireac,ipm)
          endif
        enddo
      enddo
!
! move schedule parameters
!
!V091218:
      mp_ipak=mp_ipak+1
!c    theta_pk(mp_ipak)=imc_smp
!:V091218
!
      mp_ipak=mp_ipak+1
!c    theta_pk(mp_ipak)=imc_rep
!
      mp_ipak=mp_ipak+1
!c    theta_pk(mp_ipak)=imc_eql
!
      mp_ipak=mp_ipak+1
!c    theta_pk(mp_ipak)=imc_acc
!
      mp_ipak=mp_ipak+1
!c    theta_pk(mp_ipak)=imc_upd
!
      mp_ipak=mp_ipak+1
!c    theta_pk(mp_ipak)=jmvloop
!
      mp_ipak=mp_ipak+1
!c    theta_pk(mp_ipak)=imvsequ
!
      mp_ipak=mp_ipak+1
!c    theta_pk(mp_ipak)=kmvsequ
!
      mp_ipak=mp_ipak+1
!c    theta_pk(mp_ipak)=imove
!
      mp_ipak=mp_ipak+1
!c    theta_pk(mp_ipak)=kmove
!
      mp_ipak=mp_ipak+1
!c    theta_pk(mp_ipak)=ith_rk
!
      mp_ipak=mp_ipak+1
!c    theta_pk(mp_ipak)=ith_cs
!
! misc. FT tems to include in theta_pk:
      mp_ipak=mp_ipak+1
!c    theta_pk(mp_ipak)=jsft_mc_imv
!
        mp_ipak=mp_ipak+1
!c      theta_pk(mp_ipak)=jsft_ln_imv
!
        mp_ipak=mp_ipak+1
!c      theta_pk(mp_ipak)=jsft_pf_imv
!
        mp_ipak=mp_ipak+1
!c      theta_pk(mp_ipak)=jsft_wf_imv
!
        mp_ipak=mp_ipak+1
!c      theta_pk(mp_ipak)=jsft_xd_imv
!
        do iexpt=1,nexpt
          do isegft=1,nsegft(iexpt)
            do ifil_frq=1,nfil_frq(isegft,iexpt)
              mp_ipak=mp_ipak+1
!c            theta_pk(mp_ipak)=                                          &
!c   &        wfour_sfil(ifil_frq,isegft,iexpt)
            enddo
          enddo
        enddo
!
!ccc  mp_ipak=mp_ipak+1
!cccc theta_pk(mp_ipak)=jkrxdi
!
!ccc  mp_ipak=mp_ipak+1
!cccc theta_pk(mp_ipak)=jsfxdi
!
!
      mp_dim_theta=mp_ipak
      if(mp_dim_theta.gt.mp_dim_theta_x) then
        errtag='mr+sv:mp_pki_theta:mp_dim_theta_x'
        call err_term
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mpm_pak_theta
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! mp packing of theta etc. for mr->sv shipment
!
! Mr code:
!
      if(mp_nproc.eq.1) return
      if(mp_myid.ne.mp_mrid) return
!
! initial mp_ipak=1 b/c already theta_pk(1)=jmp_kin
      mp_ipak=1
!
! theta variables
!
      do ispec=1,nspec
        do ipm=1,npmspec(ispec)
          if(jctspec(ispec,ipm).le.9) then
            mp_ipak=mp_ipak+1
            theta_pk(mp_ipak)=cspec(ispec,ipm)
          endif
        enddo
      enddo
!
      do ireac=1,nreac
        do ipm=1,npmreac(ireac)
          if(jctreac(ireac,ipm).le.9) then
            mp_ipak=mp_ipak+1
            theta_pk(mp_ipak)=rreac(ireac,ipm)
          endif
        enddo
      enddo
!
! move schedule parameters
!
!V091218:
      mp_ipak=mp_ipak+1
      theta_pk(mp_ipak)=imc_smp
!:V091218
!
      mp_ipak=mp_ipak+1
      theta_pk(mp_ipak)=imc_rep
!
      mp_ipak=mp_ipak+1
      theta_pk(mp_ipak)=imc_eql
!
      mp_ipak=mp_ipak+1
      theta_pk(mp_ipak)=imc_acc
!
      mp_ipak=mp_ipak+1
      theta_pk(mp_ipak)=imc_upd
!
      mp_ipak=mp_ipak+1
      theta_pk(mp_ipak)=jmvloop
!
      mp_ipak=mp_ipak+1
      theta_pk(mp_ipak)=imvsequ
!
      mp_ipak=mp_ipak+1
      theta_pk(mp_ipak)=kmvsequ
!
      mp_ipak=mp_ipak+1
      theta_pk(mp_ipak)=imove
!
      mp_ipak=mp_ipak+1
      theta_pk(mp_ipak)=kmove
!
      mp_ipak=mp_ipak+1
      theta_pk(mp_ipak)=ith_rk
!
      mp_ipak=mp_ipak+1
      theta_pk(mp_ipak)=ith_cs
!
! misc. FT items to include in theta_pk:
      mp_ipak=mp_ipak+1
      theta_pk(mp_ipak)=jsft_mc_imv
!
        mp_ipak=mp_ipak+1
        theta_pk(mp_ipak)=jsft_ln_imv
!
        mp_ipak=mp_ipak+1
        theta_pk(mp_ipak)=jsft_pf_imv
!
        mp_ipak=mp_ipak+1
        theta_pk(mp_ipak)=jsft_wf_imv
!
        mp_ipak=mp_ipak+1
        theta_pk(mp_ipak)=jsft_xd_imv
!
        do iexpt=1,nexpt
          do isegft=1,nsegft(iexpt)
            do ifil_frq=1,nfil_frq(isegft,iexpt)
              mp_ipak=mp_ipak+1
              theta_pk(mp_ipak)=                                          &
     &        wfour_sfil(ifil_frq,isegft,iexpt)
            enddo
          enddo
        enddo
!
!ccc  mp_ipak=mp_ipak+1
!cccc theta_pk(mp_ipak)=jkrxdi
!
!ccc  mp_ipak=mp_ipak+1
!cccc theta_pk(mp_ipak)=jsfxdi
!
!
      if(mp_dim_theta.ne.mp_ipak) then
        errtag='mr:mpm_pak_theta:mp_ipak'
        call err_term
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mp_DB_out_theta
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! mp packing of theta etc. for mr->sv shipment
!
! Mr+SV code:
!
! initial mp_ipak=1 b/c already theta_pk(1)=jmp_kin
      mp_ipak=1
!
! theta variables
!
      write(39,9010) mp_ipak, mp_myid
 9010 format(   &
     &/ 'mp_DB_out_theta: > Initial mp_ipak, mp_myid=', 2i8       &
     &/' mp_ipak   ispec     ipm           cspec'    &
     &)
!
      do ispec=1,nspec
        do ipm=1,npmspec(ispec)
          if(jctspec(ispec,ipm).le.9) then
            mp_ipak=mp_ipak+1
      write(39,9012) mp_ipak, ipm, ispec, cspec(ispec,ipm)
 9012 format( 3i8,d16.8)
          endif
        enddo
      enddo
!
!
      write(39,9020)
 9020 format(/     &
     &' mp_ipak   ireac     ipm           rreac'    &
     &)
      do ireac=1,nreac
        do ipm=1,npmreac(ireac)
          if(jctreac(ireac,ipm).le.9) then
            mp_ipak=mp_ipak+1
      write(39,9022) mp_ipak, ipm, ireac, rreac(ireac,ipm)
 9022 format( 3i8,d16.8)
          endif
        enddo
      enddo
!
! move schedule parameters
!
      mp_ipak=mp_ipak+1
!!!   theta_pk(mp_ipak)=imc_rep
!
      mp_ipak=mp_ipak+1
!!!   theta_pk(mp_ipak)=imc_eql
!
      mp_ipak=mp_ipak+1
!!!   theta_pk(mp_ipak)=imc_acc
!
      mp_ipak=mp_ipak+1
!!!   theta_pk(mp_ipak)=imc_upd
!
      mp_ipak=mp_ipak+1
!!!   theta_pk(mp_ipak)=jmvloop
!
      mp_ipak=mp_ipak+1
!!!   theta_pk(mp_ipak)=imvsequ
!
      mp_ipak=mp_ipak+1
!!!   theta_pk(mp_ipak)=kmvsequ
!
      mp_ipak=mp_ipak+1
!!!   theta_pk(mp_ipak)=imove
!
      mp_ipak=mp_ipak+1
!!!   theta_pk(mp_ipak)=kmove
!
      mp_ipak=mp_ipak+1
!!!   theta_pk(mp_ipak)=ith_rk
!
      mp_ipak=mp_ipak+1
!!!   theta_pk(mp_ipak)=ith_cs
!
! misc. FT tems to include in theta_pk:
      mp_ipak=mp_ipak+1
!!!   theta_pk(mp_ipak)=jsft_mc_imv
!
        mp_ipak=mp_ipak+1
!!!     theta_pk(mp_ipak)=jsft_ln_imv
!
        mp_ipak=mp_ipak+1
!!!     theta_pk(mp_ipak)=jsft_pf_imv
!
        mp_ipak=mp_ipak+1
!!!     theta_pk(mp_ipak)=jsft_wf_imv
!
        mp_ipak=mp_ipak+1
!!!     theta_pk(mp_ipak)=jsft_xd_imv
!
        do iexpt=1,nexpt
          do isegft=1,nsegft(iexpt)
            do ifil_frq=1,nfil_frq(isegft,iexpt)
              mp_ipak=mp_ipak+1
!!!           theta_pk(mp_ipak)=                                          &
!!!  &        wfour_sfil(ifil_frq,isegft,iexpt)
            enddo
          enddo
        enddo
!
!ccc  mp_ipak=mp_ipak+1
!cccc theta_pk(mp_ipak)=jkrxdi
!
!ccc  mp_ipak=mp_ipak+1
!cccc theta_pk(mp_ipak)=jsfxdi
!
!
      if(mp_dim_theta.ne.mp_ipak) then
        errtag='mr:mpm_pak_theta:mp_ipak'
        call err_term
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mps_upk_theta
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! mp unpacking of theta etc. from mr->sv shipment
!
! Sv code:
!
! initial mp_ipak=1 b/c already theta_pk(1)=jmp_kin
      mp_ipak=1
!
! theta variables
!
      do ispec=1,nspec
        do ipm=1,npmspec(ispec)
          if(jctspec(ispec,ipm).le.9) then
            mp_ipak=mp_ipak+1
            cspec(ispec,ipm)=theta_pk(mp_ipak)
          endif
        enddo
      enddo
!
      do ireac=1,nreac
        do ipm=1,npmreac(ireac)
          if(jctreac(ireac,ipm).le.9) then
            mp_ipak=mp_ipak+1
            rreac(ireac,ipm)=theta_pk(mp_ipak)
          endif
        enddo
      enddo
!
! move schedule parameters
!
!V091218:
      mp_ipak=mp_ipak+1
      imc_smp=myint(theta_pk(mp_ipak))
!:V091218
!
      mp_ipak=mp_ipak+1
      imc_rep=myint(theta_pk(mp_ipak))
!
      mp_ipak=mp_ipak+1
      imc_eql=myint(theta_pk(mp_ipak))
!
      mp_ipak=mp_ipak+1
      imc_acc=myint(theta_pk(mp_ipak))
!
      mp_ipak=mp_ipak+1
      imc_upd=myint(theta_pk(mp_ipak))
!
      mp_ipak=mp_ipak+1
      jmvloop=myint(theta_pk(mp_ipak))
!
      mp_ipak=mp_ipak+1
      imvsequ=myint(theta_pk(mp_ipak))
!
      mp_ipak=mp_ipak+1
      kmvsequ=myint(theta_pk(mp_ipak))
!
      mp_ipak=mp_ipak+1
      imove=myint(theta_pk(mp_ipak))
!
      mp_ipak=mp_ipak+1
      kmove=myint(theta_pk(mp_ipak))
!
      mp_ipak=mp_ipak+1
      ith_rk=myint(theta_pk(mp_ipak))
!
      mp_ipak=mp_ipak+1
      ith_cs=myint(theta_pk(mp_ipak))
!
! misc. FT items to include in theta_pk:
      mp_ipak=mp_ipak+1
      jsft_mc_imv=myint(theta_pk(mp_ipak))
!
        mp_ipak=mp_ipak+1
        jsft_ln_imv=myint(theta_pk(mp_ipak))
!
        mp_ipak=mp_ipak+1
        jsft_pf_imv=myint(theta_pk(mp_ipak))
!
        mp_ipak=mp_ipak+1
        jsft_wf_imv=myint(theta_pk(mp_ipak))
!
        mp_ipak=mp_ipak+1
        jsft_xd_imv=myint(theta_pk(mp_ipak))
!
        do iexpt=1,nexpt
          do isegft=1,nsegft(iexpt)
            do ifil_frq=1,nfil_frq(isegft,iexpt)
              mp_ipak=mp_ipak+1
              wfour_sfil(ifil_frq,isegft,iexpt)                           &
     &        =theta_pk(mp_ipak)
            enddo
          enddo
        enddo
!
!ccc  mp_ipak=mp_ipak+1
!cccc jkrxdi=myint(theta_pk(mp_ipak))
!
!ccc  mp_ipak=mp_ipak+1
!cccc jsfxdi=myint(theta_pk(mp_ipak))
!
!
      if(mp_dim_theta.ne.mp_ipak) then
        errtag='sv:mps_upk_theta:mp_ipak'
        call err_term
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mp_pki_yspec
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! counts packing array dimension to ship yspec Sv->Mr
!
! Mr+Sv Code:
!
!
      do iexpt=1,nexpt
!
      iexpt_pak=iexpt
!
      mp_ipak=0
!
!  Insert before all other cargo; to be sent for any jmp_kin.
!
!DRLIM190524-2244:
!  Pack count of rate fct calls first:
      mp_ipak=mp_ipak+1
!c    yspec_pk(mp_ipak)=                                                  &
!c   & n_drv
!:DRLIM190524-2244
!
!  Pack only crdpen-values for that iexpt_pak
!  which was actually calculated by Sv. Therefore:
!  use ndpen_tot = partial crdpen-array size for one iexpt_pak only
      do idpen=1,ndpen_tot
        mp_ipak=mp_ipak+1
!c      yspec_pk(mp_ipak)=                                                &
!c   &  crdpen(lcrdp_dpen(idpen,iexpt_pak))
      enddo
!
!
      mp_dim_yspec_inc0=mp_ipak
!
! output from kin_xpt:
!
!c    if(jmp_kin.eq.1.or.jmp_kin.eq.4) then
        do ims=1,nms_spec
          ispecB=ispec_ms(ims)
!
          if(jmsspec_px(ispecB).eq.0) then
            do itmx=itmx_ini(ims,iexpt_pak),itmx_fin(ims,iexpt_pak)
              mp_ipak=mp_ipak+1
!c            yspec_pk(mp_ipak)=                                          &
!c   &        xspec_chi(itmx)
!
              mp_ipak=mp_ipak+1
!c            yspec_pk(mp_ipak)=                                          &
!c   &        yspec_chi(itmx)
            enddo
          endif
!
          if(jmsspec_px(ispecB).eq.1) then
            do iipch=iipch_ini(ims,iexpt_pak),iipch_fin(ims,iexpt_pak)
              mp_ipak=mp_ipak+1
!c            yspec_pk(mp_ipak)=                                          &
!c   &        zspec_ipch(iipch)
            enddo
          endif
        enddo
          do ktsxdc=1,mtsxdc_max
            mp_ipak=mp_ipak+1
!c          xspec_tsxdc(1,ktsxdc+itsxdc_inixp(iexpt_pak)-1)
!c   &      =yspec_pk(mp_ipak)
!
            mp_ipak=mp_ipak+1
!c          xspec_tsxdc(2,ktsxdc+itsxdc_inixp(iexpt_pak)-1)
!c   &      =yspec_pk(mp_ipak)
          enddo
!
! output from kin_qbx:
!
        do ibx_time=1,nbx_time
          do ivs=1,nvs_spec
            mp_ipak=mp_ipak+1
!c          yspec_pk(mp_ipak)=                                            &
!c   &      yspec_qbx(ivs,ibx_time,iexpt_pak)
          enddo
        enddo
!
! output from kin_four:
!
        if(nsegft(iexpt_pak).ge.1) then
          do isegft=1,nsegft(iexpt_pak)
            do is_ft=1,nsft_spec
              mp_ipak=mp_ipak+1
!c            yspec_pk(mp_ipak)=                                          &
!c   &        pfour_sfil(is_ft,isegft,iexpt_pak)
!
              mp_ipak=mp_ipak+1
!c            yspec_pk(mp_ipak)=                                          &
!c   &        pfour_stot(is_ft,isegft,iexpt_pak)
            enddo
          enddo
        endif
!
      mp_dim_yspec_inc1                                                 &
     &=mp_ipak-mp_dim_yspec_inc0
!
! output from kin_xspec_o:
!
!c    if(jmp_kin.eq.2.or.jmp_kin.eq.3) then
        do io_time=1,no_time
          do ispec=1,nspec
            mp_ipak=mp_ipak+1
!c          yspec_pk(mp_ipak)=                                          &
!c   &      yspec_o(ispec,io_time,iexpt_pak)
          enddo
        enddo
!c    endif
!
      mp_dim_yspec_inc2                                                 &
     &=mp_ipak-mp_dim_yspec_inc1-mp_dim_yspec_inc0
!
! output from kin_truv:
!
!c    if(jmp_kin.eq.4) then
        do ims=1,nms_spec
          ispec=ispec_ms(ims)
          do itmx=itmx_ini(ims,iexpt_pak),itmx_fin(ims,iexpt_pak)
            mp_ipak=mp_ipak+1
!c          yspec_pk(mp_ipak)=                                          &
!c   &      yspec_tru(itmx)
          enddo
        enddo
!c    endif
!
      mp_dim_yspec_inc4                                                 &
     &=mp_ipak-mp_dim_yspec_inc2-mp_dim_yspec_inc1-mp_dim_yspec_inc0
!
!
      mp_dim_yspec1(iexpt_pak)= &
     &  mp_dim_yspec_inc1+mp_dim_yspec_inc0
!
      mp_dim_yspec2(iexpt_pak)= &
     &  mp_dim_yspec_inc2+mp_dim_yspec_inc0
!
      mp_dim_yspec4(iexpt_pak)= &
     &  mp_dim_yspec_inc4+mp_dim_yspec_inc1+mp_dim_yspec_inc0
!
      if(       &
     &  mp_dim_yspec1(iexpt_pak).gt.mp_dim_yspec_x.or.       &
     &  mp_dim_yspec2(iexpt_pak).gt.mp_dim_yspec_x.or.       &
     &  mp_dim_yspec4(iexpt_pak).gt.mp_dim_yspec_x       &
     &)then
        errtag='mr+sv:mp_pki_yspec:mp_dim_yspec_x'
        call err_term
      endif
!
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mps_pak_yspec
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! mp packing of yspec_xpt etc. for sv->mr shipment
!
!
! Sv Code:
!
!!    iexpt_pak=iexpt
!
      mp_ipak=0
!
!  Insert before all other cargo; to be sent for any jmp_kin.
!
!DRLIM190524-2244:
!  Pack count of rate fct calls first:
      mp_ipak=mp_ipak+1
      yspec_pk(mp_ipak)=                                                  &
     & n_drv
!:DRLIM190524-2244
!
!  Pack only crdpen-values for that iexpt_pak
!  which was actually calculated by Sv. Therefore:
!  use ndpen_tot = partial crdpen-array size for one iexpt_pak only
      do idpen=1,ndpen_tot
        mp_ipak=mp_ipak+1
        yspec_pk(mp_ipak)=                                                &
     &  crdpen(lcrdp_dpen(idpen,iexpt_pak))
      enddo
!
! output from kin_xpt:
!
      if(jmp_kin.eq.1.or.jmp_kin.eq.4) then
        do ims=1,nms_spec
          ispecB=ispec_ms(ims)
!
          if(jmsspec_px(ispecB).eq.0) then
            do itmx=itmx_ini(ims,iexpt_pak),itmx_fin(ims,iexpt_pak)
              mp_ipak=mp_ipak+1
              yspec_pk(mp_ipak)=                                          &
     &        xspec_chi(itmx)
!
              mp_ipak=mp_ipak+1
              yspec_pk(mp_ipak)=                                          &
     &        yspec_chi(itmx)
            enddo
          endif
!
          if(jmsspec_px(ispecB).eq.1) then
            do iipch=iipch_ini(ims,iexpt_pak),iipch_fin(ims,iexpt_pak)
              mp_ipak=mp_ipak+1
              yspec_pk(mp_ipak)=                                          &
     &        zspec_ipch(iipch)
            enddo
          endif
        enddo
!
          do ktsxdc=1,mtsxdc_xpt(iexpt_pak)
            mp_ipak=mp_ipak+1
            yspec_pk(mp_ipak)=                                          &
     &      xspec_tsxdc(1,ktsxdc+itsxdc_inixp(iexpt_pak)-1)
!
            mp_ipak=mp_ipak+1
            yspec_pk(mp_ipak)=                                          &
     &      xspec_tsxdc(2,ktsxdc+itsxdc_inixp(iexpt_pak)-1)
          enddo
!
! output from kin_qbx:
!
        do ibx_time=1,nbx_time
          do ivs=1,nvs_spec
            mp_ipak=mp_ipak+1
            yspec_pk(mp_ipak)=                                            &
     &      yspec_qbx(ivs,ibx_time,iexpt_pak)
          enddo
        enddo
!
! output from kin_four:
!
        if(nsegft(iexpt_pak).ge.1) then
          do isegft=1,nsegft(iexpt_pak)
            do is_ft=1,nsft_spec
              mp_ipak=mp_ipak+1
              yspec_pk(mp_ipak)=                                          &
     &        pfour_sfil(is_ft,isegft,iexpt_pak)
!
              mp_ipak=mp_ipak+1
              yspec_pk(mp_ipak)=                                          &
     &        pfour_stot(is_ft,isegft,iexpt_pak)
            enddo
          enddo
        endif
      endif
!
! output from kin_xspec_o:
!
      if(jmp_kin.eq.2.or.jmp_kin.eq.3) then
        do io_time=1,no_time
          do ispec=1,nspec
            mp_ipak=mp_ipak+1
            yspec_pk(mp_ipak)=                                          &
     &      yspec_o(ispec,io_time,iexpt_pak)
          enddo
        enddo
      endif
!
! output from kin_truv:
!
      if(jmp_kin.eq.4) then
        do ims=1,nms_spec
          ispec=ispec_ms(ims)
          do itmx=itmx_ini(ims,iexpt_pak),itmx_fin(ims,iexpt_pak)
            mp_ipak=mp_ipak+1
            yspec_pk(mp_ipak)=                                          &
     &      yspec_tru(itmx)
          enddo
        enddo
      endif
!
      if(jmp_kin.eq.1)                                                  &
     & mp_dim_yspec(iexpt_pak)=mp_dim_yspec1(iexpt_pak)
!
      if(jmp_kin.eq.2.or.jmp_kin.eq.3)                                  &
     & mp_dim_yspec(iexpt_pak)=mp_dim_yspec2(iexpt_pak)
!
      if(jmp_kin.eq.4)                                                  &
     & mp_dim_yspec(iexpt_pak)=mp_dim_yspec4(iexpt_pak)
!
      if(mp_dim_yspec(iexpt_pak).ne.mp_ipak) then
        errtag='sv:mps_pak_yspec:mp_ipak'
        call err_term
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mp_DB_out_yspec
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! mp packing of yspec_xpt etc. for sv->mr shipment
!
!
! Sv Code:
!
!!    iexpt_pak=iexpt
!
      mp_ipak=0
!
      write(39,9010) mp_ipak, iexpt_pak, mp_myid
 9010 format(   &
     &/ 'mp_DB_out_yspec: > Initial mp_ipak, iexpt_pak, mp_myid=', 3i8       &
     &)
!
! output from kin_xpt:
!
      if(jmp_kin.eq.1.or.jmp_kin.eq.4) then
        do ims=1,nms_spec
          ispecB=ispec_ms(ims)
!
      write(39,9012) iexpt_pak,ims,ispecB     &
     &              ,jmsspec_px(ispecB)
 9012 format(   &
     &/'   iexpt_pak         ims      ispecB  jmsspec_px'          &
     &/4i12                                                        &
     &)
!
          if(jmsspec_px(ispecB).eq.0) then
      write(39,9014)  jmsspec_px(ispecB)                       &
     &              ,itmx_ini(ims,iexpt_pak), itmx_fin(ims,iexpt_pak)
 9014 format(  &
     & 'writing out [x,y]spec_chi b/c jmsspec_px(ispecB)=' , i6     &
     &/' itmx_ini, itmx_fin=', 2i6       &
     &/' mp_ipak    itmx   itxpt'    &
     &,'        time_xpt       xspec_chi       yspec_chi'    &
     &/'                        '    &
     &,'          rt_xpt'     &
     &)
!
            do itmx=itmx_ini(ims,iexpt_pak),itmx_fin(ims,iexpt_pak)
              mp_ipak=mp_ipak+1
!!!           yspec_pk(mp_ipak)=                                          &
!!!  &        xspec_chi(itmx)
!
              mp_ipak=mp_ipak+1
!!!           yspec_pk(mp_ipak)=                                          &
!!!  &        yspec_chi(itmx)
      write(39,9016)                              &
     &              mp_ipak,itmx                  &
     &              ,itxpt_tmx(itmx)              &
     &              ,time_xpt(itxpt_tmx(itmx))    &
     &              ,xspec_chi(itmx)              &
     &              ,yspec_chi(itmx)              &
     &              ,rt_xpt(itxpt_tmx(itmx))
 9016 format(3i8,3d16.8/24x,d16.8)
            enddo
          endif
!
          if(jmsspec_px(ispecB).eq.1) then
      write(39,9024)  jmsspec_px(ispecB)         &
     &              ,iipch_ini(ims,iexpt_pak),iipch_fin(ims,iexpt_pak)
 9024 format(  &
     & 'writing out zspec_ipch b/c jmsspec_px(ispecB)=' , i6     &
     &/' iipch_ini, iipch_fin=', 2i6       &
     &/' mp_ipak   iipch        zspec_ipch'       &
     &)
            do iipch=iipch_ini(ims,iexpt_pak),iipch_fin(ims,iexpt_pak)
              mp_ipak=mp_ipak+1
!!!           yspec_pk(mp_ipak)=                                          &
!!!  &        zspec_ipch(iipch)
      write(39,9026)  mp_ipak,iipch,zspec_ipch(iipch)
 9026 format(2i8,d18.8)
            enddo
          endif
        enddo
!
! output from kin_qbx:
!
        do ibx_time=1,nbx_time
          do ivs=1,nvs_spec
            mp_ipak=mp_ipak+1
!!!         yspec_pk(mp_ipak)=                                            &
!!!  &      yspec_qbx(ivs,ibx_time,iexpt_pak)
          enddo
        enddo
!
! output from kin_four:
!
!ccc  if(jsft_mc_imv.ge.0.and.nsegft(iexpt_pak).ge.1) then
        if(nsegft(iexpt_pak).ge.1) then
          do isegft=1,nsegft(iexpt_pak)
            do is_ft=1,nsft_spec
              mp_ipak=mp_ipak+1
!!!           yspec_pk(mp_ipak)=                                          &
!!!  &        pfour_sfil(is_ft,isegft,iexpt_pak)
!
              mp_ipak=mp_ipak+1
!!!           yspec_pk(mp_ipak)=                                          &
!!!  &        pfour_stot(is_ft,isegft,iexpt_pak)
            enddo
          enddo
        endif
      endif
!
! output from kin_xspec_o:
!
      if(jmp_kin.eq.2.or.jmp_kin.eq.3) then
        do io_time=1,no_time
          do ispec=1,nspec
            mp_ipak=mp_ipak+1
!!!         yspec_pk(mp_ipak)=                                          &
!!!  &      yspec_o(ispec,io_time,iexpt_pak)
          enddo
        enddo
      endif
!
! output from kin_truv:
!
      if(jmp_kin.eq.4) then
        do ims=1,nms_spec
          ispec=ispec_ms(ims)
          do itmx=itmx_ini(ims,iexpt_pak),itmx_fin(ims,iexpt_pak)
            mp_ipak=mp_ipak+1
!!!         yspec_pk(mp_ipak)=                                          &
!!!  &      yspec_tru(itmx)
          enddo
        enddo
      endif
!
      if(jmp_kin.eq.1)                                                  &
     & mp_dim_yspec(iexpt_pak)=mp_dim_yspec1(iexpt_pak)
!
      if(jmp_kin.eq.2.or.jmp_kin.eq.3)                                  &
     & mp_dim_yspec(iexpt_pak)=mp_dim_yspec2(iexpt_pak)
!
      if(jmp_kin.eq.4)                                                  &
     & mp_dim_yspec(iexpt_pak)=mp_dim_yspec4(iexpt_pak)
!
      if(mp_dim_yspec(iexpt_pak).ne.mp_ipak) then
        errtag='sv:mps_pak_yspec:mp_ipak'
        call err_term
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mpm_upk_yspec
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! mp unpacking of yspec_xpt etc. from sv->mr shipment
!
!
! Mr Code:
!
      if(mp_nproc.eq.1) return
      if(mp_myid.ne.mp_mrid) return
!
!!    iexpt_pak=iexpt_upk  !  done in mpm_kin_recv_yspec
!
      mp_ipak=0
!
!  Insert before all other cargo; to be recvd for any jmp_kin.
!
!DRLIM190524-2244:
!  Unpack count of rate fct calls first:
      mp_ipak=mp_ipak+1
      n_drv_xp(iexpt_pak)=                                               &
     &nint(yspec_pk(mp_ipak))
!:DRLIM190524-2244
!
!  Unpack / extract only crdpen-values for that iexpt_pak
!  which was actually calculated and sent by Sv. Therefore:
!  use ndpen_tot = partial crdpen-array size for one iexpt_pak only
      do idpen=1,ndpen_tot
        mp_ipak=mp_ipak+1
        crdpen(lcrdp_dpen(idpen,iexpt_pak))=                             &
     &  yspec_pk(mp_ipak)
      enddo
!
! output from kin_xpt:
!
      if(jmp_kin.eq.1.or.jmp_kin.eq.4) then
        do ims=1,nms_spec
          ispecB=ispec_ms(ims)
!
          if(jmsspec_px(ispecB).eq.0) then
            do itmx=itmx_ini(ims,iexpt_pak),itmx_fin(ims,iexpt_pak)
              mp_ipak=mp_ipak+1
              xspec_chi(itmx)                                             &
     &        =yspec_pk(mp_ipak)
!
              mp_ipak=mp_ipak+1
              yspec_chi(itmx)                                             &
     &        =yspec_pk(mp_ipak)
            enddo
          endif
!
          if(jmsspec_px(ispecB).eq.1) then
            do iipch=iipch_ini(ims,iexpt_pak),iipch_fin(ims,iexpt_pak)
              mp_ipak=mp_ipak+1
              zspec_ipch(iipch)                                           &
     &        =yspec_pk(mp_ipak)
            enddo
          endif
        enddo
!
!        Must use "iexpt_pak" here, (not "expt") !!!
          do ktsxdc=1,mtsxdc_xpt(iexpt_pak)
            mp_ipak=mp_ipak+1
            xspec_tsxdc(1,ktsxdc+itsxdc_inixp(iexpt_pak)-1)      &
     &      =yspec_pk(mp_ipak)
!
            mp_ipak=mp_ipak+1
            xspec_tsxdc(2,ktsxdc+itsxdc_inixp(iexpt_pak)-1)      &
     &      =yspec_pk(mp_ipak)
          enddo
!
! output from kin_qbx:
!
        do ibx_time=1,nbx_time
          do ivs=1,nvs_spec
            mp_ipak=mp_ipak+1
            yspec_qbx(ivs,ibx_time,iexpt_pak)                             &
     &      =yspec_pk(mp_ipak)
          enddo
        enddo
!
! output from kin_four:
!
        if(nsegft(iexpt_pak).ge.1) then
          do isegft=1,nsegft(iexpt_pak)
            do is_ft=1,nsft_spec
              mp_ipak=mp_ipak+1
              pfour_sfil(is_ft,isegft,iexpt_pak)                          &
     &        =yspec_pk(mp_ipak)
!
              mp_ipak=mp_ipak+1
              pfour_stot(is_ft,isegft,iexpt_pak)                          &
     &        =yspec_pk(mp_ipak)
            enddo
          enddo
        endif
      endif
!
! output from kin_xspec_o:
!
      if(jmp_kin.eq.2.or.jmp_kin.eq.3) then
        do io_time=1,no_time
          do ispec=1,nspec
            mp_ipak=mp_ipak+1
            yspec_o(ispec,io_time,iexpt_pak)                                &
     &      =yspec_pk(mp_ipak)
            xspec_o(ispec,io_time,iexpt_pak)                                &
     &      =dexxp(yspec_pk(mp_ipak),-58.d0,58.d0)
          enddo
        enddo
      endif
!
! output from kin_truv:
!
      if(jmp_kin.eq.4) then
        do ims=1,nms_spec
          ispec=ispec_ms(ims)
          do itmx=itmx_ini(ims,iexpt_pak),itmx_fin(ims,iexpt_pak)
            mp_ipak=mp_ipak+1
            yspec_tru(itmx)                                             &
     &      =yspec_pk(mp_ipak)
            xspec_tru(itmx)                                             &
     &      =dexxp(yspec_pk(mp_ipak),-58.d0,58.d0)
          enddo
        enddo
      endif
!
!
      if(jmp_kin.eq.1)                                                  &
     & mp_dim_yspec(iexpt_pak)=mp_dim_yspec1(iexpt_pak)
!
      if(jmp_kin.eq.2.or.jmp_kin.eq.3)                                  &
     & mp_dim_yspec(iexpt_pak)=mp_dim_yspec2(iexpt_pak)
!
      if(jmp_kin.eq.4)                                                  &
     & mp_dim_yspec(iexpt_pak)=mp_dim_yspec4(iexpt_pak)
!
      if(mp_dim_yspec(iexpt_pak).ne.mp_ipak) then
        errtag='mr:mpm_upk_yspec:mp_ipak'
        call err_term
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mp_pki_arkabd
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! mp packing of ark_...(itime), abd_...(itime) for sv->mr shipment
!
      if(jo_th_ark.ge.1) then
        mp_ipak=0
!
        mp_ipak=mp_ipak+1
!c      arkabd_pk(mp_ipak)=                                             &
!c   &  ark_ksol
!
        do itime=0,ntime
          mp_ipak=mp_ipak+1
!c        arkabd_pk(mp_ipak)=                                           &
!c   &    ark_kstp(itime)
!
          mp_ipak=mp_ipak+1
!c        arkabd_pk(mp_ipak)=                                           &
!c   &    ark_kdrv(itime)
!
          mp_ipak=mp_ipak+1
!c        arkabd_pk(mp_ipak)=                                           &
!c   &    ark_ksto(itime)
!
          mp_ipak=mp_ipak+1
!c        arkabd_pk(mp_ipak)=                                           &
!c   &    ark_kbad(itime)
!
          mp_ipak=mp_ipak+1
!c        arkabd_pk(mp_ipak)=                                           &
!c   &    ark_koks(itime)
!
          mp_ipak=mp_ipak+1
!c        arkabd_pk(mp_ipak)=                                           &
!c   &    ark_kslo(itime)
!
!
          mp_ipak=mp_ipak+1
!c        arkabd_pk(mp_ipak)=                                           &
!c   &    ark_khlo(itime_f,1)
!
          mp_ipak=mp_ipak+1
!c        arkabd_pk(mp_ipak)=                                           &
!c   &    ark_khlo(itime_f,2)
!
          mp_ipak=mp_ipak+1
!c        arkabd_pk(mp_ipak)=                                           &
!c   &    ark_lhlo(itime_f,1)
!
          mp_ipak=mp_ipak+1
!c        arkabd_pk(mp_ipak)=                                           &
!c   &    ark_lhlo(itime_f,2)
!
          mp_ipak=mp_ipak+1
!c        arkabd_pk(mp_ipak)=                                           &
!c   &    ark_lerx(itime_f,1)
!
          mp_ipak=mp_ipak+1
!c        arkabd_pk(mp_ipak)=                                           &
!c   &    ark_lerx(itime_f,2)
!
!
          mp_ipak=mp_ipak+1
!c        arkabd_pk(mp_ipak)=                                           &
!c   &    abd_kfai(itime)
!
          mp_ipak=mp_ipak+1
!c        arkabd_pk(mp_ipak)=                                           &
!c   &    abd_krdo(itime)
!
          mp_ipak=mp_ipak+1
!c        arkabd_pk(mp_ipak)=                                           &
!c   &    abd_krin(itime)
!
          mp_ipak=mp_ipak+1
!c        arkabd_pk(mp_ipak)=                                           &
!c   &    abd_kjac(itime)
!
          do idum=1,7
            mp_ipak=mp_ipak+1
!c          arkabd_pk(mp_ipak)=                                         &
!c   &      abd_kist(itime,idum)
          enddo
        enddo
!
        mp_dim_arkabd=mp_ipak
!
        if(mp_dim_arkabd.gt.mp_dim_arkabd_x) then
          errtag='mr+sv:mp_pki_arkabd:mp_dim_arkabd_x'
          call err_term
        endif
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mps_pak_arkabd
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! mp packing of ark_...(itime), abd_...(itime) for sv->mr shipment
!
!cc   if(jo_th_ark.ge.1) then
        mp_ipak=0
!
        mp_ipak=mp_ipak+1
        arkabd_pk(mp_ipak)=                                             &
     &  ark_ksol
!
        do itime=0,ntime
          mp_ipak=mp_ipak+1
          arkabd_pk(mp_ipak)=                                           &
     &    ark_kstp(itime)
!
          mp_ipak=mp_ipak+1
          arkabd_pk(mp_ipak)=                                           &
     &    ark_kdrv(itime)
!
          mp_ipak=mp_ipak+1
          arkabd_pk(mp_ipak)=                                           &
     &    ark_ksto(itime)
!
          mp_ipak=mp_ipak+1
          arkabd_pk(mp_ipak)=                                           &
     &    ark_kbad(itime)
!
          mp_ipak=mp_ipak+1
          arkabd_pk(mp_ipak)=                                           &
     &    ark_koks(itime)
!
          mp_ipak=mp_ipak+1
          arkabd_pk(mp_ipak)=                                           &
     &    ark_kslo(itime)
!
!
          mp_ipak=mp_ipak+1
          arkabd_pk(mp_ipak)=                                           &
     &    ark_khlo(itime_f,1)
!
          mp_ipak=mp_ipak+1
          arkabd_pk(mp_ipak)=                                           &
     &    ark_khlo(itime_f,2)
!
          mp_ipak=mp_ipak+1
          arkabd_pk(mp_ipak)=                                           &
     &    ark_lhlo(itime_f,1)
!
          mp_ipak=mp_ipak+1
          arkabd_pk(mp_ipak)=                                           &
     &    ark_lhlo(itime_f,2)
!
          mp_ipak=mp_ipak+1
          arkabd_pk(mp_ipak)=                                           &
     &    ark_lerx(itime_f,1)
!
          mp_ipak=mp_ipak+1
          arkabd_pk(mp_ipak)=                                           &
     &    ark_lerx(itime_f,2)
!
!
          mp_ipak=mp_ipak+1
          arkabd_pk(mp_ipak)=                                           &
     &    abd_kfai(itime)
!
          mp_ipak=mp_ipak+1
          arkabd_pk(mp_ipak)=                                           &
     &    abd_krdo(itime)
!
          mp_ipak=mp_ipak+1
          arkabd_pk(mp_ipak)=                                           &
     &    abd_krin(itime)
!
          mp_ipak=mp_ipak+1
          arkabd_pk(mp_ipak)=                                           &
     &    abd_kjac(itime)
!
          do idum=1,7
            mp_ipak=mp_ipak+1
            arkabd_pk(mp_ipak)=                                         &
     &      abd_kist(itime,idum)
          enddo
        enddo
!
!
        if(mp_dim_arkabd.ne.mp_ipak) then
          errtag='sv:mps_pak_arkabd:mp_ipak'
          call err_term
        endif
!cc   endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mpm_upk_arkabd
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! Mr Code:
!
! mp unpacking of ark_...(itime), abd_...(itime) from sv->mr shipment
!
      if(mp_nproc.eq.1) return
      if(mp_myid.ne.mp_mrid) return
!
!cc   if(jo_th_ark.ge.1) then
        mp_ipak=0
!
        mp_ipak=mp_ipak+1
        ark_ksol=                                                       &
     &  ark_ksol                                                        &
     &  +arkabd_pk(mp_ipak)
!
        do itime=0,ntime
          mp_ipak=mp_ipak+1
          ark_kstp(itime)=                                              &
     &    ark_kstp(itime)                                               &
     &    +arkabd_pk(mp_ipak)
!
          mp_ipak=mp_ipak+1
          ark_kdrv(itime)=                                              &
     &    ark_kdrv(itime)                                               &
     &    +arkabd_pk(mp_ipak)
!
          mp_ipak=mp_ipak+1
          ark_ksto(itime)=                                              &
     &    ark_ksto(itime)                                               &
     &    +arkabd_pk(mp_ipak)
!
          mp_ipak=mp_ipak+1
          ark_kbad(itime)=                                              &
     &    ark_kbad(itime)                                               &
     &    +arkabd_pk(mp_ipak)
!
          mp_ipak=mp_ipak+1
          ark_koks(itime)=                                              &
     &    ark_koks(itime)                                               &
     &    +arkabd_pk(mp_ipak)
!
          mp_ipak=mp_ipak+1
          ark_kslo(itime)=                                              &
     &    ark_kslo(itime)                                               &
     &    +arkabd_pk(mp_ipak)
!
!
          mp_ipak=mp_ipak+1
          ark_khlo(itime_f,1)=                                          &
     &    ark_khlo(itime_f,1)                                           &
     &    +arkabd_pk(mp_ipak)
!
          mp_ipak=mp_ipak+1
          ark_khlo(itime_f,2)=                                          &
     &    ark_khlo(itime_f,2)                                           &
     &    +arkabd_pk(mp_ipak)
!
          mp_ipak=mp_ipak+1
          ark_lhlo(itime_f,1)=                                          &
     &    ark_lhlo(itime_f,1)                                           &
     &    +arkabd_pk(mp_ipak)
!
          mp_ipak=mp_ipak+1
          ark_lhlo(itime_f,2)=                                          &
     &    ark_lhlo(itime_f,2)                                           &
     &    +arkabd_pk(mp_ipak)
!
          mp_ipak=mp_ipak+1
          ark_lerx(itime_f,1)=                                          &
     &    ark_lerx(itime_f,1)                                           &
     &    +arkabd_pk(mp_ipak)
!
          mp_ipak=mp_ipak+1
          ark_lerx(itime_f,2)=                                          &
     &    ark_lerx(itime_f,2)                                           &
     &    +arkabd_pk(mp_ipak)
!
!
          mp_ipak=mp_ipak+1
          abd_kfai(itime)=                                              &
     &    abd_kfai(itime)                                               &
     &    +arkabd_pk(mp_ipak)
!
          mp_ipak=mp_ipak+1
          abd_krdo(itime)=                                              &
     &    abd_krdo(itime)                                               &
     &    +arkabd_pk(mp_ipak)
!
          mp_ipak=mp_ipak+1
          abd_krin(itime)=                                              &
     &    abd_krin(itime)                                               &
     &    +arkabd_pk(mp_ipak)
!
          mp_ipak=mp_ipak+1
          abd_kjac(itime)=                                              &
     &    abd_kjac(itime)                                               &
     &    +arkabd_pk(mp_ipak)
!
          do idum=1,7
            mp_ipak=mp_ipak+1
            abd_kist(itime,idum)=                                       &
     &      abd_kist(itime,idum)                                        &
     &      +arkabd_pk(mp_ipak)
          enddo
        enddo
!
        if(mp_dim_arkabd.ne.mp_ipak) then
          errtag='mr:mpm_upk_arkabd:mp_ipak'
          call err_term
        endif
!cc   endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mp_cktag(mp_ntag,mp_myid,mp_mrid,namtag_itglob)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! Mr+Sv Code:
!
! Note:
! When adding new tag name assignment
!       namtag='...'
! anywhere in the code, the same name assignment
! must be entered TWICE in lists below, in with
! preceding it-counter, in the following format:
! First, in the "tag name count list", commented out:
!       it=it+1
! !!    namtag_it(it)='...'
! Second, in the  "tag name assign list", uncommented:
!       it=it+1
!       namtag_it(it)='...'
!
      implicit none
!
      logical eqname, fexist
!
      integer mp_ntag_x
      parameter (mp_ntag_x=100)
!
      integer                                            &
     &        it, it_ck, mp_ntag            &
     &      , mp_myid, mp_mrid, iunam
!
      character*80 cknam
!
! local common block variables+arrays,
! shared with fctn. mp_itag:
      integer    &
     &        mp_ntag_loc, mp_ntag_xloc   &
     &      , mp_myid_loc, mp_mrid_loc
      character*80 namtag_it(1:2*mp_ntag_x)
      character*80 namtag_itglob(1:2*mp_ntag_x)
!
      common /mptag_iv01/                 &
     &        mp_ntag_loc, mp_ntag_xloc   &
     &      , mp_myid_loc, mp_mrid_loc
      common /mptag_ch01/ namtag_it
!
!
      inquire(file='ens.o01',exist=fexist)
      if(fexist) then
        open(31,file='ens.o01',status='old')
        iunam=31
        rewind(iunam)
      else
!BLADE:
!       open(31,file='ens.o01',status='new')
        open(31,file='ens.o01')
!:BLADE
        rewind(31)
      endif
!
!
! source code tag name check:
      cknam='namtag'
!
! sharing local array size + IDs w/ mp_itag
      mp_ntag_xloc=mp_ntag_x
      mp_myid_loc=mp_myid
      mp_mrid_loc=mp_mrid
!
! initial error parameters
      it_ck=-1
!
!
!---------------------------------------------------------
!     tag name count list:
!---------------------------------------------------------
      it=0
!
      it=it+1
!!    namtag_it(it)='mr:mpm_task_send:jmp_task:000'
      it=it+1
!!    namtag_it(it)='mr:mp_qfin:mp_qiniid:000'
      it=it+1
!!    namtag_it(it)='sv:mp_qfin:mp_qfinid:000'
      it=it+1
!!    namtag_it(it)='mr:mpm_kin_send_theta:theta_pk:000'
      it=it+1
!!    namtag_it(it)='mr:mpm_kin_send_iexpt:iexpt:000'
      it=it+1
!!    namtag_it(it)='sv:mps_kin_send_yspec:jmp_fin_yspec:000'
      it=it+1
!!    namtag_it(it)='mr:mpm_kin_recv_yspec:jmp_fin_yspec:000'
      it=it+1
!!    namtag_it(it)='sv:mps_kin_send_yspec:yspec_pk:000'
      it=it+1
!!    namtag_it(it)='sv:mps_kin_send_arkabd:jmp_fin_arkabd:000'
      it=it+1
!!    namtag_it(it)='mr:mpm_kin_recv_arkabd:jmp_fin_arkabd:000'
      it=it+1
!!    namtag_it(it)='sv:mps_kin_send_arkabd:arkabd_pk:000'
      it=it+1
!!    namtag_it(it)='sv:mps_DB_kin_send_theta:theta_pk:000'
!---------------------------------------------------------
!     end of count list
!---------------------------------------------------------
!
      mp_ntag=it
!
      if(mp_ntag.gt.mp_ntag_x) then
        goto 981
      endif
!
!
!---------------------------------------------------------
!     tag name assign list:
!---------------------------------------------------------
      it=0
!
      it=it+1
      namtag_it(it)='mr:mpm_task_send:jmp_task:000'
      it=it+1
      namtag_it(it)='mr:mp_qfin:mp_qiniid:000'
      it=it+1
      namtag_it(it)='sv:mp_qfin:mp_qfinid:000'
      it=it+1
      namtag_it(it)='mr:mpm_kin_send_theta:theta_pk:000'
      it=it+1
      namtag_it(it)='mr:mpm_kin_send_iexpt:iexpt:000'
      it=it+1
      namtag_it(it)='sv:mps_kin_send_yspec:jmp_fin_yspec:000'
      it=it+1
      namtag_it(it)='mr:mpm_kin_recv_yspec:jmp_fin_yspec:000'
      it=it+1
      namtag_it(it)='sv:mps_kin_send_yspec:yspec_pk:000'
      it=it+1
      namtag_it(it)='sv:mps_kin_send_arkabd:jmp_fin_arkabd:000'
      it=it+1
      namtag_it(it)='mr:mpm_kin_recv_arkabd:jmp_fin_arkabd:000'
      it=it+1
      namtag_it(it)='sv:mps_kin_send_arkabd:arkabd_pk:000'
      it=it+1
      namtag_it(it)='sv:mps_DB_kin_send_theta:theta_pk:000'
!---------------------------------------------------------
!     end of assign list
!---------------------------------------------------------
!
      mp_ntag_loc=it
!
      if(mp_ntag_loc.ne.mp_ntag) then
        goto 982
      endif
!
! check for duplicate list entries
!
      do it=1,(mp_ntag_loc-1)
        do it_ck=(it+1),mp_ntag_loc
          if(eqname(namtag_it(it),namtag_it(it_ck))) then
            goto 983
          endif
        enddo
      enddo
!
!
! check for tag naming consistency in source code
!
!BUG  call mp_src_namck(                           &
!BUG &     namtag_it                               &
!BUG &     ,cknam                                  &
!BUG &     ,mp_ntag                                &
!BUG &     ,mp_myid                                &
!BUG &     ,mp_mrid                                &
!BUG &     ,mp_ntag_xloc                           &
!BUG &     )
!
      do it=1,mp_ntag
        namtag_itglob(it)=namtag_it(it)
      enddo
!
! error handling:
!
      goto 999
!
!
  981 continue
      if(mp_ntag.gt.mp_ntag_x) then
        write(31,*) '  '
        write(31,*) 'ERROR in mp_cktag:'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid_loc, mp_mrid_loc
        write(31,*)   &
     &  ' No. of tag names declared in namtag_it list too large'
        write(31,*) ' mp_ntag exceeds array size mp_ntag_x:'
        write(31,*) ' mp_ntag, mp_ntag_x='
        write(31,*)   mp_ntag, mp_ntag_x
        write(31,*)                                                  &
     &  ' Edit source code file ens.f* to increase mp_ntag_x'
        write(31,*)                                                  &
     &  ' in BOTH subrt. "mp_cktag" AND in fctn. "mp_itag",'
        write(31,*)                                                  &
     &  ' using SAME mp_ntag_x in both subprgs. Then recompile.'
        write(31,*) ' EXECUTION STOPPED '
        close(31)
        call mp_stopabort
      endif
!
!
  982 continue
      if(mp_ntag.ne.mp_ntag_loc) then
        write(31,*) '  '
        write(31,*) 'ERROR in mp_cktag:'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid_loc, mp_mrid_loc
!
        write(31,*)   &
     &  ' No. of entries declared in tag name count list'
        write(31,*) ' does not match'
        write(31,*)                &
     &  ' no. of entries declared in tag name assign list'
        write(31,*) ' mp_ntag, mp_ntag_loc='
        write(31,*)   mp_ntag, mp_ntag_loc
        write(31,*)                                                  &
     &  ' Edit source code file ens.f* to correct lists'
        write(31,*)                                                  &
     &  ' in subrt. "mp_cktag" '
!
        write(31,*) ' EXECUTION STOPPED '
        close(31)
        call mp_stopabort
      endif
!
!
  983 continue
      if(it_ck.ge.1) then
        write(31,*) '  '
        write(31,*) 'ERROR in mp_cktag:'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid_loc, mp_mrid_loc
        write(31,*)   &
!
     &  ' Duplicate entries declared in tag name assign list'
        write(31,*)  ' it=', it
        write(31,*)  ' namtag_it(it)='
        write(31,2010) namtag_it(it)
 2010   format(a80)
        write(31,*)  ' it_ck=', it_ck
        write(31,*)  ' namtag_it(it_ck)='
        write(31,2010) namtag_it(it_ck)
!
        write(31,*)                                                  &
     &  ' Edit source code file ens.f* to correct'
        write(31,*)                                                  &
     &  ' BOTH tag name count and tag name assign lists'
        write(31,*)                                                  &
     &  ' in subrt. "mp_cktag" '
!
        write(31,*) ' EXECUTION STOPPED '
        close(31)
        call mp_stopabort
      endif
!
!
  999 continue
      close(31)
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      function mp_itag(namtag)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      implicit none
!
! Mr+Sv Code:
!
! Finds num. tag value for char. input tag name namtag
! using list or "registered" namtag-values, namtag_it,
! prepared by mp_cktag
!
      integer mp_ntag_x
      parameter(mp_ntag_x=100)
!
      logical eqname
!
      integer mp_itag
!
      character*80 namtag
!
! local common block variables+arrays,
! shared with  subrt. mp_cktag:
      integer    &
     &        mp_ntag_loc, mp_ntag_xloc   &
     &      , mp_myid_loc, mp_mrid_loc
      character*80 namtag_it(1:2*mp_ntag_x)
!
      common /mptag_iv01/                 &
     &        mp_ntag_loc, mp_ntag_xloc   &
     &      , mp_myid_loc, mp_mrid_loc
      common /mptag_ch01/ namtag_it
!
!
      if(mp_ntag_x.ne.mp_ntag_xloc) goto 980
!
      do mp_itag=1,mp_ntag_loc
        if(eqname(namtag,namtag_it(mp_itag))) return
      enddo
!
      mp_itag=-1
!
  980 continue
      open(31,file='ens.o01',status='unknown')
      rewind(31)
!
!
      if(mp_ntag_x.ne.mp_ntag_xloc) then
        write(31,*) '  '
        write(31,*) 'ERROR in mp_itag or mp_cktag:'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid_loc, mp_mrid_loc
        write(31,*) ' Unmatched array size values:'
        write(31,*)                                                  &
     &  ' mp_ntag_x(mp_itag)=',mp_ntag_x
        write(31,*)                                                  &
     &  ' mp_ntag_xloc=mp_ntag_x(mp_cktag)=',mp_ntag_xloc
        write(31,*)                                                  &
     &  ' Correct mp_ntag_x value in mp_itag or in mp_cktag'
        write(31,*) ' EXECUTION STOPPED '
        close(31)
        call mp_stopabort
      endif
!
      if(mp_itag.eq.-1) then
        write(31,*) '  '
        write(31,*) 'ERROR in mp_itag'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid_loc, mp_mrid_loc
        write(31,*) ' could not find input name namtag='
        write(31,2010) namtag
        write(31,*) ' check source code for:'
        write(31,*)   &
     &  ' a) misspelled namtag=''...'' assignment OR'
        write(31,*)   &
     &  ' b) missing entry namtag_it=''...'' in mp_cktag'
 2010   format(a80)
        write(31,*) ' EXECUTION STOPPED '
        close(31)
        call mp_stopabort
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mp_ckreq                                          &
     &           (mp_nreq,mp_myid,mp_mrid,mp_nproc,namreq_irglob)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! Mr+Sv Code:
!
! Note:
! When adding new request handle name assignment
!       namreq='...'
! anywhere in the code, the same name assignment
! must be entered TWICE in lists below, in with
! preceding ir-counter, in the following format:
! First, in the "req name count list", commented out:
!       ir=ir+1
! !!    namreq_ir(ir)='...'
! Second, in the  "req name assign list", uncommented:
!       ir=ir+1
!       namreq_ir(ir)='...'
!
      implicit none
!
      logical eqname, fexist
!
      integer mp_nreq_x
      parameter (mp_nreq_x=100)
!
      integer                                            &
     &        ir, ir_ck, mp_nreq            &
     &      , mp_myid, mp_mrid, mp_nproc, iunam
!
      character*80 cknam
      character*80 namreq_irglob(1:2*mp_nreq_x)
!
! local common block variables+arrays,
! shared with fctn. mp_ireq:
      integer    &
     &        mp_nreq_loc, mp_nreq_xloc   &
     &      , mp_myid_loc, mp_mrid_loc, mp_nproc_loc
      character*80 namreq_ir(1:2*mp_nreq_x)
!
      common /mpreq_iv01/                 &
     &        mp_nreq_loc, mp_nreq_xloc   &
     &      , mp_myid_loc, mp_mrid_loc, mp_nproc_loc
      common /mpreq_ch01/ namreq_ir
!
!
      inquire(file='ens.o01',exist=fexist)
      if(fexist) then
        open(31,file='ens.o01',status='old')
        iunam=31
        call efile(iunam)
      else
!BLADE:
!       open(31,file='ens.o01',status='new')
        open(31,file='ens.o01')
!:BLADE
        rewind(31)
      endif
!
!
! source code req name check:
      cknam='namreq'
!
! sharing local array size + IDs w/ mp_ireq
      mp_nreq_xloc=mp_nreq_x
      mp_myid_loc=mp_myid
      mp_mrid_loc=mp_mrid
      mp_nproc_loc=mp_nproc
!
! initial error parameters
      ir_ck=-1
!
!
!---------------------------------------------------------
!     req name count list:
!---------------------------------------------------------
      ir=0
!
      ir=ir+1
!!    namreq_ir(ir)='mr:mpm_kin_send_theta:theta_pk:000'
      ir=ir+1
!!    namreq_ir(ir)='mr:mpm_kin_send_iexpt:iexpt:000'
      ir=ir+1
!!    namreq_ir(ir)='sv:mps_kin_send_yspec:jmp_fin_yspec:000'
      ir=ir+1
!!    namreq_ir(ir)='sv:mps_kin_send_arkabd:jmp_fin_arkabd:000'
!---------------------------------------------------------
!     end of count list
!---------------------------------------------------------
!
      mp_nreq=ir
!
      if(mp_nreq.gt.mp_nreq_x) then
        goto 981
      endif
!
!
!---------------------------------------------------------
!     req name assign list:
!---------------------------------------------------------
      ir=0
!
      ir=ir+1
      namreq_ir(ir)='mr:mpm_kin_send_theta:theta_pk:000'
      ir=ir+1
      namreq_ir(ir)='mr:mpm_kin_send_iexpt:iexpt:000'
      ir=ir+1
      namreq_ir(ir)='sv:mps_kin_send_yspec:jmp_fin_yspec:000'
      ir=ir+1
      namreq_ir(ir)='sv:mps_kin_send_arkabd:jmp_fin_arkabd:000'
!---------------------------------------------------------
!     end of assign list
!---------------------------------------------------------
!
      mp_nreq_loc=ir
!
      if(mp_nreq_loc.ne.mp_nreq) then
        goto 982
      endif
!
! check for duplicate list entries
!
      do ir=1,(mp_nreq_loc-1)
        do ir_ck=(ir+1),mp_nreq_loc
          if(eqname(namreq_ir(ir),namreq_ir(ir_ck))) then
            goto 983
          endif
        enddo
      enddo
!
!
! check for req naming consistency in source code
!
!BUG  call mp_src_namck(                           &
!BUG &     namreq_ir                               &
!BUG &     ,cknam                                  &
!BUG &     ,mp_nreq                                &
!BUG &     ,mp_myid                                &
!BUG &     ,mp_mrid                                &
!BUG &     ,mp_nreq_xloc                           &
!BUG &     )
!
!
      do ir=1,mp_nreq
        namreq_irglob(ir)=namreq_ir(ir)
      enddo
!
! error handling:
!
      goto 999
!
!
  981 continue
      if(mp_nreq.gt.mp_nreq_x) then
        write(31,*) '  '
        write(31,*) 'ERROR in mp_ckreq:'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid_loc, mp_mrid_loc
        write(31,*)   &
     &  ' No. of req names declared in namreq_ir list too large'
        write(31,*) ' mp_nreq exceeds array size mp_nreq_x:'
        write(31,*) ' mp_nreq, mp_nreq_x='
        write(31,*)   mp_nreq, mp_nreq_x
        write(31,*)                                                  &
     &  ' Edit source code file ens.f* to increase mp_nreq_x'
        write(31,*)                                                  &
     &  ' in BOTH subrt. "mp_ckreq" AND in fctn. "mp_ireq",'
        write(31,*)                                                  &
     &  ' using SAME mp_nreq_x in both subprgs. Then recompile.'
        write(31,*) ' EXECUTION STOPPED '
        close(31)
        call mp_stopabort
      endif
!
!
  982 continue
      if(mp_nreq.ne.mp_nreq_loc) then
        write(31,*) '  '
        write(31,*) 'ERROR in mp_ckreq:'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid_loc, mp_mrid_loc
!
        write(31,*)   &
     &  ' No. of entries declared in req name count list'
        write(31,*) ' does not match'
        write(31,*)          &
     &  ' no. of entries declared in req name assign list'
        write(31,*) ' mp_nreq, mp_nreq_loc='
        write(31,*)   mp_nreq, mp_nreq_loc
        write(31,*)                                                  &
     &  ' Edit source code file ens.f* to correct lists'
        write(31,*)                                                  &
     &  ' in subrt. "mp_ckreq" '
!
        write(31,*) ' EXECUTION STOPPED '
        close(31)
        call mp_stopabort
      endif
!
!
  983 continue
      if(ir_ck.ge.1) then
        write(31,*) '  '
        write(31,*) 'ERROR in mp_ckreq:'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid_loc, mp_mrid_loc
        write(31,*)   &
!
     &  ' Duplicate entries declared in req name assign list'
        write(31,*)  ' ir=', ir
        write(31,*)  ' namreq_ir(ir)='
        write(31,2010) namreq_ir(ir)
 2010   format(a80)
        write(31,*)  ' ir_ck=', ir_ck
        write(31,*)  ' namreq_ir(ir_ck)='
        write(31,2010) namreq_ir(ir_ck)
!
        write(31,*)                                                  &
     &  ' Edit source code file ens.f* to correct'
        write(31,*)                                                  &
     &  ' BOTH req name count and req name assign lists'
        write(31,*)                                                  &
     &  ' in subrt. "mp_ckreq" '
!
        write(31,*) ' EXECUTION STOPPED '
        close(31)
        call mp_stopabort
      endif
!
!
  999 continue
      close(31)
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      function mp_ireq(mp_svid,namreq)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      implicit none
!
! Mr+Sv Code:
!
! Finds num. req value "request handle") for char. input req name
! namreq, using list of "registered" namreq-values, namreq_ir,
! prepared by mp_ckreq, and input processor id mp_svid
! (mp_svid can be Mr or Sv!)
!
      integer mp_nreq_x
      parameter(mp_nreq_x=100)
!
      logical eqname
!
      integer ireq0, mp_ireq, mp_svid
!
      character*80 namreq
!
! local common block variables+arrays,
! shared with  subrt. mp_ckreq:
      integer    &
     &        mp_nreq_loc, mp_nreq_xloc   &
     &      , mp_myid_loc, mp_mrid_loc, mp_nproc_loc
      character*80 namreq_ir(1:2*mp_nreq_x)
!
      common /mpreq_iv01/                 &
     &        mp_nreq_loc, mp_nreq_xloc   &
     &      , mp_myid_loc, mp_mrid_loc, mp_nproc_loc
      common /mpreq_ch01/ namreq_ir
!
!
      if(mp_nreq_x.ne.mp_nreq_xloc) goto 980
!
      do ireq0=1,mp_nreq_loc
        if(eqname(namreq,namreq_ir(ireq0))) then
          mp_ireq=(ireq0-1)*mp_nproc_loc+mp_svid+1
          return
        endif
      enddo
!
      mp_ireq=-1
!
  980 continue
      open(31,file='ens.o01',status='unknown')
      rewind(31)
!
!
      if(mp_nreq_x.ne.mp_nreq_xloc) then
        write(31,*) '  '
        write(31,*) 'ERROR in mp_ireq or mp_ckreq:'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid_loc, mp_mrid_loc
        write(31,*) ' Unmatched array size values:'
        write(31,*)                                                  &
     &  ' mp_nreq_x(mp_ireq)=',mp_nreq_x
        write(31,*)                                                  &
     &  ' mp_nreq_xloc=mp_nreq_x(mp_ckreq)=',mp_nreq_xloc
        write(31,*)                                                  &
     &  ' Correct mp_nreq_x value in mp_ireq or in mp_ckreq'
        write(31,*) ' EXECUTION STOPPED '
        close(31)
        call mp_stopabort
      endif
!
      if(mp_ireq.eq.-1) then
        write(31,*) '  '
        write(31,*) 'ERROR in mp_ireq'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid_loc, mp_mrid_loc
        write(31,*) ' could not find input name namreq='
        write(31,2010) namreq
        write(31,*) ' check source code for:'
        write(31,*)   &
     &  ' a) misspelled namreq=''...'' assignment OR'
        write(31,*)   &
     &  ' b) missing entry namreq_it=''...'' in mp_ckreq'
 2010   format(a80)
        write(31,*) ' EXECUTION STOPPED '
        close(31)
        call mp_stopabort
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mp_src_namck(                     &
     &      namtag_it                              &
     &     ,cknam                                  &
     &     ,mp_ntag                                &
     &     ,mp_myid                                &
     &     ,mp_mrid                                &
     &     ,mp_ntag_x                              &
     &     )
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! checks for tag/req naming consistency in source code
!
      implicit none
!
      integer ntln_x, nrangln_x, nchar_x
      parameter(ntln_x=600)
      parameter(nrangln_x=5)
      parameter(nchar_x=80)
!
!
      logical eqname, fexist
!
!
      integer                                            &
     &        it, mp_ntag,  mp_ntag_x                    &
     &      , irangln, nrangln, mp_myid, mp_mrid         &
     &      , ich, ich0, ichi, ichf, ichln               &
     &      , ichlni, ichlnf, iln, ilx, ilx0, nln, nlx   &
     &      , itln, itln0, ntln, mtln_nit
!
      integer                                            &
     &        namcount_tln(1:ntln_x)                     &
     &      , nrangln_tln(1:ntln_x)                      &
     &      , jnam1st_tln(1:ntln_x)                      &
     &      , iln_tln(1:ntln_x)                          &
     &      , ilx_tln(1:ntln_x)
!
      character*80                                       &
     &             cknam, cline, cknamln, linsub         &
     &            ,aline
!
      character*80                                        &
     &              lintag_tln(1:ntln_x,-1:(nrangln_x+1)) &
     &            , namtag_tln(1:ntln_x)                  &
     &            , namtag_it(1:2*mp_ntag_x)
!
!
      nrangln=nrangln_x
!!    if(nrangln.gt.nrangln_x) goto 981
!
      inquire(file='ens.f',exist=fexist)
      if(fexist) then
        open(11,file='ens.f',status='old')
        aline='ens.f'
        goto 10
      endif
!
      inquire(file='ens.f90',exist=fexist)
      if(fexist) then
        open(11,file='ens.f90',status='old')
        aline='ens.f90'
        goto 10
      endif
!
      inquire(file='ens.for',exist=fexist)
      if(fexist) then
        open(11,file='ens.for',status='old')
        aline='ens.for'
        goto 10
      endif
!
      write(31,*) '   '
      write(31,*) ' Source code file "ens.f*" not found.'
      write(31,*) ' No source code tag name or req name'
      write(31,*) ' consistency check performed.'
!
      return
!
!
   10 continue
      rewind(11)
!
      write(31,*) '   '
      write(31,*) ' Source code file "ens.f*" found:'
      write(31,2010) aline
 2010 format(a80)
!
      write(31,*) ' Checking tag or req names by'
      write(31,*) ' either "namtag" or "namreq":'
      write(31,2010) cknam
!
      rewind(11)
!
      call chif(cknam,ichi,ichf)
      cknamln=' '
      do ich=ichi,ichf
        ichln=ich-ichi+7
        cknamln(ichln:ichln)=cknam(ich:ich)
      enddo
      ichln=ichf-ichi+7+1
      cknamln(ichln:ichln)='='
      call chif(cknamln,ichlni,ichlnf)
!
      iln=0
      ilx=0
      itln=0
      ntln=0
      linsub=' '
!
   20 continue
      read(11,2010,end=90) cline
      iln=iln+1
!
      if(                                          &
     &index(cline(1:1),'!').eq.0.and.             &
     &index(cline(1:1),'c').eq.0.and.             &
     &index(cline(1:1),'C').eq.0                  &
     &)then
        ilx=ilx+1
!
        if(                                        &
     &  index(cline,'      subroutine ').ne.0.or.  &
     &  index(cline,'      function ').ne.0        &
     &  )then
          linsub=cline
          goto 22
        endif
!
   22   continue
        if(index(cline,cknamln(1:ichlnf)).ne.0) then
          itln=itln+1
          irangln=0
          ilx0=ilx
          if(itln.le.ntln_x) then
            lintag_tln(itln,-1)=linsub
            lintag_tln(itln,0)=cline
            lintag_tln(itln,+1)=' '
            nrangln_tln(itln)=irangln
            iln_tln(itln)=iln
            ilx_tln(itln)=ilx
          endif
!
   30     continue
          read(11,2010,end=90) cline
          iln=iln+1
!
          if(                                          &
     &    index(cline(1:1),'!').eq.0.and.             &
     &    index(cline(1:1),'c').eq.0.and.             &
     &    index(cline(1:1),'C').eq.0                  &
     &    )then
            ilx=ilx+1
!
            if(                                        &
     &      index(cline,'      subroutine ').ne.0.or.  &
     &      index(cline,'      function ').ne.0        &
     &      )then
              linsub=cline
              goto 22
            endif
!
            if(index(cline,cknamln(1:ichlnf)).ne.0)    &
     &      goto 22
!
            if(     &
     &      index(cline,' call ').ne.0.and.             &
     &      index(cline,' MPI_').ne.0                   &
     &      )then
              irangln=irangln+1
              if(itln.le.ntln_x) then
                lintag_tln(itln,irangln)=cline
                nrangln_tln(itln)=irangln
              endif
              if((ilx-ilx0).gt.(2*nrangln_x)) goto 20
!
   40         continue
              read(11,2010,end=90) cline
              iln=iln+1
!
              if(                                          &
     &        index(cline(1:1),'!').eq.0.and.             &
     &        index(cline(1:1),'c').eq.0.and.             &
     &        index(cline(1:1),'C').eq.0                  &
     &        )then
                ilx=ilx+1
!
                if(                                        &
     &          index(cline,'      subroutine ').ne.0.or.  &
     &          index(cline,'      function ').ne.0        &
     &          )then
                  linsub=cline
                  goto 22
                endif
!
                irangln=irangln+1
                if(itln.le.ntln_x) then
                  lintag_tln(itln,irangln)=cline
                  nrangln_tln(itln)=irangln
                endif
                if((ilx-ilx0).gt.(2*nrangln_x)) goto 20
!
                if(index(cline,cknamln(1:ichlnf)).ne.0)    &
     &          goto 22
!
                if(irangln.lt.nrangln) then
                  goto 40
                else
                  goto 20
                endif
              else
                goto 40
              endif
!
            else
              if((ilx-ilx0).gt.(2*nrangln_x)) goto 20
              goto 30
            endif
          else
            goto 30
          endif
!
        else
          goto 20
        endif
      else
        goto 20
      endif
!
!
   90 continue
!
      nln=iln
      nlx=ilx
      ntln=itln
!
      write(31,*) '  '
      write(31,*) '  no. of code lines total:    nln=', nln
      write(31,*) '  no. of active code lines:   nlx=', nlx
      write(31,*) '  no. of tag/req name lines: ntln=', ntln
!
      if(ntln.gt.ntln_x) goto 982
!
      write(31,*) '  '
      write(31,*) '  '
      write(31,*) '  list of full namtag/req lines found:'
      do itln=1,ntln
        iln=iln_tln(itln)
        write(31,*) ' '
        write(31,*) ' found at line no.      iln=', iln,' in:'
        write(31,2010) lintag_tln(itln,-1)
        write(31,*) ' tag/req name line no. itln=', itln,':'
        write(31,2010) lintag_tln(itln,0)
        write(31,*) ' followed by mpi-call:'
        write(31,2010)                 &
     &  (lintag_tln(itln,irangln),irangln=1,nrangln_tln(itln))
      enddo
!
! extract name string "namtag_tln" from "lintag_tln(itln,0)";
! check if list "namtag_it(it)" contains "namtag_tln";
! if so how many times; and whether occurences of "namtag_tln"
! are matched as send-recv pairs
!
      do itln=1,ntln
        namtag_tln(itln)=' '
        cline=lintag_tln(itln,0)
        do ich=1,nchar_x
          if(index(cline(ich:ich),'''').ne.0) then
            ichi=ich+1
            goto 110
          endif
        enddo
  110   continue
        do ich0=1,nchar_x
          ich=nchar_x+1-ich0
          if(index(cline(ich:ich),'''').ne.0) then
            ichf=ich-1
            goto 112
          endif
        enddo
  112   continue
!
        if(ichi.gt.ichf) goto 983
        namtag_tln(itln)=cline(ichi:ichf)
      enddo
!
      mtln_nit=0
!
      write(31,*) '  '
      write(31,*) '  '
      write(31,*)   &
     &'  checking tag/req name declarations in mp_cktag/req'
      write(31,*)   &
     &'  and counting name assign occurences in code  '
!
      do itln=1,ntln
        write(31,*) '  '
        write(31,*) '  tag/req name no. itln=', itln,':'
        write(31,2010)    namtag_tln(itln)
!
        do it=1,mp_ntag
          if(eqname(namtag_it(it),namtag_tln(itln)))  &
     &    goto 120
        enddo
          write(31,*)                                 &
     &    ' Coding error:'                            &
     &    ,' namtag/req_tln name not declared'
          write(31,*)                                 &
     &    ' as namtag/req_i[t,r] entry in mp_cktag/req!'
          mtln_nit=mtln_nit+1
          goto 122
!
  120   continue
          write(31,*)                                       &
     &    ' Coding OK:'                                     &
     &    ,' namtag/req_tln name correctly declared'
          write(31,*)                                       &
     &    ' as namtag/req_i[t,r] entry in mp_ck_ag/req'
          write(31,*) ' at it/ir=', it,':'
          write(31,2010)  namtag_it(it)
  122   continue
!
        namcount_tln(itln)=1
        jnam1st_tln(itln)=itln
        do itln0=1,ntln
          if(                                             &
     &    itln.ne.itln0.and.                              &
     &    eqname(namtag_tln(itln),namtag_tln(itln0))      &
     &    )                                               &
     &    namcount_tln(itln)=namcount_tln(itln)+1
!
          if(                                             &
     &    jnam1st_tln(itln).gt.itln0.and.                   &
     &    eqname(namtag_tln(itln),namtag_tln(itln0))      &
     &    )                                               &
     &    jnam1st_tln(itln)=itln0
        enddo
!
        write(31,*)                                       &
     &  '  count of namtag/req_tln assign occurences in code=' &
     &  , namcount_tln(itln)
      enddo
!
!
      write(31,*) '  '
      write(31,*) '  '
      write(31,*)       &
     & '  listing of name assign occurence relations'
!
      do itln=1,ntln
        if(jnam1st_tln(itln).eq.itln) then
          write(31,*) '  '
          write(31,*) '  name assign itln=', itln, ':'
          write(31,2010) namtag_tln(itln)
          write(31,*) '  in subprg.'
          write(31,2010) lintag_tln(itln,-1)
          write(31,*) '  for mpi-call'
          write(31,2010) lintag_tln(itln,+1)
!
          write(31,*) '  re-occurs also in/for :'
          do itln0=(itln+1),ntln
            if(jnam1st_tln(itln0).eq.itln) then
              write(31,2010) lintag_tln(itln0,-1)
              write(31,2010) lintag_tln(itln0,+1)
            endif
          enddo
        endif
      enddo
!
      if(mtln_nit.gt.0) goto 984
!
!
! error handling:
!
      goto 999
  981 continue
      if(nrangln.gt.nrangln_x) then
        write(31,*) '  '
        write(31,*) ' ERROR in mp_src_namck'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*)      &
     &  ' nrangln exceeds array dimension nrangln_x'
        write(31,*) 'nrangln,nrangln_x=', nrangln,nrangln_x
!
        write(31,*)  &
     &  ' Correct nrangln or nrangln_x in mp_src_namck'
        write(31,*)  &
     &  ' Then re-compile.'
!
        write(31,*) ' EXECUTION STOPPED '
        close(11)
        close(31)
        call mp_stopabort
      endif
!
  982 continue
      if(ntln.gt.ntln_x) then
        write(31,*) '  '
        write(31,*) ' ERROR in mp_src_namck'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*)      &
     &  ' ntln exceeds array dimension ntln_x'
        write(31,*) 'ntln,ntln_x=', ntln,ntln_x
!
        write(31,*)  &
     &  ' Increase ntln_x in mp_src_namck.'
        write(31,*)  &
     &  ' Then re-compile.'
!
        write(31,*) ' EXECUTION STOPPED '
        close(11)
        close(31)
        call mp_stopabort
      endif
!
  983 continue
      if(ichi.gt.ichf) then
        write(31,*) '  '
        write(31,*) ' ERROR in mp_src_namck'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*) ' searching for cknam='
        write(31,2010) cknam
!
        write(31,*) '  '
        write(31,*)            &
     &  ' Cannot find a name char. string, enclosed by ''...'' '
        write(31,*)            &
     &  ' in namtag/req line no. itln, codeline no. iln='
        write(31,*)            &
     &  itln, iln_tln(itln), ':'
        write(31,2010)  lintag_tln(itln,0)
!
        write(31,*)  &
     &  ' Fill in correct namtag/req name in mp-code.'
        write(31,*)  &
     &  ' Then re-compile.'
!
        write(31,*) ' EXECUTION STOPPED '
        close(11)
        close(31)
        call mp_stopabort
      endif
!
  984 continue
      if(mtln_nit.gt.0) then
        write(31,*) '  '
        write(31,*) ' ERROR in mp_src_namck'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*)            &
     &  ' Some namtag/req name(s) found in code'
        write(31,*)            &
     &  ' have not been declared in mp_cktag/req: see above.'
        write(31,*)  &
     &  ' Correct spelling of namtag/req names in mp-code'
        write(31,*)  &
     &  ' and/or add missing entries in mp_cktag/req.'
        write(31,*)  &
     &  ' Then re-compile.'
!
        write(31,*) ' EXECUTION STOPPED '
        close(11)
        close(31)
        call mp_stopabort
      endif
!
  999 continue
      close(11)
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mp_DB_out
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! misc. debug outputs
!
      include 'ens.def'
!
!
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
!!      write(39,*) ' '
!!      write(39,*) 'ens_main:>mp_cktag'
!!      write(39,*) 'mp_ntag, mp_ntag_x=', mp_ntag, mp_ntag_x
!!      read(*,*) idum
!
!!      call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
!!      write(39,*) ' '
!!      write(39,*) 'ens_main:>MPI_uck...'
!!      write(39,*) 'MPI_TAG_UB=', MPI_TAG_UB
!!      read(*,*) idum
!
!!      call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
!!      write(39,*) ' '
!!      write(39,*) 'ens_main:>mp_ckreq'
!!      write(39,*) 'mp_nreq, mp_nreq_x=', mp_nreq, mp_nreq_x
!!      read(*,*) idum
!
!!      call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
! Mr main:
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
!BLADE:
!       open(39,file='ens.o08',status='new')
        open(39,file='ens.o08')
!:BLADE
        write(39,*) '  '
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
!BLADE:
!       if(mp_myid.eq.1) open(39,file='ens.o09.1',status='new')
!       if(mp_myid.eq.2) open(39,file='ens.o09.2',status='new')
!       if(mp_myid.eq.3) open(39,file='ens.o09.3',status='new')
!       if(mp_myid.eq.4) open(39,file='ens.o09.4',status='new')
!       if(mp_myid.eq.5) open(39,file='ens.o09.5',status='new')
!       if(mp_myid.eq.6) open(39,file='ens.o09.6',status='new')
!       if(mp_myid.eq.7) open(39,file='ens.o09.7',status='new')
!       if(mp_myid.eq.8) open(39,file='ens.o09.8',status='new')
        if(mp_myid.eq.1) open(39,file='ens.o09.1')
        if(mp_myid.eq.2) open(39,file='ens.o09.2')
        if(mp_myid.eq.3) open(39,file='ens.o09.3')
        if(mp_myid.eq.4) open(39,file='ens.o09.4')
        if(mp_myid.eq.5) open(39,file='ens.o09.5')
        if(mp_myid.eq.6) open(39,file='ens.o09.6')
        if(mp_myid.eq.7) open(39,file='ens.o09.7')
        if(mp_myid.eq.8) open(39,file='ens.o09.8')
!:BLADE
        write(39,*) '  '
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mps_main:<get_xpt'
        write(39,*) 'mp_myid=',mp_myid
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mps_main:>get_xpt'
        write(39,*) 'mp_myid=',mp_myid
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mps_main:>mps_task_recv'
        write(39,*) 'mp_myid=',mp_myid
        write(39,*) 'jmp_task=',jmp_task
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mps_main:<mp_kin_pki'
        write(39,*) 'mp_myid=',mp_myid
        write(39,*) 'jmp_task=',jmp_task
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mps_main:<mps_getkin'
        write(39,*) 'mp_myid=',mp_myid
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mps_main:>mps_getkin'
        write(39,*) 'mp_myid=',mp_myid
        write(39,*) 'jmp_kin=',jmp_kin
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mpm_getkin: START'
        write(39,*) 'mp_myid=',mp_myid
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mpm_getkin: <mpm_kin_send_theta'
        write(39,*) 'mp_myid=',mp_myid
        write(39,*) 'jmp_kin=', jmp_kin
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      call mpm_kin_send_theta
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mpm_getkin: <mpm_kin_ini_iexpt'
        write(39,*) 'mp_myid=',mp_myid
        write(39,*) 'jmp_kin=', jmp_kin
!
        call mp_DB_fx
!
!XXX    call mp_bug_theta
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mpm_getkin: <mpm_kin_ini_iexpt'
        write(39,*) 'mp_myid=',mp_myid
        write(39,*) 'jmp_kin=', jmp_kin
!
        call mp_DB_fx
!
!XXX    call mp_bug_theta
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      write(39,*) ' '
      write(39,*) 'mpm_getkin: <mpm_kin_send_iexpt,>mpm_kin_ini_iexpt'
      write(39,*) 'mp_myid=',mp_myid
      write(39,*) 'jmp_kin=', jmp_kin
      write(39,*) 'iexpt,iexpt_bgun=', iexpt,iexpt_bgun
      if(iexpt.le.nexpt) then
        write(39,*) 'mp_dim_yspec(iexpt)=',mp_dim_yspec(iexpt)
        write(39,*) 'mp_dim_yspec1(iexpt)=',mp_dim_yspec1(iexpt)
        write(39,*) 'mp_dim_yspec2(iexpt)=',mp_dim_yspec2(iexpt)
        write(39,*) 'mp_dim_yspec4(iexpt)=',mp_dim_yspec4(iexpt)
        write(39,*) 'mp_dim_yspec_x=',mp_dim_yspec_x
      endif
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mpm_getkin: <mpm_kin_w2sv(1),>mpm_kin_send_iexpt'
        write(39,*) 'mp_myid=',mp_myid
        write(39,*) 'iexpt,iexpt_bgun=', iexpt,iexpt_bgun
      if(iexpt_bgun.le.nexpt.and.iexpt_bgun.ge.1) then
        write(39,*) 'mp_dim_yspec(iexpt_bgun)=',mp_dim_yspec(iexpt_bgun)
        write(39,*) 'mp_dim_yspec1(iexpt_bgun)=',mp_dim_yspec1(iexpt_bgun)
        write(39,*) 'mp_dim_yspec2(iexpt_bgun)=',mp_dim_yspec2(iexpt_bgun)
        write(39,*) 'mp_dim_yspec4(iexpt_bgun)=',mp_dim_yspec4(iexpt_bgun)
        write(39,*) 'mp_dim_yspec_x=',mp_dim_yspec_x
      endif
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mpm_getkin: >do iexpt='
        write(39,*) 'mp_myid=',mp_myid
        write(39,*) 'iexpt=', iexpt
      if(iexpt_bgun.le.nexpt.and.iexpt_bgun.ge.1) then
        write(39,*) 'mp_dim_yspec(iexpt_bgun)=',mp_dim_yspec(iexpt_bgun)
        write(39,*) 'mp_dim_yspec1(iexpt_bgun)=',mp_dim_yspec1(iexpt_bgun)
        write(39,*) 'mp_dim_yspec2(iexpt_bgun)=',mp_dim_yspec2(iexpt_bgun)
        write(39,*) 'mp_dim_yspec4(iexpt_bgun)=',mp_dim_yspec4(iexpt_bgun)
        write(39,*) 'mp_dim_yspec_x=',mp_dim_yspec_x
      endif
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mpm_getkin: >iexpt_bgun=iexpt'
        write(39,*) 'mp_myid=',mp_myid
        write(39,*) 'iexpt=', iexpt
        write(39,*) 'iexpt_bgun=', iexpt_bgun
        write(39,*) 'jdokin(iexpt)=', jdokin(iexpt)
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mpm_getkin: >kin_ini'
        write(39,*) 'mp_myid=',mp_myid
        write(39,*) 'iexpt=', iexpt
        write(39,*) 'iexpt_bgun=', iexpt_bgun
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mpm_getkin: >kin_run'
        write(39,*) 'mp_myid=',mp_myid
        write(39,*) 'iexpt=', iexpt
        write(39,*) 'iexpt_bgun=', iexpt_bgun
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mpm_getkin: >kin_xpt'
        write(39,*) 'mp_myid=',mp_myid
        write(39,*) 'iexpt=', iexpt
        write(39,*) 'iexpt_bgun=', iexpt_bgun
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mpm_getkin: >kin_qbx'
        write(39,*) 'mp_myid=',mp_myid
        write(39,*) 'iexpt=', iexpt
        write(39,*) 'iexpt_bgun=', iexpt_bgun
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mpm_getkin: <mpm_kin_w2sv'
        write(39,*) 'mp_myid=',mp_myid
        write(39,*) 'iexpt=', iexpt
        write(39,*) 'iexpt_bgun=', iexpt_bgun
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mpm_getkin: >mpm_kin_w2sv, <enddo(iexpt)'
        write(39,*) 'mp_myid=',mp_myid
        write(39,*) 'iexpt=', iexpt
        write(39,*) 'iexpt_bgun=', iexpt_bgun
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      write(39,*) ' '
      write(39,*) 'mpm_getkin: >mpm_kin_wait_yspec'
      do iexpt_upk=1,nexpt
        iexpt_pak=iexpt_upk
        call mp_DB_fx
      enddo
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mpm_kin_send_theta: START'
        write(39,*) 'mp_myid=',mp_myid
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mpm_kin_send_theta: >mpm_pak_theta'
        write(39,*) 'mp_myid=',mp_myid
        write(39,*) 'mp_ipak=',mp_ipak
        write(39,*) &
     &   'mp_dim_theta,mp_dim_theta_x=' &
     &  , mp_dim_theta,mp_dim_theta_x
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mpm_kin_send_theta: < ISEND:theta_pk'
        write(39,*) 'mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(39,*) 'mp_svid=', mp_svid
        write(39,*) &
     &   'mp_dim_theta,mp_dim_theta_x=' &
     &  , mp_dim_theta,mp_dim_theta_x
        write(39,*) &
     &   ' mp_itag(namtag)='   &
     &  ,  mp_itag(namtag)
        write(39,*) &
     &   ' mp_ireq(mp_svid,namreq)='                        &
     &   , mp_ireq(mp_svid,namreq)
        write(39,*) &
     &   ' mp_hand(mp_ireq(mp_svid,namreq))='                        &
     &   , mp_hand(mp_ireq(mp_svid,namreq))
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mpm_kin_send_theta: > ISEND:theta_pk'
        write(39,*) 'mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(39,*) 'mp_svid=', mp_svid
        write(39,*) &
     &   'mp_dim_theta,mp_dim_theta_x=' &
     &  , mp_dim_theta,mp_dim_theta_x
        write(39,*) &
     &   ' mp_itag(namtag)='   &
     &  ,  mp_itag(namtag)
        write(39,*) &
     &   ' mp_ireq(mp_svid,namreq)='                        &
     &   , mp_ireq(mp_svid,namreq)
        write(39,*) &
     &   ' mp_hand(mp_ireq(mp_svid,namreq))='                        &
     &   , mp_hand(mp_ireq(mp_svid,namreq))
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      write(39,*) ' '
      write(39,*) 'mpm_kin_send_theta: < return'
      write(39,*) 'mp_myid=',mp_myid
!
      call mp_DB_fx
!
      call mpm_DB_kin_recv_theta
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mpm_kin_ini_iexpt:START'
        write(39,*) 'mp_myid=',mp_myid
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mpm_kin_ini_iexpt:<return'
        write(39,*) 'mp_myid=',mp_myid
        if(iexpt.le.nexpt) then
          write(39,*) 'mp_dim_yspec(iexpt)=',mp_dim_yspec(iexpt)
          write(39,*) 'mp_dim_yspec1(iexpt)=',mp_dim_yspec1(iexpt)
          write(39,*) 'mp_dim_yspec2(iexpt)=',mp_dim_yspec2(iexpt)
          write(39,*) 'mp_dim_yspec4(iexpt)=',mp_dim_yspec4(iexpt)
          write(39,*) 'mp_dim_yspec_x=',mp_dim_yspec_x
        endif
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mpm_kin_send_iexpt:START'
        write(39,*) 'mp_myid, mp_mrid,mp_nproc=', mp_myid, mp_mrid,mp_nproc
        write(39,*) 'iexpt,iexpt_bgun=', iexpt,iexpt_bgun
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        mp_svid=mp_nproc-mp_iproc
!
        write(39,*) ' '
        write(39,*) 'mpm_kin_send_iexpt: >do mp_iproc..., mp_svid=...'
        write(39,*) 'SEND ORDER REVERSED!'
        write(39,*) 'mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(39,*) 'mp_iproc,mp_svid=', mp_iproc,mp_svid
        write(39,*) 'iexpt,iexpt_bgun=', iexpt,iexpt_bgun
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mpm_kin_send_iexpt: < ISEND:mp_iexpt_sbuf'
        write(39,*) 'mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(39,*) 'mp_svid=', mp_svid
        write(39,*) 'mp_iexpt_sbuf(mp_svid)=', mp_iexpt_sbuf(mp_svid)
        write(39,*) 'iexpt_bgun=', iexpt_bgun
        if(iexpt_bgun.ge.1.and.iexpt_bgun.le.nexpt) then
          write(39,*) 'mp_dim_yspec(iexpt_bgun)=',mp_dim_yspec(iexpt_bgun)
          write(39,*) 'mp_dim_yspec1(iexpt_bgun)=',mp_dim_yspec1(iexpt_bgun)
          write(39,*) 'mp_dim_yspec2(iexpt_bgun)=',mp_dim_yspec2(iexpt_bgun)
          write(39,*) 'mp_dim_yspec4(iexpt_bgun)=',mp_dim_yspec4(iexpt_bgun)
          write(39,*) 'mp_dim_yspec_x=',mp_dim_yspec_x
        endif
        write(39,*) &
     &   ' mp_itag(namtag)='   &
     &  ,  mp_itag(namtag)
        write(39,*) &
     &   ' mp_ireq(mp_svid,namreq)='                        &
     &   , mp_ireq(mp_svid,namreq)
        write(39,*) &
     &   ' mp_hand(mp_ireq(mp_svid,namreq))='                        &
     &   , mp_hand(mp_ireq(mp_svid,namreq))
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mpm_kin_send_iexpt: > ISEND:mp_iexpt_sbuf'
        write(39,*) 'mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(39,*) 'mp_ierr=', mp_ierr
        write(39,*) 'mp_svid=', mp_svid
        write(39,*) 'mp_iexpt_sbuf(mp_svid)=', mp_iexpt_sbuf(mp_svid)
        write(39,*) 'iexpt_bgun=', iexpt_bgun
        write(39,*) &
     &   ' mp_itag(namtag)='   &
     &  ,  mp_itag(namtag)
        write(39,*) &
     &   ' mp_ireq(mp_svid,namreq)='                        &
     &   , mp_ireq(mp_svid,namreq)
        write(39,*) &
     &   ' mp_hand(mp_ireq(mp_svid,namreq))='                        &
     &   , mp_hand(mp_ireq(mp_svid,namreq))
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mpm_kin_send_iexpt: < IRECV:jmp_fin_yspec'
        write(39,*) 'mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(39,*) 'mp_svid=', mp_svid
        write(39,*) 'jmp_fin_yspec(mp_svid)=', jmp_fin_yspec(mp_svid)
        write(39,*) 'iexpt_bgun=', iexpt_bgun
        write(39,*) &
     &   ' mp_itag(namtag)='   &
     &  ,  mp_itag(namtag)
        write(39,*) &
     &   ' mp_ireq(mp_svid,namreq)='                        &
     &   , mp_ireq(mp_svid,namreq)
        write(39,*) &
     &   ' mp_hand(mp_ireq(mp_svid,namreq))='                        &
     &   , mp_hand(mp_ireq(mp_svid,namreq))
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mpm_kin_send_iexpt: > IRECV:jmp_fin_yspec'
        write(39,*) 'mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(39,*) 'mp_ierr=', mp_ierr
        write(39,*) 'mp_svid=', mp_svid
        write(39,*) 'mp_iexpt_sbuf(mp_svid)=', mp_iexpt_sbuf(mp_svid)
        write(39,*) 'iexpt_bgun=', iexpt_bgun
        write(39,*) &
     &   ' mp_itag(namtag)='   &
     &  ,  mp_itag(namtag)
        write(39,*) &
     &   ' mp_ireq(mp_svid,namreq)='                        &
     &   , mp_ireq(mp_svid,namreq)
        write(39,*) &
     &   ' mp_hand(mp_ireq(mp_svid,namreq))='                        &
     &   , mp_hand(mp_ireq(mp_svid,namreq))
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mpm_kin_chek_yspec: > TEST:jmp_fin_yspec'
        write(39,*) 'mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(39,*) 'mp_ierr=', mp_ierr
        write(39,*) 'lmp_done=', lmp_done
        if(lmp_done) write(39,*) 'lmp_done=TRUE!!'
        write(39,*) 'mp_svid=', mp_svid
        write(39,*) 'jmp_fin_yspec(mp_svid)=', jmp_fin_yspec(mp_svid)
        write(39,*) 'iexpt,iexpt_upk=', iexpt,iexpt_upk
        write(39,*) 'mp_dim_yspec(iexpt_upk)=',mp_dim_yspec(iexpt_upk)
        write(39,*) 'mp_dim_yspec1(iexpt_upk)=',mp_dim_yspec1(iexpt_upk)
        write(39,*) 'mp_dim_yspec2(iexpt_upk)=',mp_dim_yspec2(iexpt_upk)
        write(39,*) 'mp_dim_yspec4(iexpt_upk)=',mp_dim_yspec4(iexpt_upk)
        write(39,*) 'mp_dim_yspec_x=',mp_dim_yspec_x
!
        write(39,*) &
     &   ' mp_ireq(mp_svid,namreq)='                        &
     &   , mp_ireq(mp_svid,namreq)
        write(39,*) &
     &   ' mp_hand(mp_ireq(mp_svid,namreq))='                        &
     &   , mp_hand(mp_ireq(mp_svid,namreq))
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mpm_kin_recv_yspec: > SSEND:jmp_fin_yspec'
        write(39,*) 'mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(39,*) 'jmp_fin_yspec(mp_svid)=',jmp_fin_yspec(mp_svid)
        write(39,*) 'mp_ierr=',mp_ierr
        write(39,*) 'mp_svid=',mp_svid
        write(39,*) &
     &   ' mp_itag(namtag)='   &
     &  ,  mp_itag(namtag)
        write(39,*) 'iexpt,iexpt_upk=',iexpt,iexpt_upk
        write(39,*) 'mp_dim_yspec(iexpt_upk)=',mp_dim_yspec(iexpt_upk)
        write(39,*) 'mp_dim_yspec1(iexpt_upk)=',mp_dim_yspec1(iexpt_upk)
        write(39,*) 'mp_dim_yspec2(iexpt_upk)=',mp_dim_yspec2(iexpt_upk)
        write(39,*) 'mp_dim_yspec4(iexpt_upk)=',mp_dim_yspec4(iexpt_upk)
        write(39,*) 'mp_dim_yspec_x=',mp_dim_yspec_x
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mpm_kin_recv_yspec: > RECV:yspec_pk'
        write(39,*) 'mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(39,*) 'mp_ierr=',mp_ierr
        write(39,*) 'mp_svid=',mp_svid
        write(39,*) &
     &   ' mp_itag(namtag)='   &
     &  ,  mp_itag(namtag)
        write(39,*) 'iexpt,iexpt_upk=',iexpt,iexpt_upk
        write(39,*) 'mp_dim_yspec(iexpt_upk)=',mp_dim_yspec(iexpt_upk)
        write(39,*) 'mp_dim_yspec1(iexpt_upk)=',mp_dim_yspec1(iexpt_upk)
        write(39,*) 'mp_dim_yspec2(iexpt_upk)=',mp_dim_yspec2(iexpt_upk)
        write(39,*) 'mp_dim_yspec4(iexpt_upk)=',mp_dim_yspec4(iexpt_upk)
        write(39,*) 'mp_dim_yspec_x=',mp_dim_yspec_x
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      write(39,*) ' '
      write(39,*) 'mpm_kin_recv_yspec: >mpm_upk_yspec'
!XXX  write(39,*) '<mp_bug_yspec for iexpt_pak=',  iexpt_pak
        call mp_DB_fx
!
!XXX    call mp_bug_yspec
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mps_getkin: START'
        write(39,*) 'mp_myid=',mp_myid
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mps_getkin: >...recv_theta, '  &
     &  , 'mp_myid=',mp_myid
        write(39,*) 'jmp_kin=',jmp_kin
!
        call mp_DB_fx
!
      write(39,*) ' '
      write(39,*) 'mps_getkin: >mpm_kin_recv_theta, mp_myid=', mp_myid
!XXX  write(39,*) '<mp_bug_theta'
!XXX    call mp_bug_theta
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mps_getkin: >...recv_iexpt'
        write(39,*) 'mp_myid=',mp_myid
        write(39,*) 'iexpt,nexpt=',iexpt,nexpt
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mps_getkin: >setpm_uv'
        write(39,*) 'mp_myid=',mp_myid
        write(39,*) 'iexpt,nexpt=',iexpt,nexpt
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mps_getkin: >kin_ini'
        write(39,*) 'mp_myid=',mp_myid
        write(39,*) 'iexpt,nexpt=',iexpt,nexpt
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mps_getkin: >kin_run'
        write(39,*) 'mp_myid=',mp_myid
        write(39,*) 'iexpt,nexpt=',iexpt,nexpt
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mps_getkin: >kin_xpt'
        write(39,*) 'mp_myid=',mp_myid
        write(39,*) 'jmp_kin,iexpt,nexpt=',jmp_kin,iexpt,nexpt
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mps_getkin: >kin_qbx'
        write(39,*) 'mp_myid=',mp_myid
        write(39,*) 'jmp_kin,iexpt,nexpt=',jmp_kin,iexpt,nexpt
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mps_getkin: >kin_four'
        write(39,*) 'mp_myid=',mp_myid
        write(39,*) 'jmp_kin,iexpt,nexpt=',jmp_kin,iexpt,nexpt
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      write(39,*) ' '
      write(39,*) 'mps_getkin: >...send_yspec, <goto 20:....recv_iexpt'
      write(39,*) 'mp_myid=',mp_myid
      write(39,*) 'jmp_kin,iexpt,nexpt=',jmp_kin,iexpt,nexpt
!
        call mp_DB_fx
!
      write(39,*) ' '
      write(39,*) 'mps_getkin: >mpm_kin_send_yspec, mp_myid=', mp_myid
!XXX  write(39,*) '<mp_bug_yspec for iexpt=iexpt_pak=', iexpt
        iexpt_pak=iexpt
!XXX    call mp_bug_yspec
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mps_kin_recv_theta: START'
        write(39,*) 'mp_myid=',mp_myid
        write(39,*) 'iexpt=',iexpt
        write(39,*) 'jmp_kin=',jmp_kin
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mps_kin_recv_theta: < RECV:theta_pk'
        write(39,*) 'mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(39,*) &
     &   'mp_dim_theta,mp_dim_theta_x=' &
     &  , mp_dim_theta,mp_dim_theta_x
        write(39,*) &
     &   ' mp_itag(namtag)='   &
     &  ,  mp_itag(namtag)
        write(39,*) 'iexpt=',iexpt
        write(39,*) 'jmp_kin=',jmp_kin
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mps_kin_recv_theta: > RECV:theta_pk'
        write(39,*) 'mp_myid=',mp_myid
        write(39,*) 'iexpt=',iexpt
        write(39,*) 'jmp_kin=',jmp_kin
        write(39,*) 'mp_ierr=',mp_ierr
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mps_kin_recv_theta: >jmp_kin='
        write(39,*) 'mp_myid=',mp_myid
        write(39,*) 'jmp_kin=',jmp_kin
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mps_kin_recv_theta: > ...upk_theta'
        write(39,*) 'mp_myid=',mp_myid
        write(39,*) 'jmp_kin=',jmp_kin
!
        call mp_DB_fx
!
        call mps_DB_kin_send_theta
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mps_kin_send_yspec: START'
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mps_kin_send_yspec: < SSEND:jmp_fin_yspec'
        write(39,*) 'mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(39,*) 'iexpt=', iexpt
        write(39,*) 'jmp_fin_yspec(mp_myid)=', jmp_fin_yspec(mp_myid)
        write(39,*) 'mp_dim_yspec(iexpt)=', mp_dim_yspec(iexpt)
        write(39,*) 'mp_dim_yspec_x=', mp_dim_yspec_x
        write(39,*) &
     &   ' mp_itag(namtag)='   &
     &  ,  mp_itag(namtag)
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mps_kin_send_yspec: > SSEND:jmp_fin_yspec'
        write(39,*) 'mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(39,*) 'mp_ierr=', mp_ierr
        write(39,*) 'jmp_fin_yspec(mp_myid)=', jmp_fin_yspec(mp_myid)
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mps_kin_send_yspec: < RECV:jmp_fin_yspec'
        write(39,*) 'mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(39,*) 'iexpt=', iexpt
        write(39,*) 'jmp_fin_yspec(mp_myid)=', jmp_fin_yspec(mp_myid)
        write(39,*) &
     &   ' mp_itag(namtag)='   &
     &  ,  mp_itag(namtag)
!
        jmp_fin_yspec(mp_myid)=-iexpt
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mps_kin_send_yspec: > RECV:jmp_fin_yspec'
        write(39,*) 'mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(39,*) 'mp_ierr=', mp_ierr
        write(39,*) 'jmp_fin_yspec(mp_myid)=', jmp_fin_yspec(mp_myid)
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mps_kin_send_yspec: < SSEND:yspec_pk'
        write(39,*) 'mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(39,*) 'iexpt=', iexpt
        write(39,*) 'mp_dim_yspec(iexpt)=', mp_dim_yspec(iexpt)
        write(39,*) 'mp_dim_yspec_x=', mp_dim_yspec_x
        write(39,*) &
     &   ' mp_itag(namtag)='   &
     &  ,  mp_itag(namtag)
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mps_kin_send_yspec: > SSEND:yspec_pk'
        write(39,*) 'mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(39,*) 'mp_ierr=', mp_ierr
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      write(39,*) '  '
      write(39,*) 'mp_kin_pki: <return'
      do iexpt=1,nexpt
        write(39,*) 'iexpt=',iexpt
        write(39,*) 'mp_dim_yspec(iexpt)=',mp_dim_yspec(iexpt)
        write(39,*) 'mp_dim_yspec1(iexpt)=',mp_dim_yspec1(iexpt)
        write(39,*) 'mp_dim_yspec2(iexpt)=',mp_dim_yspec2(iexpt)
        write(39,*) 'mp_dim_yspec4(iexpt)=',mp_dim_yspec4(iexpt)
      enddo
      write(39,*) 'mp_dim_yspec_x=',mp_dim_yspec_x
!
      call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      write(39,*) '  '
      write(39,*) ' mps_upk_theta: <mp_ipak++, imc_rep=...'
      if(mp_myid.ne.mp_mrid) then
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      write(39,*) '  '
      write(39,*) ' mps_upk_theta: >mp_ipak++, if(mp_dim_theta...'
!
      endif
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mp_pki_arkabd: START'
        write(39,*) 'mp_myid=',mp_myid
        write(39,*) 'jo_th_ark=',  jo_th_ark
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mp_pki_arkabd: <do itime'
        write(39,*) 'mp_myid=',mp_myid
        write(39,*) 'mp_ipak=',mp_ipak
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        write(39,*) ' '
        write(39,*) 'mp_pki_arkabd: >enddo itime'
        write(39,*) 'mp_myid=',mp_myid
        write(39,*) 'mp_ipak=',mp_ipak
!
        call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
!!      write(39,*) ' '
!!      write(39,*) 'MPI_uck...:START'
!!      write(39,*) 'MPI_TAG_UB=', MPI_TAG_UB
!!      read(*,*) idum
!
!!      call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
!!      write(39,*) ' '
!!      write(39,*) 'MPI_uck...:>if(mp_ntag...)'
!!      write(39,*) 'MPI_TAG_UB=', MPI_TAG_UB
!!      write(39,*) 'mp_ntag=,mp_ntag_x=', mp_ntag, mp_ntag_x
!!      read(*,*) idum
!
!!      call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
!!      write(39,*) ' '
!!      write(39,*) 'MPI_uck...:<return'
!!      write(39,*) 'MPI_TAG_UB=', MPI_TAG_UB
!!      read(*,*) idum
!
!!      call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
!!      write(39,*) ' '
!!      write(39,*) 'err_term:START'
!!      read(*,*) idum
!
!!      call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
!!      write(39,*) ' '
!!      write(39,*) 'err_term:<efile(iun), iun=31'
!!      write(39,*) 'fexist=', fexist
!!      read(*,*) idum
!
!!      call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!DB<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      write(39,*) '   '
      write(39,*) 'kin_sol_ads21: START'
      write(39,*) ' mp_myid=',mp_myid
      write(39,*) '   iexpt=',iexpt
      write(39,*) '  dtime_ark=',dtime_ark
      write(39,*) '   dtime_rl=',dtime_rl
      write(39,*) '  rhini_ark=',rhini_ark
      write(39,*) '  hmin1_ark=',hmin1_ark
      write(39,*) '  hmin2_ark=',hmin2_ark
      write(39,*) '   hini_ark=', hini_ark
      write(39,*) '    eps_ark=',  eps_ark
      write(39,*) '   nstp_ark=', nstp_ark
!
      call mp_DB_fx
!
      write(39,9010) nspec,nvs_spec
 9010 format(                                                 &
     &/'     nspec  nvs_spec'                                 &
     &/2i10                                                   &
     &/'   ivs ispec            xspec(0)'                     &
     &,            '           xspec_min'                     &
     &,            '           xspec_max'                     &
     &)
      do ivs=1,nvs_spec
        write(39,9012)                                        &
     &  ivs                                                   &
     &  ,ispec_vs(ivs)                                        &
     &  ,xspec(ispec_vs(ivs),0)                               &
     &  ,xspec_min(ispec_vs(ivs))                             &
     &  ,xspec_max(ispec_vs(ivs))
 9012   format( 2i6,3d20.12)
      enddo
!
      call mp_DB_fx
!
      write(39,9020) nreac
 9020 format(                                                 &
     &/'     nreac'                                           &
     &/i10                                                    &
     &/'   ireac  nipart'                                     &
     &,        '  nopart'                                     &
     &,      ' nipart_vs'                                     &
     &,      ' nopart_vs'                                     &
     &,        '               rkfor'                         &
     &,        '               rkbak'                         &
     &)
      do ireac=1,nreac
        write(39,9022)                                        &
     &   ireac                                                &
     &  ,nipart(ireac)                                        &
     &  ,nopart(ireac)                                        &
     &  ,nipart_vs(ireac)                                     &
     &  ,nopart_vs(ireac)                                     &
     &  ,rkfor(ireac)                                         &
     &  ,rkbak(ireac)
 9022   format(3i8,2i10,2d20.12)
      enddo
!
      call mp_DB_fx
!
      write(39,9030)
 9030 format(                                                 &
     &/'   ireac   ipart'                                     &
     &,        '  iispec'                                     &
     &,        '              hicoop'                         &
     &/'   ireac   ipart'                                     &
     &,      ' iispec_vs'                                     &
     &,      '   iivs_vs'                                     &
     &,        '           gimult_vs'                         &
     &/'   ireac   ipart'                                     &
     &,        '  iospec'                                     &
     &,        '              hocoop'                         &
     &/'   ireac   ipart'                                     &
     &,      ' iospec_vs'                                     &
     &,      '   iovs_vs'                                     &
     &,        '           gomult_vs'                         &
     &)
      do ireac=1,nreac
        do ipart=1,nipart(ireac)
           write(39,9032)                                     &
     &     ireac,ipart                                        &
     &    ,iispec(ipart,ireac)                                &
     &    ,hicoop(ipart,ireac)
 9032     format(3i8,d20.12)
        enddo
        write(39,*)' /'
        do ipart=1,nipart_vs(ireac)
           write(39,9034)                                     &
     &     ireac,ipart                                        &
     &    ,iispec_vs(ipart,ireac)                             &
     &    ,iivs_vs(ipart,ireac)                               &
     &    ,gimult_vs(ipart,ireac)
 9034     format(2i8,2i10,d20.12)
        enddo
        write(39,*)' /'
!
        do ipart=1,nopart(ireac)
           write(39,9036)                                     &
     &     ireac,ipart                                        &
     &    ,iospec(ipart,ireac)                                &
     &    ,hocoop(ipart,ireac)
 9036     format(3i8,d20.12)
        enddo
        write(39,*)' /'
        do ipart=1,nopart_vs(ireac)
           write(39,9038)                                     &
     &     ireac,ipart                                        &
     &    ,iospec_vs(ipart,ireac)                             &
     &    ,iovs_vs(ipart,ireac)                               &
     &    ,gomult_vs(ipart,ireac)
 9038     format(2i8,2i10,d20.12)
        enddo
        write(39,*)' /'
      enddo
!
      call mp_DB_fx
!FB>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine MPI_uCK_NTAG_X
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! Important Note:
! To re-serialize the code, this subpg and all calls to it
! must be commented out!!
!
! Reason:
! This subpg accesses MPI system param. constant
!   MPI_TAG_UB
! which will become undefined in re-serialization
!
! Mr+Sv Code:
!
      if(mp_ntag_x.gt.MPI_TAG_UB.or.      &
     &   mp_ntag.gt.mp_ntag_x             &
     &)then
        mp_tag_ub=MPI_TAG_UB
        errtag='mr+sv:MPI_uCK_NTAG_X:mp_ntag_x'
        call err_term
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine err_term
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! does all fatal error handling
!
      close(39)
      close(31)
      inquire(file='ens.o01',exist=fexist)
      if(fexist) then
        open(31,file='ens.o01',status='old')
      else
!BLADE:
!       open(31,file='ens.o01',status='new')
        open(31,file='ens.o01')
!:BLADE
      endif
      iun=31
!
      call efile(iun)
      write(31,*) ' '
      write(31,*) ' '
      write(31,*) '------------------------'
      write(31,*) ' Fatal Error Termination'
      write(31,*) '------------------------'
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='mr+sv:mp_ens:mp_nproc'
      if(eqname(errtag,errtag_ck)) then
        write(31,*)                                                   &
     &  'main prg.         mp_ens'
        write(31,*) '  '
        write(31,*) ' ERROR'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*)                                                   &
     &  '   "mp_nproc" excceeds array size "mp_nproc_x"'
        write(31,*) '    mp_nproc, mp_nproc_x='
        write(31,*)      mp_nproc, mp_nproc_x
!
        write(31,*) ' Increase "mp_nproc_x" in ens.def,'
        write(31,*) ' then re-compile'
!
        write(31,*) '   errtag='
        write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='mr+sv:mp_ens:mp_ntag,mp_nreq'
      if(eqname(errtag,errtag_ck)) then
        write(31,*)                                                   &
     &  'main prg.         mp_ens'
        write(31,*) '  '
        write(31,*) ' ERROR'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*)                                                   &
     &  '   "mp_ntag" excceeds array size "mp_ntag_x" or'
        write(31,*)                                                   &
     &  '   "mp_nreq" excceeds array size "mp_nreq_x"'
        write(31,*) '    mp_ntag, mp_ntag_x='
        write(31,*)      mp_ntag, mp_ntag_x
        write(31,*) '    mp_nreq, mp_nreq_x='
        write(31,*)      mp_nreq, mp_nreq_x
!
        write(31,*) ' Increase "mp_ntag_x" in ens.def or'
        write(31,*) ' increase "mp_nreq_x" in ens.def,'
        write(31,*) ' then re-compile'
!
        write(31,*) '   errtag='
        write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='sv:mp_qini:mp_qiniid'
      if(eqname(errtag,errtag_ck)) then
        write(31,*)                                                   &
     &  'subrt.      mp_qini'
        write(31,*) '  '
        write(31,*) ' ERROR'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
!
        write(31,*) ' "mp_qiniid" does not match "mp_myid"'
        write(31,*) '  mp_qiniid, mp_myid='
        write(31,*)    mp_qiniid, mp_myid
!
        write(31,*) ' EXECUTION STOPPED '
!
        write(31,*) '   errtag='
        write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='mr:mp_qfin:mp_qfinid'
      if(eqname(errtag,errtag_ck)) then
        write(31,*)                                                   &
     &  'subrt.      mp_qfin'
        write(31,*) '  '
        write(31,*) ' ERROR'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
!
        write(31,*) ' "mp_qfinid" does not match "mp_qiniid"'
        write(31,*) '  mp_qfinid, mp_qiniid='
        write(31,*)    mp_qfinid, mp_qiniid
!
        write(31,*) ' EXECUTION STOPPED '
!
        write(31,*) '   errtag='
        write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='mr:mpm_kin_recv_yspec:jmp_fin_yspec'
      if(eqname(errtag,errtag_ck)) then
        write(31,*)                                                   &
     &  'subrt.      mpm_kin_recv_yspec'
        write(31,*) '  '
        write(31,*) ' ERROR'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
!
        write(31,*)                                                   &
     &  ' "jmp_fin_yspec(mp_svid) does not match "iexpt_upk"'
        write(31,*) '  mp_svid,jmp_fin_yspec(mp_svid),iexpt_upk='
        write(31,*)    mp_svid,jmp_fin_yspec(mp_svid),iexpt_upk
!
        write(31,*) ' EXECUTION STOPPED '
!
        write(31,*) '   errtag='
        write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='mr:mpm_kin_recv_arkabd:jmp_fin_arkabd'
      if(eqname(errtag,errtag_ck)) then
        write(31,*)                                                   &
     &  'subrt.      mpm_kin_recv_arkabd'
        write(31,*) '  '
        write(31,*) ' ERROR'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
!
        write(31,*)                                                   &
     &  ' "jmp_fin_arkabd(mp_svid)" does not match "mp_svid+1"'
        write(31,*) '  mp_svid,jmp_fin_arkabd(mp_svid)='
        write(31,*)    mp_svid,jmp_fin_arkabd(mp_svid)
!
        write(31,*) ' EXECUTION STOPPED '
!
        write(31,*) '   errtag='
        write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='sv:mps_kin_send_yspec:jmp_fin_yspec'
      if(eqname(errtag,errtag_ck)) then
        write(31,*)                                                   &
     &  'subrt.      mps_kin_send_yspec'
        write(31,*) '  '
        write(31,*) ' ERROR'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
!
        write(31,*)                                                   &
     &  ' "jmp_fin_yspec(mp_myid) does not match "iexpt"'
        write(31,*) '  mp_myid,jmp_fin_yspec(mp_myid),iexpt='
        write(31,*)    mp_myid,jmp_fin_yspec(mp_myid),iexpt
!
        write(31,*) ' EXECUTION STOPPED '
!
        write(31,*) '   errtag='
        write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='sv:mps_kin_send_arkabd:jmp_fin_arkabd'
      if(eqname(errtag,errtag_ck)) then
        write(31,*)                                                   &
     &  'subrt.      mps_kin_send_arkabd'
        write(31,*) '  '
        write(31,*) ' ERROR'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
!
        write(31,*)                                                   &
     &  ' "jmp_fin_arkabd(mp_myid) does not match "mp_myid+1"'
        write(31,*) '  mp_myid,jmp_fin_arkabd(mp_myid)='
        write(31,*)    mp_myid,jmp_fin_arkabd(mp_myid)
!
        write(31,*) ' EXECUTION STOPPED '
!
        write(31,*) '   errtag='
        write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='mr+sv:mp_pki_theta:mp_dim_theta_x'
      if(eqname(errtag,errtag_ck)) then
        write(31,*)                                                   &
     &  'subrt.         mp_pki_theta'
        write(31,*) '  '
        write(31,*) ' ERROR'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*)                                                   &
     &  ' "mp_dim_theta" exceeds array size "mp_dim_theta_x":'
        write(31,*) ' mp_dim_theta, mp_dim_theta_x='
        write(31,*)   mp_dim_theta, mp_dim_theta_x
        write(31,*) ' Increase "mp_dim_theta_x" in ens.def,'
        write(31,*) ' then re-compile'
!
        write(31,*) ' EXECUTION STOPPED '
!
        write(31,*) '   errtag='
        write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='mr:mpm_pak_theta:mp_ipak'
      if(eqname(errtag,errtag_ck)) then
        write(31,*)                                                   &
     &  'subrt.      mpm_pak_theta'
        write(31,*) '  '
        write(31,*) ' ERROR'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*)                                                   &
     &  ' Final "mp_ipak" does not match "mp_dim_theta":'
        write(31,*) ' mp_ipak,mp_dim_theta='
        write(31,*)   mp_ipak,mp_dim_theta
        write(31,*) ' Check subrt. "mp_pki_theta"'
        write(31,*) ' and subrt. "mpm_pak_theta" for consistency'
        write(31,*) ' of (un)packing list'
!
        write(31,*) ' EXECUTION STOPPED '
!
        write(31,*) '   errtag='
        write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='sv:mps_upk_theta:mp_ipak'
      if(eqname(errtag,errtag_ck)) then
        write(31,*)                                                   &
     &  'subrt.      mps_upk_theta'
        write(31,*) '  '
        write(31,*) ' ERROR'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*)                                                   &
     &  ' Final "mp_ipak" does not match "mp_dim_theta":'
        write(31,*) ' mp_ipak,mp_dim_theta='
        write(31,*)   mp_ipak,mp_dim_theta
        write(31,*) ' Check subrt. "mp_pki_theta"'
        write(31,*) ' and subrt. "mps_upk_theta" for consistency'
        write(31,*) ' of (un)packing list'
!
!
        write(31,*) ' EXECUTION STOPPED '
!
        write(31,*) '   errtag='
        write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='mr+sv:mp_pki_yspec:mp_dim_yspec_x'
      if(eqname(errtag,errtag_ck)) then
        write(31,*)                                                   &
     &  'subrt.         mp_pki_yspec'
        write(31,*) '  '
        write(31,*) ' ERROR'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*)                                                   &
     &  ' "mp_dim_yspecN" exceeds array size "mp_dim_yspec_x":'
        write(31,*) ' iexpt_pak=', iexpt_pak
        write(31,*) ' mp_dim_yspec1(iexpt_pak)='
        write(31,*)   mp_dim_yspec1(iexpt_pak)
        write(31,*) ' mp_dim_yspec2(iexpt_pak)='
        write(31,*)   mp_dim_yspec2(iexpt_pak)
        write(31,*) ' mp_dim_yspec4(iexpt_pak)='
        write(31,*)   mp_dim_yspec4(iexpt_pak)
        write(31,*) ' mp_dim_yspec_x='
        write(31,*)   mp_dim_yspec_x
        write(31,*) ' Increase "mp_dim_yspec_x" in ens.def,'
        write(31,*) ' then re-compile'
!
!
        write(31,*) ' EXECUTION STOPPED '
!
        write(31,*) '   errtag='
        write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='sv:mps_pak_yspec:mp_ipak'
      if(eqname(errtag,errtag_ck)) then
        write(31,*)                                                   &
     &  'subrt.      mps_pak_yspec'
        write(31,*) '  '
        write(31,*) ' ERROR'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*)                                                   &
     &  ' Final "mp_ipak" does not match "mp_dim_yspec":'
        write(31,*) ' iexpt_pak=', iexpt_pak
        write(31,*) ' mp_ipak,mp_dim_yspec(iexpt_pak)='
        write(31,*)   mp_ipak,mp_dim_yspec(iexpt_pak)
        write(31,*) ' Check subrt. "mp_pki_yspec"'
        write(31,*) ' and subrt. "mps_pak_yspec" for consistency'
        write(31,*) ' of (un)packing list'
!
        write(31,*) ' EXECUTION STOPPED '
!
        write(31,*) '   errtag='
        write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='mr:mpm_upk_yspec:mp_ipak'
      if(eqname(errtag,errtag_ck)) then
        write(31,*)                                                   &
     &  'subrt.      mpm_upk_yspec'
        write(31,*) '  '
        write(31,*) ' ERROR'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*)                                                   &
     &  ' Final "mp_ipak" does not match "mp_dim_yspec":'
        write(31,*) ' iexpt_pak=', iexpt_pak
        write(31,*) ' mp_ipak,mp_dim_yspec(iexpt_pak)='
        write(31,*)   mp_ipak,mp_dim_yspec(iexpt_pak)
        write(31,*) ' Check subrt. "mp_pki_yspec"'
        write(31,*) ' and subrt. "mpm_upk_yspec" for consistency'
        write(31,*) ' of (un)packing list'
!
!
        write(31,*) ' EXECUTION STOPPED '
!
        write(31,*) '   errtag='
        write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='mr+sv:mp_pki_arkabd:mp_dim_arkabd_x'
      if(eqname(errtag,errtag_ck)) then
        write(31,*)                                                   &
     &  'subrt.         mp_pki_arkabd'
        write(31,*) '  '
        write(31,*) ' ERROR'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*)                                                   &
     &  ' "mp_dim_arkabd" exceeds array size "mp_dim_arkabd_x":'
        write(31,*) ' mp_dim_arkabd, mp_dim_arkabd_x='
        write(31,*)   mp_dim_arkabd, mp_dim_arkabd_x
        write(31,*) ' Increase "mp_dim_arkabd_x" in ens.def,'
        write(31,*) ' then re-compile'
!
!
        write(31,*) ' EXECUTION STOPPED '
!
        write(31,*) '   errtag='
        write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='sv:mps_pak_arkabd:mp_ipak'
      if(eqname(errtag,errtag_ck)) then
        write(31,*)                                                   &
     &  'subrt.      mps_pak_arkabd'
        write(31,*) '  '
        write(31,*) ' ERROR'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*)                                                   &
     &  ' Final "mp_ipak" does not match "mp_dim_arkabd":'
        write(31,*) ' mp_ipak,mp_dim_arkabd='
        write(31,*)   mp_ipak,mp_dim_arkabd
        write(31,*) ' Check subrt. "mp_pki_arkabd"'
        write(31,*) ' and subrt. "mps_pak_arkabd" for consistency'
        write(31,*) ' of (un)packing list'
!
        write(31,*) ' EXECUTION STOPPED '
!
        write(31,*) '   errtag='
        write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='mr:mpm_upk_arkabd:mp_ipak'
      if(eqname(errtag,errtag_ck)) then
        write(31,*)                                                     &
     &  'subrt.      mpm_upk_arkabd'
        write(31,*) '  '
        write(31,*) ' ERROR'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*)                                                     &
     &  ' Final "mp_ipak" does not match "mp_dim_arkabd":'
        write(31,*) ' mp_ipak,mp_dim_arkabd='
        write(31,*)   mp_ipak,mp_dim_arkabd
        write(31,*) ' Check subrt. "mp_pki_arkabd"'
        write(31,*) ' and subrt. "mpm_upk_arkabd" for consistency'
        write(31,*) ' of (un)packing list'
!
        write(31,*) ' EXECUTION STOPPED '
!
        write(31,*) '   errtag='
        write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='mr+sv:MPI_uCK_NTAG_X:mp_ntag_x'
      if(eqname(errtag,errtag_ck)) then
        write(31,*)                                                   &
     &  'subrt.      MPI_uCK_NTAG_X'
        write(31,*) '  '
        write(31,*) ' ERROR'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*)                                                   &
     &  ' Array size problem: "mp_ntag_x > MPI_TAG_UB"'               &
     &  ,' or "mp_ntag > mp_ntag_x":'
!
        write(31,*)                                                   &
     &  ' mp_ntag, mp_ntag_x, MPI_TAG_UB='
        write(31,*)                                                   &
     &    mp_ntag, mp_ntag_x, mp_tag_ub
!
        write(31,*) '  '
        write(31,*) '   If mp_ntag > mp_ntag_x:'
        write(31,*) '   Increase array size parameter mp_ntag_x'      &
     &    , ' in "ens.def"+re-compile'
!
        write(31,*) ' '
        write(31,*)    &
     &  '   If mp_ntag_x > 0 > MPI_TAG_UB: Ignore'
        write(31,*)    &
     &  '   If mp_ntag_x > MPI_TAG_UB >= 0: Check with System Admin.'
        write(31,*) ' '
!
        write(31,*) ' EXECUTION STOPPED '
!
        write(31,*) '   errtag='
        write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000001'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     ostart'
        write(31,*) '  '
        write(31,*) ' ERROR'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*) ' npmspre_x,npmspec_x,npmreac_x='
        write(31,*)   npmspre_x,npmspec_x,npmreac_x
        write(31,*) ' Must have: npmspre_x>=max(npmspec_x,npmreac_x)'
        write(31,*) '   Increase array size parameter npmspre_x'        &
     &    , ' in "ens.def"+re-compile'
        write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000002'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
        write(31,*) '   '
        write(31,*) '   '
        write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*) '   nmc_rep, nmc_rep_x =', nmc_rep, nmc_rep_x
        write(31,*) '   Increase array size parameter nmc_rep_x '       &
     &    , ' in "ens.def"+re-compile'
        write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000003'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
        write(31,*) '   '
        write(31,*) '   '
        write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*) '   nmc_eql, nmc_eql_x =', nmc_eql, nmc_eql_x
        write(31,*) '   Increase array size parameter nmc_eql_x '       &
     &    , ' in "ens.def"+re-compile'
        write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000004'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
        write(31,*) '   '
        write(31,*) '   '
        write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*) '   nmc_acc, nmc_acc_x =', nmc_acc, nmc_acc_x
        write(31,*) '   Increase array size parameter nmc_acc_x '       &
     &    , ' in "ens.def"+re-compile'
        write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000005'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
        write(31,*) '   '
        write(31,*) '   '
        write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*) '   nmc_upd, nmc_upd_x =', nmc_upd, nmc_upd_x
        write(31,*) '   Increase array size parameter nmc_upd_x '       &
     &    , ' in "ens.def"+re-compile'
        write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000006'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
        write(31,*) '   '
        write(31,*) '   '
        write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*) '   npow_spec, npow_spec_x ='                       &
     &                , npow_spec, npow_spec_x
        write(31,*)                                                     &
     &      '   Increase array size parameter npow_spec_x '             &
     &    , ' in "ens.def"+re-compile'
        write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000007'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
        write(31,*) '   '
        write(31,*) '   '
        write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*) '   npow_reac, npow_reac_x ='                       &
     &                , npow_reac, npow_reac_x
        write(31,*)                                                     &
     &      '   Increase array size parameter npow_reac_x '             &
     &    , ' in "ens.def"+re-compile'
        write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000008'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
        write(31,*) '   '
        write(31,*) '   '
        write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*) '   nbx_time, nbx_time_x =', nbx_time, nbx_time_x
        write(31,*) '   Increase array size parameter nbx_time_x '      &
     &    , ' in "ens.def"+re-compile'
        write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000009'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
        write(31,*) '   '
        write(31,*) '   '
        write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*) '   ntfic, ntfic_x =', ntfic, ntfic_x
        write(31,*) '   Increase array size parameter ntfic_x '         &
     &    , ' in "ens.def"+re-compile'
        write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000010'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
          write(31,*) '   '
          write(31,*) '   '
          write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
          write(31,*) '   jmvloop=', jmvloop
          write(31,*) '   nmvsequ(jmvloop), nmvsequ_x ='                &
     &                  , nmvsequ(jmvloop), nmvsequ_x
          write(31,*) '   Increase array size parameter nmvsequ_x '     &
     &    , ' in "ens.def"+re-compile'
          write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
          close(31)
          call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000011'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
            write(31,*) '   '
            write(31,*) '   '
            write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) '   jmvloop, imvsequ=', jmvloop, imvsequ
            write(31,*) '   nmove(imvsequ,jmvloop), nmove_x ='          &
     &                 ,    nmove(imvsequ,jmvloop), nmove_x
            write(31,*) '   Increase array size parameter nmove_x '     &
     &    , ' in "ens.def"+re-compile'
            write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000012'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
            write(31,*) '   '
            write(31,*) '   '
            write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) '   jmvloop, imvsequ=', jmvloop, imvsequ
            write(31,*)                                                 &
     &      '   number of trapez. reweighting parameters'
            write(31,*)                                                 &
     &      '   exceeds array size limit'
            write(31,*)                                                 &
     &      '   npwgt(0,imvsequ,jmvloop), npwgt_x ='                    &
     &      ,   npwgt(0,imvsequ,jmvloop), npwgt_x
            write(31,*) '   Increase array size parameter npwgt_x '     &
     &    , ' in "ens.def"+re-compile'
            write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000013.000'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
            write(31,*) '   '
            write(31,*) '   '
            write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) '   jmvloop, imvsequ='                          &
     &                    , jmvloop, imvsequ
            write(31,*) '   tot. number of reweighting parameters'
            write(31,*) '   exceeds array size limit "npwgt_x":'
            write(31,*)                                                 &
     &      '   npwgt_tot(imvsequ,jmvloop), npwgt_x ='                  &
     &      ,   npwgt_tot, npwgt_x
            write(31,*)                                                 &
     &      '   Increase array size parameter npwgt_x '                 &
     &      , ' in "ens.def"+re-compile'
            write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000014'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
              write(31,*) '   '
              write(31,*) '   '
              write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
              write(31,*) '   jmvloop, imvsequ=', jmvloop, imvsequ
              write(31,*)                                               &
     &        '   npop_st(imvsequ,jmvloop), npopst_x, nthr_x ='         &
     &        ,   npop_st(imvsequ,jmvloop), npopst_x, nthr_x
!
              write(31,*)                                               &
     &        '   npar_st(imvsequ,jmvloop), nparst_x ='                 &
     &        ,   npar_st(imvsequ,jmvloop), nparst_x
              write(31,*)                                               &
     &        '   Increase array size nthr_x, npopst_x or nparst_x '    &
     &    , ' in "ens.def"+re-compile'
              write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
              close(31)
              call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000015'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
              write(31,*) '   '
              write(31,*) '   '
              write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
              write(31,*) '   jmvloop, imvsequ=', jmvloop, imvsequ
              write(31,*)                                               &
     &         '  npop_ge(imvsequ,jmvloop)'                             &
     &        ,' ,npopge_x, npopst_x, nthr_x ='
              write(31,*)                                               &
     &            npop_ge(imvsequ,jmvloop)                              &
     &        ,   npopge_x, npopst_x, nthr_x
!
              write(31,*)                                               &
     &        '   npar_ge(imvsequ,jmvloop), nparge_x ='                 &
     &        ,   npar_ge(imvsequ,jmvloop), nparge_x
              write(31,*)                                               &
     &        '   Increase array size'                                  &
     &          ,' nthr_x, npopge_x, npopst_x or nparge_x '             &
     &    , ' in "ens.def"+re-compile'
              write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
              close(31)
              call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000016'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
        write(31,*) '   '
        write(31,*) '   '
        write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*) '   nexpt, nexpt_x =', nexpt, nexpt_x
        write(31,*) '   Increase array size parameter nexpt_x '         &
     &    , ' in "ens.def"+re-compile'
        write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000017'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
        write(31,*) '   '
        write(31,*) '   '
        write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*) '   ntxpt, ntxpt_x =', ntxpt, ntxpt_x
        write(31,*) '   Increase array size parameter ntxpt_x '         &
     &    , ' in "ens.def"+re-compile'
        write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000018'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
        write(31,*) '   '
        write(31,*) '   '
        write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*) '   nspec, nspec_x =', nspec, nspec_x
        write(31,*) '   Increase array size parameter nspec_x '         &
     &    , ' in "ens.def"+re-compile'
        write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000019'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
        write(31,*) '   '
        write(31,*) '   '
        write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*) '   nreac, nreac_x =', nreac, nreac_x
        write(31,*) '   Increase array size parameter nreac_x '         &
     &    , ' in "ens.def"+re-compile'
        write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000020'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
        write(31,*) '   '
        write(31,*) '   '
        write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*) '   glob_scal=', glob_scal
        write(31,*) '   Must be positive !'
        write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000021'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
        write(31,*) '   '
        write(31,*) '   '
        write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*) '   ntime, ntime_x =', ntime, ntime_x
        write(31,*) '   Increase array size parameter ntime_x '         &
     &    , ' in "ens.def"+re-compile'
        write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000022'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
          write(31,*) '   '
          write(31,*) '   '
          write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
          write(31,*) '   nstp_ark, nstp_ark_x='                        &
     &                  , nstp_ark, nstp_ark_x
          write(31,*) ' Increase array size parameter nstp_ark_x '      &
     &    , ' in "ens.def"+re-compile'
          write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
          close(31)
          call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000023'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
          write(31,*) '   '
          write(31,*) '   '
          write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
          write(31,*) '   iexpt,isegft=',  iexpt,isegft
          write(31,*) '   nsegft, nsegft_x='                            &
     &                  , nsegft(iexpt), nsegft_x
          write(31,*) ' Increase array size parameter nsegft_x '        &
     &    , ' in "ens.def"+re-compile'
          write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
          close(31)
          call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000024'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
            write(31,*) '   '
            write(31,*) '   '
            write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) '   iexpt,isegft=',  iexpt,isegft
            write(31,*) '   nft_time, nft_time_x='                      &
     &                    , nft_time(isegft,iexpt), nft_time_x
            write(31,*) ' Increase array size parameter nft_time_x '    &
     &    , ' in "ens.def"+re-compile'
            write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000025'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
            write(31,*) '   '
            write(31,*) '   '
            write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) '   iexpt,isegft=',  iexpt,isegft
            write(31,*) '   nfil_frq, nfil_frq_x='                      &
     &                    , nfil_frq(isegft,iexpt), nfil_frq_x
            write(31,*) ' Increase array size parameter nfil_frq_x '    &
     &    , ' in "ens.def"+re-compile'
            write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000026'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
              write(31,*) '   '
              write(31,*) '   '
              write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
              write(31,*) '   iexpt,isegft=',  iexpt,isegft
              write(31,*) '   lft_time,2**lft_time,nft_time='           &
     &                    ,   lft_time(isegft,iexpt)                    &
     &                    ,   idum2                                     &
     &                    ,   nft_time(isegft,iexpt)
              write(31,*) '   nft_time not FFT-compatible:'
              write(31,*) ' nft_time must be an integer power of 2;'
              write(31,*) ' nft_time=2,4,8,16,32,64,128,256,512,...'
              write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
              close(31)
              call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000027'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
            write(31,*) '   '
            write(31,*) '   '
            write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) '   iexpt,isegft=',  iexpt,isegft
            write(31,*) '   nsho_frq, nsho_frq_x='                      &
     &                    , nsho_frq(isegft,iexpt), nsho_frq_x
            write(31,*) ' Increase array size parameter nsho_frq_x '    &
     &    , ' in "ens.def"+re-compile'
            write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000028'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
            write(31,*) '   '
            write(31,*) '   '
            write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*)                                                 &
     &      '  illegal input jmsspec(ispec)=',jmsspec(ispec)
            write(31,*) '  at ispec=', ispec
            write(31,*) '  namespec(ispec)='
            write(31,2010) namespec(ispec)
!
            write(31,*) ' '
            write(31,*)                                                 &
     &      '  jmsspec=1000*jmsspec_ft'                                 &
     &               ,'+100*jmsspec_px'                                 &
     &                ,'+10*jmsspec_ip'                                 &
     &                 ,'+1*jmsspec_ch:'
            write(31,*)                                                 &
     &      '  Hence: jmsspec_ft,jmsspec_px,jmsspec_ip,jmsspec_ch='     &
     &        ,jmsspec_ft(ispec),jmsspec_px(ispec)                      &
     &        ,jmsspec_ip(ispec),jmsspec_ch(ispec)
!
            write(31,*)                                                 &
     &      '  '
            write(31,*)                                                 &
     &      '  jmsspec_ch=0:'
            write(31,*)                                                 &
     &      '    not a measured species, no exptl. data in "ens.i02"'
            write(31,*)                                                 &
     &      '  jmsspec_ch=1:'
            write(31,*)                                                 &
     &      '    a measured species;'
            write(31,*)                                                 &
     &      '    use residues of LOG-concentration to calculate chi^2'
            write(31,*)                                                 &
     &      '  jmsspec_ch=2:'
            write(31,*)                                                 &
     &      '    a measured species;'
            write(31,*)                                                 &
     &      '    use residues of LIN-concentration to calculate chi^2'
            write(31,*)                                                 &
     &      '  '
            write(31,*)                                                 &
     &      '  jmsspec_ip=1:'
            write(31,*)                                                 &
     &      '    calculate predicted model conc. at exptl. t-pts. by'
            write(31,*)                                                 &
     &      '    linear interpolaton of LOG-concentration'
            write(31,*)                                                 &
     &      '  jmsspec_ip=0 or =2:'
            write(31,*)                                                 &
     &      '    calculate predicted model conc. at exptl. t-pts. by'
            write(31,*)                                                 &
     &      '    linear interpolaton of LIN-concentration'
            write(31,*)                                                 &
     &      '  '
            write(31,*)                                                 &
     &      '  jmsspec_px=0:'
            write(31,*)                                                 &
     &      '    calculate chi^2-contibution by direct summation of'
            write(31,*)                                                 &
     &      '    weighted squared residues over all exptl. data pts.;'
            write(31,*)                                                 &
     &      '    slow, esp. for large exptl. data sets: '
            write(31,*)                                                 &
     &      '    CPU effort ~ ndtin=no. of exptl. data pts.'
            write(31,*)                                                 &
     &      '  jmsspec_px=1:'
            write(31,*)                                                 &
     &      '    calculate chi^2-contibution by pre-summation of'
            write(31,*)                                                 &
     &      '    exptl. weight interpolation factors over all'
            write(31,*)                                                 &
     &      '    exptl. data pts. prior to MC updating and then use'
            write(31,*)                                                 &
     &      '    those interpol. factors to sum up chi^2 from'
            write(31,*)                                                 &
     &      '    predicted model concentrations at model grid t-pts.'
            write(31,*)                                                 &
     &      '    during MC updating;'
            write(31,*)                                                 &
     &      '    faster: CPU effort ~ ntime=no. of model t-grid pts.'
!
            write(31,*) ' '
            write(31,*)                                                 &
     &      '  jmsspec_px = 1   requires:'
            write(31,*)                                                 &
     &      '    EITHER: jmsspec_ch=1 AND jmsspec_ip=1'
            write(31,*)                                                 &
     &      '    OR:     jmsspec_ch=2 AND jmsspec_ip=2'
            write(31,*)                                                 &
     &      '    OR:     jmsspec_ch=2 AND jmsspec_ip=0'
            write(31,*)                                                 &
     &      '    Note: jmsspec_ip=2 and jmsspec_ip=0 are equivalent'
!
            write(31,*) ' '
            write(31,*)                                                 &
     &      '    To correct, either set jmsspec_px=0'
            write(31,*)                                                 &
     &      '    or choose a legal combination'                         &
     &      ,' of jmsspec_ch and jmsspec_ip'
            write(31,*)                                                 &
     &      '    Recommended (fastest) choice: jmsspec=111'
!
            write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000029'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
          write(31,*) '   '
          write(31,*) '   '
          write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
          write(31,*) '   ispec=', ispec
          write(31,2110)  namespec(ispec)
          write(31,*) '   npmspec(ispec), npmspec_x, npmspre_x='        &
     &                  , npmspec(ispec), npmspec_x, npmspre_x
          write(31,*)                                                   &
     &    '   Increase array size parameter(s)'                         &
     &     ,' npmspec_x and/or npmspre_x '                              &
     &    , ' in "ens.def"+re-compile'
          write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
          close(31)
          call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000030'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
            write(31,*) '   '
            write(31,*) '   '
            write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) '   ispec,ipm=', ispec,ipm
            write(31,2110)  namespec(ispec)
            write(31,*) '   nvpmspec(ispec,ipm), nvpmspec_x=',          &
     &                      nvpmspec(ispec,ipm), nvpmspec_x
            write(31,*) '   Increase array size parameter nvpmspec_x'   &
     &    , ' in "ens.def"+re-compile'
            write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000031'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
              write(31,*) '   '
              write(31,*) '   '
              write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
              write(31,*) '   ispec,ipm=', ispec,ipm
              write(31,2110)  namespec(ispec)
              write(31,*) '   idpen, ndpen_tot_x=',                     &
     &                        idpen, ndpen_tot_x
              write(31,*)                                               &
     &        '   Increase array size parameter ndpen_tot_x'            &
     &    , ' in "ens.def"+re-compile'
              write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
              close(31)
              call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000032'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
                write(31,*) '   '
                write(31,*) '   '
                write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
                write(31,*)                                             &
     &          ' "lo", "hi", "ini", or "tru"-value for species '
                write(31,2110) namespec(ispec)
                write(31,*) '   ispec,ipm,ivpm=', ispec,ipm,ivpm
                write(31,*) '   jfix(ispec)=', jfix(ispec)
                write(31,*) '   pmspec(ispec,ipm,ivpm)='                &
     &                         ,pmspec(ispec,ipm,ivpm)
                write(31,*) '   is out of bounds:'
                write(31,*) '   xspec_min(ispec),xspec_max(ispec)='     &
     &                         ,xspec_min(ispec),xspec_max(ispec)
                write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
                close(31)
                call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000033'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
            write(31,*) '   '
            write(31,*) '   '
            write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) '   ispec,ipm,kdpen=', ispec,ipm,kdpen
            write(31,2110)  namespec(ispec)
            write(31,*) '   mparn_dpen(kdpen), mparn_x=',               &
     &                      mparn_dpen(kdpen), mparn_x
            write(31,*) '   Increase array size parameter mparn_x'      &
     &    , ' in "ens.def"+re-compile'
            write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000034'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
          write(31,*) '   '
          write(31,*) '   '
          write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
          write(31,*) '   ireac=',ireac,':'
          write(31,2110) namereac(ireac)
          write(31,2010) bline(iline)
          write(31,*) '   nipart, nopart,npart_x='                      &
     &                , nipart(ireac),nopart(ireac),npart_x
          write(31,*) '   Increase array size parameter npart_x '       &
     &    , ' in "ens.def"+re-compile'
          write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
          close(31)
          call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000035'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
          write(31,*) '   '
          write(31,*) '   '
          write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
          write(31,*) '   ireac=', ireac
          write(31,2110)  namereac(ireac)
          write(31,*) '   npmreac(ireac), npmreac_x, npmspre_x='        &
     &                  , npmreac(ireac), npmreac_x, npmspre_x
          write(31,*)                                                   &
     &    '   Increase array size parameter(s)'                         &
     &     ,' npmreac_x and/or npmspre_x '
          write(31,*) ' in "ens.def"+re-compile'
          write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
          close(31)
          call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000036'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
            write(31,*) '   '
            write(31,*) '   '
            write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) '   ireac,ipm=', ireac,ipm
            write(31,2110)  namereac(ireac)
            write(31,*) '   nvpmreac(ireac,ipm), nvpmreac_x=',          &
     &                      nvpmreac(ireac,ipm), nvpmreac_x
            write(31,*) '   Increase array size parameter nvpmreac_x'   &
     &    , ' in "ens.def"+re-compile'
            write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000037'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
              write(31,*) '   '
              write(31,*) '   '
              write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
              write(31,*) '   ireac,ipm=', ireac,ipm
              write(31,2110)  namereac(ireac)
              write(31,*) '   idpen, ndpen_tot_x=',                     &
     &                        idpen, ndpen_tot_x
              write(31,*)                                               &
     &        '   Increase array size parameter ndpen_tot_x'            &
     &      , ' in "ens.def"+re-compile'
              write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
              close(31)
              call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000038'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
            write(31,*) '   '
            write(31,*) '   '
            write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) '   ireac,ipm,kdpen=', ireac,ipm,kdpen
            write(31,2110)  namereac(ireac)
            write(31,*) '   mparn_dpen(kdpen), mparn_x=',               &
     &                      mparn_dpen(kdpen), mparn_x
            write(31,*) '   Increase array size parameter mparn_x'      &
     &                , ' in "ens.def"+re-compile'
            write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000039'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
        write(31,*) '   '
        write(31,*) '   '
        write(31,*) '   '
        write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*) '   idokin,mdokin_x='                               &
     &                 ,idokin,mdokin_x
        write(31,*) '   Increase array size parameter mdokin_x'         &
     &            , ' in "ens.def"+re-compile'
        write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000040'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
            write(31,*) '   '
            write(31,*) '   '
            write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) '   incomplete list of jdokin_expt;'
            write(31,*) '   no jdokin_expt entry found for:'
!
            write(31,*)                                                 &
     &      '   mdokin,mldokin='                                        &
     &         ,mdokin,mldokin
!
            write(31,*)                                                 &
     &      '   iexpt,idokin,ldokin(idokin)='                           &
     &      ,   iexpt,idokin,ldokin(idokin)
            ireac=ireac_dokin(idokin)
            ispec=ispec_dokin(idokin)
            ipm=ipm_dokin(idokin)
!
            if(ispec.gt.0) aline=namespec(ispec)
            if(ireac.gt.0) aline=namereac(ireac)
!
            write(31,*)  '  ispec,ireac,ipm='                           &
     &                  ,   ispec,ireac,ipm
            write(31,*)  '  namespec/reac:'
            write(31,2110)  aline
!
            write(31,*) '  '
            write(31,*)                                                 &
     &      '  To correct:'
            write(31,*)                                                 &
     &      '  add an entry for jdokin_expt in "ens.i01"'
            write(31,*)                                                 &
     &      '  with label value ldokin=', ldokin(idokin)
            write(31,*)                                                 &
     &      '  and make sure each ldokin-value occurs'
            write(31,*)                                                 &
     &      '  only once in the ldokin-input list in "ens.i01"'
!
            write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000041'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat'
        write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*) '   Input format error in "ens.i01"'
        write(31,*)                                                     &
     &'   At or after one of the following input text line(s)'
        write(31,*)                                                     &
     &'   with last iline=', iline
        write(31,*) ' '
        write(31,*)                                                     &
     &  '************************************************************'
        write(31,*)                                                     &
     &  '    ****************************************************    '
        write(31,*)                                                     &
     &  '        ********************************************        '
        write(31,*)                                                     &
     &  '            ************************************            '
        write(31,*)                                                     &
     &  '                ****************************                '
        write(31,*)                                                     &
     &  '                    ********************                    '
        write(31,*)                                                     &
     &  '                        ***QUOTE:***                        '
        idum1=iline-20
        if(idum1.lt.0) idum1=0
        do idum=idum1,iline
          write(31,2110) bline(idum)
        enddo
        write(31,*)                                                     &
     &  '********************END OF QUOTE****************************'
        write(31,*) ' '
!
        write(31,*) '   Correct input format in "ens.i01"'
        write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000042'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     cread21'
        write(31,*) '   '
        write(31,*) ' ERROR in "cread21":  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*) ' At "aline"='
        write(31,2010)  aline
        write(31,*) ' iline,iline_x=',iline,iline_x
        write(31,*) ' "iline" exceeds array size "iline_x"'
        write(31,*) ' increase "iline_x"'                               &
     &            , ' in "ens.def"+re-compile'
        write(31,*) ' EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000043'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat_inipm'
        write(31,*) '  '
        write(31,*) '  '
        write(31,*) 'ERROR in "idat_inipm"'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*)                                                     &
     &  ' no complete, readable Theta vector was found in "ens.i12"'
        write(31,*)                                                     &
     &  ' correct or provide new "ens.i12"-file'
        write(31,*)
        write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000044'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat_rstart'
        write(31,*) '   '
        write(31,*) '   '
        write(31,*) ' ERROR in "ens.o02" '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*) '   jmvloop    =', jmvloop
        write(31,*) '   jmvloop_rst=', jmvloop_rst
        write(31,*) '   jmvloop_rst >2 or <1 !!!'
        write(31,*)                                                     &
     &   ' Restart-data in "ens.o02" not compatible'
        write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000045'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat_rstart'
        write(31,*) '   '
        write(31,*) '   '
        write(31,*) ' ERROR in "ens.o02" '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*) '   jmvloop    =', jmvloop
        write(31,*) '   jmvloop_rst=', jmvloop_rst
        write(31,*) '   imvsequ,     nmvsequ ='                         &
     &                , imvsequ,     nmvsequ(jmvloop)
        write(31,*) '   imvsequ_rst, nmvsequ_rst ='                     &
     &                , imvsequ_rst, nmvsequ(jmvloop_rst)
        write(31,*)                                                     &
     &   ' Restart-data in "ens.o02" not compatible'                    &
     &  ,' with input from "ens.i01"'
        write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000046'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat_tr_i'
          write(31,*) '   '
          write(31,*) '   '
          write(31,*)                                                   &
     &    ' ERROR in population restart file, no. iorf=',iorf
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
          write(31,2010) fname
          write(31,*) '   jtrepl_orf(iorf)=',jtrepl_orf(iorf)
          write(31,*) '   jtrepl_x        =',jtrepl_x
          write(31,*) '   Change array size "jtrepl_x"'                 &
     &              , '   in "ens.def"+re-compile'
          write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
          close(31)
          call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000047'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat_xpt'
        write(31,*) ' ERROR in input file ens.i02'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*)                                                     &
     &  '   ens.i02 lists more experiments than ens.i01 allows:'
        write(31,*) '     iexpt, nexpt=',iexpt, nexpt
        write(31,*) ' EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000048'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat_xpt'
        write(31,*) ' ERROR in input file ens.i02'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*)                                                     &
     &  '   for iexpt=',iexpt
        write(31,*)                                                     &
     &  '   ens.i02 lists more species than ens.i01 allows:'
        write(31,*) '   ndtspec(iexpt), nspec='                         &
     &                 ,ndtspec(iexpt), nspec
        write(31,*) ' EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000049'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat_xpt'
          write(31,*) ' ERROR in input file ens.i02'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
          write(31,*) '   for idtspec, iexpt='                          &
     &                       ,idtspec, iexpt
          write(31,*) '   species name not recognized:'
          write(31,*) '   '
          write(31,*) '   namespec_dtspec(idtspec,iexpt)='
          write(31,2020)  namespec_dtspec(idtspec,iexpt)
          write(31,*) '   '
          write(31,*) '   returned ispec=', ispec
!
          write(31,*) ' '
          write(31,*)                                                   &
     &    '  correct this species name to match one of the'
          write(31,*)                                                   &
     &    '  input species names declared in input file ens.i01'
!
          write(31,*) ' EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
          close(31)
          call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000050'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat_xpt'
          write(31,*) ' ERROR in input file ens.i02'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
          write(31,*) '   for idtspec, ispec, iexpt='                   &
     &                       ,idtspec, ispec, iexpt
          write(31,*) '   '
          write(31,*) '   namespec_dtspec(idtspec,iexpt)='
          write(31,2020)  namespec_dtspec(idtspec,iexpt)
          write(31,*) '   '
!
          write(31,*)                                                   &
     &     '  exptl. data for a non-measured species'                   &
     &    ,'  (jmsspec_ch=0 in ens.i01)'                                &
     &    ,'  are included in ens.i02'
          write(31,*)                                                   &
     &    '  either set jmsspec_ch>0 for this species in ens.i01'
          write(31,*)                                                   &
     &    '  or remove reference to this species from ens.i02'
!
          write(31,*) ' EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
          close(31)
          call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000051'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat_xpt'
            write(31,*) ' ERROR in input file ens.i02'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) '   for iexpt, ispec, ipm=',iexpt,ispec,ipm_D
            write(31,*) '   namespec_dtspec(idtspec,iexpt)='
            write(31,2020)  namespec_dtspec(idtspec,iexpt)
            write(31,*) '   jctspec(ispec,ipm)=', jctspec(ispec,ipm)
!
            write(31,*)                                                 &
     &       ' This is a dependent species;'
            write(31,*)                                                 &
     &       ' its "exptl. data pts." are calculated as dependents,'
            write(31,*)                                                 &
     &       ' from another species'' exptl. data pts., for output'
            write(31,*)                                                 &
     &       ' purposes only, and are not included in "chi^2".'
            write(31,*)                                                 &
     &       ' Therefore, this species cannot have exptl. data pts.'
            write(31,*)                                                 &
     &       ' listed in "ens.i02".'
            write(31,*)                                                 &
     &       ' To correct this:'
            write(31,*)                                                 &
     &       ' either remove this species from "ens.i02",'
            write(31,*)                                                 &
     &       ' or change or remove all dependency declarations'
            write(31,*)                                                 &
     &       '   jctspec(ispec,ipm)=30 or jctspec(ispec,ipm)=40'
            write(31,*)                                                 &
     &       ' for this species in "ens.i01".'
!
            write(31,*) ' EXECUTION TERMINATED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000052'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat_xpt'
          write(31,*) ' ERROR in input file ens.i02'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
          write(31,*) '    namespec_dtspec='
          write(31,2020)  namespec_dtspec(idtspec,iexpt)
          write(31,*)                                                   &
     &    '     for idtspec,ispec,iexpt='                               &
     &           ,idtspec,ispec,iexpt
          write(31,*) '    namespec_dtspec='
          write(31,2020)  namespec_dtspec(idtspec,iexpt)
          write(31,*)                                                   &
     &    '   nwintx(idtspec,iexpt)'
          write(31,*)                                                   &
     &    '   exceeds array size nwintx_x:'
          write(31,*) '   nwintx(idtspec,iexpt), nwintx_x='             &
     &                   ,nwintx(idtspec,iexpt), nwintx_x
          write(31,*) ' Increase array size nwintx_x'                   &
     &              , ' in "ens.def"+re-compile'
          write(31,*) ' EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
          close(31)
          call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000053'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat_xpt'
              write(31,*) ' ERROR in input file ens.i02'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
              write(31,*) '    namespec_dtspec='
              write(31,2020)  namespec_dtspec(idtspec,iexpt)
              write(31,*)                                               &
     &        '     for iwintx,idtspec,ispec,iexpt='                    &
     &                 ,iwintx,idtspec,ispec,iexpt
              write(31,*) '    namespec_dtspec='
              write(31,2020)  namespec_dtspec(idtspec,iexpt)
              write(31,*)                                               &
     &        '   nbintx(iwintx,idtspec,iexpt)'
              write(31,*)                                               &
     &        '   exceeds array size nbintx_x:'
              write(31,*) ' Increase array size nbintx_x'               &
     &                  , ' in "ens.def"+re-compile'
              write(31,*)                                               &
     &        '   nbintx(iwintx,idtspec,iexpt), nbintx_x='              &
     &           ,nbintx(iwintx,idtspec,iexpt), nbintx_x
              write(31,*) ' EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
              close(31)
              call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000054'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat_xpt'
            write(31,*) ' ERROR in input file ens.i02:'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) ' idtin out of bounds:'
            write(31,*) '   idtin, ndtin_x=',idtin,ndtin_x
            write(31,*) ' at:'
            write(31,*) '   ldtin, idtspec, iexpt='                     &
     &                 ,    ldtin, idtspec, iexpt
            write(31,*) ' '
            write(31,*) ' Increase array size ndtin_x'                  &
     &                , ' in "ens.def"+re-compile'
            write(31,*) ' EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000055'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat_xpt'
            write(31,*) ' ERROR in input file ens.i02'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*)                                                 &
     &       '   non-positive species concentration,'                   &
     &      ,' width or scale factor:'
            write(31,*)                                                 &
     &      '   iexpt, idtspec, ispec, ldtin='                          &
     &         ,iexpt, idtspec, ispec, ldtin
            write(31,*) '   namespec_dtspec(idtspec,iexpt)='
            write(31,2020)  namespec_dtspec(idtspec,iexpt)
            write(31,*)                                                 &
     &      '   zspec_xpt(idtin)=',zspec_xpt(idtin)
            write(31,*)                                                 &
     &      '   zspec_wid(idtin)=',zspec_wid(idtin)
            write(31,*)                                                 &
     &      '   zscal(idtin)=',zscal(idtin)
            write(31,*) ' EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000056'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat_xpt'
        write(31,*) ' ERROR in input file ens.i02:'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*) '   Input format error in "ens.i02"'
        write(31,*) '   At or after following input ID nos.:'
        write(31,*) '   iexpt,ldtin,idtin,idtspec,ispec=',              &
     &                  iexpt,ldtin,idtin,idtspec,ispec
!
        if(idtspec.gt.0.and.iexpt.gt.0) then
          write(31,*) '   for input species namespec_dtspec='
          write(31,2020)  namespec_dtspec(idtspec,iexpt)
        endif
!
        write(31,*)                                                     &
     &'   At or after one of the following input text line(s):'
        write(31,*) '  '
        write(31,*)                                                     &
     &  '************************************************************'
        write(31,*)                                                     &
     &  '    ****************************************************    '
        write(31,*)                                                     &
     &  '        ********************************************        '
        write(31,*)                                                     &
     &  '            ************************************            '
        write(31,*)                                                     &
     &  '                ****************************                '
        write(31,*)                                                     &
     &  '                    ********************                    '
        write(31,*)                                                     &
     &  '                        ***QUOTE:***                        '
          write(31,2010) aline
        write(31,*)                                                     &
     &  '************************END OF QUOTE************************'
        write(31,*) '  '
!
        write(31,*) '   Correct input format in "ens.i02"'
        write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000057'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     idat_xpt'
        write(31,*) ' ERROR in input file ens.i02'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*)                                                     &
     &   '   number of expts. found in ens.i02'                         &
     &  ,' does not match "nexpt" given in ens.i01'
        write(31,*)                                                     &
     &  '   iexpt(ens.i02), nexpt='                                     &
     &     ,iexpt, nexpt
        write(31,*) ' EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000058'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     wwgt_xpt'
                write(31,*) ' ERROR in input file ens.i02/wwgt_xpt'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
                write(31,*) '    namespec_dtspec='
                write(31,2020)  namespec_dtspec(idtspec,iexpt)
 2020           format(a80)
!
                write(31,*)                                             &
     &          '     for idtspec,ispec,iexpt='                         &
     &                   ,idtspec,ispec,iexpt
                write(31,*) '    namespec_dtspec='
                write(31,2020)  namespec_dtspec(idtspec,iexpt)
                write(31,*)                                             &
     &          '   mblok_ms'
                write(31,*)                                             &
     &          '   exceeds array size mblok_ms_x:'
                write(31,*) ' Increase array size mblok_ms_x'           &
     &                    , ' in "ens.def"+re-compile'
                write(31,*)                                             &
     &          '   mblok_ms, mblok_ms_x='                              &
     &           ,mblok_ms, mblok_ms_x
                write(31,*) ' EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
                close(31)
                call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000059'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     cprs_xpt'
                write(31,*) ' ERROR in input file ens.i02/cprs_xpt'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
                write(31,*) '    namespec_dtspec='
                write(31,2020)  namespec_dtspec(idtspec,iexpt)
!
                write(31,*)                                             &
     &          '     for idtspec,ispec,iexpt='                         &
     &                   ,idtspec,ispec,iexpt
                write(31,*) '    namespec_dtspec='
                write(31,2020)  namespec_dtspec(idtspec,iexpt)
                write(31,*)                                             &
     &          '   mblok_ms'
                write(31,*)                                             &
     &          '   exceeds array size mblok_ms_x:'
                write(31,*) ' Increase array size mblok_ms_x'           &
     &                    , ' in "ens.def"+re-compile'
                write(31,*)                                             &
     &          '   mblok_ms, mblok_ms_x='                              &
     &           ,mblok_ms, mblok_ms_x
                write(31,*) ' EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
                close(31)
                call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000060'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     stot_xpt'
            write(31,*) ' ERROR in input file ens.i02:'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) '   ktxpt out of bounds'
            write(31,*) '   idtin, ispec, iexpt='                       &
     &                 ,    idtin, ispec, iexpt
            write(31,*) '   ktxpt, ntxpt_x='                            &
     &                 ,    ktxpt, ntxpt_x
            write(31,*) ' EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000061'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     stot_xpt'
          write(31,*) ' ERROR in input file ens.i02:'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
          write(31,*) '   exptl. time tabulation failed'
          write(31,*) '   ktxpt, ltxpt_kt(ktxpt)='                      &
     &               ,    ktxpt, ltxpt_kt(ktxpt)
          write(31,*) ' time_xpt_kt(ktxpt)='
          write(31,*)   time_xpt_kt(ktxpt)
          write(31,*) ' EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
          close(31)
          call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000062'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     stot_xpt'
            write(31,*) ' ERROR in input file ens.i02:'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) '   itxpt out of bounds'
            write(31,*) '   ktxpt, itxpt, ntxpt_x='                     &
     &                 ,    ktxpt, itxpt, ntxpt_x
            write(31,*) ' time_xpt_kt(ktxpt)='
            write(31,*)   time_xpt_kt(ktxpt)
            write(31,*) ' Increase array size ntxpt_x'                  &
     &                , ' in "ens.def"+re-compile'
            write(31,*) ' EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000063'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     form_xpt'
                    write(31,*) '  '
                    write(31,*) '  '
                    write(31,*) ' ERROR in input file ens.i02:'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
                    write(31,*) '   itmx out of bounds'
                    write(31,*) '   idtin,itmx, mdtin_x='               &
     &                            , idtin,itmx, mdtin_x
                    write(31,*) '   at:'
                    write(31,*) '   itxpt,ims,ispec,iexpt='             &
     &                            , itxpt,ims,ispec,iexpt
                    write(31,*) '   namespec(ispec)='
                    write(31,2010)  namespec(ispec)
!
                    write(31,*) '   time_xpt(itxpt)='                   &
     &                            , time_xpt(itxpt)
!
                    write(31,*) ' Increase array size mdtin_x'          &
     &                        , ' in "ens.def"+re-compile'
!
                    write(31,*) ' EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
                    close(31)
                    call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000064'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     alloc_odpen'
          write(39,*) ' '
          write(39,*) ' ERROR in "alloc_odpen"'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
          write(39,*)                                                    &
     &    '  dependent exptl. species "ispec_D"'                        &
     &    ,' with jctspec=30 or 40'
          write(39,*)                                                    &
     &    '  either:'
          write(39,*)                                                    &
     &    '  has an exptl. parent "ispec_P"'                            &
     &    ,' with -309=<ipm_P=<-300 or -409=<ipm_P=<-400'
          write(39,*)                                                    &
     &    '  which is not declared as a measured species:'              &
     &    ,' i.e. has jmsspec(ispec_P)=0'
          write(39,*)                                                    &
     &    '  or:'
          write(39,*)                                                    &
     &    '  has no exptl. parent "ispec_P"'                            &
     &    ,' with -309=<ipm_P=<-300 or -409=<ipm_P=<-400'
          write(39,*)                                                    &
     &    '  _at all_'
!
          write(39,*) ' '
          write(39,*) ' Dependent:'
          write(39,*)                                                    &
     &    '  ispec_D, ims_D, ipm_D, jctspec='
          write(39,*)                                                    &
     &       ispec_D, ims_D, ipm_D, jctspec(ispec_D,ipm_D)
          write(39,*)                                                    &
     &    '  namespec(ispec_D)='
          write(39,2010)                                                 &
     &       namespec(ispec_D)
!
          write(39,*) ' '
          write(39,*) ' Parent, exptl. (if any):'
          write(39,*)                                                    &
     &    '  ispec_P, ims_P, ipm_P, jmsspec='
          write(39,*)                                                    &
     &       ispec_P, ims_P, ipm_P, jmsspec(ispec_P)
          write(39,*)                                                    &
     &    '  namespec(ispec_P)='
          write(39,2010)                                                 &
     &       namespec(ispec_P)
!
          write(31,*) ' EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
          close(31)
          call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000065'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     alloc_odpen'
            write(39,*) ' '
            write(39,*) ' ERROR in "alloc_odpen"'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(39,*)                                                  &
     &      '  tried to allocate array size "mdtin_odp"'
            write(39,*)                                                  &
     &      '  which exceeds limit "mdtin_odp_x"'
            write(39,*) ' mdtin_odp, mdtin_odp_x='                       &
     &                 , mdtin_odp, mdtin_odp_x
            write(39,*)                                                  &
     &      '  ispec_D, ims_D, ipm_D='
            write(39,*)                                                  &
     &         ispec_D, ims_D, ipm_D
            write(39,*)                                                  &
     &      '  namespec(ispec_D)='
            write(39,2010)                                               &
     &      namespec(ispec_D)
!
            write(39,*)                                                  &
     &      '  increase array size limit "mdtin_odp_x"'
!
            write(39,*)                                                  &
     &      '  in "ens.def"+re-compile'
!
            write(31,*) ' EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000066'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_sfc'
              write(31,*) ' ERROR in input file ens.i02:'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
              write(31,*) '   iscal out of bounds'
              write(31,*) '   ims, itxpt, iexpt='                       &
     &                   ,    ims, itxpt, iexpt
              write(31,*) '   iscal, niscal_x='                         &
     &                   ,    iscal, niscal_x
              write(31,*) ' EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
              close(31)
              call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000067.00'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_sfc'
              write(31,*) ' ERROR in input file ens.i02:'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
              write(31,*) '   tabulation error: '                       &
     &                   ,'   iscal_xpt not found for'
              write(31,*) '   ims, itxpt, iexpt='                       &
     &                   ,    ims, itxpt, iexpt
              write(31,*) ' EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
              close(31)
              call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000068'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_prex'
                    write(31,*) ' ERROR "set_prex"'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
                    write(31,*) '   iipch out of bounds'
                    write(31,*) '   iipch, nipch_x='                    &
     &                            , iipch, nipch_x
                    write(31,*) '   at or near:'
                    write(31,*) '   itxpt,ims,ispec,iexpt='             &
     &                            , itxpt,ims,ispec,iexpt
                    write(31,*) '   namespec(ispec)='
                    write(31,2010)  namespec(ispec)
!
                    write(31,*) '   time_xpt(itxpt)='                   &
     &                            , time_xpt(itxpt)
!
                    write(31,*) ' Increase array size nipch_x'          &
     &                        , ' in "ens.def"+re-compile'
!
                    write(31,*) ' EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
                    close(31)
                    call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000069'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_fix_pctl'
            write(31,*) '   '
            write(31,*) '   '
            write(31,*) ' ERROR '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) '   ims, nms_spec_x =', ims, nms_spec_x
            write(31,*) '   Increase array size parameter nms_spec_x '  &
     &    , ' in "ens.def"+re-compile'
            write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000070'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_fix_pctl'
            write(31,*) '   '
            write(31,*) '   '
            write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) '   is_ft, nsft_spec_x =', is_ft, nsft_spec_x
            write(31,*) '   Increase array size parameter nsft_spec_x ' &
     &    , ' in "ens.def"+re-compile'
            write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000071'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_fix_pctl'
              write(31,*) '   '
              write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
!
              write(31,*)                                               &
     &        '   Illegal "lo", "hi", "ini" or "tru" value'
              write(31,*) '   for species Theta-variable ispec,ipm='    &
     &                                               , ispec,ipm
!
              write(31,*) '   namespec(ispec)='
              write(31,2010)  namespec(ispec)
              write(31,*) '   jctspec(ispec,ipm)='                      &
     &                       ,jctspec(ispec,ipm)
!
              write(31,*) '   pmspec(ispec,ipm,1)=lo='                  &
     &                       ,rlospec(ith)
              write(31,*) '   pmspec(ispec,ipm,2)=hi='                  &
     &                       ,rhispec(ith)
              write(31,*) '   pmspec(ispec,ipm,4)=ini='                 &
     &                       ,pmspec(ispec,ipm,4)
              write(31,*) '   pmspec(ispec,ipm,5)=tru='                 &
     &                       ,pmspec(ispec,ipm,5)
!
              write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
              close(31)
              call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000072'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_fix_pctl'
              write(31,*) '   '
              write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
              write(31,*) '   in input file "ens.i01"'
              write(31,*) '   found by "set_fix_dpen"'
!
              write(31,*)                                               &
     &        '   Illegal "lo", "hi", "ini" or "tru" value'
              write(31,*) '   for reaction Theta-variable ireac,ipm='   &
     &                                               , ireac,ipm
              write(31,*) '   namereac(ireac)='
              write(31,2010)  namereac(ireac)
              write(31,*) '   jctreac(ireac,ipm)='                      &
     &                       ,jctreac(ireac,ipm)
              write(31,*) '   pmreac(ireac,ipm,1)=lo='                  &
     &                       ,rloreac(ith)
              write(31,*) '   pmreac(ireac,ipm,2)=hi='                  &
     &                       ,rhireac(ith)
              write(31,*) '   pmreac(ireac,ipm,4)=ini='                 &
     &                       ,pmreac(ireac,ipm,4)
              write(31,*) '   pmreac(ireac,ipm,5)=tru='                 &
     &                       ,pmreac(ireac,ipm,5)
              write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
              close(31)
              call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000073'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_fix_pctl'
        write(31,*) '   '
        write(31,*) '   '
        write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*)                                                     &
     &  '   mth_tot, nthr_x ='                                          &
     &  ,   mth_tot, nthr_x
!
        write(31,*)                                                     &
     &  '   Increase array size nthr_x: nthr_x >= mth_tot'              &
     &  , ' in "ens.def"+re-compile'
        write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000074'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_fix_pctl'
        write(31,*) '   '
        write(31,*) '   '
        write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*) '   mth_swo, mth_swo_x =', mth_swo, mth_swo_x
        write(31,*) '   Increase array size parameter mth_swo_x '       &
     &            , '   in "ens.def"+re-compile'
        write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000075'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_fix_mty'
        write(31,*) '   '
        write(31,*) '   '
        write(31,*) ' ERROR in "set_fix_mty" '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*) '   jmvloop,imvsequ=',jmvloop,imvsequ
        write(31,*)                                                     &
     &  '   ljmty,njmty_x=',ljmty,njmty_x
        write(31,*)                                                     &
     &  '   Move type counter "ljmty" exceeds array size "njmty_x" '
        write(31,*)                                                     &
     &  '   Increase array size "njmty_x" in "ens.def" + re-compile'
        write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000076'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_fix_imvs'
            write(31,*) '   '
            write(31,*) '   '
            write(31,*) ' ERROR in "set_fix_imvs" '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) '   jmvloop,imvsequ=',jmvloop,imvsequ
            write(31,*) '   kmvsequ_ini,kmvsequ=',kmvsequ_ini,kmvsequ
            write(31,*)                                                 &
     &      '   levlp,levlp_nxt,levlp_x=',levlp,levlp_nxt,levlp_x
            write(31,*)                                                 &
     &      '   Move sequence level levlp exceeds array size levlp_x'
            write(31,*)                                                 &
     &      '   or level step size limit levlp_nxt-levlp=<1'
            write(31,*)                                                 &
     &      '   or starting/ending value levlp=0'                       &
     &      , ' at imvsequ=kmvsequ_ini,kmvsequ'
            write(31,*)                                                 &
     &      '   Increase array size levlp_x in "ens.def" + re-compile'
            write(31,*)                                                 &
     &      '   or correct level sequence levlp_mvs(imvsequ,jmvloop)'
            write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000077'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_fix_orf'
        write(31,*) '   '
        write(31,*) '   '
        write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*) '   found by "set_fix_orf"'
!
        write(31,*) '   iorf,jtrepl_x,morf,norf_x='                     &
     &                 ,iorf,jtrepl_x,morf,norf_x
        write(31,*)                                                     &
     &  '   norf_x or morf out of bounds in "ens.def":'
!
        idum1=jtrepl_x*morf-1
        write(31,*)                                                     &
     &  '   1) norf_x must be >= jtrepl_x*morf-1=',idum1
        write(31,*)                                                     &
     &  '   2) norf_x must be =<                      ',norf_max
        write(31,*)                                                     &
     &  '   3) morf   must be >=                       2'
!
        write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000078'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_fix_reac'
            write(31,*) '  '
            write(31,*) '  '
            write(31,*) ' ERROR '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) '   in input file "ens.i01"'
            write(31,*) '   found by "set_fix_reac"'
!
!N180810
            write(31,*)                                                 &
     &       ' A t-evol. dependent species (jfix<0) with jfix|=-110'
            write(31,*)                                                 &
     &       ' has been listed as a participant in a reaction'
            write(31,*)  ' '
!
            write(31,*) ' Dependent (Child) Species:'
            write(31,*)                                                 &
     &      '   ispec,jfix(ispec)/namespec='                            &
     &        , ispec,jfix(ispec)
            write(31,2110)  namespec(ispec)
 2110       format(a80)
!
            write(31,*) '  '
            write(31,*) ' Illegal Reaction:'
            write(31,*)                                                 &
     &      '  ireac,ipart/namereac='
            write(31,*)                                                 &
     &         ireac,ipart
            write(31,2110) namereac(ireac)
!
            write(31,*) ' The dependent species is listed as:'
            if(ipart0.le.nipart(ireac)) then
              write(31,*) '  a reactant (input) to the reaction'
              write(31,*) '     ispec=iispec(ipart,ireac)'
            else
              write(31,*) '  a product (output) of the reaction'
              write(31,*) '     ispec=iospec(ipart,ireac)'
            endif
!N180810
            write(31,*) ' This is NOT allowed for jfix(ispec)<0 unless jfix(ispec)=-110'
!
            write(31,*) ' '
!N180810
            write(31,*)                                                 &
     &      ' Set jfix=-110 for dependent species or'
            write(31,*)                                                 &
     &      ' correct or dependent species list in ens.i01:'
!
            write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000079'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_fix_reac'
          write(31,*) '  '
          write(31,*) '  '
          write(31,*) ' ERROR '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
          write(31,*)                                                   &
     &     ' Estimated count of non-zero Jacobian'                      &
     &    ,' matrix elements nnz_lss'
          write(31,*)                                                   &
     &     ' exceeds array size limit nnz_lss_x'
          write(31,*) ' nnz_lss, nnz_lss_x=', nnz_lss, nnz_lss_x
          write(31,*) ' '
          write(31,*)                                                   &
     &      ' Increase array size nnz_lss_x'                            &
     &    , ' in "ens.def"+re-compile'
!
          write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
          close(31)
          call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000080'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_fix_wl'
          write(31,*) '   '
          write(31,*) '   '
          write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
          write(31,*) '   in input file "ens.i01"'
          write(31,*) '   found by "set_fix_wl"'
!
          write(31,*) ' '
          write(31,*)                                                   &
     &    '   for ig=',igintv
          write(31,*)                                                   &
     &    '   enrg_ig is not listed in ascending order:'
          write(31,*)                                                   &
     &    '   deintv,enrg_ig(ig-1), enrg_ig(ig)='                       &
     &       ,deintv,enrg_ig(igintv-1),enrg_ig(igintv)
          write(31,*)                                                   &
     &    '   Correct the energy interval list in "ens.i01"'
          write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
          close(31)
          call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000081'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_fix_wl'
              write(31,*) '   '
              write(31,*) '   '
              write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
              write(31,*) '   ieintv, neintv_x =', ieintv, neintv_x
              write(31,*) '   Increase array size parameter neintv_x '  &
     &    , ' in "ens.def"+re-compile'
              write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
              close(31)
              call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000082'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_fix_wl'
              write(31,*) '   '
              write(31,*) '   '
              write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
              write(31,*) '   ieintv, neintv_x =', ieintv, neintv_x
              write(31,*) '   Increase array size parameter neintv_x '  &
     &    , ' in "ens.def"+re-compile'
              write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
              close(31)
              call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000082.001'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_fix_dpen'
          write(31,*) '  '
          write(31,*) ' ERROR '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
          write(31,*) ' lcrdp_dpen out of bounds:'
          write(31,*) ' lcrdp_dpen(idpen,iexpt), mdpen_tot_x='
          write(31,*)   lcrdp_dpen(idpen,iexpt), mdpen_tot_x
          write(31,*) ' idpen, iexpt, ndpen_tot, nexpt='
          write(31,*)   idpen, iexpt, ndpen_tot, nexpt
          write(31,*) ' ispre, ipm / namespre(ispre)='
          write(31,*)   ispre, ipm
          write(31,2010) namespre(ispre)
          write(31,*) ' jctspre(ispre,ipm), jbcspre(ispre,ipm)='
          write(31,*)   jctspre(ispre,ipm), jbcspre(ispre,ipm)
!
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
              write(31,*) '   Increase array size parameter mdpen_tot_x '  &
     &    , ' in "ens.def"+re-compile'
              write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
              close(31)
              call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000083'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_fix_dpen'
          write(31,*) '  '
          write(31,*) ' ERROR '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
          write(31,*) '   in input file "ens.i01"'
          write(31,*) '   found by "set_fix_dpen"'
          write(31,*) ' error in species/reaction names:'
          write(31,*) ' ispre0,ispec0,ireac0/name0='
          write(31,*)   ispre0,ispec0,ireac0
          write(31,2110)   name0
          write(31,*) ' ispre1,ispec1,ireac1/name1='
          write(31,*)   ispre1,ispec1,ireac1
          write(31,2110)   name1
          write(31,*) ' '
          write(31,*)                                                   &
     &     ' choose different name for at least one '                   &
     &    ,'of these 2 species/reactions'
!
          write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
          close(31)
          call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000084'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_fix_dpen'
            write(31,*) '  '
            write(31,*) ' ERROR '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) '   in input file "ens.i01"'
            write(31,*) '   found by "set_fix_dpen"'
            write(31,*) ' collision in species/reaction names:'
            write(31,*) ' ispre0,ispec0,ireac0/name0='
            write(31,*)   ispre0,ispec0,ireac0
            write(31,2110)   name0
            write(31,*) ' '
            write(31,*) ' ispre1,ispec1,ireac1/name1='
            write(31,*)   ispre1,ispec1,ireac1
            write(31,2110)   name1
            write(31,*) ' '
            write(31,*)                                                 &
     &       ' choose a different name for at least one '               &
     &      ,'of these 2 species/reactions'
!
            write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000085'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_fix_dpen'
              write(31,*) '  '
              write(31,*) ' ERROR '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
              write(31,*) '   in input file "ens.i01"'
              write(31,*) '   found by "set_fix_dpen"'
              write(31,*)                                               &
     &        ' Unknown or ambiguous parent name used'
              write(31,*)                                               &
     &        ' to specify a dependent parameter`s parent.'
              write(31,*) ' Dependent (Child) Parameter or Species:'
              write(31,*) '   idpen,ispre,ispec,ireac,ipm/namespre='
              write(31,*) '   ', idpen,ispre,ispec,ireac,ipm
              write(31,2110)  namespre(ispre)
              write(31,*) '   has a Parent of the Name:'
              write(31,*) '   iparn,ipm_parn/nmparn='
              write(31,*) '   ', iparn,ipm_parn(iparn,idpen)
              write(31,2110)   nmparn(iparn,idpen)
              write(31,*)                                               &
     &        ' Number of full names containing the parent name:'
              write(31,*) '   mname=', mname
              write(31,*)                                               &
     &        ' Parent name is contained in following full names:'
              do iname=1,mname
                write(31,*) '   ispre_nam(iname)=', ispre_nam(iname)
                write(31,2110)  namespre(ispre_nam(iname))
                write(31,*) ' '
              enddo
              write(31,*) ' '
              write(31,*)                                               &
     &        ' Choose a different name to represent parent'
!
              write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
              close(31)
              call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000086'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_fix_dpen'
                write(31,*) '  '
                write(31,*) '  '
                write(31,*) ' ERROR '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
                write(31,*) '   in input file "ens.i01"'
                write(31,*) '   found by "set_fix_dpen"'
                write(31,*)                                             &
     &          ' The "ipm"-ID of a parent parameter exceeds limit:'
!
                write(31,*) ' Dependent parameter:'
                write(31,*)                                             &
     &          '   ispre,ispec,ireac/namespre='                        &
     &            , ispre,ispec,ireac
                write(31,2110)  namespre(ispre)
!
                write(31,*) '  '
                write(31,*) ' Parent parameter:'
                write(31,*)                                             &
     &          '   iparn,idpen,ipm_parn(iparn,idpen)='                 &
     &            , iparn,idpen,ipm_parn(iparn,idpen)
                write(31,*)                                             &
     &          '   ispre0,ispec0,ireac0,npmspre0/namespre0/nmparn='    &
     &            , ispre0,ispec0,ireac0,npmspre0
                write(31,2110)  namespre(ispre0)
                write(31,2110)  nmparn(iparn,idpen)
!
                write(31,*) '  '
                write(31,*)                                             &
     &          ' Value of "ipm_parn" is not allowed to exceed',        &
     &          ' value of "npmspre0" '
                write(31,*)                                             &
     &          ' (npmspre0=npmspec/reac of parent species/reaction)'
                write(31,*) 'Correct parent input list'
!
                write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
                close(31)
                call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000087'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_fix_dpen'
            write(31,*) '  '
            write(31,*) '  '
            write(31,*) ' ERROR '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) '   in input file "ens.i01"'
            write(31,*) '   found by "set_fix_dpen"'
            write(31,*)                                                 &
     &       ' Improperly declared t-evol. dependent'
!
            write(31,*) ' '
            write(31,*)                                                 &
     &       '   ispre,ispec,ireac,ipm,'                                &
     &      ,'jctspec.jctreac,jfix/namespec.namereac='
            write(31,*)                                                 &
     &      ispre,ispec,ireac,ipm,jctspre(ispre,ipm),jfix0
            write(31,2110)  namespre(ispre)
!
            write(31,*)                                                 &
     &      ' For reactions (ireac>0):'
            write(31,*)                                                 &
     &      '   jctreac=20,30,40 is NOT allowed'
            write(31,*)                                                 &
     &       ' For species (ispec>0):'
!N180810
            write(31,*)                                                 &
     &      '   jctspec=20,30,40 is allowed ONLY if jfix=-100 or -110'
!
            write(31,*)                                                 &
     &      '  Correct dependent declaration in ens.i01:'
!
            write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000088'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_fix_dpen'
                  write(31,*) '  '
                  write(31,*) '  '
                  write(31,*) ' ERROR '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
                  write(31,*) '   in input file "ens.i01"'
                  write(31,*) '   found by "set_fix_dpen"'
                  write(31,*)                                           &
     &             ' Non-t-evol. dependent'                             &
     &            ,' species or reaction parameter'
                  write(31,*)                                           &
     &             ' has been given a t-evol. species'                  &
     &            ,' as a parent parameter'
!
                  write(31,*) ' Dependent (Child) Parameter:'
                  write(31,*)                                           &
     &            '   idpen,ipm,ispre,ispec,ireac/namespec.namereac='   &
     &              , idpen,ipm,ispre,ispec,ireac
                  write(31,2110)  namespre(ispre)
!
                  write(31,*) '  '
                  write(31,*) ' Illegal Parent:'
                  write(31,*)                                           &
     &            '   iparn,ipm_parn,jctspec_parn='                     &
     &              , iparn,ipm_P,jctspre_P
                  write(31,*)                                           &
     &            '   ipm_parn<0 or jctspec_parn=20,30 NOT allowed here'
                  write(31,*)                                           &
     &            '   ispre_parn,ispec_parn,ireac_parn/nmparn='         &
     &              , ispre_parn(iparn,idpen)                           &
     &              , ispec_parn(iparn,idpen)                           &
     &              , ireac_parn(iparn,idpen)
                  write(31,2110) nmparn(iparn,idpen)
!
                  write(31,*) ' Correct parent input list in ens.i01:'
!
                  write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
                  close(31)
                  call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000089'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_fix_dpen'
            write(31,*) '  '
            write(31,*) '  '
            write(31,*) ' ERROR '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) '   in input file "ens.i01"'
            write(31,*) '   found by "set_fix_dpen"'
            write(31,*)                                                 &
     &       ' A t-evol. parent has been declared'                      &
     &      ,' which is NOT a species'
            write(31,*)                                                 &
     &       ' instead t-evol. parent is a reaction: illegal!'
!
            write(31,*) ' Dependent (Child) Parameter or Species:'
            write(31,*)                                                 &
     &      '   idpen,ipm,ispre,ispec,ireac/namespec.namereac='         &
     &        , idpen,ipm,ispre,ispec,ireac
            write(31,2110)  namespre(ispre)
!
            write(31,*) '  '
            write(31,*) ' Illegal Parent:'
            write(31,*)                                                 &
     &      '   iparn,ipm_parn,ispec_parn,ireac_parn/nmparn='           &
     &        , iparn,ipm_P,ispec_P,ireac_P
            write(31,2110) nmparn(iparn,idpen)
!
            write(31,*) ' '
            write(31,*)                                                 &
     &      '   For ipm_parn<0, ispec_parn<0 is NOT allowed'
            write(31,*)                                                 &
     &      '   For ipm_parn<0, MUST have ispec_parn>0'
!
            write(31,*) ' Correct parent input list in ens.i01:'
!
            write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000090'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_fix_dpen'
            write(31,*) '  '
            write(31,*) '  '
            write(31,*) ' ERROR '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) '   in input file "ens.i01"'
            write(31,*) '   found by "set_fix_dpen"'
            write(31,*)                                                 &
     &       ' A non-t-evol. parent has been declared'
            write(31,*)                                                 &
     &       ' to actually refer to a t-evol. species directive'
!
            write(31,*) ' Dependent (Child) Parameter or Species:'
            write(31,*)                                                 &
     &      '   idpen,ipm,ispre,ispec,ireac/namespec.namereac='         &
     &        , idpen,ipm,ispre,ispec,ireac
            write(31,2110)  namespre(ispre)
!
            write(31,*) '  '
            write(31,*) ' Illegal Parent:'
            write(31,*)                                                 &
     &      '   iparn,ipm_parn,ispec_parn,ireac_parn/nmparn='           &
     &        , iparn,ipm_P,ispec_P,ireac_P
            write(31,2110) nmparn(iparn,idpen)
!
            write(31,*)                                                 &
     &      '   jctspre_parn='                                          &
     &        , jctspre_P
            write(31,*)                                                 &
     &      '   For ipm_parn>0, jctspre_parn=20 or 30 is NOT allowed'
!
            write(31,*) ' Correct parent input list in ens.i01:'
!
            write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000091'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_fix_dpen'
            write(31,*) '  '
            write(31,*) '  '
            write(31,*) ' ERROR '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) '   in input file "ens.i01"'
            write(31,*) '   found by "set_fix_dpen"'
            write(31,*)                                                 &
     &       ' A t-evol. dependent model species (jctspec=20) has'
            write(31,*)                                                 &
     &       ' been given t-evol. parent with out-of-range ipm_parn'
!
            write(31,*) ' Dependent (Child) Species:'
            write(31,*)                                                 &
     &      '   idpen,ipm,ispre,ispec,ireac/namespec.namereac='         &
     &        , idpen,ipm,ispre,ispec,ireac
            write(31,2110)  namespre(ispre)
!
            write(31,*)                                                 &
     &      '   jctspec(ispec,ipm)='                                    &
     &      ,   jctspre(ispre,ipm)
!
            write(31,*) '  '
            write(31,*) ' Illegal Parent:'
            write(31,*)                                                 &
     &      '   iparn,ipm_parn,ispec_parn,ireac_parn/nmparn='           &
     &        , iparn,ipm_P,ispec_P,ireac_P
            write(31,2110) nmparn(iparn,idpen)
!
            write(31,*)                                                 &
     &      '   ipm_parn='                                              &
     &      ,   ipm_P
!
            write(31,*)                                                 &
     &      '   For a dependent with jctspec=20, you MUST have'
            write(31,*)                                                 &
     &      '       -300 < ipm_parn =< 200  or  ipm_parn>=0'
!
            write(31,*) ' Correct parent input list in ens.i01:'
!
            write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000092'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_fix_dpen'
            write(31,*) '  '
            write(31,*) '  '
            write(31,*) ' ERROR '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) '   in input file "ens.i01"'
            write(31,*) '   found by "set_fix_dpen"'
            write(31,*)                                                 &
     &       ' A t-evol. dependent exptl. output species (jctspec=30)'
            write(31,*)                                                 &
     &       ' has been given t-evol. parent with'
            write(31,*)                                                 &
     &       '    either out-of-range ipm_parn'
            write(31,*)                                                 &
     &       '    or species without exptl. data: ims_parn =< 0'
!
            write(31,*) ' Dependent (Child) Species:'
            write(31,*)                                                 &
     &      '   idpen,ipm,ispre,ispec,ireac/namespec.namereac='         &
     &        , idpen,ipm,ispre,ispec,ireac
            write(31,2110)  namespre(ispre)
!
            write(31,*)                                                 &
     &      '   ims_spec,jctspec(ispec,ipm)='                           &
     &      ,   ims,jctspre(ispre,ipm)
!
!
            write(31,*) '  '
            write(31,*) ' Illegal Parent:'
            write(31,*)                                                 &
     &      '   iparn,ispec_parn,ireac_parn/nmparn='                    &
     &        , iparn,ispec_P,ireac_P
            write(31,2110) nmparn(iparn,idpen)
            write(31,*)                                                 &
     &      '   ipm_parn, ims_parn='                                    &
     &      ,   ipm_P, ims_P
!
            write(31,*)                                                 &
     &       '   For a dependent with jctspec=30 or 40,'                &
     &      ,' you MUST have:'
            write(31,*)                                                 &
     &      '       -500 < ipm_parn =< 300  or  ipm_parn>=0'
            write(31,*)                                                 &
     &      '   AND'
            write(31,*)                                                 &
     &      '       ims_parn:=ims_spec(ispec_parn) > 0'                 &
     &         ,'   if   ipm_parn < 0'
            write(31,*)                                                 &
     &      '   AND'
            write(31,*)                                                 &
     &      '       ims:=ims_spec(ispec) > 0'
!
            write(31,*) ' Correct parent input list in ens.i01:'
!
            write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000093'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_fix_dpen'
            write(31,*) '  '
            write(31,*) ' ERROR '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) '   in input file "ens.i01"'
            write(31,*) '   found by "set_fix_dpen"'
            write(31,*)                                                 &
     &      ' Interrupted parameter dependency chain:'
            write(31,*)                                                 &
     &      '   dependent child "(ispre1,ipm1)" requires'
            write(31,*)                                                 &
     &      '   uninitialed, dependent parent "(ispre0,ipm0)"'
!
            write(31,*) ' '
            write(31,*) ' Child:'
            write(31,*)                                                 &
     &      ' ispre1,ispec1,ireac1,ipm1,iprio1,jprio1/name1='
            write(31,*)                                                 &
     &      '  ', ispre1,ispec1,ireac1,ipm1,ipriodp,jprio_dpen(idpen)
            write(31,2110)   name1
            if(ispre1.gt.0.and.ipm1.gt.0) then
              write(31,*) ' jctspre1=',jctspre(ispre1,ipm1)
            endif
!
            write(31,*) ' '
            write(31,*) ' Parent:'
            write(31,*) ' ispre0,ispec0,ireac0,ipm0/name0='
            write(31,*) '  ', ispre0,ispec0,ireac0,ipm0
            write(31,2110)   name0
!
            write(31,*) ' '
            write(31,*)                                                 &
     &      ' Provide uninterrupted dependency chain'
            write(31,*)                                                 &
     &      ' by correcting dependency declarations (jct...>=10)'
            write(31,*)                                                 &
     &      ' and/or dependency evaluation priorities (jprio_dpen)'
!
            write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000093.001'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_fix_dpen'
            write(31,*) '  '
            write(31,*) ' ERROR '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) '   in input file "ens.i01"'
            write(31,*) '   found by "set_fix_dpen"'
!
        write(31,*) ' DOSIB_... function name not recognized:'
        write(31,2110) aline
        write(31,*) ' jfunc=', jfunc
        write(31,*) ' idpen=', idpen
        write(31,*) ' ispre_dpen=', ispre_dpen(idpen)
        write(31,*) ' ispec_dpen=', ispec_dpen(idpen)
        write(31,*) ' ireac_dpen=', ireac_dpen(idpen)
!
        write(31,*) ' namespre='
        write(31,2110) namespre(ispre_dpen(idpen))
        write(31,*) ' ipm_dpen=', ipm_dpen(idpen)
!
        write(31,*) ' Correct this function name'
!
!
        write(31,*) ' EXECUTION STOPPED '
!
        write(31,*) '   errtag='
        write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000093.011.001'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_fix_dcon'
            write(31,*) '  '
            write(31,*) ' ERROR '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) '   in input file "ens.i01"'
            write(31,*) '   found by "set_fix_dcon"'
!
        write(31,*) ' INCOMPATIBLE deconv. ampl. block size'
        write(31,*) 'jmvloop,imvsequ=', jmvloop, imvsequ
        write(31,*) 'ldconp,ldconr,kampdv=', ldconp,ldconr,kampdv
!
      if(jmvloop.ge.1.and.imvsequ.ge.1) then
        write(31,*) 'nmvsequ(jmvloop)=', nmvsequ(jmvloop)
!
        write(31,*) 'ldconp_ini,ldconp_fin='      &
     &              ,ldconp_ini(imvsequ,jmvloop)  &
     &              ,ldconp_fin(imvsequ,jmvloop)
!
        write(31,*) 'ldconr_ini,ldconr_fin='      &
     &              ,ldconr_ini(imvsequ,jmvloop)  &
     &              ,ldconr_fin(imvsequ,jmvloop)
!
        write(31,*) 'kpmb_ini,kpmbdv_fin='      &
     &              ,kpmb_ini(imvsequ,jmvloop)  &
     &              ,kpmb_fin(imvsequ,jmvloop)
!
        write(31,*) 'kampdv_ini,kampdv_fin='      &
     &              ,kampdv_ini(imvsequ,jmvloop)  &
     &              ,kampdv_fin(imvsequ,jmvloop)
      endif
!
        write(31,*) 'idum1,idum2=', idum1,idum2
!
        write(31,*) 'ipspec/namespec(ipspec)=',ipspec
        write(31,2010) namespec(ipspec)
!
        write(31,*) 'irspec/namespec(irspec)=',irspec
        write(31,2010) namespec(irspec)
!
        write(31,*) ' EXECUTION STOPPED '
!
        write(31,*) '   errtag='
        write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000094'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     func_dpen_lo  OR  func_dpen_hi'
      write(31,*) '  '
      write(31,*) '  '
      write(31,*) ' ERROR '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
      write(31,*) '   in input file "ens.i01"'
      write(31,*) '   found by "func_dpen"'
      write(31,*)                                                       &
     &' no parameter dependence function defined for'
      write(31,*)                                                       &
     & ' the following input function ID ("jfunc")'
      write(31,*)                                                       &
     & ' and/or function name ("namefunc_dpen"): '
      write(31,*)                                                       &
     &'   jfunc_dpen=',jfunc
!
      if(jfunc.eq.-1) then
        write(31,*)                                                     &
     &  '   namefunc_dpen='
        write(31,2110) namefunc
      endif
!
      write(31,*)  ' '
      write(31,*)                                                       &
     &'   Dependent parameter id/name:'
      write(31,*) 'ispre_D,ispec_D,ireac_D,ipm_D/namespre='
      write(31,*)  ispre_D,ispec_D,ireac_D,ipm_D
      write(31,2110) namespre(ispre_D)
!
      write(31,*) ' Correct "jfunc_dpen"'
      write(31,*) ' or      "namefunc_dpen"'
      write(31,*) ' or provide new parameter dependence function '
      write(31,*) ' in subprogr. "func_dpen"'
!
      write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
      close(31)
      call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000095.000'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_vxpt'
                write(31,*) '  '
                write(31,*) '  '
                write(31,*) '  '
                write(31,*) ' ERROR in "set_vxpt":'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
                write(31,*) '   itmx out of bounds'
                write(31,*) '   itmx, mdtin_x='                         &
     &                        , itmx, mdtin_x
                write(31,*) '   at:'
                write(31,*) '   itxpt,ims,ispec,iexpt='                 &
     &                        , itxpt,ims,ispec,iexpt
                write(31,*) '   namespec(ispec)='
                write(31,2010)  namespec(ispec)
!
                write(31,*) '   time_xpt(itxpt)='                       &
     &                        , time_xpt(itxpt)
!
                write(31,*) ' Increase array size mdtin_x'              &
     &                    , ' in "ens.def"+re-compile'
!
                write(31,*) ' EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
                close(31)
                call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000096'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_tint'
        write(31,*) '   '
        write(31,*) '   '
        write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*) '   in input file "ens.i02"'
        write(31,*) '   found by "set_tint"'
        write(31,*) '   No exptl. data points available ?!?'
        write(31,*) '   mdtin='
        write(31,*)     mdtin
        write(31,*) '   nexpt,itxpt_min,itxpt_max,nms_spec='
        write(31,*)     nexpt,itxpt_min,itxpt_max,nms_spec
        write(31,*) 'ispec jmsspec _ch _ip _px _ft'
        write(31,920) (ispec                     &
     &              , jmsspec(ispec)             &
     &              , jmsspec_ch(ispec)          &
     &              , jmsspec_ip(ispec)          &
     &              , jmsspec_px(ispec)          &
     &              , jmsspec_ft(ispec)          &
     &              , ispec=1,nspec)
  920   format(6i4)
!
        write(31,*)                                                     &
     &  '    Are integration time limits "time0", "time1"'
        write(31,*)                                                     &
     &  '    compatible with exptl. "time_xpt(itxpt)"-values ?'
        write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000097'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_tint'
            write(31,*) '   '
            write(31,*) '   '
            write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) '   irkit, nrkit_x =', irkit, nrkit_x
            write(31,*) '   Increase array size parameter nrkit_x '     &
     &    , ' in "ens.def"+re-compile'
            write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000098'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_tint'
            write(31,*) '   '
            write(31,*) '   '
            write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) '   itgri, ntgri_x =', itgri, ntgri_x
            write(31,*) '   Increase array size parameter ntgri_x '     &
     &    , ' in "ens.def"+re-compile'
            write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000099.000'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_tint'
          write(31,*) '   '
          write(31,*) '   '
          write(31,*) ' ERROR  '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
          write(31,*) '   io_time, no_time_x =', io_time, no_time_x
          write(31,*) '   Increase array size parameter no_time_x '     &
     &    , ' in "ens.def"+re-compile'
          write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
          close(31)
          call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000100'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_xdi'
              write(31,*) '  '
              write(31,*) '  '
              write(31,*) '  ERROR in "set_xdi"'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
              write(31,*) '    illegal exptl. data point'
              write(31,*) '    itmx_xpt(ims,itxpt,iexpt)='              &
     &                     ,   itmx_xpt(ims,itxpt,iexpt)
              write(31,*) '    at:'
              write(31,*) '    iexpt,ims,ispec,itxpt='                  &
     &                     ,  iexpt,ims,ispec_ms(ims),itxpt
              write(31,*) '    namespec(ispec)='
              write(31,2010)   namespec(ispec_ms(ims))
              write(31,*) '    time_xpt(itxpt)='                        &
     &                     ,  time_xpt(itxpt)
              write(31,*) '    choose time_xpt(itxpt) within the limits'
              write(31,*) '    time0, time1=',  time0, time1
              write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
              close(31)
              call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000101'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_xdi'
              write(31,*) '   '
              write(31,*) '   '
              write(31,*) ' !!! SEVERE CODING ERROR (1) !!!  '
              write(31,*) '   in "set_xdi"'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
              write(31,*) '   At: ispec,iexpt=', ispec,iexpt
              write(31,*) ' namespec='
              write(31,2010)  namespec(ispec)
              write(31,*)                                               &
     &        '   is_xdi, nms_spec_x =', is_xdi, nms_spec_x
              write(31,*) '     Check for Programming Bug !!'
!
              write(31,*) ' '
              write(31,*) 'jmvloop,imc_rep,imc_eql,imc_acc,imc_upd='
              write(31,*)  jmvloop,imc_rep,imc_eql,imc_acc,imc_upd
              write(31,*) 'imvsequ,kmove,imove='
              write(31,*)  imvsequ,kmove,imove
              write(31,*) 'ith_rk,ith_cs=', ith_rk,ith_cs
              write(31,*) ' '
!
              write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
              close(31)
              call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000102'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_xdi'
                  write(31,*) '   '
                  write(31,*) '  ERROR   '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
                  write(31,*) '    in input file "ens.i02":'
                  write(31,*) '    found by subprogr. "set_xdi":'
                  write(31,*)                                           &
     &            '    Inconsistent segment initialization marker'      &
     &            ,   ' for exptl. data interpolation'
                  write(31,*)                                           &
     &            '    Initialization must be preceded by termination'
                  write(31,*) '    ispec/namespec='
                  write(31,*) ispec_ms(ims)
                  write(31,2010) namespec(ispec)
                  write(31,*) '    iexpt,ims,itxpt,isegxd='             &
     &                      , iexpt,ims,itxpt,isegxd
                  if(isegxd.ge.1) then
                    write(31,*) '   itxpt_xdii(isegxd,is_xdi,iexpt)='   &
     &                           ,  itxpt_xdii(isegxd,is_xdi,iexpt)
                  endif
                  write(31,*)                                           &
     &            '    jzxdi_xpt(itmx_xpt(ims,itxpt,iexpt))='           &
     &               , jzxdi_xpt(itmx_xpt(ims,itxpt,iexpt))
                  write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
                  close(31)
                  call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000103'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_xdi'
                  write(31,*) '   '
                  write(31,*) '   '
                  write(31,*) '  ERROR   '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
                  write(31,*) '    in input file "ens.i02":'
                  write(31,*) '    found by subprogr. "set_xdi":'
                  write(31,*) '   At: is_xdi,ispec,iexpt='              &
     &                         ,  is_xdi,ispec,iexpt
                  write(31,*) ' namespec='
                  write(31,2010)  namespec(ispec)
                  write(31,*)                                           &
     &            '   isegxd, nsegxd_x =',   isegxd, nsegxd_x
                  write(31,*)                                           &
     &              '   Increase array size parameter nsegxd_x '        &
     &            , ' in "ens.def"+re-compile'
!
                  write(31,*) ' '
                  write(31,*) 'jmvloop,imc_rep,imc_eql,imc_acc,imc_upd='
                  write(31,*)  jmvloop,imc_rep,imc_eql,imc_acc,imc_upd
                  write(31,*) 'imvsequ,kmove,imove='
                  write(31,*)  imvsequ,kmove,imove
                  write(31,*) 'ith_rk,ith_cs=', ith_rk,ith_cs
                  write(31,*) ' '
!
                  write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
                  close(31)
                  call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000104'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_xdi'
                  write(31,*) '   '
                  write(31,*) '  ERROR   '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
                  write(31,*) '    in input file "ens.i02":'
                  write(31,*) '    found by subprogr. "set_xdi":'
                  write(31,*)                                           &
     &            '    Inconsistent segment termination marker'         &
     &            ,  ' for exptl. data interpolation'
                  write(31,*)                                           &
     &            '    Termination must be preceded'                    &
     &              ,' by initialization'
                  write(31,*) '    ispec/namespec='
                  write(31,*) ispec_ms(ims)
                  write(31,2010) namespec(ispec)
                  write(31,*) '    iexpt,ims,itxpt,isegxd='             &
     &                      , iexpt,ims,itxpt,isegxd
                  if(isegxd.ge.1) then
                    write(31,*)                                         &
     &              '    itxpt_xdif(isegxd,is_xdi,iexpt)='              &
     &                ,  itxpt_xdif(isegxd,is_xdi,iexpt)
                  endif
                  if(isegxd.ge.2) then
                    write(31,*)                                         &
     &              '    itxpt_xdif(isegxd-1,is_xdi,iexpt)='            &
     &                ,  itxpt_xdif(isegxd-1,is_xdi,iexpt)
                  endif
                  write(31,*)                                           &
     &            '    jzxdi_xpt(itmx_xpt(ims,itxpt,iexpt))='           &
     &               , jzxdi_xpt(itmx_xpt(ims,itxpt,iexpt))
!
                  write(31,*) ' '
                  write(31,*) 'jmvloop,imc_rep,imc_eql,imc_acc,imc_upd='
                  write(31,*)  jmvloop,imc_rep,imc_eql,imc_acc,imc_upd
                  write(31,*) 'imvsequ,kmove,imove='
                  write(31,*)  imvsequ,kmove,imove
                  write(31,*) 'ith_rk,ith_cs=', ith_rk,ith_cs
                  write(31,*) ' '
!
                  write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
                  close(31)
                  call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000105'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_xdi'
                write(31,*) '   '
                write(31,*) '  ERROR   '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
                write(31,*) '    in input file "ens.i02":'
                write(31,*) '    found by subprogr. "set_xdi":'
                write(31,*)                                             &
     &          '    Missing segment termination marker'                &
     &          ,  ' for exptl. data interpolation'
                write(31,*) '    ispec,ntxpt/namespec='
                write(31,*) ispec_ms(ims),ntxpt
                write(31,2010) namespec(ispec)
                write(31,*) '    iexpt,ims,itxpt,isegxd='               &
     &                    , iexpt,ims,itxpt,isegxd
                if(isegxd.ge.1) then
                  write(31,*) '    itxpt_xdii(isegxd,is_xdi,iexpt)='    &
     &                          ,  itxpt_xdii(isegxd,is_xdi,iexpt)
                  write(31,*) '    itxpt_xdif(isegxd,is_xdi,iexpt)='    &
     &                          ,  itxpt_xdif(isegxd,is_xdi,iexpt)
                endif
                write(31,*) '    jzxdi_xpt(itmx_xpt(ims,itxpt,iexpt))=' &
     &                         , jzxdi_xpt(itmx_xpt(ims,itxpt,iexpt))
                write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
                close(31)
                call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000106'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_xdi'
            write(31,*) ' !!! SEVERE CODING ERROR (2) !!!  '
            write(31,*) '     in "set_xdi"'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) '     iexpt,ispec,ims=', iexpt,ispec,ims
            write(31,*) '     Check for Programming Bug !!'
!
            write(31,*) ' '
            write(31,*) 'jmvloop,imc_rep,imc_eql,imc_acc,imc_upd='
            write(31,*)  jmvloop,imc_rep,imc_eql,imc_acc,imc_upd
            write(31,*) 'imvsequ,kmove,imove='
            write(31,*)  imvsequ,kmove,imove
            write(31,*) 'ith_rk,ith_cs=', ith_rk,ith_cs
            write(31,*) ' '
!
            write(31,*) '   EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000107'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     set_xdi'
              write(31,*) '   '
              write(31,*) '   '
              write(31,*) ' ERROR in "set_xdi"'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
              write(31,*) '   At: isegxd,is_xdi,ispec,iexpt='           &
     &                         ,  isegxd,is_xdi,ispec,iexpt
              write(31,*) ' namespec='
              write(31,2010)  namespec(ispec)
              write(31,*)                                               &
     &        '   nbaxdi(0,...) nbaxdi_x='                              &
     &        ,   nbaxdi(0,isegxd,is_xdi,iexpt), nbaxdi_x
              write(31,*)                                               &
     &        '   Increase array size parameter nbaxdi_x '              &
     &    , ' in "ens.def"+re-compile'
!
              write(31,*) ' '
              write(31,*) 'jmvloop,imc_rep,imc_eql,imc_acc,imc_upd='
              write(31,*)  jmvloop,imc_rep,imc_eql,imc_acc,imc_upd
              write(31,*) 'imvsequ,kmove,imove='
              write(31,*)  imvsequ,kmove,imove
              write(31,*) 'ith_rk,ith_cs=', ith_rk,ith_cs
              write(31,*) ' '
!
              write(31,*) ' EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
              close(31)
              call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000108'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     get_xdi'
              write(31,*) '   ERROR in "get_xdi" '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
              write(31,*)                                               &
     &        '     No. of input-specified ipl. basis states'           &
     &        ,   ' exceeds no. of available data pts. for:'
              write(31,*) '     ispec, iexpt, nsegxd/namespec='
              write(31,*) ispec, iexpt, nsegxd(is_xdi,iexpt)
              write(31,2010) namespec(ispec)
              write(31,*)                                               &
     &        '     isegxd,itxpt_i,itxpt_f='                            &
     &            , isegxd,itxpt_i,itxpt_f
              write(31,*)                                               &
     &        '     nbas1,nbas2,nbas,ntxdi='                            &
     &            , nbas1,nbas2,nbas,ntxdi(isegxd,is_xdi,iexpt)
!
              write(31,*) ' '
              write(31,*) 'jmvloop,imc_rep,imc_eql,imc_acc,imc_upd='
              write(31,*)  jmvloop,imc_rep,imc_eql,imc_acc,imc_upd
              write(31,*) 'imvsequ,kmove,imove='
              write(31,*)  imvsequ,kmove,imove
              write(31,*) 'ith_rk,ith_cs=', ith_rk,ith_cs
              write(31,*) ' '
!
              write(31,*) '   EXECUTION STOPPED '
!
          write(31,*) '   errtag='
          write(31,2010) errtag
              close(31)
              call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000109'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     setpm_th'
          write(31,*) '  '
          write(31,*) '  '
          write(31,*) 'ERROR in "setpm_th"'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
          write(31,*) 'Theta-component not properly initialized '       &
     &               ,'for species Theta-variable no.:'
          write(31,*) '  ith,ispec,ipm=',ith,ispec,ipm
          write(31,*) '  namespec(ispec)='
          write(31,2011)  namespec(ispec)
 2011     format(a80)
          write(31,*) 'Check/change "jmc_inir" and/or "jctspec":'
          write(31,*) '  jmc_inir,jctspec(ispec,ipm)='                  &
     &                  ,jmc_inir,jctspec(ispec,ipm)
!
          write(31,*) ' '
          write(31,*) 'jmvloop,imc_rep,imc_eql,imc_acc,imc_upd='
          write(31,*)  jmvloop,imc_rep,imc_eql,imc_acc,imc_upd
          write(31,*) 'imvsequ,kmove,imove='
          write(31,*)  imvsequ,kmove,imove
          write(31,*) 'ith_rk,ith_cs=', ith_rk,ith_cs
!
          write(31,*) ' '
          write(31,*) 'EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
          close(31)
          call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000110.000'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     setpm_th'
          write(31,*) '  '
          write(31,*) '  '
          write(31,*) 'ERROR in "setpm_th"'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
          write(31,*) 'Theta-component not properly initialized '       &
     &               ,'for reaction Theta-variable no.:'
          write(31,*) '  ith,ireac,ipm=',ith,ireac,ipm
          write(31,*) '  namereac(ireac)='
          write(31,2012)  namereac(ireac)
 2012     format(a80)
          write(31,*) 'Check/change "jmc_inir" and/or "jctreac":'
          write(31,*) '  jmc_inir,jctreac(ireac,ipm)='                  &
     &                  ,jmc_inir,jctreac(ireac,ipm)
!
          write(31,*) ' '
          write(31,*) 'jmvloop,imc_rep,imc_eql,imc_acc,imc_upd='
          write(31,*)  jmvloop,imc_rep,imc_eql,imc_acc,imc_upd
          write(31,*) 'imvsequ,kmove,imove='
          write(31,*)  imvsequ,kmove,imove
          write(31,*) 'ith_rk,ith_cs=', ith_rk,ith_cs
!
          write(31,*) ' '
          write(31,*) 'EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
          close(31)
          call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000110.003'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     move_cs1_blk'
        write(31,*) '  '
        write(31,*) '  '
        write(31,*) 'ERROR in "move_cs1_blk" '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
!
!
          write(31,*) ' '
          write(31,*) 'jmvloop,imc_rep,imc_eql,imc_acc,imc_upd='
          write(31,*)  jmvloop,imc_rep,imc_eql,imc_acc,imc_upd
          write(31,*) 'imvsequ,kmove,imove='
          write(31,*)  imvsequ,kmove,imove
          write(31,*) 'ith_rk,ith_cs=', ith_rk,ith_cs
!
          if(jmvloop.ge.1.and.imvsequ.ge.1) then
            write(31,*) 'mthb_spec(imvsequ,jmvloop)='
            write(31,*)  mthb_spec(imvsequ,jmvloop)
            write(31,*) 'kthb_spec_ini,kthb_spec_fin='
            write(31,*)  kthb_spec_ini(imvsequ,jmvloop)                &
     &                 , kthb_spec_fin(imvsequ,jmvloop)
          endif
!
          write(31,*) 'ith_upd,mth_spec,mthblk1,mthblk0,kthblk,kthblk_tot='
          write(31,*)  ith_upd,mth_spec,mthblk1,mthblk0,kthblk,kthblk_tot
          write(31,*) 'kthblk, ithc_thblk='
          do kthblk=1,kthblk_tot
            write(31,*) kthblk, ithc_thblk(kthblk)
          enddo
!
          write(31,*) ' '
          write(31,*) 'EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
          close(31)
          call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000111.000'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     move_fsu'
        write(31,*) '  '
        write(31,*) '  '
        write(31,*) 'ERROR in "move_fsu" '
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
!
        write(31,*) ' '
        write(31,*) 'jmvloop,imc_rep,imc_eql,imc_acc,imc_upd='
        write(31,*)  jmvloop,imc_rep,imc_eql,imc_acc,imc_upd
        write(31,*) 'imvsequ,kmove,imove='
        write(31,*)  imvsequ,kmove,imove
        write(31,*) 'ith_rk,ith_cs=', ith_rk,ith_cs
!
        write(31,*) 'kmvsequ,imvsequ,jmty(imvsequ,jmvloop)='
        write(31,*)  kmvsequ,imvsequ,jmty(imvsequ,jmvloop)
!
        write(31,*) 'ipop_fsux,ipop_fsu1,ipop_fsu2,isurvx='
        write(31,*)  ipop_fsux,ipop_fsu1,ipop_fsu2,isurvx
!
        write(31,*) 'npopge,nsurvge,nsurvck1,nsurvck2='
        write(31,*)  npopge,nsurvge,nsurvck1,nsurvck2
!
        write(31,*) 'selection of random survivor list failed:'
        write(31,5010)
 5010   format(' ipop     jsurv isurv_pop')
        write(31,5012)                                                  &
     &  (ipop, jsurv(ipop), isurv_pop(ipop),ipop=0,npopge)
 5012   format(i5,2i10)
!
        write(31,5020)
 5020   format('isurv ipop_surv')
        write(31,5022)                                                  &
     &  (isurv, ipop_surv(isurv),isurv=0,nsurvge)
 5022   format(i5,i10)
!
        write(31,*) ' EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000112'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     mc_ini_m'
        write(31,*) 'ERROR in "mc_ini_m"'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*) 'htot_th exceeds htot-cut-off limit:'
        write(31,*) 'htot_th,htot_cut=',htot_th,htot_cut
!
        write(31,*) ' '
        write(31,*) 'jmvloop,imc_rep,imc_eql,imc_acc,imc_upd='
        write(31,*)  jmvloop,imc_rep,imc_eql,imc_acc,imc_upd
        write(31,*) 'imvsequ,kmove,imove='
        write(31,*)  imvsequ,kmove,imove
        write(31,*) 'ith_rk,ith_cs=', ith_rk,ith_cs
!
!
        write(31,*) ' '
        write(31,*) 'EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
        close(31)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000113'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     kin_run0'
            write(31,*) '  '
            write(31,*) '  '
            write(31,*) 'ERROR in "kin_run0"'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) 'initial concentration value out of bounds:'
            write(31,*) 'ispec,xspec(.,0), xspec_max,xspec_min='
            write(31,*)  ispec,xspec(ispec,0)                           &
     &                  ,xspec_max(ispec),xspec_min(ispec)
            write(31,*) 'namespec(ispec)='
            write(31,2010)  namespec(ispec)
!
            write(31,*) ' '
            write(31,*) 'jmvloop,imc_rep,imc_eql,imc_acc,imc_upd='
            write(31,*)  jmvloop,imc_rep,imc_eql,imc_acc,imc_upd
            write(31,*) 'imvsequ,kmove,imove='
            write(31,*)  imvsequ,kmove,imove
            write(31,*) 'ith_rk,ith_cs=', ith_rk,ith_cs
!
            if(imvsequ.ge.1.and.jmvloop.ge.1) then
              write(31,*) 'jmty(imvsequ,jmvloop)='
              write(31,*)  jmty(imvsequ,jmvloop)
            endif
            write(31,*) ' '
            write(31,*) 'EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000114'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     upd_tifodes'
        write(31,*) '  '
        write(31,*) '  '
        write(31,*) 'ERROR in "upd_tifodes"'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*)                                                     &
     &  ' "itifal" or "itifode" exceeds array size:'
!
        write(31,*)                                                     &
     &    'itifal, ntifal_x=', itifal, ntifal_x
!
        write(31,*)                                                     &
     &    'itifode, ntifode_x=', itifode, ntifode_x
!
!
        write(31,*)                                                     &
     &  ' time_tifal(itifal) or time_tif(itifode) = tpulse_tif='
        write(31,*)                                                     &
     &    tpulse_tif
!
        if(itifal.gt.ntifode_x) then
          if(ifs.gt.nfs_spec) ifs=nfs_spec
!
          ispec=ispec_fs(ifs)
          ipulse=ipulse_tif_fs(ifs)
          mshift=mshift_tif_fs(ifs)
          tshift=mshift*tperiod(ispec)
!
          write(31,*)  '  '
          write(31,*)  ' Species:'
          write(31,*)  '   ifs,ispec=',ifs,ispec
          write(31,*)  '   namespec(ispec)='
          write(31,2010)    namespec(ispec)
!
          write(31,*)  '  '
          write(31,*)  'Pulse:'
          write(31,*)  '  ipulse, mshift, tshift='                      &
     &                ,   ipulse, mshift, tshift
        endif
!
        write(31,*) ' '
        write(31,*)                                                     &
     &    'iexpt,itime_i,itime_f,time_ib,time_fb='
        write(31,*)                                                     &
     &     iexpt,itime_i,itime_f,time_ib,time_fb
!
        write(31,*)                                                     &
     &    'iexpt,itime_i,itime_f,time_ir,time_fr='
        write(31,*)                                                     &
     &     iexpt,itime_i,itime_f,time_ir,time_fr
!
        write(31,*) ' '
        write(31,*) 'jmvloop,imc_rep,imc_eql,imc_acc,imc_upd='
        write(31,*)  jmvloop,imc_rep,imc_eql,imc_acc,imc_upd
        write(31,*) 'imvsequ,kmove,imove='
        write(31,*)  imvsequ,kmove,imove
        write(31,*) 'ith_rk,ith_cs=', ith_rk,ith_cs
!
        write(31,*) ' '
        write(31,*)                                                     &
     &  ' increase array size "ntifal_x" or "ntifode_x"'
        write(31,*)                                                     &
     &  ' in "ens.def"; then re-compile'
!
        write(31,*) 'EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
        close(31)
        close(32)
        close(33)
        close(34)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000115'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     adodes'
        write(31,*) '  '
        write(31,*) '  '
        write(31,*) 'ERROR in "adodes"'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
        write(31,*)                                                     &
     &    'ARK or BDF kin. solver integration terminated '              &
     &   ,'at time "time_fo"'
        write(31,*)                                                     &
     &    'which does not match the '                                   &
     &   ,'requested final integration time "time_fi":'
!
        write(31,*)                                                     &
     &    'iexpt,itime_f,time_fi,time_fo='
        write(31,*)                                                     &
     &     iexpt,itime_f,time_fi,time_fo
!
        write(31,*) ' '
        write(31,*)                                                     &
     &      'k_stp,nlim_drv,n_drv,k_drv,k_sto,k_bad,k_slo'              &
     &    ,',k_hlo(1),k_hlo(2)='
        write(31,*)                                                     &
     &     k_stp,nlim_drv,n_drv,k_drv,k_sto,k_bad,k_slo                 &
     &    ,k_hlo(1),k_hlo(2)
!
        write(31,*)                                                     &
     &      'k_fai,k_rdo,k_rin,k_jac'
        write(31,*)                                                     &
     &     k_fai,k_rdo,k_rin,k_jac
!
        write(31,*)                                                     &
     &      'k_ist(1)...k_ist(7)'
        write(31,*)                                                     &
     &     (k_ist(idum),idum=1,7)
!
        write(31,*) ' '
        write(31,*) 'jmvloop,imc_rep,imc_eql,imc_acc,imc_upd='
        write(31,*)  jmvloop,imc_rep,imc_eql,imc_acc,imc_upd
        write(31,*) 'imvsequ,kmove,imove='
        write(31,*)  imvsequ,kmove,imove
        write(31,*) 'ith_rk,ith_cs=', ith_rk,ith_cs
!
        write(31,*) ' '
        write(31,*)                                                     &
     &    ' hmin0_ark,hmin1_ark,hmin2_ark='
        write(31,*)                                                     &
     &      hmin0_ark,hmin1_ark,hmin2_ark
!
        write(31,*) ' '
        write(31,*)                                                     &
     &    ' may need to increase "hmin1_ark" or "hmin2_ark" '
        write(31,*)                                                     &
     &    ' by increasing "rhmin1_ark" and/or "rhmin2_ark"'             &
     &   ,' in "ens.i01" so that'
        write(31,*)                                                     &
     &    '     rhmin1_ark+rhmin2_ark >= 1.0  '
        write(31,*) ' '
        write(31,*)                                                     &
     &    ' note:'
        write(31,*)                                                     &
     &    '    hmin0_ark=hmin1_ark+hmin2_ark'
        write(31,*)                                                     &
     &    ' where'
        write(31,*)                                                     &
     &    '    hmin1_ark=dtime_ark*rhmin1_ark'
        write(31,*)                                                     &
     &    '    hmin2_ark=dtime_ark*rhmin2_ark'
        write(31,*)                                                     &
     &    '    dtime_ark=dtime/nstp_ark'
        write(31,*)                                                     &
     &    '    dtime    =(time1-time0)/ntime'
!
        write(31,*) ' '
        write(31,*) 'EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
!
        close(31)
        close(32)
        close(33)
        close(34)
        call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000116'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     kin_run1'
            write(31,*) '  '
            write(31,*) '  '
            write(31,*) 'ERROR in "kin_run1"'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) 'initial concentration value out of bounds:'
            write(31,*) 'jmvloop,imc_rep,imc_eql,imc_acc,imc_upd='
            write(31,*)  jmvloop,imc_rep,imc_eql,imc_acc,imc_upd
            write(31,*) 'imvsequ,kmove,imove='
            write(31,*)  imvsequ,kmove,imove
            write(31,*) 'ith_rk,ith_cs=', ith_rk,ith_cs
!
            if(imvsequ.ge.1.and.jmvloop.ge.1) then
              write(31,*) 'jmty(imvsequ,jmvloop)='
              write(31,*)  jmty(imvsequ,jmvloop)
            endif
            write(31,*) 'ispec,xspec(.,0), xspec_max,xspec_min='
            write(31,*)  ispec,xspec(ispec,0)                           &
     &                  ,xspec_max(ispec),xspec_min(ispec)
            write(31,*) 'EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000117'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     kin_sol_ads0xd'
            write(31,*) '  '
            write(31,*) '  '
            write(31,*) 'ERROR in "kin_run" / "kin_sol_ads0xd" :'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) 'Selected option jkrxdi,jtime=',jkrxdi,jtime
            write(31,*) 'currently not yet available for this code.'
            write(31,*)                                                 &
     &                  'In "ens.i01", set either'
            write(31,*)                                                 &
     &                  '    jkrxdi:=jtmp_kx(imvsequ,jmvloop)=0'
            write(31,*)                                                 &
     &                  ' or set'
            write(31,*)                                                 &
     &                  '    jtime=1 or jtime=2'
            write(31,*) 'EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000118'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     kin_sol_ads1xd'
            write(31,*) '  '
            write(31,*) '  '
            write(31,*) 'ERROR in "kin_run" / "kin_sol_ads1xd" :'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) 'Selected option jkrxdi,jtime=',jkrxdi,jtime
            write(31,*) 'currently not yet available for this code.'
            write(31,*)                                                 &
     &                  'In "ens.i01", set either'
            write(31,*)                                                 &
     &                  '    jkrxdi:=jtmp_kx(imvsequ,jmvloop)=0'
            write(31,*)                                                 &
     &                  ' or set'
            write(31,*)                                                 &
     &                  '    jtime=1 or jtime=2'
            write(31,*) 'EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000119'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     djacs'
            write(31,*) '  '
            write(31,*) '  '
            write(31,*) 'ERROR in "DLSODES" etc.:'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) ' call to "djacs"'
            write(31,*)                                                 &
     &      ' user-supplied subprg. "djacs" not yet implemented'
!
            write(31,*)                                                 &
     &        'iexpt,itime_i,itime_f,time_ir,time_fr='
            write(31,*)                                                 &
     &         iexpt,itime_i,itime_f,time_ir,time_fr
!
            write(31,*)                                                 &
     &      'jmvloop,imc_rep,imc_eql,imc_acc,imc_upd,kmove,imove='
            write(31,*)                                                 &
     &       jmvloop,imc_rep,imc_eql,imc_acc,imc_upd,kmove,imove
            write(31,*) 'ith_rk,ith_cs=', ith_rk,ith_cs
!
            write(31,*) 'EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            close(32)
            close(33)
            close(34)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000120'
      if(eqname(errtag,errtag_ck)) then
        ename1=' '
        ename2=' '
        ispre4=-1
!
        if(jerrtag.eq.1) then
          nspre_i=-nspec
          ispre4=ispec
          if(ierrtag.le.nspec) ename1=namespec(ierrtag)
          ename2=namespec_dtspec(idtspec,iexpt)
        endif
!
        if(jerrtag.eq.2) then
          nspre_i=nspec
          ispre4=ispec
          if(ierrtag.le.nspec) ename1=namespec(ierrtag)
          ename2=namespec_dtspec(idtspec,iexpt)
        endif
!
        if(jerrtag.eq.3) then
          nspre_i=nspec
          ispre4=ispec
          if(ierrtag.le.nspec) ename1=namespec(ierrtag)
          ename2=namespec_dtspec(idtspec,iexpt)
        endif
!
        if(jerrtag.eq.4) then
          nspre_i=nspec
          ispre4=ispec
          if(ierrtag.le.nspec) ename1=namespec(ierrtag)
          ename2=namespec_dtspec(idtspec,iexpt)
        endif
!
        if(jerrtag.eq.5) then
          nspre_i=nspec
          ispre4=ispec1
          if(ierrtag.le.nspec) ename1=namespec(ierrtag)
          ename2=namespec_dtspec(idtspec1,iexpt)
        endif
!
        if(jerrtag.eq.6) then
          nspre_i=nspec
          ispre4=ispec
          if(ierrtag.le.nspec) ename1=namespec(ierrtag)
          ename2=namespec_dtspec(idtspec,iexpt)
        endif
!
        if(jerrtag.eq.7) then
          nspre_i=nspec
          ispre4=ispec1
          if(ierrtag.le.nspec) ename1=namespec(ierrtag)
          ename2=namespec_dtspec(idtspec1,iexpt)
        endif
!
        if(jerrtag.eq.8) then
          nspre_i=nspec
          ispre4=iispec(ipart,ireac)
          if(ierrtag.le.nspec) ename1=namespec(ierrtag)
          ename2=nameispec(ipart,ireac)
        endif
!
        if(jerrtag.eq.9) then
          nspre_i=nspec
          ispre4=iospec(ipart,ireac)
          if(ierrtag.le.nspec) ename1=namespec(ierrtag)
          ename2=nameospec(ipart,ireac)
        endif
!
        if(jerrtag.eq.10) then
          nspre_i=nspre
          ispre4=ispre1
          if(ierrtag.le.nspre) ename1=namespre(ierrtag)
          ename2=name0
        endif
!
        if(jerrtag.eq.11) then
          nspre_i=nspre
          ispre4=ispre
          if(ierrtag.le.nspre) ename1=namespre(ierrtag)
          ename2=nmparn(iparn,idpen)
        endif
!
!
        if(jerrtag.eq.12) then
          nspre_i=nspre
          ispre4=ispre
          if(ierrtag.le.nspre) ename1=namespre(ierrtag)
          ename2=namespre_lo_blkth(lblkth)
        endif
!
        if(jerrtag.eq.13) then
          nspre_i=nspre
          ispre4=ispre
          if(ierrtag.le.nspre) ename1=namespre(ierrtag)
          ename2=namespre_hi_blkth(lblkth)
        endif
!
        if(jerrtag.eq.14) then
          nspre_i=nspre
          ispre4=ispre
          if(ierrtag.le.nspre) ename1=namespre(ierrtag)
          ename2=name_dconr(ldconr)
        endif
!
        if(jerrtag.eq.15) then
          nspre_i=nspre
          ispre4=ispre
          if(ierrtag.le.nspre) ename1=namespre(ierrtag)
          ename2=name_dconp(ldconp)
        endif
!
        if(jerrtag.eq.16) then
          nspre_i=nspre
          ispre4=ispre
          if(ierrtag.le.nspre) ename1=namespre(ierrtag)
          ename2=namerspec_dconfz(ldconfz)
        endif
!
        if(jerrtag.eq.17) then
          nspre_i=nspre
          ispre4=ispre
          if(ierrtag.le.nspre) ename1=namespre(ierrtag)
          ename2=namepspec_dconfz(ldconfz)
        endif
!
        nspre_ia=nspre_i
        if(nspre_i.lt.0) nspre_ia=-nspre_i
!
        if(ierrtag.eq.(nspre_ia+1)) then
          write(31,*)                                                 &
     &    'functn.  ispre4name'
          write(31,*) ' ERROR in "ispre4name":'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
          write(31,*) ' jerrtag,ierrtag,nspre_i='                     &
     &                , jerrtag,ierrtag,nspre_i
          write(31,*) ' Could not analyze following spec/reac name:'
          write(31,*) ' name2look='
          write(31,9120)   ename2
 9120     format(a80)
!!!!      write(31,*) ' ich2i,ich2f=',ich2i,ich2f
          write(31,*) ' EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
          close(31)
          call mp_stopabort
        endif
!
!
        if(ierrtag.le.nspre_ia) then
          write(31,*)                                                   &
     &    'functn.  ispre4name'
          write(31,*) ' ERROR in "ispre4name":'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
          write(31,*) ' jerrtag,ierrtag,nspre_i='                     &
     &                , jerrtag,ierrtag,nspre_i
          write(31,*) ' Could not analyze following spec/reac name:'
          write(31,*) ' ispre/spec/reac=',ispre4
          write(31,*) ' namespre/spec/reac='
          write(31,*)   ename1
!!!!      write(31,*) ' ich1i,ich1f=',ich1i,ich1f
          write(31,*) ' EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
          close(31)
          call mp_stopabort
        endif
!
!
        if(ierrtag.eq.(nspre_ia+2)) then
          write(31,*)                                                   &
     &    'functn.  ispre4name'
          write(31,*) ' ERROR in "ispre4name":'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
          write(31,*) ' jerrtag,ierrtag,nspre_i='                     &
     &                , jerrtag,ierrtag,nspre_i
          write(31,*)                                                   &
     &    ' Could not find ispec/ireac of following input name:'
          write(31,*) ' name2look='
          write(31,9120)   ename2
          write(31,*) ' ispre4name=0'
          write(31,*) '  '
          write(31,*)                                                     &
     &    ' correct this name (spelling ?) in ens.i01 and/or ens.i02'
          write(31,*)                                                     &
     &    ' to match a name from the namespec or namereac list'
          write(31,*)                                                     &
     &    ' declared in input file ens.i01'
!
          if(nspre_i.ge.0) then
            write(31,*) ' EXECUTION STOPPED'
!
            write(31,*) '   errtag='
            write(31,2010) errtag
            close(31)
            call mp_stopabort
          else
            write(31,*)                                                   &
     &      ' EXECUTION TO BE STOPPED AFTER FURTHER MESSAGES:'
!
            write(31,*) '   errtag='
            write(31,2010) errtag
            write(31,*) ' '
            close(31)
            return
          endif
        endif
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      errtag_ck='000122'
      if(eqname(errtag,errtag_ck)) then
          write(31,*)                                                   &
     &    'subrt.     svdcmp'
            write(31,*) '  '
            write(31,*) '  '
            write(31,*) 'ERROR in "svdcmp"'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
            write(31,*) ' No convergence'
            write(31,*) ' ierrtag=', ierrtag
            write(31,*) 'EXECUTION STOPPED'
!
          write(31,*) '   errtag='
          write(31,2010) errtag
            close(31)
            call mp_stopabort
      endif
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      write(31,*) 'ERROR in "err_term"'
        write(31,*)   &
     &  ' mp_myid, mp_mrid=', mp_myid, mp_mrid
      write(31,*) 'Unknown errtag='
      write(31,2010) errtag
      write(31,*) 'EXECUTION STOPPED'
!
      write(31,*) '   errtag='
      write(31,2010) errtag
 2010 format(a80)
      close(31)
      call mp_stopabort
!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ostart
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! checks/modifies for exisiting o00 output file,
! checks/modifies for exisiting stop input file,
! some array dimensioning consistency, etc.
!
      inquire(file='ens.o00',exist=fexist)
      if(fexist) then
        open(30,file='ens.o00',status='old')
      else
!BLADE:
!       open(30,file='ens.o00',status='new')
        open(30,file='ens.o00')
!:BLADE
      endif
!
      if(nset.ge.1) then
        iun=30
        call efile(iun)
      else
        rewind(30)
      endif
!
      write(30,*) 'START'
!
      close(30)
!
      inquire(file='ens.stop',exist=fexist)
      if(fexist) then
        open(99,file='ens.stop',status='old')
        rewind(99)
        write(99,*) ' DEACTIVATED '
        close(99)
      endif
!
!
      if(npmspre_x.lt.npmspec_x.or.                                     &
     & npmspre_x.lt.npmreac_x) then
        inquire(file='ens.o01',exist=fexist)
        if(fexist) then
          open(31,file='ens.o01',status='old')
        else
!BLADE:
!         open(31,file='ens.o01',status='new')
          open(31,file='ens.o01')
!:BLADE
        endif
!
        if(nset.ge.1) then
          iun=31
          call efile(iun)
        else
          rewind(31)
        endif
!
        errtag='000001'
        call err_term
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine idat
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! reads input data from "ens.i01" and
! writes them into "ens.o01"
!
      include 'ens.def'
!
      call mp_qini
!
      close(39)
      inquire(file='ens.o09',exist=fexist)
      if(fexist) then
        open(39,file='ens.o09',status='old')
        iun=39
        if(mp_myid.eq.mp_mrid) then
          rewind(39)
          write(39,*) ' '
        else
          call efile(iun)
          write(39,*) ' '
        endif
      else
!BLADE:
!       open(39,file='ens.o09',status='new')
        open(39,file='ens.o09')
        write(39,*) ' '
!:BLADE
      endif
!
      if(jdb_i01.eq.1) then
        write(39,*) ' '
        write(39,*) ' '
        write(39,*) 'ENTERING "idat" mp_myid=', mp_myid
        write(39,*) ' '
      endif
!
!
! find first/next input data set:
!
      iset=0
      jset=0
!
      open(21,file='ens.i01',status='old')
      rewind(21)
!
!
      inquire(file='ens.o01',exist=fexist)
      if(fexist) then
        open(31,file='ens.o01',status='old')
      else
!BLADE:
!       open(31,file='ens.o01',status='new')
        open(31,file='ens.o01')
!:BLADE
      endif
!
      if(nset.ge.1) then
        iun=31
        call efile(iun)
      else
        rewind(31)
      endif
!
   10 continue
      iline=0
      call cread21(bline,jiline,iline,iline_y)
      if(jiline(iline).eq.-1) goto 990
      aline=bline(iline)
!
      if(jdb_i01.eq.1) write(39,2010) aline
 2010 format(a80)
!
      if(index(aline(1:80),'data set').eq.0) goto 10
!
      iset=iset+1
      if(iset.le.nset) goto 10
!
!
! read in input parameters:
!
      nset=iset
      jset=1
      bline(0)=aline
      iline=0
!
!   MPI control parameters
!   if no. of processors, mp_nproc>1 only
!!!   if(mp_nproc.gt.1) then
        call cread21(bline,jiline,iline,iline_y)
!
        if(jdb_i01.eq.1) write(39,2010) bline(iline)
        read(21,*,err=980) jmp_task, mp_w2sv       &
     &            ,idum1,idum1,idum1,idum1,idum1   &
     &            ,idum1,idum1,idum1
!!!   endif
!
!
!   numbers of MC repetitions, equilib. seq's,
!   accum seq's, updates per accum. seq.,
!   MC random number seed, meas. powers of Theta-params.
      call cread21(bline,jiline,iline,iline_y)
!
      if(jdb_i01.eq.1) write(39,2010) bline(iline)
      if(index(bline(iline),'jrand').eq.0) then
        read(21,*,err=980) nmc_rep,jmc_eql,nmc_eql,nmc_acc,nmc_upd      &
     &            ,imc_ran,npow_spec,npow_reac
        jrand=1
        iseed2=1
      else
        read(21,*,err=980) nmc_rep,jmc_eql,nmc_eql,nmc_acc,nmc_upd      &
     &            ,imc_ran,npow_spec,npow_reac,jrand,iseed2
      endif
!
      if(nmc_rep.gt.nmc_rep_x) then
            errtag='000002'
            call err_term
      endif
!
      if(nmc_eql.gt.nmc_eql_x) then
            errtag='000003'
            call err_term
      endif
!
      if(nmc_acc.gt.nmc_acc_x) then
            errtag='000004'
            call err_term
      endif
!
      if(nmc_upd.gt.nmc_upd_x) then
            errtag='000005'
            call err_term
      endif
!
      if(npow_spec.gt.npow_spec_x) then
            errtag='000006'
            call err_term
      endif
!
      if(npow_reac.gt.npow_reac_x) then
            errtag='000007'
            call err_term
      endif
!
!   MC sampling temperature and MC initialization
      call cread21(bline,jiline,iline,iline_y)
      if(jdb_i01.eq.1) write(39,2010) bline(iline)
      read(21,*,err=980) temp_mc,htot_cut,jmc_inii,jst_ini
!
      mbase=100000
      call fdigit(jmc_inii                                              &
     &           ,mbase,jdig,nzdig,ndig_y)
      jskip12=jdig(2)
      jmc_inir=jdig(1)
!
      inquire(file='ens.o02',exist=fexist)
      if(fexist.and.                                                    &
     &.not.(jmc_inir.ge.240.and.jmc_inir.lt.250))                       &
     &jmc_inir=241
!
! Initial skip and stride for restart/rerun from "o02" or "i12"
      n0skip12=0
      nrskip12=1
      if(jskip12.gt.0) then
        call cread21(bline,jiline,iline,iline_y)
        if(jdb_i01.eq.1) write(39,2010) bline(iline)
        read(21,*,err=980) n0skip12,nrskip12                            &
     &                   , idum1,idum2,idum1,idum2                      &
     &                   , idum1,idum2
      endif
!
!   MC max. update step width factors
      call cread21(bline,jiline,iline,iline_y)
      if(jdb_i01.eq.1) write(39,2010) bline(iline)
      read(21,*,err=980) mpr_swo,jac_swo
!
!
!   MC boundary contact force parameters
      call cread21(bline,jiline,iline,iline_y)
      if(jdb_i01.eq.1) write(39,2010) bline(iline)
      read(21,*,err=980) meq_fbx,mac_fbx,nbx_time
!
      if(nbx_time.gt.nbx_time_x) then
            errtag='000008'
            call err_term
      endif
!
!
!   fict. Hamiltonian time evol. parameters:
      call cread21(bline,jiline,iline,iline_y)
      if(jdb_i01.eq.1) write(39,2010) bline(iline)
      read(21,*,err=980) gamma_ms,gamma_fx,dtfic,dderiv_th
!
      call cread21(bline,jiline,iline,iline_y)
      if(jdb_i01.eq.1) write(39,2010) bline(iline)
      read(21,*,err=980) ntfic,jbcfic,jmsfic,jdtfic,jfxfic
!
!
      if(ntfic.gt.ntfic_x) then
            errtag='000009'
            call err_term
      endif
!
!   Convg. tolerance and max. number of iteration sweeps
!   for Amoeba moves
      call cread21(bline,jiline,iline,iline_y)
      if(jdb_i01.eq.1) write(39,2010) bline(iline)
      read(21,*,err=980) tol_amb, mit_amb
!
!   MC move schedule and number of move types per seq
!   jmvloop=1: equilibr'n
!   jmvloop=2: accum
      call cread21(bline,jiline,iline,iline_y)
      if(jdb_i01.eq.1) write(39,2010) bline(iline)
      do jmvloop=1,2
!V090927:
        read(21,*,err=980)                                                &
     &  idum1,jmvsched(jmvloop),nmvsequ(jmvloop)
!
        if(nmvsequ(jmvloop).gt.nmvsequ_x) then
            errtag='000010'
            call err_term
        endif
      enddo
!
      do jmvloop=1,2
        jrpwgt(jmvloop)=0
        am_chisq_lo(jmvloop)=-1.d30
        am_chisq_hi(jmvloop)=1.d30
        temp_repav(jmvloop)=1.d30
        beta_repav(jmvloop)=1.d-30
!
        if(jmvsched(jmvloop).eq.100.and.jmvloop.eq.2) then
          call cread21(bline,jiline,iline,iline_y)
          if(jdb_i01.eq.1) write(39,2010) bline(iline)
          read(21,*,err=980)                                                &
     &     idum                                                             &
     &    ,jrpwgt(jmvloop)                                                  &
     &    ,idum                                                             &
     &    ,idum                                                             &
     &    ,idum                                                             &
     &    ,idum                                                             &
     &    ,idum                                                             &
     &    ,idum                                                             &
     &    ,idum                                                             &
     &    ,idum
        endif
        if(jmvloop.eq.2) then
          if(jrpwgt(jmvloop).eq.1.or.jrpwgt(jmvloop).eq.2) then
            call cread21(bline,jiline,iline,iline_y)
            if(jdb_i01.eq.1) write(39,2010) bline(iline)
            read(21,*,err=980)                                                &
     &       idum                                                             &
     &      ,am_chisq_lo(jmvloop)                                             &
     &      ,am_chisq_hi(jmvloop)                                             &
     &      ,temp_repav(jmvloop)                                              &
     &      ,idum                                                             &
     &      ,idum                                                             &
     &      ,idum
!
            beta_repav(jmvloop)=1.d20
            if(temp_repav(jmvloop).lt.0.d0) beta_repav(jmvloop)=-1.d20
            if(dabs(temp_repav(jmvloop)).gt.1.d-20)                           &
     &      beta_repav(jmvloop)=1.d0/temp_repav(jmvloop)
          endif
        endif
!:V090927
      enddo
!
!   MC move types by sequ and number of moves per sequ
!     jmvloop=1: equilibr'n
!     jmvloop=2: accum
      lblkth=0
      ldconr=0
      ldconp=0
      ldconfz=0
      lrasf=0
!
      do jmvloop=1,2
        do imvsequ=1,nmvsequ(jmvloop)
          call cread21(bline,jiline,iline,iline_y)
          if(jdb_i01.eq.1) write(39,2010) bline(iline)
          read(21,*,err=980)                                            &
     &                    idum1,idum2                                   &
     &              ,      jmty_mc(imvsequ,jmvloop)                     &
     &              ,        nmove(imvsequ,jmvloop)                     &
     &              ,      pmvtype(imvsequ,jmvloop)                     &
     &              ,     raccp_lo(imvsequ,jmvloop)                     &
     &              ,     raccp_hi(imvsequ,jmvloop)
!
          if(jmty_mc(imvsequ,jmvloop).eq.-100) goto 40
!
          jmty(imvsequ,jmvloop)=jmty_mc(imvsequ,jmvloop)
          if(jmty_mc(imvsequ,jmvloop).lt.0)                             &
     &    jmty(imvsequ,jmvloop)=-jmty_mc(imvsequ,jmvloop)
          mbase=1000000
          call fdigit(jmty(imvsequ,jmvloop)                             &
     &               ,mbase,jdig,nzdig,ndig_y)
          jnorep(imvsequ,jmvloop)=jdig(2)
          jmty(imvsequ,jmvloop)  =jdig(1)
!
   40     continue
          jblkth_pik(imvsequ,jmvloop)=-1
          jblkth_fmt(imvsequ,jmvloop)=-1
          jblkth_ord(imvsequ,jmvloop)=-1
          jblkth_sco(imvsequ,jmvloop)=-1
          nblkth(imvsequ,jmvloop)=-1
          jovr_bcth(imvsequ,jmvloop)=-1
          jovr_stp(imvsequ,jmvloop)=-1
          jovr_oth(imvsequ,jmvloop)=-1
!
          jrasf_pik(imvsequ,jmvloop)=-1
          jrasf_fmt(imvsequ,jmvloop)=-1
          jrasf_ctl(imvsequ,jmvloop)=-1
          nrasf(imvsequ,jmvloop)=-1
!CHG090823:
          sxplog_nlo(imvsequ,jmvloop)=1.d-20
          sxplog_nhi(imvsequ,jmvloop)=1.d+20
          sxplin_nlo(imvsequ,jmvloop)=1.d-20
          sxplin_nhi(imvsequ,jmvloop)=1.d+20
!:CHG090823
!
          lblkth_ini(imvsequ,jmvloop)=lblkth+1
          lrasf_ini(imvsequ,jmvloop)=lrasf+1
!
!        read in special move types, special MC controls
!        and/or theta move blocking params.
!
          if(jmty_mc(imvsequ,jmvloop).eq.-100) then
            call cread21(bline,jiline,iline,iline_y)
            if(jdb_i01.eq.1) write(39,2010) bline(iline)
            read(21,*,err=980)                                            &
     &                       jmty(imvsequ,jmvloop)                        &
     &                ,      jnorep(imvsequ,jmvloop)                      &
     &                ,      jblkth_pik(imvsequ,jmvloop)                  &
     &                ,      jrasf_pik(imvsequ,jmvloop)                   &
     &                ,      idum1, idum1, idum1, idum1, idum1, idum1
!
! Later:
! Use jblkth_sco>0, to define poss. scope
! of theta-blocks extending beyond current move sequence
! Use jovr_bcth>0, to override/suppress/control MC boundaries
! on blocks of theta vars. in this move sequence
! Use jovr_stp>0, to override/suppress/control MC step widths
! on blocks of theta vars. in this move sequence
! Use jovr_oth>0, to override/suppress/control ens.o02 output
! from this move sequence
!
            call cread21(bline,jiline,iline,iline_y)
            if(jdb_i01.eq.1) write(39,2010) bline(iline)
            read(21,*,err=980)                                            &
     &                       jovr_bcth(imvsequ,jmvloop)                   &
     &                ,      jovr_stp(imvsequ,jmvloop)                    &
     &                ,      jovr_oth(imvsequ,jmvloop)                    &
     &                ,      idum1, idum1, idum1, idum1, idum1, idum1, idum1
!
!
! Declare theta blocks for block-restricted MC move sequence
!
            if(jblkth_pik(imvsequ,jmvloop).eq.1) then
              call cread21(bline,jiline,iline,iline_y)
              if(jdb_i01.eq.1) write(39,2010) bline(iline)
              read(21,*,err=980)                                          &
     &                         jblkth_fmt(imvsequ,jmvloop)                &
     &                  ,      jblkth_ord(imvsequ,jmvloop)                &
     &                  ,      jblkth_sco(imvsequ,jmvloop)                &
     &                  ,      nblkth(imvsequ,jmvloop)                    &
     &                  ,      idum1, idum1, idum1, idum1, idum1, idum1
!
              if(jblkth_fmt(imvsequ,jmvloop).eq.0) then
                do iblkth=1,nblkth(imvsequ,jmvloop)
                  lblkth=lblkth+1
                  if(lblkth.gt.lblkth_x) then
                    errtag='000010.002'
                    call err_term
                  endif
!
                  call cread21(bline,jiline,iline,iline_y)
                  if(jdb_i01.eq.1) write(39,2010) bline(iline)
                  read(21,*,err=980)                                &
     &                         idum1                                &
     &                  ,      ipm_lo_blkth(lblkth)                 &
     &                  ,      ipm_hi_blkth(lblkth)                 &
     &                  ,      ipm_str_blkth(lblkth)                &
     &                  ,      jipm_str_blkth(lblkth)               &
     &                  ,      ispre_str_blkth(lblkth)              &
     &                  ,      jispre_str_blkth(lblkth)             &
     &                  ,      jbc_blkth(lblkth)                    &
     &                  ,      jstp_blkth(lblkth), idum1
!
                  call cread21(bline,jiline,iline,iline_y)
                  if(jdb_i01.eq.1) write(39,2010) bline(iline)
                  read(21,2010,err=980)                             &
     &                         namespre_lo_blkth(lblkth)
                  read(21,2010,err=980)                             &
     &                         namespre_hi_blkth(lblkth)
!
! set or override boundary conditions on theta-vars.
! in theta block
                  if(jbc_blkth(lblkth).eq.1) then
                    call cread21(bline,jiline,iline,iline_y)
                    if(jdb_i01.eq.1) write(39,2010) bline(iline)
                    read(21,*,err=980)                           &
     &                         idum1                                &
     &                       , bc_lo_blkth(lblkth)                  &
     &                       , bc_hi_blkth(lblkth)                  &
     &                       , jbc_lo_blkth(lblkth)                 &
     &                       , jbc_hi_blkth(lblkth)                 &
     &                       , idum1, idum1, idum1
                  endif
!
! set or override MC step width and step width adjustmt.
! on theta-vars. in theta block
                  if(jstp_blkth(lblkth).eq.1) then
                    call cread21(bline,jiline,iline,iline_y)
                    if(jdb_i01.eq.1) write(39,2010) bline(iline)
                    read(21,*,err=980)                                &
     &                         idum1                                     &
     &                       , fstp_wid_blkth(lblkth)                    &
     &                       , jstp_wid_blkth(lblkth)                    &
     &                       , idum1, idum1, idum1, idum1, idum1, idum1
                  endif
                enddo
              endif
            endif
!
! Declare SF blocks for SF Gaussian randomization
!
            if(jrasf_pik(imvsequ,jmvloop).eq.1) then
              call cread21(bline,jiline,iline,iline_y)
              if(jdb_i01.eq.1) write(39,2010) bline(iline)
              read(21,*,err=980)                                         &
     &                         jrasf_ctl(imvsequ,jmvloop)                &
     &                  ,      jrasf_fmt(imvsequ,jmvloop)                &
     &                  ,      nrasf(imvsequ,jmvloop)                    &
     &                  ,      jrasf_xch(imvsequ,jmvloop)                &
     &                  ,      idum1, idum1, idum1, idum1                &
     &                  ,      idum1, idum1
!
              call cread21(bline,jiline,iline,iline_y)
              if(jdb_i01.eq.1) write(39,2010) bline(iline)
              read(21,*,err=980)                                         &
     &                         sxplog_nlo(imvsequ,jmvloop)               &
     &                  ,      sxplog_nhi(imvsequ,jmvloop)               &
     &                  ,      sxplin_nlo(imvsequ,jmvloop)               &
     &                  ,      sxplin_nhi(imvsequ,jmvloop)               &
     &                  ,      idum1, idum1
!
              if(                                                             &
     &        sxplog_nlo(imvsequ,jmvloop).le.0.d0                        .or. &
     &        sxplog_nlo(imvsequ,jmvloop).ge.sxplog_nhi(imvsequ,jmvloop) .or. &
     &        sxplin_nlo(imvsequ,jmvloop).le.0.d0                        .or. &
     &        sxplin_nlo(imvsequ,jmvloop).ge.sxplin_nhi(imvsequ,jmvloop)      &
     &        )then
                errtag='000010.003'
                call err_term
              endif
!
              if(jrasf_fmt(imvsequ,jmvloop).eq.0) then
                errtag='000010.002.000: jrasf_fmt>=0 NOT YET IMPLEMENTED'
                call err_term
!
                do irasf=1,nrasf(imvsequ,jmvloop)
                  lrasf=lrasf+1
                  if(lrasf.gt.lrasf_x) then
                    errtag='000010.004'
                  call err_term
                  endif
!
                  call cread21(bline,jiline,iline,iline_y)
                  if(jdb_i01.eq.1) write(39,2010) bline(iline)
                  read(21,*,err=980)                                     &
     &                         idum1                                     &
     &                  ,      lscalin_rasf(lrasf)                       &
     &                  ,      lscalog_rasf(lrasf)                       &
     &                  ,      ipm_rasf(lrasf)                           &
     &                  ,      idum1, idum1, idum1, idum1                &
     &                  ,      idum1, idum1
!
                  read(21,2010,err=980)                          &
     &            namespre_rasf(lrasf)
                enddo
              endif
            endif
          endif
          lblkth_fin(imvsequ,jmvloop)=lblkth
          lrasf_fin(imvsequ,jmvloop)=lrasf
!
!         read in special deconvolution Gibbs sampler move parameters
!
          ldconr_ini(imvsequ,jmvloop)=ldconr+1
          ldconp_ini(imvsequ,jmvloop)=ldconp+1
          ldconfz_ini(imvsequ,jmvloop)=ldconfz+1
!
          jmty_ampdc(imvsequ,jmvloop)=-1
          jdcrspec_pik(imvsequ,jmvloop)=-1
          jdcpspec_pik(imvsequ,jmvloop)=-1
          jdcfz_pik(imvsequ,jmvloop)=-1
          ndcsweep(imvsequ,jmvloop)=0
!V090912:`
          jdcckev(imvsequ,jmvloop)=0
!:V090912
!
          stpdcon(imvsequ,jmvloop)=-1.d0
          bcdcon(imvsequ,jmvloop)=-1.d0
!
          jdcon_stp(imvsequ,jmvloop)=-1
          jdcon_bc(imvsequ,jmvloop)=-1
!
          mdconr(imvsequ,jmvloop)=-1
          jdcrspec_fmt(imvsequ,jmvloop)=-1
          mdconp(imvsequ,jmvloop)=-1
          jdcpspec_fmt(imvsequ,jmvloop)=-1
          jdcpspec_sum(imvsequ,jmvloop)=-1
          mdconfz(imvsequ,jmvloop)=-1
          jdcfz_fmt(imvsequ,jmvloop)=-1
!
          if(jmty(imvsequ,jmvloop).eq.20)then
            call cread21(bline,jiline,iline,iline_y)
            if(jdb_i01.eq.1) write(39,2010) bline(iline)
            read(21,*,err=980)                                            &
     &                  jmty_ampdc(imvsequ,jmvloop)                       &
     &                , jdcrspec_pik(imvsequ,jmvloop)                     &
     &                , jdcpspec_pik(imvsequ,jmvloop)                     &
     &                , jdcfz_pik(imvsequ,jmvloop)                        &
     &                , ndcsweep(imvsequ,jmvloop)                         &
!V090912:`
     &                , jdcckev(imvsequ,jmvloop)                          &
     &                , idum1, idum1, idum1, idum1
!:V090912
!
              call cread21(bline,jiline,iline,iline_y)
              if(jdb_i01.eq.1) write(39,2010) bline(iline)
              read(21,*,err=980)                               &
     &                   stpdcon(imvsequ,jmvloop)              &
     &                 , bcdcon(imvsequ,jmvloop)               &
     &                 , jdcon_stp(imvsequ,jmvloop)            &
     &                 , jdcon_bc(imvsequ,jmvloop)             &
     &                 , idum1, idum1, idum1, idum1
!
            if(jdcrspec_pik(imvsequ,jmvloop).eq.1) then
              call cread21(bline,jiline,iline,iline_y)
              if(jdb_i01.eq.1) write(39,2010) bline(iline)
              read(21,*,err=980)                                    &
     &                   mdconr(imvsequ,jmvloop)               &
     &                 , jdcrspec_fmt(imvsequ,jmvloop)              &
     &                 , idum1, idum1, idum1, idum1, idum1, idum1   &
     &                 , idum1, idum1
              if(mdconr(imvsequ,jmvloop).gt.mdconr_x) then
                errtag='000013.002'
                call err_term
              endif
!
              if(jdcrspec_fmt(imvsequ,jmvloop).eq.0) then
                call cread21(bline,jiline,iline,iline_y)
                if(jdb_i01.eq.1) write(39,2010) bline(iline)
!
                do idcon=1,mdconr(imvsequ,jmvloop)
                  ldconr=ldconr+1
                  if(ldconr.gt.ldconr_x) then
                    errtag='000013.003'
                    call err_term
                  endif
                  read(21,2010,err=980)                          &
     &            name_dconr(ldconr)
                enddo
              endif
            endif
!
            if(jdcpspec_pik(imvsequ,jmvloop).eq.1) then
              call cread21(bline,jiline,iline,iline_y)
              if(jdb_i01.eq.1) write(39,2010) bline(iline)
              read(21,*,err=980)                                    &
     &                   mdconp(imvsequ,jmvloop)               &
     &                 , jdcpspec_fmt(imvsequ,jmvloop)              &
     &                 , jdcpspec_sum(imvsequ,jmvloop)              &
     &                 , idum1, idum1, idum1, idum1, idum1, idum1, idum1
              if(mdconp(imvsequ,jmvloop).gt.mdconp_x) then
                errtag='000013.004'
                call err_term
              endif
!
              if(jdcpspec_fmt(imvsequ,jmvloop).eq.0) then
                call cread21(bline,jiline,iline,iline_y)
                if(jdb_i01.eq.1) write(39,2010) bline(iline)
!
                do idcon=1,mdconp(imvsequ,jmvloop)
                  ldconp=ldconp+1
                  if(ldconp.gt.ldconp_x) then
                    errtag='000013.005'
                    call err_term
                  endif
                  read(21,2010,err=980)                                   &
     &            name_dconp(ldconp)
                enddo
              endif
            endif
!
            if(jdcfz_pik(imvsequ,jmvloop).eq.1) then
              call cread21(bline,jiline,iline,iline_y)
              if(jdb_i01.eq.1) write(39,2010) bline(iline)
              read(21,*,err=980)                                     &
     &              mdconfz(imvsequ,jmvloop)                        &
     &        ,     jdcfz_fmt(imvsequ,jmvloop)                       &
     &        ,     idum1, idum1, idum1, idum1, idum1, idum1, idum1, idum1
              if(mdconfz(imvsequ,jmvloop).gt.mdconfz_x) then
                errtag='000013.006'
                call err_term
              endif
!
!
              if(jdcfz_fmt(imvsequ,jmvloop).eq.0) then
                do idcon=1,mdconfz(imvsequ,jmvloop)
                  ldconfz=ldconfz+1
                  if(ldconfz.gt.ldconfz_x) then
                    errtag='000013.007'
                    call err_term
                  endif
!
                  call cread21(bline,jiline,iline,iline_y)
                  if(jdb_i01.eq.1) write(39,2010) bline(iline)
                  read(21,2010,err=980)                                   &
     &            namerspec_dconfz(ldconfz)
                  read(21,2010,err=980)                                   &
     &            namepspec_dconfz(ldconfz)
                enddo
              endif
            endif
          endif
!
          ldconr_fin(imvsequ,jmvloop)=ldconr
          ldconp_fin(imvsequ,jmvloop)=ldconp
          ldconfz_fin(imvsequ,jmvloop)=ldconfz
!
          call cread21(bline,jiline,iline,iline_y)
          if(jdb_i01.eq.1) write(39,2010) bline(iline)
          read(21,*,err=980)                                            &
     &               jtmp_mc(imvsequ,jmvloop)                           &
     &              ,jstp_mc(imvsequ,jmvloop)                           &
     &              ,jwgt_mc(imvsequ,jmvloop)                           &
     &              ,npwgt(0,imvsequ,jmvloop)                           &
     &              ,ftmp_mc(imvsequ,jmvloop)                           &
     &              ,fstp_mc(imvsequ,jmvloop)
!
          if(nmove(imvsequ,jmvloop).gt.nmove_x) then
            errtag='000011'
            call err_term
          endif
!
          if(npwgt(0,imvsequ,jmvloop).gt.npwgt_x) then
            errtag='000012'
            call err_term
          endif
!
          mbase=100
          call fdigit(jtmp_mc(imvsequ,jmvloop),mbase,jdig,nzdig,ndig_y)
          jtmp_sx(imvsequ,jmvloop)=jdig(4)
          jtmp_kx(imvsequ,jmvloop)=jdig(3)
          jtmp_en(imvsequ,jmvloop)=jdig(2)
          jtmp_mv(imvsequ,jmvloop)=jdig(1)
!
          mbase=100
          call fdigit(jwgt_mc(imvsequ,jmvloop),mbase,jdig,nzdig,ndig_y)
          jwgt_wc(imvsequ,jmvloop)=jdig(4)
          jwgt_sh(imvsequ,jmvloop)=jdig(3)
          jwgt_tv(imvsequ,jmvloop)=jdig(2)
          jwgt_mv(imvsequ,jmvloop)=jdig(1)
!
          call cread21(bline,jiline,iline,iline_y)
          if(jdb_i01.eq.1) write(39,2010) bline(iline)
          if(npwgt(0,imvsequ,jmvloop).gt.0) then
            read(21,*,err=980)                                          &
     &      (pwgt_mc(lpwgt,imvsequ,jmvloop)                             &
     &      ,lpwgt=1,npwgt(0,imvsequ,jmvloop))
          endif
!
!
! First, re-weight all exptl. data points by
! exptl.-time- (itxpt-) dependent factor "fwgt_txpz" with
! trapezoidal exptl.-time dependence calculated from
! the "npwgt(0,.)", trapezoidal parameter values "pwgt_mc",
! and "jwgt_tv", "jwgt_sh", as listed above.
!
! Then, if jwgt_wc=1, multiply each data point weight (DPW)
! by additional reweighting factors "fwgt_wc" for reweighting
! reweighting classes, defined as follows:
!
! a) read in, as lpwgt-list defined below, npwgt(1,.) values
!    of "reweighting class" comprising address vector range
!       (itxpt_wc0,ims_wc0,iexpt_wc0)
!     --(itxpt_wc1,ims_wc1,iexpt_wc1)
!    and corresp. weight factor values
!       fwgt_wc := pwgt_mc(lpwgt,.),
!    stored in pwgt_mc(lpwgt,.);
! b) for all unlisted values of (itxpt,ispec,iexpt), automatically
!       fwgt_wc = 1.d0;
! c) for all listed values (itxpt_wc1,ims_wc1,iexpt_wc1) with...
!    ...itxpt_wc1(lpwgt)=-1:
!      the reweighting class includes all
!        itxpt=1,...ntxpt
!    ...ims_wc1(lpwgt)=-1:
!      the reweighting class includes all
!        ims=1,...nms_spec
!    ...iexpt_wc1(lpwgt)=-1:
!      the reweighting class includes all
!        iexpt=1,...nexpt
! d) for each class delimted by
!       (itxpt_wc0,ims_wc1,iexpt_wc0)
!     --(itxpt_wc1,ims_wc1,iexpt_wc1)
!    multiply the DPW of all data pts. in that class with fwgt_wc
!
          npwgt(1,imvsequ,jmvloop)=0
!
          if(jwgt_wc(imvsequ,jmvloop).gt.0) then
            call cread21(bline,jiline,iline,iline_y)
            if(jdb_i01.eq.1) write(39,2010) bline(iline)
            read(21,*,err=980)                                          &
     &       npwgt(1,imvsequ,jmvloop)                                   &
     &      ,idum,idum,idum                                             &
     &      ,idum,idum,idum                                             &
     &      ,idum,idum,idum
          endif
!
          npwgt_tot=npwgt(0,imvsequ,jmvloop)                            &
     &             +npwgt(1,imvsequ,jmvloop)
!
          if(npwgt_tot.gt.npwgt_x) then
            errtag='000013.000'
            call err_term
          endif
!
          if(npwgt(1,imvsequ,jmvloop).gt.0) then
            call cread21(bline,jiline,iline,iline_y)
            if(jdb_i01.eq.1) write(39,2010) bline(iline)
!
            lpwgt=npwgt(0,imvsequ,jmvloop)
            do ipwgt=1,npwgt(1,imvsequ,jmvloop)
              lpwgt=lpwgt+1
!
              read(21,*,err=980)                                        &
     &         iexpt_wc0(lpwgt,imvsequ,jmvloop)                         &
     &        ,iexpt_wc1(lpwgt,imvsequ,jmvloop)                         &
     &        ,  ims_wc0(lpwgt,imvsequ,jmvloop)                         &
     &        ,  ims_wc1(lpwgt,imvsequ,jmvloop)                         &
     &        ,itxpt_wc0(lpwgt,imvsequ,jmvloop)                         &
     &        ,itxpt_wc1(lpwgt,imvsequ,jmvloop)                         &
     &        ,  pwgt_mc(lpwgt,imvsequ,jmvloop)
            enddo
          endif
!
          call cread21(bline,jiline,iline,iline_y)
          if(jdb_i01.eq.1) write(39,2010) bline(iline)
          read(21,*,err=980)                                            &
     &                 jbxx_mc(imvsequ,jmvloop)                         &
     &              ,  fbxx_mc(imvsequ,jmvloop)                         &
     &              ,bxx_lo_mc(imvsequ,jmvloop)                         &
     &              ,bxx_hi_mc(imvsequ,jmvloop)
!
          mbase=100
          call fdigit(jbxx_mc(imvsequ,jmvloop),mbase,jdig,nzdig,ndig_y)
          jbxx_qb(imvsequ,jmvloop)=jdig(4)
          jbxx_af(imvsequ,jmvloop)=jdig(3)
          jbxx_nf(imvsequ,jmvloop)=jdig(2)
          jbxx_mv(imvsequ,jmvloop)=jdig(1)
!
!
          call cread21(bline,jiline,iline,iline_y)
          if(jdb_i01.eq.1) write(39,2010) bline(iline)
          read(21,*,err=980)                                            &
     &                qqbxx_mc(imvsequ,jmvloop)                         &
     &           ,   redbxx_mc(imvsequ,jmvloop)                         &
     &           ,afbxx_max_mc(imvsequ,jmvloop)
!
          call cread21(bline,jiline,iline,iline_y)
          if(jdb_i01.eq.1) write(39,2010) bline(iline)
          read(21,*,err=980)                                            &
     &                 jbxn_mc(imvsequ,jmvloop)                         &
     &              ,  fbxn_mc(imvsequ,jmvloop)                         &
     &              ,bxn_lo_mc(imvsequ,jmvloop)                         &
     &              ,bxn_hi_mc(imvsequ,jmvloop)
!
          mbase=100
          call fdigit(jbxn_mc(imvsequ,jmvloop),mbase,jdig,nzdig,ndig_y)
          jbxn_qb(imvsequ,jmvloop)=jdig(4)
          jbxn_af(imvsequ,jmvloop)=jdig(3)
          jbxn_nf(imvsequ,jmvloop)=jdig(2)
          jbxn_mv(imvsequ,jmvloop)=jdig(1)
!
          call cread21(bline,jiline,iline,iline_y)
          if(jdb_i01.eq.1) write(39,2010) bline(iline)
          read(21,*,err=980)                                            &
     &                qqbxn_mc(imvsequ,jmvloop)                         &
     &           ,   redbxn_mc(imvsequ,jmvloop)                         &
     &           ,afbxn_max_mc(imvsequ,jmvloop)
!
          call cread21(bline,jiline,iline,iline_y)
          if(jdb_i01.eq.1) write(39,2010) bline(iline)
          read(21,*,err=980)                                            &
     &                jsft_mc(imvsequ,jmvloop)                          &
     &           ,   ffour_mc(imvsequ,jmvloop)                          &
     &           ,   efour_mc(imvsequ,jmvloop)                          &
     &           ,   cfour_mc(imvsequ,jmvloop)
!
          mbase=100
          call fdigit(jsft_mc(imvsequ,jmvloop),mbase,jdig,nzdig,ndig_y)
!V090911:
!DEACTIVATED
!R        jsft_xd(imvsequ,jmvloop)=jdig(5)
!:V090911
          jsft_wf(imvsequ,jmvloop)=jdig(4)
          jsft_pf(imvsequ,jmvloop)=jdig(3)
          jsft_ln(imvsequ,jmvloop)=jdig(2)
          jsft_mv(imvsequ,jmvloop)=jdig(1)
!
!
          if(                                                           &
     &    jmty(imvsequ,jmvloop).ge.1000.and.                            &
     &    jmty(imvsequ,jmvloop).le.2999                                 &
     &    )then
            call cread21(bline,jiline,iline,iline_y)
            if(jdb_i01.eq.1) write(39,2010) bline(iline)
            read(21,*,err=980)                                          &
     &                 jini_st(imvsequ,jmvloop)                         &
     &                ,jtmp_st(imvsequ,jmvloop)                         &
     &                ,jxc1_st(imvsequ,jmvloop)                         &
     &                ,jxc2_st(imvsequ,jmvloop)                         &
     &                ,jmthy_st(imvsequ,jmvloop)                        &
     &                ,jrthy_st(imvsequ,jmvloop)                        &
     &                ,jxthy_st(imvsequ,jmvloop)                        &
     &                ,mfox_st(imvsequ,jmvloop)                         &
     &                ,npop_st(imvsequ,jmvloop)                         &
     &                ,npar_st(imvsequ,jmvloop)
!
            call cread21(bline,jiline,iline,iline_y)
            if(jdb_i01.eq.1) write(39,2010) bline(iline)
            read(21,*,err=980)                                          &
     &                 temp_st(imvsequ,jmvloop)                         &
     &                ,althy_st(imvsequ,jmvloop)                        &
     &                ,estp_st(imvsequ,jmvloop)                         &
     &                ,amthy_st(imvsequ,jmvloop)                        &
     &                ,bmthy_st(imvsequ,jmvloop)
!
            if(                                                         &
     &      npop_st(imvsequ,jmvloop).gt.npopst_x.or.                    &
     &      npop_st(imvsequ,jmvloop).gt.nthr_x.or.                      &
     &      npar_st(imvsequ,jmvloop).gt.nparst_x                        &
     &      )then
              errtag='000014'
              call err_term
            endif
          endif
!
          if(                                                           &
     &    jmty(imvsequ,jmvloop).ge.3000.and.                            &
     &    jmty(imvsequ,jmvloop).le.4999                                 &
     &    )then
            call cread21(bline,jiline,iline,iline_y)
            if(jdb_i01.eq.1) write(39,2010) bline(iline)
            read(21,*,err=980)                                          &
     &                 jini_ge(imvsequ,jmvloop)                         &
     &                ,jtmp_ge(imvsequ,jmvloop)                         &
     &                ,jfsu_ge(imvsequ,jmvloop)                         &
     &                ,jnsu_ge(imvsequ,jmvloop)                         &
     &                ,jbsu_ge(imvsequ,jmvloop)                         &
     &                ,jrsu_ge(imvsequ,jmvloop)                         &
     &                ,jxsu_ge(imvsequ,jmvloop)                         &
     &                ,jysu_ge(imvsequ,jmvloop)                         &
     &                ,npop_ge(imvsequ,jmvloop)                         &
     &                ,npar_ge(imvsequ,jmvloop)
!
            call cread21(bline,jiline,iline,iline_y)
            if(jdb_i01.eq.1) write(39,2010) bline(iline)
            read(21,*,err=980)                                          &
     &                 temp_ge(imvsequ,jmvloop)                         &
     &                ,ansur_ge(imvsequ,jmvloop)                        &
     &                ,bnsur_ge(imvsequ,jmvloop)                        &
     &                ,cnsur_ge(imvsequ,jmvloop)                        &
     &                ,dnsur_ge(imvsequ,jmvloop)
!
!
            if(                                                         &
     &      npop_ge(imvsequ,jmvloop).gt.npopst_x.or.                    &
     &      npop_ge(imvsequ,jmvloop).gt.npopge_x.or.                    &
     &      npop_ge(imvsequ,jmvloop).gt.nthr_x.or.                      &
     &      npar_ge(imvsequ,jmvloop).gt.nparge_x                        &
     &      )then
              errtag='000015'
              call err_term
            endif
          endif
        enddo
      enddo
      lblkth_tot=lblkth
      lrasf_tot=lrasf
      ldconr_tot=ldconr
      ldconp_tot=ldconp
      ldconfz_tot=ldconfz
!
!   DOS sampling and Wang-Landau parameters
      call cread21(bline,jiline,iline,iline_y)
      if(jdb_i01.eq.1) write(39,2010) bline(iline)
      read(21,*,err=980) alnf_dos0,alnf_dos1,pf_dos,ck_his
!
      call cread21(bline,jiline,iline,iline_y)
      if(jdb_i01.eq.1) write(39,2010) bline(iline)
      read(21,*,err=980) nit_dos,nck_dos,no_dos                         &
     &          ,jnm_dos,jck_his,jbc_dos,ngintv
!
      call cread21(bline,jiline,iline,iline_y)
      if(jdb_i01.eq.1) write(39,2010) bline(iline)
      do igintv=0,ngintv
        read(21,*,err=980)                                              &
     &  idum,mgintv(igintv),jdv_ig(igintv),enrg_ig(igintv)
      enddo
!
!   number of species and reactions:
      call cread21(bline,jiline,iline,iline_y)
      if(jdb_i01.eq.1) write(39,2010) bline(iline)
      read(21,*,err=980) nexpt, jxpt, ntxpt_inp                         &
     &         , ixpt_ran, nspec, nreac
!
!
      ntxpt=ntxpt_inp
      if(jxpt.ge.0.and.jxpt.lt.100) ntxpt=0
!
      if(nexpt.gt.nexpt_x) then
            errtag='000016'
            call err_term
      endif
!
      if(ntxpt.gt.ntxpt_x) then
            errtag='000017'
            call err_term
      endif
!
      if(nspec.gt.nspec_x) then
            errtag='000018'
            call err_term
      endif
!
      if(nreac.gt.nreac_x) then
            errtag='000019'
            call err_term
      endif
!
!   MC sampling temperature,
!   virt. expt. Gaussian width-of-log-conc. parameters
      call cread21(bline,jiline,iline,iline_y)
      if(jdb_i01.eq.1) write(39,2010) bline(iline)
      read(21,*,err=980) glob_scal, widlog_spec, fdtxdi
!
      jwidxpt=1
      if(widlog_spec.lt.0) jwidxpt=0
!
      if(glob_scal.lt.0.d0) then
            errtag='000020'
            call err_term
      endif
!
!   initial + final time, number of kin. solver time steps,
!   time integrtn. option
      call cread21(bline,jiline,iline,iline_y)
      if(jdb_i01.eq.1) write(39,2010) bline(iline)
      read(21,*,err=980) time0, time1, ntime, ntskip, jtime, jrlim
!
      if(ntime.gt.ntime_x) then
            errtag='000021'
            call err_term
      endif
!
!   Adaptive Runge Kutta (ARK) and ABD kin. solver parameters
!
!DRLIM190524-2244:
      call cread21(bline,jiline,iline,iline_y)
      if(jdb_i01.eq.1) write(39,2010) bline(iline)
!X    read(21,*,err=980) eps_ark,dtime_rl,nstp_ark, jsto_ark
      read(21,*,err=980) eps_ark,dtime_rl,nlim_all, jsto_ark
!
      if(nlim_all.gt.0) then
        nlim_drv=-1
        nstp_ark=nlim_all
      endif
!
      if(nlim_all.eq.-1) then
        call cread21(bline,jiline,iline,iline_y)
        if(jdb_i01.eq.1) write(39,2010) bline(iline)
        read(21,*,err=980) nstp_ark, nlim_drv, idum1, idum1, idum1, idum1, idum1, idum1
      endif
!:DRLIM190524-2244
!
      if(nstp_ark.gt.nstp_ark_x) then
        errtag='000022'
        call err_term
      endif
!
      call cread21(bline,jiline,iline,iline_y)
      if(jdb_i01.eq.1) write(39,2010) bline(iline)
      read(21,*,err=980) rdtsto_ark,rhini_ark                         &
     &          ,rhmin1_ark,rhmin2_ark
!
!
!   expt'l. observation time points
      call cread21(bline,jiline,iline,iline_y)
      if(jdb_i01.eq.1) write(39,2010) bline(iline)
!
      do itxpt=1,ntxpt
        read(21,*,err=980) idum1,time_xpt(itxpt)
      enddo
!
!   Fourier filtering time segments and frequencies
      do iexpt=1,nexpt
        call cread21(bline,jiline,iline,iline_y)
        if(jdb_i01.eq.1) write(39,2010) bline(iline)
!
        read(21,*,err=980) idum1,nsegft(iexpt)
!
        if(idum1.ge.9999999) goto 190
!
        if(nsegft(iexpt).gt.nsegft_x) then
            errtag='000023'
            call err_term
        endif
!
!
        do isegft=1,nsegft(iexpt)
          call cread21(bline,jiline,iline,iline_y)
          if(jdb_i01.eq.1) write(39,2010) bline(iline)
!
          read(21,*,err=980) idum1                                      &
     &              ,time_fti(isegft,iexpt)                             &
     &              ,time_ftf(isegft,iexpt)                             &
     &              ,nft_time(isegft,iexpt)                             &
     &              ,nfil_frq(isegft,iexpt)
!
!
          if(nft_time(isegft,iexpt).gt.nft_time_x) then
            errtag='000024'
            call err_term
          endif
!
          if(nfil_frq(isegft,iexpt).gt.nfil_frq_x) then
            errtag='000025'
            call err_term
          endif
!
          idum2=1
          lft_time(isegft,iexpt)=0
            if(nft_time(isegft,iexpt).le.0) then
            lft_time(isegft,iexpt)=-1
            goto 120
          endif
          do idum1=1,1000
            idum2=idum2*2
            lft_time(isegft,iexpt)=lft_time(isegft,iexpt)+1
            if(idum2.eq.nft_time(isegft,iexpt)) goto 120
            if(idum2.gt.nft_time(isegft,iexpt)) then
              errtag='000026'
              call err_term
            endif
          enddo
  120     continue
!
          call cread21(bline,jiline,iline,iline_y)
          if(jdb_i01.eq.1) write(39,2010) bline(iline)
!
          read(21,*,err=980)                                            &
     &               bfil_frq(isegft,iexpt)                             &
     &              ,cfil_frq(isegft,iexpt)                             &
     &              ,jfil_frq(isegft,iexpt)                             &
     &              ,nsho_frq(isegft,iexpt)
!
          if(nsho_frq(isegft,iexpt).gt.nsho_frq_x) then
            errtag='000027'
            call err_term
          endif
!
!
          call cread21(bline,jiline,iline,iline_y)
          if(jdb_i01.eq.1) write(39,2010) bline(iline)
!
          read(21,*,err=980) (ift_freq_fil(ifil_frq,isegft,iexpt)       &
     &               ,ifil_frq=1,nfil_frq(isegft,iexpt))
!
!
          call cread21(bline,jiline,iline,iline_y)
          if(jdb_i01.eq.1) write(39,2010) bline(iline)
!
          read(21,*,err=980) (ift_freq_sho(isho_frq,isegft,iexpt)       &
     &               ,isho_frq=1,nsho_frq(isegft,iexpt))
        enddo
      enddo
!
      goto 192
  190 continue
      do iexpt=1,nexpt
        nsegft(iexpt)=-idum1
      enddo
  192 continue
!
!
!   output control parameters
      call cread21(bline,jiline,iline,iline_y)
      if(jdb_i01.eq.1) write(39,2010) bline(iline)
!
      read(21,*,err=980)                                                &
     &           jo_ar,jo_xspec                                         &
     &          ,jo_th,jo_th_opt1,jo_th_opt2
!
      mbase=10
      call fdigit(jo_xspec,mbase,jdig,nzdig,ndig_y)
      jo_sxt=jdig(4)
      jo_cfi=jdig(3)
      jo_xdi=jdig(2)
      jo_xko=jdig(1)
!
      mbase=10
      call fdigit(jo_th_opt1,mbase,jdig,nzdig,ndig_y)
      jo_th_mvs=jdig(9)
      jo_th_xo =jdig(8)
      jo_th_wg =jdig(7)
      jo_th_cu =jdig(6)
      jo_th_sw =jdig(5)
      jo_th_bxx=jdig(4)
      jo_th_bxn=jdig(3)
      jo_th_ft =jdig(2)
      jo_th_hto=jdig(1)
!
      mbase=10
      call fdigit(jo_th_opt2,mbase,jdig,nzdig,ndig_y)
!
!DRLIM190524-2244: jo_th_lmdrv==1 -> Enable lim-drv output by ith
      jo_th_lmdrv=jdig(5)
!CHG190516-1747: Enable ODE solver stats output for all iout_th blocks w/ jo_th_mchi==1.
      jo_th_mchi=jdig(4)
!:CHG190516-1747
      jo_th_dprec=jdig(3)
      jo_th_mine=jdig(2)
      jo_th_ark=jdig(1)
!:DRLIM190524-2244
!
!
!
!   names and initial-/fixed-conc. parameters of reacting species:
!
!     zero dependent parameter counter
      idpen=0
      idokin=0
!
      kdpen_spre(0)=0
!
      do ispec=1,nspec
        ispre=ispec
        kdpen_spre(ispre)=kdpen_spre(ispre-1)
!
        call cread21(bline,jiline,iline,iline_y)
        if(jdb_i01.eq.1) write(39,2010) bline(iline)
!
        read(21,2110) namespec(ispec)
        if(jdb_i01.eq.1) write(39,2110) namespec(ispec)
 2110   format(a80)
        read(21,*,err=980)                                              &
     &             jpmspec(ispec)                                       &
     &            ,mpulse(ispec)                                        &
     &            ,nperiod(ispec)                                       &
     &            ,jmsspec(ispec)                                       &
     &            ,xspec_min(ispec)                                     &
     &            ,xspec_max(ispec)
!
        mbase=10000
        call fdigit_abs(mpulse(ispec),mbase,jdig,nzdig,ndig_y)
        jfox(ispec)=jdig(2)
        npulse(ispec)=jdig(1)
!
        mbase=10
        call fdigit(jmsspec(ispec),mbase,jdig,nzdig,ndig_y)
        jmsspec_ft(ispec)=jdig(4)
        jmsspec_px(ispec)=jdig(3)
        jmsspec_ip(ispec)=jdig(2)
        jmsspec_ch(ispec)=jdig(1)
!
        if(jmsspec_px(ispec).ge.1) then
          if(                                                           &
     &    (                                                             &
     &    jmsspec_ch(ispec).eq.1.and.                                   &
     &    jmsspec_ip(ispec).ne.1                                        &
     &    )                                                             &
     &    .or.                                                          &
     &    (                                                             &
     &    jmsspec_ch(ispec).eq.2.and.                                   &
     &    jmsspec_ip(ispec).ne.0.and.                                   &
     &    jmsspec_ip(ispec).ne.2                                        &
     &    )                                                             &
     &    )then
            errtag='000028'
            call err_term
          endif
        endif
!
!
        mbase=10000
        call fdigit_abs(jpmspec(ispec),mbase,jdig,nzdig,ndig_y)
        npxspec(ispec)=jdig(2)
        jfix(ispec)=jdig(1)
!
        if(jpmspec(ispec).lt.0) jfix(ispec)=-jfix(ispec)
!
!
        npmspec(ispec)=0
        if(jfix(ispec).lt.0)    npmspec(ispec)=1
        if(jfix(ispec).eq.0)    npmspec(ispec)=1
        if(jfix(ispec).eq.1)    npmspec(ispec)=1
        if(jfix(ispec).eq.10)   npmspec(ispec)=2*npulse(ispec)+2
        if(jfix(ispec).eq.11)   npmspec(ispec)=2*npulse(ispec)+2
        if(jfix(ispec).eq.5010) npmspec(ispec)=2*npulse(ispec)+2
        if(jfix(ispec).eq.5011) npmspec(ispec)=2*npulse(ispec)+2
        if(jfix(ispec).eq.20)   npmspec(ispec)=2*npulse(ispec)+2
        if(jfix(ispec).eq.21)   npmspec(ispec)=2*npulse(ispec)+2
        if(jfix(ispec).eq.5020) npmspec(ispec)=2*npulse(ispec)+2
        if(jfix(ispec).eq.5021) npmspec(ispec)=2*npulse(ispec)+2
!V090831:
        if(jfix(ispec).eq.30)   npmspec(ispec)=3*npulse(ispec)
        if(jfix(ispec).eq.31)   npmspec(ispec)=3*npulse(ispec)+2
        if(jfix(ispec).eq.5030) npmspec(ispec)=3*npulse(ispec)
        if(jfix(ispec).eq.5031) npmspec(ispec)=3*npulse(ispec)+2
!:V090831
!
        npmspec(ispec)=npmspec(ispec)+npxspec(ispec)
!
        if(npmspec(ispec).gt.npmspec_x.or.                              &
     &   npmspec(ispec).gt.npmspre_x) then
            errtag='000029'
            call err_term
        endif
!
        if(jmsspec_ft(ispec).eq.1) then
          do iexpt=1,nexpt
            if(nsegft(iexpt).ge.1) then
              do isegft=1,nsegft(iexpt)
                gfour_spec(ispec,isegft,iexpt)=1.d0
              enddo
            endif
          enddo
        endif
!
        if(jmsspec_ft(ispec).eq.2) then
          call cread21(bline,jiline,iline,iline_y)
          if(jdb_i01.eq.1) write(39,2010) bline(iline)
!
          do iexpt=1,nexpt
            if(nsegft(iexpt).ge.1) then
              do isegft=1,nsegft(iexpt)
                read(21,*,err=980)                                      &
     &          idum1,idum2,gfour_spec(ispec,isegft,iexpt)
              enddo
            endif
          enddo
        endif
!
        call cread21(bline,jiline,iline,iline_y)
        if(jdb_i01.eq.1) write(39,2010) bline(iline)
!
        ipm_i=0
        ipm_f=0
!
        do ipm=1,npmspec(ispec)
          idpen_spre(ispec,ipm)=-1
!
          if(ipm.gt.ipm_f) then
            read(21,*,err=980) idum1,idum2,pmspec(ispec,ipm,1)          &
     &                ,jctspec(ispec,ipm),jbcspec(ispec,ipm)
!
            ipm_i=ipm
            if(idum1.lt.0) ipm_f=-idum1
!
            ldokin0=0
            if(idum2.lt.0) ldokin0=-idum2
          else
            pmspec(ispec,ipm,1)=pmspec(ispec,ipm_i,1)
            jctspec(ispec,ipm)=jctspec(ispec,ipm_i)
            jbcspec(ispec,ipm)=jbcspec(ispec,ipm_i)
            if(ldokin0.ge.10000) ldokin0=ldokin0+1
          endif
!
          idokin_spre(ispec,ipm)=-1
          if(ldokin0.gt.0) then
            idokin=idokin+1
            if(idokin.gt.mdokin_x) goto 381
            ldokin(idokin)=ldokin0
            ispec_dokin(idokin)=ispec
            ireac_dokin(idokin)=-1
            ipm_dokin(idokin)=ipm
            idokin_spre(ispec,ipm)=idokin
          endif
!
          nvpmspec(ispec,ipm)=1
!
!       jctspec=0,1:
!         "pmspec" is unknown / MC movable "Theta" model parameter,
!         enter 5 values:
!         ivpm=1,2,3,4,5 <-> "lo", "hi", "step", "ini", "tru"
          if( jctspec(ispec,ipm).eq.0                                   &
     &    .or.jctspec(ispec,ipm).eq.1) nvpmspec(ispec,ipm)=5
!
!       jctspec=10,20,30,40:
!         10:    "pmspec" is a dependent of
!                "Psi"-, "U^f"-, and "U^v"-model parameters,
!         20:    t-evol. model species "ispec" is a dependent of other
!                model species and/or various "pmspec"/"pmreac"
!         30,40: t-evol. exptl species "ispec" is a dependent of other
!                exptl. species and/or various "pmspec"/"pmreac"
!           30:  final result stored in xspec_xpt
!           40:  final result stored in yspec_xpt
!
!N180810
!         Note:
!         If jctspec=20, 30, 40 for any "ipm", MUST have jfix=-100 or -110 !!
!
          if(                                                           &
     &    jctspec(ispec,ipm).eq.10.or.                                  &
     &    jctspec(ispec,ipm).eq.20.or.                                  &
     &    jctspec(ispec,ipm).eq.30.or.                                  &
     &    jctspec(ispec,ipm).eq.40                                      &
     &    )then
            nvpmspec(ispec,ipm)=1
          endif
!
!       jctspec=100:
!         "pmspec" is fixed control "U^f" parameter,
!         enter 1 value
          if(jctspec(ispec,ipm).eq.100) nvpmspec(ispec,ipm)=1
!
!       jctspec=200:
!         "pmspec" is expt'lly varied control "U^v" parameter,
!         enter "nexpt" values, 1 for each expt here
          if(jctspec(ispec,ipm).eq.200) nvpmspec(ispec,ipm)=nexpt
!
          if(nvpmspec(ispec,ipm).gt.nvpmspec_x) then
            errtag='000030'
            call err_term
          endif
!
          if(nvpmspec(ispec,ipm).ge.2) then
             do ivpm=2,nvpmspec(ispec,ipm)
               if(ipm.eq.ipm_i) then
                 read(21,*,err=980)                                     &
     &           idum1,idum2,pmspec(ispec,ipm,ivpm)
               else
                 pmspec(ispec,ipm,ivpm)                                 &
     &           =pmspec(ispec,ipm_i,ivpm)
               endif
             enddo
           endif
!
!
          if(                                                           &
     &    jctspec(ispec,ipm).eq.10.or.                                  &
     &    jctspec(ispec,ipm).eq.20.or.                                  &
     &    jctspec(ispec,ipm).eq.30.or.                                  &
     &    jctspec(ispec,ipm).eq.40                                      &
     &    )then
            idpen=idpen+1
!
            if(idpen.gt.ndpen_tot_x) then
            errtag='000031'
            call err_term
            endif
!
            ispre_dpen(idpen)=ispec
            ispec_dpen(idpen)=ispec
            ireac_dpen(idpen)=-1
            ipm_dpen(idpen)=ipm
            idpen_spre(ispec,ipm)=idpen
          endif
!
          do ivpm=1,nvpmspec(ispec,ipm)
            iodd=ipm/2
            iodd=ipm-2*iodd
            if(                                                         &
     &      ((jfix(ispec).eq.0.or.jfix(ispec).eq.1)                     &
     &      .and.ipm.eq.1.and.ivpm.ne.3                                 &
     &      )                                                           &
     &      .or.                                                        &
     &      ((   jfix(ispec).eq.10                                      &
     &       .or.jfix(ispec).eq.11                                      &
     &       .or.jfix(ispec).eq.5010                                    &
     &       .or.jfix(ispec).eq.5011                                    &
     &       .or.jfix(ispec).eq.20                                      &
     &       .or.jfix(ispec).eq.21                                      &
     &       .or.jfix(ispec).eq.5020                                    &
     &       .or.jfix(ispec).eq.5021                                    &
     &       )                                                          &
     &      .and.iodd.eq.0.and.ivpm.ne.3                                &
     &      )                                                           &
     &      )then
              if(pmspec(ispec,ipm,ivpm).gt.xspec_max(ispec).or.         &
     &           pmspec(ispec,ipm,ivpm).lt.xspec_min(ispec))            &
     &        then
            errtag='000032'
            call err_term
              endif
            endif
          enddo
        enddo
!
!
        kdpen_spre(ispre)=idpen
!
        do kdpen=(kdpen_spre(ispre-1)+1),kdpen_spre(ispre)
          ipm=ipm_dpen(kdpen)
!
          call cread21(bline,jiline,iline,iline_y)
          if(jdb_i01.eq.1) write(39,2010) bline(iline)
!
          read(21,*,err=980) idum,mparn_dpen(kdpen)                     &
     &              ,jprio_dpen(kdpen)                                  &
     &              ,jfunc_dpen(kdpen)
          if(jfunc_dpen(kdpen).eq.-1) then
            read(21,2110) namefunc_dpen(kdpen)
          endif
!
          if(mparn_dpen(kdpen).gt.mparn_x) then
            errtag='000033'
            call err_term
          endif
!
          call cread21(bline,jiline,iline,iline_y)
          if(jdb_i01.eq.1) write(39,2010) bline(iline)
!
          iparn_i=0
          iparn_f=0
          do iparn=1,mparn_dpen(kdpen)
            if(iparn.gt.iparn_f) then
!N180810
              if(jfix(ispec).eq.-100.or.jfix(ispec).eq.-110) then
                read(21,*,err=980) idum,ipm_parn(iparn,kdpen)           &
     &                         ,ti_parn(iparn,kdpen)
              else
                read(21,*,err=980) idum,ipm_parn(iparn,kdpen)
                ti_parn(iparn,kdpen)=0.000001d0
              endif
!
              iparn_i=iparn
              if(idum.lt.0) iparn_f=-idum
!
              if(ipm_parn(iparn,kdpen).ne.0) then
                read(21,2110) nmparn(iparn,kdpen)
                pmparn(iparn,kdpen)=-1.d20
              else
                read(21,*,err=980) pmparn(iparn,kdpen)
                nmparn(iparn,kdpen)=' '
              endif
            else
              ipm_parn(iparn,kdpen)=ipm_parn(iparn_i,kdpen)             &
     &                             +(iparn-iparn_i)
              ti_parn(iparn,kdpen)=ti_parn(iparn_i,kdpen)
              nmparn(iparn,kdpen)=nmparn(iparn_i,kdpen)
              pmparn(iparn,kdpen)=pmparn(iparn_i,kdpen)
            endif
          enddo
        enddo
!
      enddo
!
      ndpen_spec=idpen
!
!
!   reaction network by reaction number:
!
      do ireac=1,nreac
        ispre=ireac+nspec
        kdpen_spre(ispre)=kdpen_spre(ispre-1)
!
!     reaction kinetics and rates,
!     number of reactant and product species:
!
!     jkin= 1: standard single-step kinetics with
!       rkfor, rkbak   = forward, backward rate constants
!
!     jkin=2: standard kinetics with
!           arbitrary fractional cooperativity exponents
!           and molec. multiplicity = cooperativity exponent
!           rkfor(.) <-> ipm=1
!           rkbak(.) <-> ipm=2
!           for ipart=1,...nipart(.):
!             hicoop(ipart,.) <-> ipm=2+ipart
!             gispec(ipart,.) = hicoop(ipart,.)
!           for ipart=1,...nopart(.):
!             hocoop(ipart,.) <-> ipm=2+nipart(.)+ipart
!             gospec(ipart,.) = hocoop(ipart,.)
!
!     jkin=3: standard kinetics with
!           arbitrary fractional cooperativity exponents
!           and arbitrary fractional molec. multiplicities
!           rkfor(.) <-> ipm=1
!           rkbak(.) <-> ipm=2
!           for ipart=1,...nipart(.):
!             hicoop(ipart,.) <-> ipm=2+(2*ipart-1)
!             gispec(ipart,.) <-> ipm=2+(2*ipart)
!           for ipart=1,...nopart(.):
!             hocoop(ipart,.) <-> ipm=2+2*nipart(.)+(2*ipart-1)
!             gospec(ipart,.) <-> ipm=2+2*nipart(.)+(2*ipart)
!
!     jkin=11: Non-coop Michaelis-Menten (MM) two-step kinetics with
!       nameispec(1,.)=nameospec(1,.) = enzyme species
!       rkfor,  rkbak  = step-1 rate constants
!       rkfor2, rkbak2 = step-2 rate constants
!
!     jkin=22: Coop. activated transcription (CAT) kinetics
!
!     jkin=30: Poisson polymerization kinetics
!
!     jkin=40: Non-coop MM three-step two-way kinetics
!                   E+S <--> ES <--> EP <--> E+P
!              with multiple competing substrates per enzyme
!              and quasi-equilibria for E+S<-->ES and EP<-->E+P
!                nipart=3+n, nopart=2, npmreac=4+n=nipart+1
!                ipart=1: E, =2: S, =3: P, 4: C1, ..., =3+n: Cn
!              where C1,...Cn are other competing substrates
!              (which are the same for input S,ES and output P,EP);
!              Also, in "set_fix_reac" or "kin_ini", we will set
!                iospec(1,.) :=iispec(1,.) == E
!                iospec(2,.) :=iispec(3,.) == P
!              so that automatically:
!                iopart=1: E, =2: P
!              The list of output species names in ens.i01
!              must then contain _no_ entries, i.e., species
!              names for E and P must _not_ be listed in ens.i01
!              for iopart=1,2, even though nopart=2 is set
!              in ens.i01. This is done to simplify ens.i01 input.
!              Then, kin. param. vars. are stored as ...
!              rkfor, rkbak:
!                ipm=1:     \Gamma(ES-->EP)
!                ipm=2:     \Gamma(EP-->ES)
!              hicoop(ipart,.), ipart=2,...n+3==nipart:
!                ipm=3:     Q(E+S<-->ES)
!                ipm=4:     Q(E+P<-->EP)
!                ipm=5:     Q(E+C1<-->EC1)
!                ...
!                ipm=4+n:   Q(E+Cn<-->ECn)
!              and with constant stoich. coeffs. set to
!                gispec(ipart,.)=0,1,0,0,... 0,
!                  for ipart=1,2,...n+3==nipart;
!                gospec(iopart,.)=0,1
!                  for iopart=1,2==nopart.
!
!     jkin=41: Non-coop multinary MM three-step two-way kinetics
!                E+C_k <--> EC_k <--> EC_j <--> E+C_j
!              with multi-species reactant complexes C_k, C_j
!                k from 1,...K;   j from 1,...K
!              multiple competing substrates per enzyme and quasi-equilibria for
!                E+S_1,n+...S_M_n,n<-->EC_n
!              for all competing reactant complexes
!                C_n:=(S_{1,n},...S_{M_n,n})  with  n=1,...K
!              of total complex no. K and complex sizes M_n and
!                nipart=1+sum_n M_n, nopart=1+M_j, npmreac=K+2
!              See "drivs" for further details
!
        call cread21(bline,jiline,iline,iline_y)
        if(jdb_i01.eq.1) write(39,2010) bline(iline)
!
        read(21,2110) namereac(ireac)
        if(jdb_i01.eq.1) write(39,2110) namereac(ireac)
!
        read(21,*,err=980) nipart(ireac),nopart(ireac)                  &
     &            ,jpmreac(ireac)
!
        mbase=10000
        call fdigit(jpmreac(ireac),mbase,jdig,nzdig,ndig_y)
        npxreac(ireac)=jdig(2)
        jkin(ireac)=jdig(1)
!
        if(nipart(ireac).gt.npart_x                                     &
     &   .or.nopart(ireac).gt.npart_x) then
            errtag='000034'
            call err_term
        endif
!
!
        if(jkin(ireac).eq.41) then
          call cread21(bline,jiline,iline,iline_y)
          if(jdb_i01.eq.1) write(39,2010) bline(iline)
!
          read(21,*,err=980)                    &
     &              ncplex(ireac)               &
     &             ,iicplex(ireac)              &
     &             ,iocplex(ireac)              &
     &             ,idum                        &
     &             ,idum                        &
     &             ,idum                        &
     &             ,idum                        &
     &             ,idum                        &
     &             ,idum                        &
     &             ,idum
!
          if(ncplex(ireac).gt.npart_x) then
            errtag='000034.002'
            call err_term
          endif
!
          if(                                                          &
     &    iicplex(ireac).lt.1.or.iicplex(ireac).gt.ncplex(ireac).or.   &
     &    iocplex(ireac).lt.1.or.iocplex(ireac).gt.ncplex(ireac).or.   &
     &    iocplex(ireac).eq.iicplex(ireac)                             &
     &    ) then
            errtag='000034.003'
            call err_term
          endif
!
          call cread21(bline,jiline,iline,iline_y)
          if(jdb_i01.eq.1) write(39,2010) bline(iline)
!
          ipart=1
          do icplex=1,ncplex(ireac)
            read(21,*,err=980)                    &
     &                mpplex(icplex,ireac)        &
     &               ,idum                        &
     &               ,idum                        &
     &               ,idum                        &
     &               ,idum                        &
     &               ,idum                        &
     &               ,idum                        &
     &               ,idum                        &
     &               ,idum                        &
     &               ,idum
            ipart=ipart+mpplex(icplex,ireac)
!
            ipart_ini(icplex,ireac)=ipart-mpplex(icplex,ireac)+1
            ipart_fin(icplex,ireac)=ipart
          enddo
!
          if(ipart.ne.nipart(ireac)) then
            errtag='000034.004'
            call err_term
          endif
        endif
!
!     reactants:
!
        do ipart=1,nipart(ireac)
          read(21,2110) nameispec(ipart,ireac)
          if(jdb_i01.eq.1) write(39,2110) nameispec(ipart,ireac)
        enddo
!
!     products:
!
        if(jkin(ireac).eq.40) then
          nameospec(1,ireac)=nameispec(1,ireac)
          nameospec(2,ireac)=nameispec(3,ireac)
          nopart(ireac)=2
        else
          if(jkin(ireac).eq.41) then
            nameospec(1,ireac)=nameispec(1,ireac)
            nopart(ireac)=1
!
            if(ncplex(ireac).ge.2) then
              nopart(ireac)=mpplex(iocplex(ireac),ireac)+1
              do ipart=2,nopart(ireac)
                nameospec(ipart,ireac)=                  &
     &          nameispec(ipart_ini(iocplex(ireac),ireac)+ipart-2,ireac)
              enddo
            endif
          else
            do ipart=1,nopart(ireac)
              read(21,2110) nameospec(ipart,ireac)
              if(jdb_i01.eq.1) write(39,2110) nameospec(ipart,ireac)
            enddo
          endif
        endif
!
        npmreac(ireac)=0
        if(jkin(ireac).eq.1)  npmreac(ireac)=2
!
        if(jkin(ireac).eq.2)  npmreac(ireac)=2                          &
     &                       +nipart(ireac)+nopart(ireac)
        if(jkin(ireac).eq.3)  npmreac(ireac)=2                          &
     &                       +2*(nipart(ireac)+nopart(ireac))
!
        if(jkin(ireac).eq.11) npmreac(ireac)=4
        if(jkin(ireac).eq.21) npmreac(ireac)=4
!
        if(jkin(ireac).eq.30)  npmreac(ireac)=                          &
     &                        2*nipart(ireac)+nopart(ireac)
!
        if(jkin(ireac).eq.40)  npmreac(ireac)=                          &
     &                         nipart(ireac)+1
!
        if(jkin(ireac).eq.41)  npmreac(ireac)=                          &
     &                         ncplex(ireac)+2
!
!
        npmreac(ireac)=npmreac(ireac)+npxreac(ireac)
!
!
        if(npmreac(ireac).gt.npmreac_x.or.                              &
     &   npmreac(ireac).gt.npmspre_x) then
            errtag='000035'
            call err_term
        endif
!
!
        call cread21(bline,jiline,iline,iline_y)
        if(jdb_i01.eq.1) write(39,2010) bline(iline)
!
        ipm_i=0
        ipm_f=0
!
        do ipm=1,npmreac(ireac)
          idpen_spre(ispre,ipm)=-1
!
          if(ipm.gt.ipm_f) then
            read(21,*,err=980) idum1,idum2,pmreac(ireac,ipm,1)          &
     &              ,jctreac(ireac,ipm),jbcreac(ireac,ipm)
!
            ipm_i=ipm
            if(idum1.lt.0) ipm_f=-idum1
!
            ldokin0=0
            if(idum2.lt.0) ldokin0=-idum2
          else
            pmreac(ireac,ipm,1)=pmreac(ireac,ipm_i,1)
            jctreac(ireac,ipm)=jctreac(ireac,ipm_i)
            jbcreac(ireac,ipm)=jbcreac(ireac,ipm_i)
            if(ldokin0.ge.10000) ldokin0=ldokin0+1
          endif
!
          idokin_spre(ispre,ipm)=-1
          if(ldokin0.gt.0) then
            idokin=idokin+1
            if(idokin.gt.mdokin_x) goto 381
            ldokin(idokin)=ldokin0
            ireac_dokin(idokin)=ireac
            ispec_dokin(idokin)=-1
            ipm_dokin(idokin)=ipm
            idokin_spre(ispre,ipm)=idokin
          endif
!
          nvpmreac(ireac,ipm)=1
!
!       jctreac=0,1:
!         "pmreac" is unknown / MC movable "Theta" model parameter,
!         enter 5 values:
!         ivpm=1,2,3,4,5 <-> "lo", "hi", "step", "ini", "tru"
          if( jctreac(ireac,ipm).eq.0                                   &
     &    .or.jctreac(ireac,ipm).eq.1)  nvpmreac(ireac,ipm)=5
!
!       jctreac=10:
!         "pmreac" is dependent "Psi" model parameter,
!       Note:
!         jctreac=20, 30 NOT allowed !
!
          if(jctreac(ireac,ipm).eq.10)  then
            nvpmreac(ireac,ipm)=1
          endif
!
!       jctreac=100:
!         "pmreac" is fixed control "U^f" parameter,
!         enter 1 value
!
          if(jctreac(ireac,ipm).eq.100) nvpmreac(ireac,ipm)=1
!
!       jctreac=200:
!         "pmreac" is expt'lly varied control "U^v" parameter,
!         enter "nexpt" values, 1 for each expt here
!
          if(jctreac(ireac,ipm).eq.200) nvpmreac(ireac,ipm)=nexpt
!
          if(nvpmreac(ireac,ipm).gt.nvpmreac_x) then
            errtag='000036'
            call err_term
          endif
!
!
          if(nvpmreac(ireac,ipm).ge.2) then
             do ivpm=2,nvpmreac(ireac,ipm)
               if(ipm.eq.ipm_i) then
                 read(21,*,err=980)                                     &
     &           idum1,idum2,pmreac(ireac,ipm,ivpm)
               else
                 pmreac(ireac,ipm,ivpm)                                 &
     &           =pmreac(ireac,ipm_i,ivpm)
               endif
             enddo
           endif
!
!
          if(jctreac(ireac,ipm).eq.10) then
            idpen=idpen+1
!
            if(idpen.gt.ndpen_tot_x) then
            errtag='000037'
            call err_term
            endif
!
            ispre_dpen(idpen)=ireac+nspec
            ispec_dpen(idpen)=-1
            ireac_dpen(idpen)=ireac
            ipm_dpen(idpen)=ipm
            idpen_spre(ireac+nspec,ipm)=idpen
          endif
        enddo
!
        kdpen_spre(ispre)=idpen
!
        do kdpen=(kdpen_spre(ispre-1)+1),kdpen_spre(ispre)
          ipm=ipm_dpen(kdpen)
!
          call cread21(bline,jiline,iline,iline_y)
          if(jdb_i01.eq.1) write(39,2010) bline(iline)
!
          read(21,*,err=980) idum,mparn_dpen(kdpen)                     &
     &              ,jprio_dpen(kdpen)                                  &
     &              ,jfunc_dpen(kdpen)
          if(jfunc_dpen(kdpen).eq.-1) then
            read(21,2110) namefunc_dpen(kdpen)
          endif
!
          if(mparn_dpen(kdpen).gt.mparn_x) then
            errtag='000038'
            call err_term
          endif
!
          call cread21(bline,jiline,iline,iline_y)
          if(jdb_i01.eq.1) write(39,2010) bline(iline)
!
          iparn_i=0
          iparn_f=0
!
          do iparn=1,mparn_dpen(kdpen)
            if(iparn.gt.iparn_f) then
              read(21,*,err=980) idum,ipm_parn(iparn,kdpen)
              ti_parn(iparn,kdpen)=1000001.d0
!
              iparn_i=iparn
              if(idum.lt.0) iparn_f=-idum
!
              if(ipm_parn(iparn,kdpen).ne.0) then
                read(21,2110) nmparn(iparn,kdpen)
                pmparn(iparn,kdpen)=-1.d20
              else
                read(21,*,err=980) pmparn(iparn,kdpen)
                nmparn(iparn,kdpen)=' '
              endif
            else
              ipm_parn(iparn,kdpen)=ipm_parn(iparn_i,kdpen)             &
     &                             +(iparn-iparn_i)
              ti_parn(iparn,kdpen)=ti_parn(iparn_i,kdpen)
              nmparn(iparn,kdpen)=nmparn(iparn_i,kdpen)
              pmparn(iparn,kdpen)=pmparn(iparn_i,kdpen)
            endif
          enddo
        enddo
      enddo
!
!   store total no. of dependent parameters
      ndpen_tot=idpen
      ndpen_reac=ndpen_tot-ndpen_spec
!
!   read in skip-kinsolver patterns
  381 continue
      if(idokin.gt.mdokin_x) then
            errtag='000039'
            call err_term
      endif
!
! store total number of ipm-parameters w/
! skip-kinsolver ID's  ldokin>0
      mdokin=idokin
!
!
! void jdokin-vectors and count distinct ldokin-values
      mldokin=0
      do idokin=1,mdokin
        do iexpt=1,nexpt
          jdokin_expt(iexpt,idokin)=-1234567
        enddo
!
        do idokin0=1,(idokin-1)
          if(ldokin(idokin0).eq.ldokin(idokin)) goto 389
        enddo
          mldokin=mldokin+1
  389   continue
      enddo
!
!     read-in / construct jdokin-vectors
!
      ildokin_i=0
      ildokin_f=0
      ldokin0=0
      ldokin1=0
!
!
      do ildokin=1,mldokin
        if(ildokin.gt.ildokin_f) then
          iline_ini(1)=iline+1
          call cread21(bline,jiline,iline,iline_y)
          if(jdb_i01.eq.1) write(39,2010) bline(iline)
          iline_fin(1)=iline
!
          read(21,*,err=980) ldokin0
!
          jpatki=0
          jpatkf=0
          ldokin1=0
!
          if(ldokin0.lt.0) then
            ldokin0=-ldokin0
!
            call cread21(bline,jiline,iline,iline_y)
            if(jdb_i01.eq.1) write(39,2010) bline(iline)
            read(21,*,err=980) ldokin1,jpatki,mpatki,jpatkf             &
     &                        ,idum,idum,idum                           &
     &                        ,idum,idum,idum
          endif
!
          ildokin_i=ildokin
          if(ldokin1.gt.ldokin0) ildokin_f=ildokin+ldokin1-ldokin0
!
          iline_ini(2)=iline+1
          call cread21(bline,jiline,iline,iline_y)
          if(jdb_i01.eq.1) write(39,2010) bline(iline)
          iline_fin(2)=iline
!
!         jpatki=0:
!           read-in whole jdokin-vector
!         jpatki=1:
!           read-in only one single non-zero comp. of
!           jdokin-vector, "jdokin_nz", then set
!           jdokin to mpatki-th unit vector times jdokin_nz
!
          if(jpatki.eq.0) then
            do iexpt=1,nexpt
              read(21,*,err=980) idum1,jdokin_expt0(iexpt)
            enddo
          endif
!
          if(jpatki.eq.1) then
            read(21,*,err=980) idum1,jdokin_nz                          &
     &                        ,idum,idum,idum,idum                      &
     &                        ,idum,idum,idum,idum
!
            do iexpt=1,nexpt
              jdokin_expt0(iexpt)=0
            enddo
            jdokin_expt0(mpatki)=jdokin_nz
          endif
!
          iline_dokin(1,ildokin)=iline_ini(1)
          iline_dokin(2,ildokin)=iline_ini(2)
        else
          ldokin0=ldokin0+1
          iline_dokin(1,ildokin)=iline_fin(1)
          iline_dokin(2,ildokin)=iline_fin(2)
!
!         jpatkf=0: new jdokin_expt = same as last
!         jpatkf=1: new jdokin_expt = +1 cycl. perm. of last
!
          if(jpatkf.eq.1) then
            do iexpt=1,nexpt
              idum=iexpt+1
              if(idum.gt.nexpt) idum=idum-nexpt
              jdokin_expt1(idum)=jdokin_expt0(iexpt)
            enddo
            do iexpt=1,nexpt
              jdokin_expt0(iexpt)=jdokin_expt1(iexpt)
            enddo
          endif
        endif
!
!
        ldokin_inp(ildokin)=ldokin0
        idokin_inp(ildokin)=-1
!
        do idokin=1,mdokin
          if(ldokin0.eq.ldokin(idokin)) then
            do iexpt=1,nexpt
              jdokin_expt(iexpt,idokin)                                 &
     &        =jdokin_expt0(iexpt)
            enddo
!
            if(idokin_inp(ildokin).eq.-1)                               &
     &      idokin_inp(ildokin)=idokin
          endif
        enddo
      enddo
!
!
      do idokin=1,mdokin
        do iexpt=1,nexpt
          if(jdokin_expt(iexpt,idokin).eq.-1234567) then
            errtag='000040'
            call err_term
          endif
        enddo
      enddo
!
      if(jdb_i01.eq.1) then
        write(39,*) '  '
        write(39,*) 'INPUT FROM "ens.i01" COMPLETED SUCCESSFULLY'        &
     &           ,' mp_myid=', mp_myid
      endif
!
      iun=21
      close(iun)
!
      if(mp_myid.ne.mp_mrid) goto 990
!
!   write out input parameters
!
      write(31,*) ' '
      write(31,*) ' '
      iline=0
      write(31,2010) bline(iline)
!
!   MPI control parameters
!   if no. of processors, mp_nproc>1 only
!!!   if(mp_nproc.gt.1) then
        idum1=0
        call cwrite31(bline,jiline,iline,iline_y)
        write(31,2301) jmp_task, mp_w2sv       &
     &            ,idum1,idum1,idum1,idum1,idum1   &
     &            ,idum1,idum1,idum1
 2301 format(10i8)
!!!   endif
!
!   numbers of MC repetitions, equilibr. seq's,
!   accum seq's, updates per accum seq,
!   MC random number seed, meas. powers of Theta-params.
      call cwrite31(bline,jiline,iline,iline_y)
!
      write(31,2310) nmc_rep,jmc_eql,nmc_eql,nmc_acc,nmc_upd            &
     &              ,imc_ran,npow_spec,npow_reac,jrand,iseed2
 2310 format(10i8)
!
!
!   MC sampling temperature
      call cwrite31(bline,jiline,iline,iline_y)
      write(31,2315) temp_mc,htot_cut,jmc_inii,jst_ini
 2315 format(f16.8,d16.8,2i8)
!
! Initial skip and stride for restart/rerun from "o02" or "i12"
      if(jskip12.gt.0) then
        idum1=0
        idum2=0
        call cwrite31(bline,jiline,iline,iline_y)
        write(31,2316) n0skip12,nrskip12                                &
     &               , idum1,idum2,idum1,idum2                          &
     &               , idum1,idum2
 2316 format(8i8)
      endif
!
!   MC max. update step width factors
      call cwrite31(bline,jiline,iline,iline_y)
      write(31,2320) mpr_swo,jac_swo
 2320 format(2i8)
!
!
!
!   MC boundary contact force parameters
      call cwrite31(bline,jiline,iline,iline_y)
      write(31,2321) meq_fbx,mac_fbx,nbx_time
 2321 format(3i8)
!
!
!   fict. Hamiltonian time evol. parameters:
      call cwrite31(bline,jiline,iline,iline_y)
      write(31,2322) gamma_ms,gamma_fx,dtfic,dderiv_th
 2322 format(4d16.8)
!
      call cwrite31(bline,jiline,iline,iline_y)
      write(31,2323) ntfic,jbcfic,jmsfic,jdtfic,jfxfic
 2323 format(5i8)
!
!   Convg. tolerance and max. number of iteration
!   sweeps for Amoeba moves
      call cwrite31(bline,jiline,iline,iline_y)
      write(31,2325) tol_amb, mit_amb
 2325 format(f16.8,i8)
!
!   MC move schedule and number of move types per sequ
!   jmvloop=1: equilibr'n
!   jmvloop=2: accum
      call cwrite31(bline,jiline,iline,iline_y)
!V090927:
      idum=0
      write(31,2330)                                                    &
     &(jmvloop                                                          &
     &,jmvsched(jmvloop)                                                &
     &,nmvsequ(jmvloop)                                                 &
     &,idum                                                             &
     &,idum                                                             &
     &,idum                                                             &
     &,idum                                                             &
     &,idum                                                             &
     &,idum                                                             &
     &,idum                                                             &
     &,jmvloop=1,2)
 2330 format(10i8)
!
      do jmvloop=1,2
        if(jmvsched(jmvloop).eq.100.and.jmvloop.eq.2) then
          call cwrite31(bline,jiline,iline,iline_y)
          idum=0
          write(31,2332)                                                    &
     &     jmvloop                                                          &
     &    ,jrpwgt(jmvloop)                                                  &
     &    ,idum                                                             &
     &    ,idum                                                             &
     &    ,idum                                                             &
     &    ,idum                                                             &
     &    ,idum                                                             &
     &    ,idum                                                             &
     &    ,idum                                                             &
     &    ,idum
 2332     format(10i8)
        endif
        if(jmvloop.eq.2) then
          if(jrpwgt(jmvloop).eq.1.or.jrpwgt(jmvloop).eq.2) then
            call cwrite31(bline,jiline,iline,iline_y)
            idum=0
            write(31,2334)                                                    &
     &       jmvloop                                                          &
     &      ,am_chisq_lo(jmvloop)                                             &
     &      ,am_chisq_hi(jmvloop)                                             &
     &      ,temp_repav(jmvloop)                                              &
     &      ,idum                                                             &
     &      ,idum                                                             &
     &      ,idum
 2334       format(i8,3d16.8,3i8)
          endif
        endif
      enddo
!
!:V090927
!
!   MC move types by sequ and number of moves per sequ
!     jmvloop=1: equilibration
!     jmvloop=2: accum./updating
      lblkth=0
      ldconr=0
      ldconp=0
      ldconfz=0
!
      lrasf=0
!
      do jmvloop=1,2
        do imvsequ=1,nmvsequ(jmvloop)
          call cwrite31(bline,jiline,iline,iline_y)
          write(31,2340)                                                &
     &                     jmvloop,imvsequ                              &
     &              ,      jmty_mc(imvsequ,jmvloop)                     &
     &              ,        nmove(imvsequ,jmvloop)                     &
     &              ,      pmvtype(imvsequ,jmvloop)                     &
     &              ,     raccp_lo(imvsequ,jmvloop)                     &
     &              ,     raccp_hi(imvsequ,jmvloop)
 2340     format(3i8,1x,i9,f14.6,2f16.8)
!
!        write out special move types, special MC controls
!        and/or theta move block params.
!
          if(jmty_mc(imvsequ,jmvloop).eq.-100) then
            idum1=0
            call cwrite31(bline,jiline,iline,iline_y)
            write(31,2342)                                                &
     &                       jmty(imvsequ,jmvloop)                        &
     &                ,      jnorep(imvsequ,jmvloop)                      &
     &                ,      jblkth_pik(imvsequ,jmvloop)                  &
     &                ,      jrasf_pik(imvsequ,jmvloop)                   &
     &                ,      idum1, idum1, idum1, idum1, idum1, idum1
 2342       format(i10,i6,8i8)
!
! Later:
! Use jblkth_sco>0, to define poss. scope
! of theta-blocks extending beyond current move sequence
! Use jovr_bcth>0, to override/suppress/control MC boundaries
! on blocks of theta vars. in this move sequence
! Use jovr_stp>0, to override/suppress/control MC step widths
! on blocks of theta vars. in this move sequence
! Use jovr_oth>0, to override/suppress/control ens.o02 output
! from this move sequence
!
            idum1=0
            call cwrite31(bline,jiline,iline,iline_y)
            write(31,2343)                                            &
     &                       jovr_bcth(imvsequ,jmvloop)                   &
     &                ,      jovr_stp(imvsequ,jmvloop)                    &
     &                ,      jovr_oth(imvsequ,jmvloop)                    &
     &                ,      idum1, idum1, idum1, idum1, idum1, idum1, idum1
 2343       format(10i8)
!
! Declare theta blocks for block-restricted MC move sequence
            if(jblkth_pik(imvsequ,jmvloop).eq.1) then
              idum1=0
              call cwrite31(bline,jiline,iline,iline_y)
              write(31,2344)                                              &
     &                         jblkth_fmt(imvsequ,jmvloop)                &
     &                  ,      jblkth_ord(imvsequ,jmvloop)                &
     &                  ,      jblkth_sco(imvsequ,jmvloop)                &
     &                  ,      nblkth(imvsequ,jmvloop)                    &
     &                  ,      idum1, idum1, idum1, idum1, idum1, idum1
 2344         format(10i8)
!
              if(jblkth_fmt(imvsequ,jmvloop).eq.0) then
                do iblkth=1,nblkth(imvsequ,jmvloop)
                  lblkth=lblkth+1
!
                  idum1=0
                  call cwrite31(bline,jiline,iline,iline_y)
                  write(31,2346)                                    &
     &                         iblkth                               &
     &                  ,      ipm_lo_blkth(lblkth)                 &
     &                  ,      ipm_hi_blkth(lblkth)                 &
     &                  ,      ipm_str_blkth(lblkth)                &
     &                  ,      jipm_str_blkth(lblkth)               &
     &                  ,      ispre_str_blkth(lblkth)              &
     &                  ,      jispre_str_blkth(lblkth)             &
     &                  ,      jbc_blkth(lblkth)                    &
     &                  ,      jstp_blkth(lblkth), idum1
 2346             format(10i8)
!
                  call cwrite31(bline,jiline,iline,iline_y)
                  write(31,2010)                             &
     &                         namespre_lo_blkth(lblkth)
                  write(31,2010)                             &
     &                         namespre_hi_blkth(lblkth)
!
! set or override boundary conditions on theta-vars.
! in theta block
                  if(jbc_blkth(lblkth).eq.1) then
                    idum1=0
                    call cwrite31(bline,jiline,iline,iline_y)
                    write(31,2348)                           &
     &                       iblkth                               &
     &                     , bc_lo_blkth(lblkth)                  &
     &                     , bc_hi_blkth(lblkth)                  &
     &                     , jbc_lo_blkth(lblkth)                 &
     &                     , jbc_hi_blkth(lblkth)                 &
     &                     , idum1, idum1, idum1
 2348               format(i8,2d16.8,5i8)
                  endif
!
! set or override MC step width and step width adjustmt.
! on theta-vars. in theta block
                  if(jstp_blkth(lblkth).eq.1) then
                    idum1=0
                    call cwrite31(bline,jiline,iline,iline_y)
                    write(31,2350)                                       &
     &                       iblkth                                    &
     &                     , fstp_wid_blkth(lblkth)                    &
     &                     , jstp_wid_blkth(lblkth)                    &
     &                     , idum1, idum1, idum1, idum1, idum1, idum1
 2350               format(i8,d16.8,7i8)
                  endif
                enddo
              endif
            endif
!
! SF list for SF Gaussian randomization
!
            if(jrasf_pik(imvsequ,jmvloop).eq.1) then
              idum1=0
              call cwrite31(bline,jiline,iline,iline_y)
              if(jdb_i01.eq.1) write(39,2010) bline(iline)
              write(31,2360)                                             &
     &                         jrasf_ctl(imvsequ,jmvloop)                &
     &                  ,      jrasf_fmt(imvsequ,jmvloop)                &
     &                  ,      nrasf(imvsequ,jmvloop)                    &
     &                  ,      jrasf_xch(imvsequ,jmvloop)                &
     &                  ,      idum1, idum1, idum1, idum1                &
     &                  ,      idum1, idum1
 2360         format(10i8)
!
              idum1=0
              call cwrite31(bline,jiline,iline,iline_y)
              if(jdb_i01.eq.1) write(39,2010) bline(iline)
              write(31,2361)                                             &
     &                         sxplog_nlo(imvsequ,jmvloop)               &
     &                  ,      sxplog_nhi(imvsequ,jmvloop)               &
     &                  ,      sxplin_nlo(imvsequ,jmvloop)               &
     &                  ,      sxplin_nhi(imvsequ,jmvloop)               &
     &                  ,      idum1, idum1
 2361         format(4d16.8,2i8)
!
              if(jrasf_fmt(imvsequ,jmvloop).eq.0) then
                do irasf=1,nrasf(imvsequ,jmvloop)
                  lrasf=lrasf+1
                  if(lrasf.gt.lrasf_x) then
                    errtag='000010.002.001'
                    call err_term
                  endif
!
                  idum1=0
                  call cwrite31(bline,jiline,iline,iline_y)
                  if(jdb_i01.eq.1) write(39,2010) bline(iline)
                  write(31,2362)                                         &
     &                         irasf                                     &
     &                  ,      lscalin_rasf(lrasf)                       &
     &                  ,      lscalog_rasf(lrasf)                       &
     &                  ,      ipm_rasf(lrasf)                           &
     &                  ,      idum1, idum1, idum1, idum1                &
     &                  ,      idum1, idum1
 2362             format(10i8)
!
                  write(31,2010,err=980)                          &
     &            namespre_rasf(lrasf)
                enddo
              endif
            endif
          endif
!
!        write out special deconvolution Gibbs sampler move parameters
!
          if(jmty(imvsequ,jmvloop).eq.20)then
            idum1=0
            call cwrite31(bline,jiline,iline,iline_y)
            write(31,3350)                                                &
     &                  jmty_ampdc(imvsequ,jmvloop)                       &
     &                , jdcrspec_pik(imvsequ,jmvloop)                     &
     &                , jdcpspec_pik(imvsequ,jmvloop)                     &
     &                , jdcfz_pik(imvsequ,jmvloop)                        &
     &                , ndcsweep(imvsequ,jmvloop)                         &
!V090912:`
     &                , jdcckev(imvsequ,jmvloop)                          &
     &                , idum1, idum1, idum1, idum1
!:V090912
 3350       format(10i8)
!
              idum1=0
              call cwrite31(bline,jiline,iline,iline_y)
              write(31,3352)                                   &
     &                   stpdcon(imvsequ,jmvloop)              &
     &                 , bcdcon(imvsequ,jmvloop)               &
     &                 , jdcon_stp(imvsequ,jmvloop)            &
     &                 , jdcon_bc(imvsequ,jmvloop)             &
     &                 , idum1, idum1, idum1, idum1
 3352       format(2d16.8,6i8)
!
            if(jdcrspec_pik(imvsequ,jmvloop).eq.1) then
              idum1=0
              call cwrite31(bline,jiline,iline,iline_y)
              write(31,3354)                                   &
     &                   mdconr(imvsequ,jmvloop)               &
     &                 , jdcrspec_fmt(imvsequ,jmvloop)              &
     &                 , idum1, idum1, idum1, idum1, idum1, idum1  &
     &                 , idum1, idum1
 3354         format(10i8)
!
              if(jdcrspec_fmt(imvsequ,jmvloop).eq.0) then
                call cwrite31(bline,jiline,iline,iline_y)
                do idcon=1,mdconr(imvsequ,jmvloop)
                  ldconr=ldconr+1
!
                  write(31,2010)                          &
     &            name_dconr(ldconr)
                enddo
              endif
            endif
!
            if(jdcpspec_pik(imvsequ,jmvloop).eq.1) then
              idum1=0
              call cwrite31(bline,jiline,iline,iline_y)
              write(31,3356)                                   &
     &                   mdconp(imvsequ,jmvloop)               &
     &                 , jdcpspec_fmt(imvsequ,jmvloop)              &
     &                 , jdcpspec_sum(imvsequ,jmvloop)              &
     &                 , idum1, idum1, idum1, idum1, idum1, idum1, idum1
 3356         format(10i8)
!
              if(jdcpspec_fmt(imvsequ,jmvloop).eq.0) then
                call cwrite31(bline,jiline,iline,iline_y)
                do idcon=1,mdconp(imvsequ,jmvloop)
                  ldconp=ldconp+1
!
                  write(31,2010)                                   &
     &            name_dconp(ldconp)
                enddo
              endif
            endif
!
            if(jdcfz_pik(imvsequ,jmvloop).eq.1) then
              idum1=0
              call cwrite31(bline,jiline,iline,iline_y)
              write(31,3358)                                      &
     &              mdconfz(imvsequ,jmvloop)                        &
     &        ,     jdcfz_fmt(imvsequ,jmvloop)                       &
     &        ,     idum1, idum1, idum1, idum1, idum1, idum1, idum1, idum1
 3358         format(10i8)
!
              if(jdcfz_fmt(imvsequ,jmvloop).eq.0) then
                do idcon=1,mdconfz(imvsequ,jmvloop)
                  ldconfz=ldconfz+1
!
                  call cwrite31(bline,jiline,iline,iline_y)
                  write(31,2010)                                   &
     &            namerspec_dconfz(ldconfz)
                  write(31,2010)                                   &
     &            namepspec_dconfz(ldconfz)
                enddo
              endif
            endif
          endif
!
          call cwrite31(bline,jiline,iline,iline_y)
          write(31,3333)                                                &
     &               jtmp_mc(imvsequ,jmvloop)                           &
     &              ,jstp_mc(imvsequ,jmvloop)                           &
     &              ,jwgt_mc(imvsequ,jmvloop)                           &
     &              ,npwgt(0,imvsequ,jmvloop)                           &
     &              ,ftmp_mc(imvsequ,jmvloop)                           &
     &              ,fstp_mc(imvsequ,jmvloop)
 3333     format(4i12,2f16.8)
!
          call cwrite31(bline,jiline,iline,iline_y)
          if(npwgt(0,imvsequ,jmvloop).gt.0)                             &
     &    write(31,3334)                                                &
     &             (pwgt_mc(lpwgt,imvsequ,jmvloop)                      &
     &            ,lpwgt=1,npwgt(0,imvsequ,jmvloop))
 3334     format(16x,4d16.8)
!
!
          if(jwgt_wc(imvsequ,jmvloop).gt.0) then
            call cwrite31(bline,jiline,iline,iline_y)
            idum=0
            write(31,3336)                                              &
     &       npwgt(1,imvsequ,jmvloop)                                   &
     &      ,idum,idum,idum                                             &
     &      ,idum,idum,idum                                             &
     &      ,idum,idum,idum
 3336       format(10i8)
          endif
!
!
          if(npwgt(1,imvsequ,jmvloop).gt.0) then
            call cwrite31(bline,jiline,iline,iline_y)
!
            lpwgt=npwgt(0,imvsequ,jmvloop)
            do ipwgt=1,npwgt(1,imvsequ,jmvloop)
              lpwgt=lpwgt+1
!            Note: lpwgt array size limit already checked above
!            via"npwgt_tot".
              write(31,3338)                                            &
     &         iexpt_wc0(lpwgt,imvsequ,jmvloop)                         &
     &        ,iexpt_wc1(lpwgt,imvsequ,jmvloop)                         &
     &        ,  ims_wc0(lpwgt,imvsequ,jmvloop)                         &
     &        ,  ims_wc1(lpwgt,imvsequ,jmvloop)                         &
     &        ,itxpt_wc0(lpwgt,imvsequ,jmvloop)                         &
     &        ,itxpt_wc1(lpwgt,imvsequ,jmvloop)                         &
     &        ,  pwgt_mc(lpwgt,imvsequ,jmvloop)
 3338         format(6i8,d16.8)
            enddo
          endif
!
          call cwrite31(bline,jiline,iline,iline_y)
          write(31,3340)                                                &
     &               jbxx_mc(imvsequ,jmvloop)                           &
     &            ,  fbxx_mc(imvsequ,jmvloop)                           &
     &            ,bxx_lo_mc(imvsequ,jmvloop)                           &
     &            ,bxx_hi_mc(imvsequ,jmvloop)
 3340     format(8x,i8,3d16.8)
!
          call cwrite31(bline,jiline,iline,iline_y)
          write(31,3342)                                                &
     &              qqbxx_mc(imvsequ,jmvloop)                           &
     &         ,   redbxx_mc(imvsequ,jmvloop)                           &
     &         ,afbxx_max_mc(imvsequ,jmvloop)
 3342     format(16x,3d16.8)
!
          call cwrite31(bline,jiline,iline,iline_y)
          write(31,3344)                                                &
     &               jbxn_mc(imvsequ,jmvloop)                           &
     &            ,  fbxn_mc(imvsequ,jmvloop)                           &
     &            ,bxn_lo_mc(imvsequ,jmvloop)                           &
     &            ,bxn_hi_mc(imvsequ,jmvloop)
 3344     format(8x,i8,3d16.8)
!
          call cwrite31(bline,jiline,iline,iline_y)
          write(31,3346)                                                &
     &              qqbxn_mc(imvsequ,jmvloop)                           &
     &         ,   redbxn_mc(imvsequ,jmvloop)                           &
     &         ,afbxn_max_mc(imvsequ,jmvloop)
 3346     format(16x,3d16.8)
!
          call cwrite31(bline,jiline,iline,iline_y)
          write(31,3348)                                                &
     &                jsft_mc(imvsequ,jmvloop)                          &
     &           ,   ffour_mc(imvsequ,jmvloop)                          &
     &           ,   efour_mc(imvsequ,jmvloop)                          &
     &           ,   cfour_mc(imvsequ,jmvloop)
 3348 format(i16,3d16.8)
!
!
          if(                                                           &
     &    jmty(imvsequ,jmvloop).ge.1000.and.                            &
     &    jmty(imvsequ,jmvloop).le.2999                                 &
     &    )then
            call cwrite31(bline,jiline,iline,iline_y)
            write(31,4360)                                              &
     &                 jini_st(imvsequ,jmvloop)                         &
     &                ,jtmp_st(imvsequ,jmvloop)                         &
     &                ,jxc1_st(imvsequ,jmvloop)                         &
     &                ,jxc2_st(imvsequ,jmvloop)                         &
     &                ,jmthy_st(imvsequ,jmvloop)                        &
     &                ,jrthy_st(imvsequ,jmvloop)                        &
     &                ,jxthy_st(imvsequ,jmvloop)                        &
     &                ,mfox_st(imvsequ,jmvloop)                         &
     &                ,npop_st(imvsequ,jmvloop)                         &
     &                ,npar_st(imvsequ,jmvloop)
 4360       format(10i8)
!
            call cwrite31(bline,jiline,iline,iline_y)
            write(31,4362)                                              &
     &                 temp_st(imvsequ,jmvloop)                         &
     &                ,althy_st(imvsequ,jmvloop)                        &
     &                ,estp_st(imvsequ,jmvloop)                         &
     &                ,amthy_st(imvsequ,jmvloop)                        &
     &                ,bmthy_st(imvsequ,jmvloop)
 4362       format(5d16.8)
          endif
!
          if(                                                           &
     &    jmty(imvsequ,jmvloop).ge.3000.and.                            &
     &    jmty(imvsequ,jmvloop).le.4999                                 &
     &    )then
            call cwrite31(bline,jiline,iline,iline_y)
            write(31,4370)                                              &
     &                 jini_ge(imvsequ,jmvloop)                         &
     &                ,jtmp_ge(imvsequ,jmvloop)                         &
     &                ,jfsu_ge(imvsequ,jmvloop)                         &
     &                ,jnsu_ge(imvsequ,jmvloop)                         &
     &                ,jbsu_ge(imvsequ,jmvloop)                         &
     &                ,jrsu_ge(imvsequ,jmvloop)                         &
     &                ,jxsu_ge(imvsequ,jmvloop)                         &
     &                ,jysu_ge(imvsequ,jmvloop)                         &
     &                ,npop_ge(imvsequ,jmvloop)                         &
     &                ,npar_ge(imvsequ,jmvloop)
 4370       format(10i8)
!
            call cwrite31(bline,jiline,iline,iline_y)
            write(31,4372)                                              &
     &                 temp_ge(imvsequ,jmvloop)                         &
     &                ,ansur_ge(imvsequ,jmvloop)                        &
     &                ,bnsur_ge(imvsequ,jmvloop)                        &
     &                ,cnsur_ge(imvsequ,jmvloop)                        &
     &                ,dnsur_ge(imvsequ,jmvloop)
 4372       format(5d16.8)
          endif
!
        enddo
      enddo
!
!   Wang-Landau parameters
      call cwrite31(bline,jiline,iline,iline_y)
      write(31,4442) alnf_dos0,alnf_dos1,pf_dos,ck_his
 4442 format(4f16.8)
!
      call cwrite31(bline,jiline,iline,iline_y)
      write(31,4444) nit_dos,nck_dos,no_dos                             &
     &             ,jnm_dos,jck_his,jbc_dos,ngintv
 4444 format(7i8)
!
      call cwrite31(bline,jiline,iline,iline_y)
      do igintv=0,ngintv
        write(31,4446)                                                  &
     &  igintv,mgintv(igintv),jdv_ig(igintv),enrg_ig(igintv)
      enddo
 4446 format(3i8,d16.8)
!
!
!   number of species and reactions:
      call cwrite31(bline,jiline,iline,iline_y)
      write(31,4450) nexpt, jxpt, ntxpt_inp                             &
     &             , ixpt_ran, nspec, nreac
 4450 format(7i8)
!
!   Virt. expt. Gaussian width-of-log-conc. parameters
      call cwrite31(bline,jiline,iline,iline_y)
      write(31,4460) glob_scal,widlog_spec, fdtxdi
 4460 format(d16.8,2f16.8)
!
!   initial + final time, number of time steps,
!   time integrtn. option
      call cwrite31(bline,jiline,iline,iline_y)
      write(31,4470) time0, time1, ntime, ntskip, jtime, jrlim
 4470 format(2f16.8,4i8)
!
!   Adaptive Runge Kutta (ARK) kin. solver parameters
!c    if(jtime.ge.10) then
!
!DRLIM190524-2244:
        call cwrite31(bline,jiline,iline,iline_y)
!X      write(31,4472) eps_ark,dtime_rl,nstp_ark, jsto_ark
        write(31,4472) eps_ark,dtime_rl,nlim_all, jsto_ark
 4472   format(2d16.8,2i8)
!
!c      if(nlim_all.eq.-1) then
!c        nlim_drv=-1
!c        nstp_ark=nlim_all
!c      endif
!
        if(nlim_all.eq.-1) then
          call cwrite31(bline,jiline,iline,iline_y)
          write(31,4473) nstp_ark, nlim_drv, idum1, idum1, idum1, idum1, idum1, idum1
 4473   format(8i8)
        endif
!:DRLIM190524-2244
!
        call cwrite31(bline,jiline,iline,iline_y)
        write(31,4474) rdtsto_ark,rhini_ark                             &
     &            ,rhmin1_ark,rhmin2_ark
 4474   format(4d16.8)
!c    endif
!
!   expt'l. time points
      call cwrite31(bline,jiline,iline,iline_y)
      do itxpt=1,ntxpt
        write(31,4480) itxpt,time_xpt(itxpt)
      enddo
 4480 format(i8,f16.8)
!
!   Fourier filtering time segments and frequencies
      do iexpt=1,nexpt
        call cwrite31(bline,jiline,iline,iline_y)
!
        if(nsegft(iexpt).le.-9999999) then
          idum1=-nsegft(iexpt)
          write(31,4490) idum1, nsegft(iexpt)
          goto 590
        endif
!
        write(31,4490) iexpt,nsegft(iexpt)
 4490   format(2i10)
!
        do isegft=1,nsegft(iexpt)
          call cwrite31(bline,jiline,iline,iline_y)
!
          write(31,4492) isegft                                         &
     &              ,time_fti(isegft,iexpt)                             &
     &              ,time_ftf(isegft,iexpt)                             &
     &              ,nft_time(isegft,iexpt)                             &
     &              ,nfil_frq(isegft,iexpt)
 4492     format(8x,i8,2d16.8,2i8)
!
!
          call cwrite31(bline,jiline,iline,iline_y)
!
          write(31,4493)                                                &
     &               bfil_frq(isegft,iexpt)                             &
     &              ,cfil_frq(isegft,iexpt)                             &
     &              ,jfil_frq(isegft,iexpt)                             &
     &              ,nsho_frq(isegft,iexpt)
 4493     format(16x,2d16.8,2i8)
!
!
          call cwrite31(bline,jiline,iline,iline_y)
!
          write(31,4494) (ift_freq_fil(ifil_frq,isegft,iexpt)           &
     &               ,ifil_frq=1,nfil_frq(isegft,iexpt))
 4494     format(10i6)
!
!
          call cwrite31(bline,jiline,iline,iline_y)
!
          write(31,4495) (ift_freq_sho(isho_frq,isegft,iexpt)           &
     &               ,isho_frq=1,nsho_frq(isegft,iexpt))
 4495     format(10i6)
        enddo
      enddo
!
  590 continue
!
!
!   output control parameters
!
      call cwrite31(bline,jiline,iline,iline_y)
      write(31,4590)                                                    &
     &           jo_ar,jo_xspec                                         &
     &          ,jo_th,jo_th_opt1,jo_th_opt2
 4590 format(3i8,2i16)
!
!
!   names and initial-/fixed-conc. parameters of reacting species:
!
      do ispec=1,nspec
        ispre=ispec
!
        call cwrite31(bline,jiline,iline,iline_y)
!
        write(31,2110) namespec(ispec)
        write(31,4610) jpmspec(ispec)                                   &
     &                ,mpulse(ispec)                                    &
     &                ,nperiod(ispec)                                   &
     &                ,jmsspec(ispec)                                   &
     &                ,xspec_min(ispec)                                 &
     &                ,xspec_max(ispec)
 4610   format(4i8,2d16.8)
!
        if(jmsspec_ft(ispec).eq.2) then
          call cwrite31(bline,jiline,iline,iline_y)
!
          do iexpt=1,nexpt
            if(nsegft(iexpt).ge.1) then
              do isegft=1,nsegft(iexpt)
                write(31,4615)                                          &
     &          iexpt,isegft,gfour_spec(ispec,isegft,iexpt)
 4615           format(2i8,d16.8)
              enddo
            endif
          enddo
        endif
!
        call cwrite31(bline,jiline,iline,iline_y)
!
        do ipm=1,npmspec(ispec)
          ivpm=1
          if(idokin_spre(ispec,ipm).gt.0)                               &
     &    ivpm=-ldokin(idokin_spre(ispec,ipm))
!
          write(31,4620) ipm,ivpm,pmspec(ispec,ipm,1)                   &
     &                  ,jctspec(ispec,ipm),jbcspec(ispec,ipm)
 4620     format(2i8,d16.8,2i8)
!
          if( nvpmspec(ispec,ipm).ge.2                                  &
     &    .and.jctspec(ispec,ipm).lt.300) then
            do ivpm=2,nvpmspec(ispec,ipm)
              write(31,4630) ipm,ivpm,pmspec(ispec,ipm,ivpm)
 4630         format(2i8,d16.8)
            enddo
          endif
        enddo
!
!
        do idpen=(kdpen_spre(ispre-1)+1),kdpen_spre(ispre)
          ipm=ipm_dpen(idpen)
!
          call cwrite31(bline,jiline,iline,iline_y)
!
          write(31,4710) ipm,mparn_dpen(idpen)                          &
     &              ,jprio_dpen(idpen)                                  &
     &              ,jfunc_dpen(idpen)
 4710     format(4i8)
          if(jfunc_dpen(idpen).eq.-1) then
            write(31,2110) namefunc_dpen(idpen)
          endif
!
          call cwrite31(bline,jiline,iline,iline_y)
!
          do iparn=1,mparn_dpen(idpen)
            write(31,4720) iparn,ipm_parn(iparn,idpen)                  &
     &                          ,ti_parn(iparn,idpen)
 4720       format(8x,2i8,d16.8)
!
            if(ipm_parn(iparn,idpen).ne.0) then
              write(31,2110) nmparn(iparn,idpen)
            else
              write(31,4730) pmparn(iparn,idpen)
 4730         format(24x,d16.8)
            endif
          enddo
        enddo
!
      enddo
!
!   reaction network by reaction number:
!
      do ireac=1,nreac
        ispre=ireac+nspec
!
        call cwrite31(bline,jiline,iline,iline_y)
!
        write(31,2110) namereac(ireac)
!
        write(31,4850) nipart(ireac),nopart(ireac)                      &
     &                ,jpmreac(ireac)
 4850   format(8x,3i8)
!
!     reactants:
        do ipart=1,nipart(ireac)
          write(31,2110) nameispec(ipart,ireac)
        enddo
!
        if(jkin(ireac).eq.41) then
!
          call cwrite31(bline,jiline,iline,iline_y)
          idum=0
          write(31,4851)               &
     &     ncplex(ireac)               &
     &    ,iicplex(ireac)              &
     &    ,iocplex(ireac)              &
     &    ,idum                        &
     &    ,idum                        &
     &    ,idum                        &
     &    ,idum                        &
     &    ,idum                        &
     &    ,idum                        &
     &    ,idum
 4851     format(10i8)
!
          call cwrite31(bline,jiline,iline,iline_y)
          do icplex=1,ncplex(ireac)
            idum=0
            write(31,4852)               &
     &       mpplex(icplex,ireac)        &
     &      ,idum                        &
     &      ,idum                        &
     &      ,idum                        &
     &      ,idum                        &
     &      ,idum                        &
     &      ,idum                        &
     &      ,idum                        &
     &      ,idum                        &
     &      ,idum
 4852       format(10i8)
          enddo
        endif
!
!     products:
        if(                                         &
     &  jkin(ireac).ne.40.and.                      &
     &  jkin(ireac).ne.41                           &
     &  )then
          do ipart=1,nopart(ireac)
            write(31,2110) nameospec(ipart,ireac)
          enddo
        endif
!
!     control parameters
        call cwrite31(bline,jiline,iline,iline_y)
        do ipm=1,npmreac(ireac)
          ivpm=1
          if(idokin_spre(ireac+nspec,ipm).gt.0)                         &
     &    ivpm=-ldokin(idokin_spre(ireac+nspec,ipm))
!
          write(31,4860) ipm,ivpm,pmreac(ireac,ipm,1)                   &
     &                  ,jctreac(ireac,ipm),jbcreac(ireac,ipm)
 4860     format(2i8,d16.8,2i8)
!
          if(nvpmreac(ireac,ipm).ge.2                                   &
     &    .and.jctreac(ireac,ipm).lt.300) then
            do ivpm=2,nvpmreac(ireac,ipm)
              write(31,4870) ipm,ivpm,pmreac(ireac,ipm,ivpm)
 4870         format(2i8,d16.8)
            enddo
          endif
        enddo
!
!
        do idpen=(kdpen_spre(ispre-1)+1),kdpen_spre(ispre)
          ipm=ipm_dpen(idpen)
!
          call cwrite31(bline,jiline,iline,iline_y)
!
          write(31,4910) ipm,mparn_dpen(idpen)                          &
     &              ,jprio_dpen(idpen)                                  &
     &              ,jfunc_dpen(idpen)
 4910     format(4i8)
          if(jfunc_dpen(idpen).eq.-1) then
            write(31,2110) namefunc_dpen(idpen)
          endif
!
          call cwrite31(bline,jiline,iline,iline_y)
!
          do iparn=1,mparn_dpen(idpen)
            write(31,4920) iparn,ipm_parn(iparn,idpen)                  &
     &                          ,ti_parn(iparn,idpen)
 4920       format(8x,2i8,d16.8)
!
            if(ipm_parn(iparn,idpen).ne.0) then
              write(31,2110) nmparn(iparn,idpen)
            else
              write(31,4930) pmparn(iparn,idpen)
 4930         format(24x,d16.8)
            endif
          enddo
        enddo
!
      enddo
!
      do ildokin=1,mldokin
        iline=iline_dokin(1,ildokin)-1
        call cwrite31(bline,jiline,iline,iline_y)
!
        write(31,4940) ldokin_inp(ildokin)
 4940   format(i8)
!
        iline=iline_dokin(2,ildokin)-1
        call cwrite31(bline,jiline,iline,iline_y)
        do iexpt=1,nexpt
          write(31,4942)                                                &
     &     iexpt                                                        &
     &    ,jdokin_expt(iexpt,idokin_inp(ildokin))
 4942     format(2i8)
        enddo
  489   continue
      enddo
!
      write(31,5100) vcode
 5100 format(// ' Code Version:'           &
     &        /a80//)
!
!
      write(31,5101) mp_nproc
 5101 format(' Number of Processors:'           &
     &        /i8)
!
      iun=31
      close(iun)
!
      goto 989
  980 continue
            errtag='000041'
            call err_term
  989 continue
!
!
  990 continue
!
!
      if(jdb_i01.eq.1) then
        write(39,*) 'LEAVING "idat", mp_myid=', mp_myid
        write(39,*) ' '
        write(39,*) ' '
      endif
      close(39)
      inquire(file='ens.o09',exist=fexist)
      if(fexist) then
        open(39,file='ens.o09',status='old')
        iun=39
        call efile(iun)
      else
!BLADE:
!       open(39,file='ens.o09',status='new')
        open(39,file='ens.o09')
!:BLADE
      endif
!
!
!V090911:
      close(39)
      call mp_qfin
!:V090911
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine cread21(bline,jiline,iline,iline_x)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      implicit none
!
      integer iline, iline_x, iline_err
!
      integer jiline(0:iline_x)
!
      character*80 aline, bline(0:iline_x), aline_err
!
   10 continue
!
      read(21,2010,end=90) aline
 2010 format(a80)
      goto 190
   90   continue
        if(iline.gt.iline_x) goto 20
        jiline(iline)=-1
        return
  190 continue
!
      iline=iline+1
!
   20 continue
      if(iline.gt.iline_x) then
        iline_err=iline
        aline_err=aline
        call cread21_err(iline_err,aline_err)
      endif
!
      bline(iline)=aline
!
      if(index(aline(1:1),'#').ne.0) then
        jiline(iline)=0
        goto 10
      else
        jiline(iline)=1
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine cread21_err(iline_err,aline_err)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! reads input data from "ens.i01" and
! writes them into "ens.o01"
!
      include 'ens.def'
!
      character*80 aline_err
      integer iline_err
!
      aline=aline_err
      iline=iline_err
!
      errtag='000042'
      call err_term
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine cwrite31(bline,jiline,iline,iline_x)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      implicit none
!
      integer iline, iline_x
!
      integer jiline(0:iline_x)
!
      character*80 aline, bline(0:iline_x)
!
   10 continue
!
      iline=iline+1
      write(31,2010) bline(iline)
 2010 format(a80)
!
      if(jiline(iline).eq.0) goto 10
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      function myint(r)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      implicit none
!
      integer myint, jsign
      real*8 r, rabs
!
      jsign=1
      if(r.lt.0) jsign=-1
      rabs=dabs(r)+0.5d0
!
      myint=rabs
      myint=myint*jsign
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine idat_inipm
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
      kth_spec_gse=0
      kth_reac_gse=0
!
      if(jmc_inir.eq.141.or.jmc_inir.eq.143.or.                         &
     &  (jmc_inir.ge.340.and.jmc_inir.le.399)) then
        do ith=1,mth_tot
          fstp_swo(ith)=1.d0
        enddo
        fstp_swo(mth_tot+1)=1.d0
        fstp_swo(mth_tot+11)=1.d0
        fstp_swo(mth_tot+12)=1.d0
      endif
!
      jrd_th=0
      jrd_swo=0
!
      if(jmc_inir.eq.140.or.jmc_inir.eq.142.or.                         &
     &  (jmc_inir.ge.340.and.jmc_inir.le.399)) jrd_swo=1
!
      if(jmc_inir.ge.140.and.jmc_inir.lt.150) then
        open(24,file='ens.i12',status='old')
        rewind(24)
      endif
!
!
   10 continue
      read(24,2010,end=90) aline
 2010 format(a80)
!
!ccccc NOT YET IMPLEMENTED:
!c    if(index(aline,'GROW THETA').ne.0) call idat_gse_th
!c    if(index(aline,'SHRINK THETA').ne.0) call idat_gse_th
!c    if(index(aline,'EDIT THETA').ne.0) call idat_gse_th
!c    read(24,2010,end=90) aline
!ccccc
!
      if(index(aline,' cspec_th ').eq.0) goto 10
!
      read(24,*,end=90,err=10)                                          &
     & (cspec_th(ith),ith=1,(mth_spec-kth_spec_gse))
!
!
   12 continue
      read(24,2010,end=90,err=10) aline
!
      if(index(aline,'iout_th').ne.0) goto 10
      if(index(aline,' chisq_th ').ne.0) goto 10
      if(index(aline,' rreac_th ').eq.0) goto 12
!
      read(24,*,end=90,err=10)                                          &
     & (rreac_th(ith),ith=1,(mth_reac-kth_reac_gse))
!
!ccccc NOT YET IMPLEMENTED:
!c    call sto_gse_th
!ccccc
!
      do ith=1,mth_spec
        ispec=ispec_th(ith)
        ipm=ipmspec_th(ith)
        cspec(ispec,ipm)=cspec_th(ith)
      enddo
!
      do ith=1,mth_reac
        ireac=ireac_th(ith)
        ipm=ipmreac_th(ith)
        rreac(ireac,ipm) =rreac_th(ith)
      enddo
      jrd_th=1
!
!
      if(jmc_inir.ge.340.and.jmc_inir.le.399) goto 990
!
!
      if(jmc_inir.eq.141.or.jmc_inir.eq.143) then
   20   continue
        read(24,2010,end=90) aline
!
        if(index(aline,' fstp_swo ').eq.0) goto 20
!
        read(24,*,end=90,err=10) (fstp_swo(ith),ith=1,mth_tot)
        read(24,*,end=90,err=10) fstp_swo(mth_tot+1)                    &
     &                          ,fstp_swo(mth_tot+11)                   &
     &                          ,fstp_swo(mth_tot+12)
        jrd_swo=1
      endif
!
      goto 10
!
!
   90 continue
      close(24)
!
!
      if(jrd_th.eq.0.or.                                                &
     &  (jmc_inir.ge.340.and.jmc_inir.le.399)) then
            errtag='000043'
            call err_term
      endif
!
      if(jrd_swo.eq.0) then
        open(31,file='ens.o01',status='old')
        iun=31
        call efile(iun)
        write(31,*) '  '
        write(31,*) '  '
        write(31,*) 'WARNING in "idat_inipm"'
        write(31,*)                                                     &
     &  ' no complete, readable fstp_swo was found in "ens.i12"'
        write(31,*)                                                     &
     &  ' initialization by default (fstp_swo=1.0) and/or '
        write(31,*)                                                     &
     &  ' read-in fragments from "ens.i12" will be used instead'
        write(31,*) ' EXECUTION CONTINUED'
        close(31)
      endif
!
!
      if(jmc_inir.eq.142.or.jmc_inir.eq.143) then
        open(28,file='ens.i14',status='old')
        rewind(28)
!
  110   continue
        read(28,2010,end=190) aline
!
        if(index(aline,'iout_dos').eq.0) goto 110
!
!
  112   continue
        read(28,2010,end=190) aline
!
        if(index(aline,'it_dos mck_dos nacc_dos').eq.0) goto 112
!
!      input line:
!      "ith_rk  ith_cs it_dos mck_dos nacc_dos ..."
        read(28,*) idum1,idum2,it_dos,mck_dos,nacc_dos
!
!
  114   continue
        read(28,2010,end=190) aline
!
        if(index(aline,'aln_dos_ie_o').eq.0) goto 114
!
        ien_base=0
        nen_inc=5
        do ien_line=0,neintv+1
          if((ien_base+nen_inc-1).gt.(neintv+1)) then
            nen_inc=neintv+2-ien_base
            if(nen_inc.lt.1) goto 120
          endif
          read(28,*) (aln_dos_ie(ien_base+ien_inc-1),ien_inc=1,nen_inc)
          ien_base=ien_base+5
          if(ien_base.gt.(neintv+1)) goto 120
        enddo
  120   continue
!
        read(28,2010) aline
!
        ien_base=0
        nen_inc=5
        do ien_line=0,neintv+1
          if((ien_base+nen_inc-1).gt.(neintv+1)) then
            nen_inc=neintv+2-ien_base
            if(nen_inc.lt.1) goto 130
          endif
          read(28,*) (hist_ie(ien_base+ien_inc-1),ien_inc=1,nen_inc)
          ien_base=ien_base+5
          if(ien_base.gt.(neintv+1)) goto 130
        enddo
  130   continue
!
        goto 110
!
  190   continue
        close(28)
!
        call zero_wlit
        ien_base=mck_dos
        mck_dos=-2
        mo_dos=no_dos
!
        call ckcvg_dos
!
        call zero_wlit
        mck_dos=ien_base
      endif
!
  990 continue
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine idat_rstart
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! read Theta etc. for MC restarts from "ens.o02" or
! for MC re-accumulation from "ens.i12"
!
      include 'ens.def'
!
      iout_th_rst=-1
!
      ihtot_amb_ini=0
      ihtot_pst_ini=0
      ihtot_pge_ini=0
!
   10 continue
      jidat_amb=0
      jidat_pst=0
      jidat_pge=0
!
      ihtot_amb_rst=-1
      ihtot_pst_rst=-1
      ihtot_pge_rst=-1
!
!
      if(jmc_inir.ge.240.and.jmc_inir.lt.250) iun_rst=32
      if(jmc_inir.ge.340.and.jmc_inir.le.399) iun_rst=24
!
      read(iun_rst,2010,end=990) aline
 2010 format(a80)
      if(index(aline,'RESTART').ne.0) goto 12
!
      if(index(aline,'iout_th').eq.0) goto 10
      read(iun_rst,*,end=990,err=12) iout_th_rst
      if(iout_th_rst.eq.0) goto 10
!
!
      goto 19
   12   continue
!
        read(iun_rst,2010,end=990) aline
        if(index(aline,'iout_th').eq.0) goto 12
!
   14 continue
        open(31,file='ens.o01',status='old')
        rewind(31)
        iun0=31
        call efile(iun0)
        write(31,*) '   '
        write(31,*) ' INFO:'
        write(31,*)                                                     &
     &   ' Non-fatal read-in error by "idat_rstart"'                    &
     &  ,' in "ens.o02" near/after:'
        write(31,*) ' iout_th_rst, iout_th_rsi='
        write(31,*)   iout_th_rst, iout_th_rsi
!
        write(31,*)                                                     &
     &  ' jmvloop,imc_rep,imc_eql,imc_acc,imc_upd='
        write(31,*)                                                     &
     &    jmvloop,imc_rep,imc_eql,imc_acc,imc_upd
!
        write(31,*)                                                     &
     &   ' jmvloop_rsi,imc_rep_rsi,imc_eql_rsi'                         &
     &  ,',imc_acc_rsi,imc_upd_rsi='
        write(31,*)                                                     &
     &    jmvloop_rsi,imc_rep_rsi,imc_eql_rsi                           &
     &   ,imc_acc_rsi,imc_upd_rsi
!
        write(31,*)                                                     &
     &   ' jmvloop_rst,imc_rep_rst,imc_eql_rst'                         &
     &  ,',imc_acc_rst,imc_upd_rst='
        write(31,*)                                                     &
     &    jmvloop_rst,imc_rep_rst,imc_eql_rst                           &
     &   ,imc_acc_rst,imc_upd_rst
!
        write(31,*)                                                     &
     &    ' kmvsequ,imvsequ,jmty,imove,kmove,jrstarT='
        write(31,*)                                                     &
     &      kmvsequ,imvsequ,jmty(imvsequ,jmvloop),imove,kmove,jrstart
!
        write(31,*)                                                     &
     &  ' kmvsequ_rsi,imvsequ_rsi,jmty_rsi,imove_rsi,kmove_rsi='
        write(31,*)                                                     &
     &    kmvsequ_rsi,imvsequ_rsi,jmty_rsi,imove_rsi,kmove_rsi
!
        write(31,*)                                                     &
     &  ' kmvsequ_rst,imvsequ_rst,jmty_rst,imove_rst,kmove_rst='
        write(31,*)                                                     &
     &    kmvsequ_rst,imvsequ_rst,jmty_rst,imove_rst,kmove_rst
        write(31,*) ' EXECUTION CONTINUED'
        close(31)
!
        read(iun_rst,*,end=990,err=12) iout_th_rst
!
!
        jidat_amb=0
        jidat_pst=0
        jidat_pge=0
!
        ihtot_amb_rst=-1
        ihtot_pst_rst=-1
        ihtot_pge_rst=-1
!
!
   19 continue
!
!
   20 continue
      read(iun_rst,2010,end=990) aline
      if(index(aline,'iout_th').ne.0) goto 14
      if(index(aline,'RESTART').ne.0) goto 12
!
      if(index(aline,'start configuration').ne.0) goto 10
      if(index(aline,'Start configuration').ne.0) goto 10
      if(index(aline,'Start Configuration').ne.0) goto 10
!
      if(index(aline,'ihtot_amb').ne.0) jidat_amb=1
      if(index(aline,'ihtot_pst').ne.0) jidat_pst=1
      if(index(aline,'ihtot_pge').ne.0) jidat_pge=1
!
      if(index(aline,'ihtot_amb').ne.0                                  &
     &.or.index(aline,'nhtot_amb').ne.0) then
        read(iun_rst,*,end=990,err=12) ihtot_amb_rst
      endif
!
      if(index(aline,'ihtot_pst').ne.0                                  &
     &.or.index(aline,'nhtot_pst').ne.0) then
        read(iun_rst,*,end=990,err=12) ihtot_pst_rst
      endif
!
      if(index(aline,'ihtot_pge').ne.0                                  &
     &.or.index(aline,'nhtot_pge').ne.0) then
        read(iun_rst,*,end=990,err=12) ihtot_pge_rst
      endif
!
      if(index(aline,'jmvloop imc_rep imc_eql imc_acc').eq.0) goto 20
      if(index(aline,'..._rst').ne.0) goto 20
!
!
      if(index(aline,' kmove').eq.0) then
        read(iun_rst,*,end=990,err=12)                                  &
     &    jmvloop_rst,imc_rep_rst,imc_eql_rst                           &
     &   ,imc_acc_rst,imc_upd_rst                                       &
     &   ,imvsequ_rst,jmty_rst,imove_rst
        kmove_rst=imove_rst
      else
        read(iun_rst,*,end=990,err=12)                                  &
     &    jmvloop_rst,imc_rep_rst,imc_eql_rst                           &
     &   ,imc_acc_rst,imc_upd_rst                                       &
     &   ,imvsequ_rst,jmty_rst,imove_rst,kmove_rst
      endif
!
      if(jmvloop_rst.lt.1.or.jmvloop_rst.gt.2) then
            errtag='000044'
            call err_term
      endif
!
      if(                                                               &
     & imvsequ_rst.lt.-1.or.                                            &
     & imvsequ_rst.gt.nmvsequ(jmvloop_rst)                              &
     &)then
            errtag='000045'
            call err_term
      endif
!
      kmvsequ_rst=kmvsequ_mvs(imvsequ_rst,jmvloop_rst)
!
      if(jo_th.eq.51) then
   30   continue
        read(iun_rst,2010,end=990) aline
        if(index(aline,'iout_th').ne.0) goto 14
        if(index(aline,'RESTART').ne.0) goto 12
!
        if(index(aline,' ith_rk  ith_cs').eq.0) goto 30
!
        read(iun_rst,*,end=990,err=12) ith_rk_rst,ith_cs_rst
        if(.not.(                                                       &
     &    (ith_rk_rst.eq.-1.and.ith_cs_rst.eq.-1)                       &
     &  .or.                                                            &
     &    (ith_rk_rst.eq.-1.and.ith_cs_rst.eq.mth_spec                  &
     &     .and.jmty_rst.lt.7).or.                                      &
     &    (ith_rk_rst.eq.mth_reac.and.ith_cs_rst.eq.-1                  &
     &     .and.jmty_rst.lt.7).or.                                      &
     &    (ith_rk_rst.eq.mth_reac.and.ith_cs_rst.eq.mth_spec            &
     &     .and.jmty_rst.lt.7)                                          &
     &  .or.                                                            &
     &    (ith_rk_rst.eq.-1.and.ith_cs_rst.eq.mth_tot                   &
     &     .and.jmty_rst.ge.7).or.                                      &
     &    (ith_rk_rst.eq.mth_tot.and.ith_cs_rst.eq.-1                   &
     &     .and.jmty_rst.ge.7)                                          &
     &  ))                                                              &
     &  goto 10
      endif
!
!
   40 continue
      read(iun_rst,2010,end=990) aline
      if(index(aline,'iout_th').ne.0) goto 14
      if(index(aline,'RESTART').ne.0) goto 12
!
      if(index(aline,'Min ChiSq_Th').ne.0) then
        goto 10
      endif
!
      if(index(aline,' chisq_th ').eq.0) goto 40
!
      read(iun_rst,*,end=990,err=12) chisq_th_rst                       &
     &                       , chisq_th_min_rst                         &
     &                       , chisq_th_max_rst
!
      if(jmc_inir.eq.350) goto 850
!
   45   continue
        read(iun_rst,2010,end=990) aline
        if(index(aline,'iout_th').ne.0) goto 14
        if(index(aline,'RESTART').ne.0) goto 12
!
        if(index(aline,' sxplog_ks_th').eq.0) goto 45
!
        do kscal=1,nkscal
          read(iun_rst,*,end=990,err=12)                                &
     &     idum1,idum2                                                  &
     &    ,adum1,adum2,adum3                                            &
     &    ,sxplog_ks_th_rst(kscal)
        enddo
!
!
      if(jo_th_hto.ge.1) then
   50   continue
        read(iun_rst,2010,end=990) aline
        if(index(aline,'iout_th').ne.0) goto 14
        if(index(aline,'RESTART').ne.0) goto 12
!
        if(index(aline,' htot_th ').eq.0) goto 50
!
        read(iun_rst,*,end=990,err=12)                                  &
     &                           htot_th_rst                            &
     &                         , htot_th_min_rst                        &
     &                         , htot_th_max_rst
!
!
        if(jo_th_hto.ge.2) then
   52     continue
          read(iun_rst,2010,end=990) aline
          if(index(aline,'iout_th').ne.0) goto 14
          if(index(aline,'RESTART').ne.0) goto 12
!
          if(index(aline,' hwall_th ').eq.0) goto 52
!
          read(iun_rst,*,end=990,err=12)                                &
     &                             hwall_th_rst                         &
     &                           , hwall_th_min_rst                     &
     &                           , hwall_th_max_rst
        endif
!
        if(jo_th_hto.ge.3) then
   54     continue
          read(iun_rst,2010,end=990) aline
          if(index(aline,'iout_th').ne.0) goto 14
          if(index(aline,'RESTART').ne.0) goto 12
!
          if(index(aline,' hbxx_th ').eq.0) goto 54
!
          read(iun_rst,*,end=990,err=12)                                &
     &                             hbxx_th_rst                          &
     &                           , hbxx_th_min_rst                      &
     &                           , hbxx_th_max_rst
        endif
!
        if(jo_th_hto.ge.4) then
   56     continue
          read(iun_rst,2010,end=990) aline
          if(index(aline,'iout_th').ne.0) goto 14
          if(index(aline,'RESTART').ne.0) goto 12
!
          if(index(aline,' hbxn_th ').eq.0) goto 56
!
          read(iun_rst,*,end=990,err=12)                                &
     &                             hbxn_th_rst                          &
     &                           , hbxn_th_min_rst                      &
     &                           , hbxn_th_max_rst
        endif
!
        if(jo_th_hto.ge.2) then
   58     continue
          read(iun_rst,2010,end=990) aline
          if(index(aline,'iout_th').ne.0) goto 14
          if(index(aline,'RESTART').ne.0) goto 12
!
          if(index(aline,' hfour_th ').eq.0) goto 58
!
          read(iun_rst,*,end=990,err=12)                                &
     &                             hfour_th_rst                         &
     &                           , hfour_th_min_rst                     &
     &                           , hfour_th_max_rst
        endif
!
        if(jo_th_hto.ge.3) then
   60     continue
          read(iun_rst,2010,end=990) aline
          if(index(aline,'iout_th').ne.0) goto 14
          if(index(aline,'RESTART').ne.0) goto 12
!
          if(index(aline,' hfous_th ').eq.0) goto 60
!
          read(iun_rst,*,end=990,err=12)                                &
     &                             hfous_th_rst                         &
     &                           , hfous_th_min_rst                     &
     &                           , hfous_th_max_rst
        endif
!
        if(jo_th_hto.ge.4) then
   62     continue
          read(iun_rst,2010,end=990) aline
          if(index(aline,'iout_th').ne.0) goto 14
          if(index(aline,'RESTART').ne.0) goto 12
!
          if(index(aline,' hfout_th ').eq.0) goto 62
!
          read(iun_rst,*,end=990,err=12)                                &
     &                             hfout_th_rst                         &
     &                           , hfout_th_min_rst                     &
     &                           , hfout_th_max_rst
        endif
      endif
!
!
      if(jo_th_cu.eq.1) then
   68   continue
        read(iun_rst,2010,end=990) aline
        if(index(aline,'iout_th').ne.0) goto 14
        if(index(aline,'RESTART').ne.0) goto 12
!
        if(index(aline,' chisq_uth ').eq.0) goto 68
!
        read(iun_rst,*,end=990,err=12) chisq_uth_rst                    &
     &                  , chisq_uth_min_rst                             &
     &                  , chisq_uth_max_rst
      endif
!
!
      if(jo_th_bxx.ge.1) then
   72   continue
        read(iun_rst,2010,end=990) aline
        if(index(aline,'iout_th').ne.0) goto 14
        if(index(aline,'RESTART').ne.0) goto 12
!
        if(index(aline,' fbxx_th ').eq.0) goto 72
!
        read(iun_rst,*,end=990,err=12)                                  &
     &                           (fbxx_th_rst(ivs),ivs=0,nvs_spec)
      endif
!
!
      if(jo_th_bxn.ge.1) then
   74   continue
        read(iun_rst,2010,end=990) aline
        if(index(aline,'iout_th').ne.0) goto 14
        if(index(aline,'RESTART').ne.0) goto 12
!
        if(index(aline,' fbxn_th ').eq.0) goto 74
!
        read(iun_rst,*,end=990,err=12)                                  &
     &                           (fbxn_th_rst(ivs),ivs=0,nvs_spec)
      endif
!
  850 continue
!
   82 continue
      read(iun_rst,2010,end=990) aline
      if(index(aline,'iout_th').ne.0) goto 14
      if(index(aline,'RESTART').ne.0) goto 12
!
      if(index(aline,' cspec_th').eq.0) goto 82
!
      read(iun_rst,*,end=990,err=12)                                    &
     & (cspec_th_rst(ith),ith=1,mth_spec)
!
   84   continue
      read(iun_rst,2010,end=990) aline
      if(index(aline,'iout_th').ne.0) goto 14
      if(index(aline,'RESTART').ne.0) goto 12
!
        if(index(aline,' rreac_th ').eq.0) goto 84
!
      read(iun_rst,*,end=990,err=12)                                    &
     & (rreac_th_rst(ith),ith=1,mth_reac)
!
      if(                                                               &
     & (jmc_inir.eq.241.or.jmc_inir.eq.341                              &
     & .or.jmc_inir.eq.361)                                             &
     & .and.jo_th_sw.eq.1                                               &
     &)then
   90   continue
        read(iun_rst,2010,end=990) aline
        if(index(aline,'iout_th').ne.0) goto 14
        if(index(aline,'RESTART').ne.0) goto 12
!
        if(index(aline,' fstp_swo ').eq.0) goto 90
!
        read(iun_rst,*,end=990,err=12)                                  &
     &   (fstp_swo_rst(ith),ith=1,mth_tot)
        read(iun_rst,*,end=990,err=12)                                  &
     &                             fstp_swo_rst(mth_tot+1)              &
     &                            ,fstp_swo_rst(mth_tot+11)             &
     &                            ,fstp_swo_rst(mth_tot+12)
!
        if(jmty_rst.ge.1000.and.jmty_rst.le.4999) then
          read(iun_rst,*,end=990,err=12)                                &
     &                             fstp_swo_rst(mth_tot+21)             &
     &                            ,fstp_swo_rst(mth_tot+22)             &
     &                            ,fstp_swo_rst(mth_tot+23)             &
     &                            ,fstp_swo_rst(mth_tot+24)             &
     &                            ,fstp_swo_rst(mth_tot+25)             &
!
     &                            ,fstp_swo_rst(mth_tot+31)             &
     &                            ,fstp_swo_rst(mth_tot+32)             &
     &                            ,fstp_swo_rst(mth_tot+33)             &
     &                            ,fstp_swo_rst(mth_tot+34)             &
     &                            ,fstp_swo_rst(mth_tot+35)
        endif
!
        if(jmty_rst.ge.3000.and.jmty_rst.le.4999) then
          read(iun_rst,*,end=990,err=12)                                &
     &                             fstp_swo_rst(mth_tot+41)             &
     &                            ,fstp_swo_rst(mth_tot+42)             &
     &                            ,fstp_swo_rst(mth_tot+43)             &
     &                            ,fstp_swo_rst(mth_tot+44)             &
     &                            ,fstp_swo_rst(mth_tot+45)
        endif
      endif
!
!
! restore the last complete read-in Theta output block:
!
!cc   if(jidat_amb.eq.0
!cc  :.or.
!cc  :(jidat_amb.ge.1.and.chisq_th_rst.lt.chisq_th)
!cc  :) then
        do ith=1,mth_spec
          ispec=ispec_th(ith)
          ipm=ipmspec_th(ith)
          cspec_th(ith)=cspec_th_rst(ith)
          cspec(ispec,ipm)=cspec_th_rst(ith)
        enddo
!
        do ith=1,mth_reac
          ireac=ireac_th(ith)
          ipm=ipmreac_th(ith)
          rreac_th(ith)=rreac_th_rst(ith)
          rreac(ireac,ipm)=rreac_th(ith)
        enddo
!
        if(                                                             &
     &  (jmc_inir.ge.240.and.jmc_inir.lt.250)                           &
     &  .or.jmc_inir.eq.361                                             &
     &  )then
          iout_th=iout_th_rst
          chisq_th=chisq_th_rst
          chisq_th_min=chisq_th_min_rst
!
          chisq_th_min0=chisq_th_min_rst
!
          chisq_th_max=chisq_th_max_rst
!
          if(ihtot_amb_rst.gt.0) ihtot_amb_ini=ihtot_amb_rst
          if(ihtot_pst_rst.gt.0) ihtot_pst_ini=ihtot_pst_rst
          if(ihtot_pge_rst.gt.0) ihtot_pge_ini=ihtot_pge_rst
!
          do kscal=1,nkscal
            sxplog_ks_th(kscal)=                                        &
     &      sxplog_ks_th_rst(kscal)
          enddo
!
          if(jo_th_cu.eq.1) then
            chisq_uth=chisq_uth_rst
            chisq_uth_min=chisq_uth_min_rst
            chisq_uth_max=chisq_uth_max_rst
          endif
!
          if(jo_th_hto.ge.1) then
            if(jo_th_hto.ge.3) then
              hbxx_th=hbxx_th_rst
              hbxx_th_min=hbxx_th_min_rst
              hbxx_th_max=hbxx_th_max_rst
              hbxx=hbxx_th_rst
            endif
!
            if(jo_th_hto.ge.4) then
              hbxn_th=hbxn_th_rst
              hbxn_th_min=hbxn_th_min_rst
              hbxn_th_max=hbxn_th_max_rst
              hbxn=hbxn_th_rst
            endif
!
            if(jo_th_hto.ge.2) then
              hwall_th=hwall_th_rst
              hwall_th_min=hwall_th_min_rst
              hwall_th_max=hwall_th_max_rst
              hwall=hwall_th_rst
!
              hfour_th=hfour_th_rst
              hfour_th_min=hfour_th_min_rst
              hfour_th_max=hfour_th_max_rst
              hfour=hfour_th_rst
!
              hfous_th=hfous_th_rst
              hfous_th_min=hfous_th_min_rst
              hfous_th_max=hfous_th_max_rst
              hfous=hfous_th_rst
!
              hfout_th=hfout_th_rst
              hfout_th_min=hfout_th_min_rst
              hfout_th_max=hfout_th_max_rst
              hfout=hfout_th_rst
            endif
!
            htot_th=htot_th_rst
            htot_th_min=htot_th_min_rst
            htot_th_max=htot_th_max_rst
            htot=htot_th_rst
          endif
!
          if(jo_th_bxx.ge.1) then
            do ivs=0,nvs_spec
              fbxx_th(ivs)=fbxx_th_rst(ivs)
              fbxx(ivs)=fbxx_th_rst(ivs)
            enddo
          endif
!
          if(jo_th_bxn.ge.1) then
            do ivs=0,nvs_spec
              fbxn_th(ivs)=fbxn_th_rst(ivs)
              fbxn(ivs)=fbxn_th_rst(ivs)
            enddo
          endif
        endif
!
        if((jmc_inir.eq.241.or.jmc_inir.eq.341                          &
     &  .or.jmc_inir.eq.361)                                            &
     &  .and.jo_th_sw.eq.1) then
          do ith=1,mth_tot
            fstp_swo(ith)=fstp_swo_rst(ith)
          enddo
          fstp_swo(mth_tot+1) =fstp_swo_rst(mth_tot+1)
          fstp_swo(mth_tot+11)=fstp_swo_rst(mth_tot+11)
          fstp_swo(mth_tot+12)=fstp_swo_rst(mth_tot+12)
!
          if(jmty_rst.ge.1000.and.jmty_rst.le.4999) then
            fstp_swo(mth_tot+21)=fstp_swo_rst(mth_tot+21)
            fstp_swo(mth_tot+22)=fstp_swo_rst(mth_tot+22)
            fstp_swo(mth_tot+23)=fstp_swo_rst(mth_tot+23)
            fstp_swo(mth_tot+24)=fstp_swo_rst(mth_tot+24)
            fstp_swo(mth_tot+25)=fstp_swo_rst(mth_tot+25)
!
            fstp_swo(mth_tot+31)=fstp_swo_rst(mth_tot+31)
            fstp_swo(mth_tot+32)=fstp_swo_rst(mth_tot+32)
            fstp_swo(mth_tot+33)=fstp_swo_rst(mth_tot+33)
            fstp_swo(mth_tot+34)=fstp_swo_rst(mth_tot+34)
            fstp_swo(mth_tot+35)=fstp_swo_rst(mth_tot+35)
          endif
!
!
          if(jmty_rst.ge.3000.and.jmty_rst.le.4999) then
            fstp_swo(mth_tot+41)=fstp_swo_rst(mth_tot+41)
            fstp_swo(mth_tot+42)=fstp_swo_rst(mth_tot+42)
            fstp_swo(mth_tot+43)=fstp_swo_rst(mth_tot+43)
            fstp_swo(mth_tot+44)=fstp_swo_rst(mth_tot+44)
            fstp_swo(mth_tot+45)=fstp_swo_rst(mth_tot+45)
          endif
!
        endif
!
        iout_th_rsi=iout_th_rst
        jmvloop_rsi=jmvloop_rst
        imc_rep_rsi=imc_rep_rst
        imc_eql_rsi=imc_eql_rst
        imc_acc_rsi=imc_acc_rst
        imc_upd_rsi=imc_upd_rst
        imvsequ_rsi=imvsequ_rst
        jmty_rsi=jmty_rst
        imove_rsi=imove_rst
!
        kmove_rsi=kmove_rst
!
        kmvsequ_rsi=kmvsequ_rst
!
        jamb_rsi=jidat_amb
        jpst_rsi=jidat_pst
        jpge_rsi=jidat_pge
!cc   endif
!
!
      if(jidat_amb.ge.1) goto 10
      if(jidat_pst.ge.1) goto 10
      if(jidat_pge.ge.1) goto 10
      goto 992
!
!
  990   continue
        jrstart=0
!
        call idat_tr_f
        call odat_tr_i
!
        idum1=imc_ran+iout_th+1
        call srandx(idum1,iseed2,jrand)
!
        rewind(32)
        iun0=32
        call efile(iun0)
        write(32,*) '   '
        write(32,*) '   '
        write(32,*) '   '
        write(32,*) '  RESTART  '
!
        write(32,3010)                                                  &
     &   jmvloop_rsi,imc_rep_rsi,imc_eql_rsi,imc_acc_rsi,imc_upd_rsi    &
     &  ,jmvloop_rst,imc_rep_rst,imc_eql_rst,imc_acc_rst,imc_upd_rst    &
!
     &  ,kmvsequ,imvsequ,jmty(imvsequ,jmvloop),imove,kmove              &
     &  ,kmvsequ_rsi,imvsequ_rsi,jmty_rsi,imove_rsi,kmove_rsi           &
     &  ,kmvsequ_rst,imvsequ_rst,jmty_rst,imove_rst,kmove_rst
 3010   format(                                                                 &
     &  /5i8                                                                    &
     &  /5i8                                                                    &
     &  /':kmvsequ:imvsequ::::jmty:::imove:::kmove/..._rsi/..._rst'     &
     &  /5i8                                                            &
     &  /5i8                                                            &
     &  /5i8                                                            &
     &  )
!
!
        open(31,file='ens.o01',status='old')
        rewind(31)
        iun0=31
        call efile(iun0)
        write(31,*) '   '
        write(31,*) ' INFO:'
        write(31,*)                                                     &
     &  ' Completed restart read-in from "ens.o02" at:'
        write(31,*)                                                     &
     &  ' iout_th,iout_th_rst,iout_th_rsi,jrstarT='
        write(31,*)                                                     &
     &    iout_th,iout_th_rst,iout_th_rsi,jrstart
!
        write(31,*)                                                     &
     &  ' jmvloop,imc_rep,imc_eql,imc_acc,imc_upd='
        write(31,*)                                                     &
     &    jmvloop,imc_rep,imc_eql,imc_acc,imc_upd
!
        write(31,*)                                                     &
     &   ' jmvloop_rsi,imc_rep_rsi,imc_eql_rsi'                         &
     &  ,',imc_acc_rsi,imc_upd_rsi='
        write(31,*)                                                     &
     &    jmvloop_rsi,imc_rep_rsi,imc_eql_rsi                           &
     &   ,imc_acc_rsi,imc_upd_rsi
!
        write(31,*)                                                     &
     &   ' jmvloop_rst,imc_rep_rst,imc_eql_rst'                         &
     &  ,',imc_acc_rst,imc_upd_rst='
        write(31,*)                                                     &
     &    jmvloop_rst,imc_rep_rst,imc_eql_rst                           &
     &   ,imc_acc_rst,imc_upd_rst
!
!
        write(31,*)                                                     &
     &  ' kmvsequ,imvsequ,jmty,imove,kmove,jrstarT='
        write(31,*)                                                     &
     &    kmvsequ,imvsequ,jmty(imvsequ,jmvloop),imove,kmove,jrstart
!
        write(31,*)                                                     &
     &  ' kmvsequ_rsi,imvsequ_rsi,jmty_rsi,imove_rsi,kmove_rsi='
        write(31,*)                                                     &
     &    kmvsequ_rsi,imvsequ_rsi,jmty_rsi,imove_rsi,kmove_rsi
!
        write(31,*)                                                     &
     &  ' kmvsequ_rst,imvsequ_rst,jmty_rst,imove_rst,kmove_rst='
        write(31,*)                                                     &
     &    kmvsequ_rst,imvsequ_rst,jmty_rst,imove_rst,kmove_rst
!
        write(31,*) ' EXECUTION CONTINUED'
        close(31)
!
!
  992 continue
!
!
      iout_th_rst=-1
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine idat_tr_i
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! read all prior Theta population outputs for multi-Theta moves
! for restart
!
      include 'ens.def'
      do jtrepl=1,jtrepl_x
          iout_repl(jtrepl)=-1
          nthr_repl(jtrepl)=-1
          iorf_repl(jtrepl)=-1
      enddo
      jtrepl=-1
!
      do iorf=0,norf_x
        iout_tr_orf(iorf)=-1
        iout_th_orf(iorf)=-1
!
        jmvloop_orf(iorf)=-1
        imc_rep_orf(iorf)=-1
        imc_eql_orf(iorf)=-1
        imc_acc_orf(iorf)=-1
        imc_upd_orf(iorf)=-1
        imove_orf(iorf)=-1
!
        imvsequ_orf(iorf)=-1
        kmvsequ_orf(iorf)=-1
        jmty_orf(iorf)=-1
        jtrepl_orf(iorf)=-1
        nthr_orf(iorf)=-1
        jorf(iorf)=-1
!
        iun_orf=50+iorf
        fname=fname_orf(iorf)
!
        inquire(file=fname,exist=fexist)
        if(fexist) then
          jorf(iorf)=1
          open(iun_orf,file=fname,status='old')
        else
          jorf(iorf)=0
          goto 190
        endif
!
        rewind(iun_orf)
!
  120   continue
        read(iun_orf,2010,end=190) aline
 2010   format(a80)
        if(index(aline,'iout_repl').eq.0) goto 120
        read(iun_orf,*,err=190,end=190)                                 &
     &      iout_tr_orf(iorf),iout_th_orf(iorf)
!
  130   continue
        read(iun_orf,2010,end=190) aline
        if(index(aline,'jmvloop').eq.0) goto 130
!
        read(iun_orf,*,err=190,end=190)                                 &
     &   jmvloop_orf(iorf)                                              &
     &  ,imc_rep_orf(iorf)                                              &
     &  ,imc_eql_orf(iorf)                                              &
     &  ,imc_acc_orf(iorf)                                              &
     &  ,imc_upd_orf(iorf)                                              &
     &  ,imove_orf(iorf)
!
  140   continue
        read(iun_orf,2010,end=190) aline
        if(index(aline,'imvsequ').eq.0) goto 140
!
        read(iun_orf,*,err=190,end=190)                                 &
     &   imvsequ_orf(iorf)                                              &
     &  ,kmvsequ_orf(iorf)                                              &
     &  ,jmty_orf(iorf)                                                 &
     &  ,jtrepl_orf(iorf)                                               &
     &  ,nthr_orf(iorf)
!
        jorf(iorf)=2
        jtrepl=jtrepl_orf(iorf)
!
        if(                                                             &
     &    jtrepl.gt.jtrepl_x.or.                                        &
     &    jtrepl.lt.1                                                   &
     &  )then
            errtag='000046'
            call err_term
        endif
!
!
  150   continue
        read(iun_orf,2010,end=190) aline
        if(index(aline,'OUTPUT COMPLETE').eq.0) goto 150
!
        jorf(iorf)=3
!
        if(iout_tr_orf(iorf).gt.iout_repl(jtrepl))                      &
     &  iout_repl(jtrepl)=iout_tr_orf(iorf)
!
        if(iout_tr_orf(iorf).eq.iout_repl(jtrepl)) then
          jorf(iorf)=4
          nthr_repl(jtrepl)=nthr_orf(iorf)
          iorf_repl(jtrepl)=iorf
!
          rewind(iun_orf)
!
          if(jtrepl.eq.2) then
            do kthr=0,nthr_orf(iorf)
              iorst(kthr)=kthr
              jhoodst(kthr)=-1
            enddo
!
  151       continue
            read(iun_orf,2010) aline
            if(index(aline,'OUTPUT COMPLETE').ne.0) goto 152
            if(index(aline,'jhoodst').eq.0) goto 151
!
            read(iun_orf,*)                                             &
     &      (jhoodst(kthr),kthr=0,nthr_orf(iorf))
!
  152       continue
            rewind(iun_orf)
          endif
!
!
          do kthr=0,nthr_orf(iorf)
  160       continue
            read(iun_orf,2010) aline
            if(index(aline,'chisq_repl').eq.0) goto 160
!
            read(iun_orf,*) idum                                        &
     &                      ,chisq_repl(kthr,jtrepl)                    &
     &                      ,htot_repl(kthr,jtrepl)
!
  162       continue
            read(iun_orf,2010) aline
            if(index(aline,'theta_repl').eq.0) goto 162
!
            read(iun_orf,*) (theta_repl(ith,kthr,jtrepl)                &
     &                         ,ith=1,mth_tot)
          enddo
          ith=-1
          kthr=-1
        endif
!
  190   continue
        if(jorf(iorf).ge.1) close(iun_orf)
  195   continue
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine idat_tr_f
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! read last complete Theta population output for multi-Theta moves
! for restart, trying to find Theta output closest to current
! "imvsequ"
!
      include 'ens.def'
!
      iorf0=-1
      jtrepl0=-1
      iout0=-1
!
      do ilev=1,3
        do iorf=0,norf_x
          if(jorf(iorf).lt.3) goto 190
          if(jmty_orf(iorf).ne.jmty_rsi) goto 190
          if(imvsequ_orf(iorf).ne.imvsequ_rsi.and.ilev.le.2) goto 190
          if(kmvsequ_orf(iorf).ne.kmvsequ_rsi.and.ilev.le.2) goto 190
          if(jmvloop_orf(iorf).ne.jmvloop_rsi.and.ilev.le.2) goto 190
          if(imove_orf(iorf).ne.imove_rsi.and.ilev.le.1) goto 190
!
          if(iout_tr_orf(iorf).gt.iout0)                                &
     &    iout0=iout_tr_orf(iorf)
!
          if(iout_tr_orf(iorf).eq.iout0) then
            jtrepl0=jtrepl_orf(iorf)
            iorf0=iorf
          endif
!
  190     continue
        enddo
        if(iorf0.gt.-1) goto 195
      enddo
  195 continue
!
!
      if(iorf0.eq.-1) goto 300
      if(jtrepl0.eq.-1) goto 300
!
!
      iout_repl(jtrepl0)=iout0
      nthr_repl(jtrepl0)=nthr_orf(iorf0)
      iorf_repl(jtrepl0)=iorf0
!
!
      iun_orf=50+iorf0
      fname=fname_orf(iorf0)
      open(iun_orf,file=fname,status='old')
      rewind(iun_orf)
!
!
!
      if(jtrepl0.eq.2) then
        do kthr=0,nthr_orf(iorf0)
          iorst(kthr)=kthr
          jhoodst(kthr)=-1
        enddo
!
  201   continue
        read(iun_orf,2010) aline
        if(index(aline,'OUTPUT COMPLETE').ne.0) goto 202
        if(index(aline,'jhoodst').eq.0) goto 201
!
        read(iun_orf,*)                                                 &
     &  (jhoodst(kthr),kthr=0,nthr_orf(iorf0))
!
  202   continue
        rewind(iun_orf)
      endif
!
!
!
      do kthr=0,nthr_orf(iorf0)
  250   continue
        read(iun_orf,2010) aline
 2010   format(a80)
        if(index(aline,'chisq_repl').eq.0) goto 250
!
        read(iun_orf,*) idum                                            &
     &                  ,chisq_repl(kthr,jtrepl0)                       &
     &                  ,htot_repl(kthr,jtrepl0)
!
  252   continue
        read(iun_orf,2010) aline
        if(index(aline,'theta_repl').eq.0) goto 252
!
        read(iun_orf,*) (theta_repl(ith,kthr,jtrepl0)                   &
     &                     ,ith=1,mth_tot)
      enddo
      ith=-1
      kthr=-1
      close(iun_orf)
!
!
  300 continue
!
!
      jtrepl=1
      if(nthr_repl(jtrepl).ge.0) call rst_amb
!
      jtrepl=2
      if(nthr_repl(jtrepl).ge.0) call rst_pst
!
      jtrepl=3
      if(nthr_repl(jtrepl).ge.0) call rst_pge
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine rst_amb
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! restart initial amoeba moves
!
      jtrepl=1
!
      jamb_repl=1
      if(mth_tot.ne.nthr_repl(jtrepl)) jamb_repl=0
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine rst_pst
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! restart initial pst moves
!
      jtrepl=2
      npopst_lst=nthr_repl(jtrepl)
!
!
      do ipop=0,npopst_lst
        htot_st(ipop)                                                   &
     &   =htot_repl(ipop,jtrepl)
!
        chisq_st(ipop)                                                  &
     &   =chisq_repl(ipop,jtrepl)
!
        do ith=1,mth_tot
          theta_st(ith,ipop)                                            &
     &     =theta_repl(ith,ipop,jtrepl)
        enddo
      enddo
      ith=-1
      ipop=-1
!
!
      if(jpst_rsi.eq.0) call sch_pst
!
      if(jdo_st4ge.eq.1) then
        if(jbsuge.eq.101.or.jbsuge.eq.102) then
          npopst=npopst_lst
          if(jbsuge.eq.101) nsurvge=npopst
          if(jbsuge.eq.102) nsurvge=npopge-npopst-1
        endif
      endif
!
!
      iorf0=iorf_repl(jtrepl)
      imvsequ0=imvsequ_orf(iorf0)
      if(                                                               &
     &jtmp_en(imvsequ0,jmvloop).eq.4.or.                                &
     &jtmp_en(imvsequ,jmvloop).eq.4                                     &
     &)then
        if(jhoodst(0).eq.-1) then
          do ipop=0,npopst_lst
            ipop_upd=ipop
            call store_st2th ! rst_pst-01
            jDB_get_chi=1
            call get_chi ! rst_pst-01
!
!DRLIM190524-2244:
!           Will likely have mlimdrv==0 here, since Theta is an already
!           accepted read-in from a previous run.
!:DRLIM190524-2244
!
            call store_chi_th
            call store_th2st
            jhoodst(ipop_upd)=0
          enddo
        else
          do ipop=0,npopst_lst
            ipop_upd=ipop
            if(jhoodst(ipop_upd).ge.1) then
              call store_st2th ! rst_pst-02
              jDB_get_chi=2
              call get_chi ! rst_pst-02
!
!DRLIM190524-2244:
!             Will likely have mlimdrv==0 here, since Theta is an already
!             accepted read-in from a previous run.
!:DRLIM190524-2244
!
              call store_chi_th
              call store_th2st
              jhoodst(ipop_upd)=0
            endif
          enddo
        endif
      endif
!
!
      if(jpst_rsi.eq.1.and.npopst.gt.npopst_lst) then
        ipop_upd=npopst_lst
        call store_st2th ! rst_pst-03
!
        do ipop=(npopst_lst+1),npopst
          ipop_upd=ipop
          call store_th2st
        enddo
!
        ipop_upd=0
        call store_st2th ! rst_pst-04
      endif
!
      ipop_upd=-1
      ipop=-1
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine rst_pge
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! restart initial pge moves
!
      jtrepl=3
      npopge_lst=nthr_repl(jtrepl)
!
!
      do ipop=0,npopge_lst
        htot_ge(ipop)                                                   &
     &   =htot_repl(ipop,jtrepl)
!
        chisq_ge(ipop)                                                  &
     &   =chisq_repl(ipop,jtrepl)
!
        do ith=1,mth_tot
          theta_ge(ith,ipop)                                            &
     &     =theta_repl(ith,ipop,jtrepl)
        enddo
      enddo
      ith=-1
      ipop=-1
!
!
      if(jpge_rsi.eq.0) call sch_pge
!
      if(jpge_rsi.eq.1.and.npopge.gt.npopge_lst) then
        ipop_upd=npopge_lst
        call store_ge2th
!
        do ipop=(npopge_lst+1),npopge
          ipop_upd=ipop
          call store_th2ge
        enddo
!
        ipop_upd=0
        call store_ge2th
      endif
!
      ipop_upd=-1
      ipop=-1
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine odat_tr_i
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! initialize Theta population output files after restart:
! reorder Theta population output file contents to be consistent
! w/ Theta population file allocation ("morf" and "jtrepl_x")
! in current run and code version, if needed.
!
      include 'ens.def'
!
!
      do jtrepl=1,jtrepl_x
        iorf_max(jtrepl)=-1
        do iorf=0,norf_x
          iorf_new(iorf,jtrepl)=-1
          iorf_old(iorf,jtrepl)=-1
        enddo
      enddo
!
!
      do iorf0=0,norf_x
        if(jorf(iorf0).lt.3) goto 190
!
        jtrepl0=jtrepl_orf(iorf0)
        ioutx=iout_repl(jtrepl0)
        iout0=iout_tr_orf(iorf0)
!
!     ..for iout_repl=last accepted Theta-pop.ouput
!     ..for class jtrepl0:
!     ..keep only iorf's w/ iout_tr =< iout_repl
        if(iout0.gt.ioutx) goto 190
!
        iorf=0
        do iorf1=0,norf_x
          if(jorf(iorf1).lt.3) goto 90
!
          iout1=iout_tr_orf(iorf1)
          if(iout1.gt.ioutx) goto 90
!
          jtrepl1=jtrepl_orf(iorf1)
          if(jtrepl1.eq.jtrepl0) then
            if(iout1.lt.iout0)                                          &
     &      iorf=iorf+1
            if(iout1.eq.iout0.and.iorf1.lt.iorf0)                       &
     &      iorf=iorf+1
          endif
   90     continue
        enddo
        iorf_new(iorf0,jtrepl0)=iorf
!
        if(iorf.gt.iorf_max(jtrepl0))                                   &
     &  iorf_max(jtrepl0)=iorf
  190   continue
      enddo
!
!
      do iorf0=0,norf_x
        iorf1=-1
        if(jorf(iorf0).lt.3) goto 210
!
        jtrepl0=jtrepl_orf(iorf0)
        iorf1=iorf_new(iorf0,jtrepl0)
!
!     ..shift iorf1:=iorf_new into interval 0,...,(morf-1)
        iorfx=iorf_max(jtrepl0)-(morf-1)
        if(iorfx.lt.0) iorfx=0
        iorf1=iorf1-iorfx
!
        if(iorf1.ge.0) then
!       ..shift iorf1:=iorf_new into interval
!       ..  (jtrepl0-1)*morf,...,jtrepl0*morf-1
          iorf1=iorf1+(jtrepl0-1)*morf
          iorf_new(iorf0,jtrepl0)=iorf1
          iorf_old(iorf1,jtrepl0)=iorf0
        else
          iorf_new(iorf0,jtrepl0)=-1
        endif
!
  210   continue
      enddo
!
!   ..update iorf_max, using latest iorf_new
!
      do jtrepl=1,jtrepl_x
          iorf_max(jtrepl)=-1
      enddo
!
      do iorf0=0,norf_x
        if(jorf(iorf0).lt.3) goto 220
!
        jtrepl0=jtrepl_orf(iorf0)
        iorf1=iorf_new(iorf0,jtrepl0)
!
        if(iorf1.gt.iorf_max(jtrepl0))                                  &
     &  iorf_max(jtrepl0)=iorf1
  220   continue
      enddo
!
!   ..reorder output files
!
      do iorf=0,norf_x
        jnew_orf(iorf)=0
      enddo
!
      fname_swap0='ens.o90'
      fname_swap1='ens.o91'
!
      iorf0=-1
  310 continue
        iorf0=iorf0+1
        iorfx=iorf0
  320 continue
        if(iorf0.gt.norf_x) goto 390
!
        if(jnew_orf(iorf0).eq.1) then
          iorf0=iorfx
          goto 310
        endif
!
        jtrepl0=jtrepl_orf(iorf0)
        if(jtrepl0.le.0) then
          jnew_orf(iorf0)=1
          iorf0=iorfx
          goto 310
        endif
!
        iorf1=iorf_new(iorf0,jtrepl0)
        if(iorf1.lt.0) then
          jnew_orf(iorf0)=1
          iorf0=iorfx
          goto 310
        endif
!
        if(iorf1.eq.iorf0) then
          jnew_orf(iorf0)=1
          iorf0=iorfx
          goto 310
        endif
!
        jtrepl1=jtrepl_orf(iorf1)
!
        if(jnew_orf(iorf0).eq.0) fname0=fname_orf(iorf0)
        if(jnew_orf(iorf0).eq.-1) fname0=fname_swap0
!
!
        iorf2=-1
        if(jtrepl1.gt.0) iorf2=iorf_new(iorf1,jtrepl1)
!
        if(iorf2.lt.0) then
          call copyfi(fname0,fname_orf(iorf1))
          jnew_orf(iorf0)=1
          iorf0=iorfx
          goto 310
        endif
!
        if(jnew_orf(iorf1).eq.1) then
          call copyfi(fname0,fname_orf(iorf1))
          jnew_orf(iorf0)=1
          iorf0=iorfx
          goto 310
        else
          call copyfi(fname_orf(iorf1),fname_swap1)
          call copyfi(fname0,fname_orf(iorf1))
          call copyfi(fname_swap1,fname_swap0)
          jnew_orf(iorf0)=1
          jnew_orf(iorf1)=-1
          iorf0=iorf1
          goto 320
        endif
  390 continue
!
!
      call erasefi(fname_swap0)
      call erasefi(fname_swap1)
!
      do iorf=0,norf_x
        jnew_orf(iorf)=0
      enddo
!
      do iorf0=0,norf_x
        if(jorf(iorf0).ge.3) then
          jtrepl0=jtrepl_orf(iorf0)
          iorf1=iorf_new(iorf0,jtrepl0)
          if(iorf1.ge.0) jnew_orf(iorf1)=1
        endif
      enddo
!
      do iorf1=0,norf_x
        if(jnew_orf(iorf1).eq.0)                                        &
     &  call erasefi(fname_orf(iorf1))
      enddo
!
!
      do jtrepl=1,jtrepl_x
        iorf0=iorf_repl(jtrepl)
        if(iorf0.ge.0) then
          if(jorf(iorf0).ge.3) then
            jtrepl0=jtrepl_orf(iorf0)
!
            if(jtrepl.ne.jtrepl0) then
              write(39,*) '"odat_tr_i": ErroR No. 2'
              write(39,*) 'iorf0,jtrepl0,jtrepl='                        &
     &                   ,iorf0,jtrepl0,jtrepl
            endif
!
            iorf_repl(jtrepl)=iorf_new(iorf0,jtrepl0)
!
            if(iorf_repl(jtrepl).ne.iorf_max(jtrepl0)) then
              write(39,*) '"odat_tr_i": ErroR No. 3'
              write(39,*)                                                &
     &        'jtrepl,jtrepl0,iorf0=',jtrepl,jtrepl0,iorf0
              write(39,*)                                                &
     &        'iorf_repl(jtrepl),iorf_max(jtrepl0)='                    &
     &        ,iorf_repl(jtrepl),iorf_max(jtrepl0)
            endif
          endif
        endif
      enddo
!
  990 continue
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine odat_tr_f
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
!
      include 'ens.def'
!
! write out Theta populations into "rotating" output files
! to enable restart after crash
!
!
      if(imvsequ.le.0.or.jmvloop.le.0) return
!
      jtrepl=-1
!
      if(jmty(imvsequ,jmvloop).eq.10                                    &
     &)then
        jtrepl=1
        nthr_repl(jtrepl)=mth_tot
      endif
!
      if(                                                               &
     &jmty(imvsequ,jmvloop).ge.1000.and.                                &
     &jmty(imvsequ,jmvloop).le.2999                                     &
     &)then
        jtrepl=2
!c      nthr_repl(jtrepl)=npop_st(imvsequ,jmvloop)
        nthr_repl(jtrepl)=npopst
      endif
!
      if(                                                               &
     &jmty(imvsequ,jmvloop).ge.3000.and.                                &
     &jmty(imvsequ,jmvloop).le.4999                                     &
     &)then
        jtrepl=3
!c      nthr_repl(jtrepl)=npop_ge(imvsequ,jmvloop)
        nthr_repl(jtrepl)=npopge
      endif
!
      if(jtrepl.lt.1) return
!
!
      iout_repl(jtrepl)=iout_repl(jtrepl)+1
!
      iorf1=iorf_repl(jtrepl)+1
!
   10 continue
      if(iorf1.ge.(jtrepl*morf)) then
        iorf1=iorf1-morf
        goto 10
      endif
      if(iorf1.lt.((jtrepl-1)*morf))                                    &
     &iorf1=(jtrepl-1)*morf
!
      iorf_repl(jtrepl)=iorf1
!
!
      fname=fname_orf(iorf1)
      iun_orf=50+iorf1
      inquire(file=fname,exist=fexist)
      if(fexist) then
        open(iun_orf,file=fname,status='old')
      else
!BLADE:
!       open(iun_orf,file=fname,status='new')
        open(iun_orf,file=fname)
!:BLADE
      endif
      rewind(iun_orf)
!
!
      write(iun_orf,5010)                                               &
     & iout_repl(jtrepl)                                                &
     &,iout_th                                                          &
     &,iorf_repl(jtrepl)                                                &
     &,jtrepl
 5010 format(       &
     &/' iout_repl   iout_th      iorf    jtrepl'                       &
     &/4i10)
!
!
      write(iun_orf,5020)                                               &
     & jmvloop                                                          &
     &,imc_rep                                                          &
     &,imc_eql                                                          &
     &,imc_acc                                                          &
     &,imc_upd                                                          &
     &,imove                                                            &
     &,kmove                                                            &
     &,jkmove
 5020 format(       &
     &/'   jmvloop   imc_rep   imc_eql   imc_acc   imc_upd'             &
     &,'     imove     kmove    jkmove'                                 &
     &/8i10)
!
!
      write(iun_orf,5030)                                               &
     & imvsequ                                                          &
     &,kmvsequ                                                          &
     &,jmty(imvsequ,jmvloop)                                            &
     &,jtrepl                                                           &
     &,nthr_repl(jtrepl)                                                &
     &,kthr_upd                                                         &
     &,kthr_xch
 5030 format(       &
     &/'   imvsequ   kmvsequ      jmty    jtrepl nthr_repl'             &
     &,'  kthr_upd  kthr_xch'                                           &
     &/7i10)
!
! jthrepl=2: PST output
!
      if(jtrepl.eq.2) then
        write(iun_orf,5202)
 5202   format(               &
     &  /' iorst '                                                      &
     &  )
!
        write(iun_orf,5204)                                             &
     &  (iorst(ipop), ipop=0,npopst)
 5204   format(10i5)
!
!
!c        write(iun_orf,*) ' '
          write(iun_orf,*) ' jhoodst '
          write(iun_orf,5206)                                           &
     &    (jhoodst(ipop), ipop=0,npopst)
 5206     format(10i5)
!
!c        write(iun_orf,*) ' '
          write(iun_orf,*) ' chisq_st '
          write(iun_orf,5208)                                           &
     &    (chisq_st(iorst(ipop)), ipop=0,npopst)
 5208     format(5d16.8)
!
!c        write(iun_orf,*) ' '
          write(iun_orf,*) ' htot_st '
          write(iun_orf,5210)                                           &
     &    (htot_st(iorst(ipop)), ipop=0,npopst)
 5210     format(5d16.8)
!
      endif
!
! jthrepl=3: PGE output
!
      if(jtrepl.eq.3) then
!
!c      if(
!c   :     jmty(imvsequ,jmvloop).eq.3901.or.
!c   :     jmty(imvsequ,jmvloop).eq.3902.or.
!c   :     jmty(imvsequ,jmvloop).eq.3912
!c   :     jmty(imvsequ,jmvloop).eq.3921
!c   :  )then
          write(iun_orf,5302)                                           &
     &     npopge,nsurvge                                               &
     &    ,jnsuge,jbsuge,jrsuge                                         &
     &    ,jmty(imvsequ,jmvloop)                                        &
     &    ,ansurge,bnsurge
 5302     format(                    &
     &    /'  npopge nsurvge  jnsuge  jbsuge  jrsuge    jmty'           &
     &    /6i8                                                          &
     &    /'         ansurge         bnsurge'                           &
     &    /2d16.9)
!
        write(iun_orf,5304)
 5304   format(        &
     &  /' iorge '                                                      &
     &  )
!
        write(iun_orf,5306)                                             &
     &  (iorge(kthr)                                                    &
     &  ,kthr=0,nthr_repl(jtrepl))
 5306   format(10i5)
!
!c        write(iun_orf,*) ' '
          write(iun_orf,*) ' jsurv '
          write(iun_orf,5308)                                           &
     &    (jsurv(ipop), ipop=0,npopge)
 5308     format(10i5)
!
!c        write(iun_orf,*) ' '
          write(iun_orf,*) ' isurv_pop '
          write(iun_orf,5310)                                           &
     &    (isurv_pop(ipop), ipop=0,npopge)
 5310     format(10i5)
!
!c        write(iun_orf,*) ' '
          write(iun_orf,*) ' ipop_surv '
          write(iun_orf,5312)                                           &
     &    (ipop_surv(isurv), isurv=0,nsurvge)
 5312     format(10i5)
!
!c        write(iun_orf,*) ' '
          write(iun_orf,*) ' chisq_ge '
          write(iun_orf,5314)                                           &
     &    (chisq_ge(iorge(ipop)), ipop=0,npopge)
 5314     format(5d16.8)
!
!c        write(iun_orf,*) ' '
          write(iun_orf,*) ' htot_ge '
          write(iun_orf,5316)                                           &
     &    (htot_ge(iorge(ipop)), ipop=0,npopge)
 5316     format(5d16.8)
!c      endif
!
      endif
!
!
      do kthr=0,nthr_repl(jtrepl)
        temp_repl=1.d0/beta_repl(kthr,jtrepl)
        write(iun_orf,5510)                                             &
     &                   kthr                                           &
     &                  ,chisq_repl(kthr,jtrepl)                        &
     &                  ,htot_repl(kthr,jtrepl)                         &
     &                  ,beta_repl(kthr,jtrepl)                         &
     &                  ,temp_repl
 5510   format(             &
     &  /'    kthr      chisq_repl       htot_repl       beta_repl'     &
     &  ,        '       temp_repl'                                     &
     &  /i8,4d16.8)
!
        write(iun_orf,*) ' theta_repl '
        write(iun_orf,5520) (theta_repl(ith,kthr,jtrepl)                &
     &                     ,ith=1,mth_tot)
 5520   format(5d16.8)
      enddo
      ith=-1
      kthr=-1
!
!
      write(iun_orf,*)  '  '
      write(iun_orf,*)  ' OUTPUT COMPLETE '
      close(iun_orf)
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine fmvsequ_repl
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! Find "imvsequ"-value from the last Theta-replica output
! for current "kmvsequ" for re-initialing theta_repl at restart.
! This "imvsequ"-value will be set only if prior run generated
! last Theta-replica output and then crashed during same "imove"
!
      include 'ens.def'
!
!
      if(jrstart.eq.1) then
        iout0=-1
        do iorf=0,norf_x
          if(                                                           &
     &      jorf(iorf).ge.3.and.                                        &
     &      kmvsequ.eq.kmvsequ_orf(iorf).and.                           &
     &      jmvloop.eq.jmvloop_orf(iorf).and.                           &
     &      imove.eq.imove_orf(iorf)                                    &
     &    )then
            if(iout0.lt.iout_tr_orf(iorf))                              &
     &      iout0=iout_tr_orf(iorf)
            if(iout0.eq.iout_tr_orf(iorf))                              &
     &      imvsequ=imvsequ_orf(iorf)
          endif
        enddo
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine idat_xpt
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! read expt'l. data for avg. measured species conc. xspec_xpt
! and Gaussian (1/e) error widths xspec_wid at time points time_xpt
!
      include 'ens.def'
!
!!!
!V090911:
        call mp_qini
!:V090911
!!!
      close(39)
      inquire(file='ens.o09',exist=fexist)
      if(fexist) then
        open(39,file='ens.o09',status='old')
        iun=39
        call efile(iun)
      else
!BLADE:
!       open(39,file='ens.o09',status='new')
        open(39,file='ens.o09')
!:BLADE
      endif
!
      write(39,*) ' '
      write(39,*) ' '
      write(39,*) 'ENTERING "idat_xpt", mp_myid=', mp_myid
      write(39,*) ' '
!
! read in expt'l. data
!
      open(22,file='ens.i02',status='old')
      rewind(22)
!
      write(39,*) '  '
      write(39,*) '  Opening "ens.i02" for input:'
!
      iset=0
    5 continue
      read(22,2010,end=970,err=970) aline
      write(39,2010) aline
 2010 format(a80)
      if(index(aline(1:80),'data set').eq.0) goto 5
      iset=iset+1
      if(iset.lt.nset) goto 5
!
!
      iexpt=0
      idtin=0
      mdtin_raw=0
      idtspec=0
      ispec=0
!
   10 continue
      read(22,2010,end=99) aline
      write(39,2010) aline
      if(index(aline(1:80),'data set').ne.0) goto 99
!
      if(index(aline(1:80),'   iexpt ndtin_spec').eq.0                  &
     &.and.index(aline(1:80),'   iexpt ndtspec').eq.0)                  &
     & goto 10
!
      iexpt=iexpt+1
!
      write(39,*) '  iexpt=',iexpt
!
      if(iexpt.gt.nexpt) then
            errtag='000047'
            call err_term
      endif
!
      read(22,*,end=970,err=970) idum1,ndtspec(iexpt)
!
      write(39,*) '  iexpt,ndtspec(iexpt)=',iexpt,ndtspec(iexpt)
!
      if(ndtspec(iexpt).gt.nspec) then
            errtag='000048'
            call err_term
      endif
!
      do idtspec=1,ndtspec(iexpt)
   15   continue
        read(22,2010,end=970,err=970) aline
        write(39,2010) aline
        if(index(aline(1:80),'namespec_dtin').eq.0                      &
     &  .and.index(aline(1:80),'namespec_dtspec').eq.0)                 &
     &  goto 15
!
        read(22,2020,end=970,err=970)                                   &
     &  namespec_dtspec(idtspec,iexpt)
 2020   format(a80)
!
        write(39,*) '  iexpt,idtspec=',iexpt,idtspec
!
        write(39,*) '  namespec_dtspec(idtspec,iexpt)='
        write(39,2020) namespec_dtspec(idtspec,iexpt)
!
        idum1=-nspec
        ispec=                                                          &
     &  ispre4name(ierrtag,namespec,idum1                              &
     &            ,namespec_dtspec(idtspec,iexpt),nspec_y)
!
        if(ierrtag.gt.0) then
          jerrtag=1
          errtag='000120'
          call err_term
        endif
!
        if(ispec.lt.1.or.ispec.gt.nspec) then
            errtag='000049'
            call err_term
        endif
!
        if(jmsspec_ch(ispec).le.0) then
            errtag='000050'
            call err_term
        endif
!
        do idpen=1,ndpen_spec
          ispec_D=ispec_dpen(idpen)
          if(ispec_D.ne.ispec) goto 90
!
          ipm_D=ipm_dpen(idpen)
!
          if(                                                           &
     &    jctspec(ispec_D,ipm_D).eq.30.or.                              &
     &    jctspec(ispec_D,ipm_D).eq.40) then
            errtag='000051'
            call err_term
          endif
   90     continue
        enddo
!
!
        read(22,2010,end=970,err=970) aline
        write(39,2010) aline
        if(                                                             &
     &  index(aline(1:80),'jcprs_dtspec').ne.0                          &
     &  )then
          read(22,*,end=970,err=970)                                    &
     &            ntxpt_dtspec(idtspec,iexpt)                           &
     &           ,jcprs_i                                               &
     &           ,nwintx(idtspec,iexpt)
!
          mbase=1000
          call fdigit(jcprs_i,mbase,jdig,nzdig,ndig_y)
          jwwgt_dtspec(idtspec,iexpt)=jdig(2)
          jcprs_dtspec(idtspec,iexpt)=jdig(1)
        else
          read(22,*,end=970,err=970)                                    &
     &            ntxpt_dtspec(idtspec,iexpt)
          jcprs_dtspec(idtspec,iexpt)=0
          jwwgt_dtspec(idtspec,iexpt)=0
          nwintx(idtspec,iexpt)=0
        endif
!
        write(39,*) '  ntxpt_dtspec(idtspec,iexpt)='                     &
     &               ,ntxpt_dtspec(idtspec,iexpt)
!
        if(                                                             &
     &  jcprs_dtspec(idtspec,iexpt).gt.0                                &
     &  .or.                                                            &
     &  jwwgt_dtspec(idtspec,iexpt).gt.0                                &
     &  )then
          write(39,*) '  jcprs_dtspec(idtspec,iexpt)='                   &
     &                 ,jcprs_dtspec(idtspec,iexpt)
          write(39,*) '  jwwgt_dtspec(idtspec,iexpt)='                   &
     &                 ,jwwgt_dtspec(idtspec,iexpt)
          write(39,*) '  nwintx(idtspec,iexpt)='                         &
     &                 ,nwintx(idtspec,iexpt)
        endif
!
!       if(ntxpt_dtspec(idtspec,iexpt).gt.ndtin_x) then
!         open(31,file='ens.o01',status='old')
!         iun=31
!         call efile(iun)
!         write(31,*) ' ERROR in input file ens.i02'
!         write(31,*) '    namespec_dtspec='
!         write(31,2020)  namespec_dtspec(idtspec,iexpt)
!         write(31,*)
!    :    '   for idtspec,ispec,iexpt='
!    :           ,idtspec,ispec,iexpt
!         write(31,*) '    namespec_dtspec='
!         write(31,2020)  namespec_dtspec(idtspec,iexpt)
!         write(31,*) ' '
!         write(31,*)'input variable'
!         write(31,*)
!    :    '   ntxpt_dtspec(idtspec,iexpt)'
!         write(31,*)
!    :    '   exceeds array size ndtin_x:'
!         write(31,*) '   ntxpt_dtspec(idtspec,iexpt), ndtin_x='
!    :                   ,ntxpt_dtspec(idtspec,iexpt), ndtin_x
!         write(31,*) ' Increase array size ndtin_x'
!    :              , ' in "ens.def"+re-compile'
!         write(31,*) ' EXECUTION STOPPED'
!         close(31)
!         call mp_stopabort
!       endif
!
        if(nwintx(idtspec,iexpt).gt.nwintx_x) then
            errtag='000052'
            call err_term
        endif
!
        if(                                                             &
     &  jcprs_dtspec(idtspec,iexpt).gt.0                                &
     &  .or.                                                            &
     &  jwwgt_dtspec(idtspec,iexpt).gt.0                                &
     &  )then
          do iwintx=1,nwintx(idtspec,iexpt)
            read(22,2010,end=970,err=970) aline
            write(39,2010) aline
            read(22,*,end=970,err=970) idum1                            &
     &      ,txwin_lo(iwintx,idtspec,iexpt)                             &
     &      ,txwin_hi(iwintx,idtspec,iexpt)                             &
     &      ,nbintx(iwintx,idtspec,iexpt)                               &
     &      ,jcprs_win(iwintx,idtspec,iexpt)                            &
     &      ,jwwgt_win(iwintx,idtspec,iexpt)
!
            if(                                                         &
     &      jwwgt_win(iwintx,idtspec,iexpt).gt.0                        &
     &      )then
              read(22,2010,end=970,err=970) aline
              write(39,2010) aline
              read(22,*,end=970,err=970)                                &
     &         fwwgt_win(iwintx,idtspec,iexpt)                          &
     &        ,denstarg(iwintx,idtspec,iexpt)
            endif
!
            if(nbintx(iwintx,idtspec,iexpt).gt.nbintx_x) then
            errtag='000053'
            call err_term
            endif
!
          enddo
        endif
!
        read(22,2010,end=970,err=970) aline
        write(39,2010) aline
!
        idtin_sxi(idtspec,iexpt)=idtin+1
!
        do ldtin=1,ntxpt_dtspec(idtspec,iexpt)
          idtin=idtin+1
          if(idtin.gt.ndtin_x) then
            errtag='000054'
            call err_term
          endif
!
          read(22,*,end=970,err=970) idum1                              &
     &              ,time_dtin(idtin)                                   &
     &              ,zspec_xpt(idtin)                                   &
     &              ,zspec_wid(idtin)                                   &
     &              ,zscal(idtin)                                       &
     &              ,jzproc(idtin)                                      &
     &              ,lscal(idtin)
          mbase=100
          call fdigit(jzproc(idtin),mbase,jdig,nzdig,ndig_y)
!V090911:
!DEACTIVATED
!R        jbaxdi_dtin(idtin)=jdig(4)
!R        nbaxdi_dtin(idtin)=jdig(3)
!R        jzxdi_dtin(idtin)=jdig(2)
!:V090911
          jzwid(idtin)=jdig(1)
!
          if(jzwid(idtin).gt.0                                          &
     &    .and.time_dtin(idtin).ge.time0                                &
     &    .and.time_dtin(idtin).le.time1                                &
     &    ) mdtin_raw=mdtin_raw+1
!
          if(mp_myid.eq.mp_mrid) then
            write(39,*) '   '
            write(39,*) '  idtin=',idtin
            write(39,*) '  time_dtin(idtin)=',time_dtin(idtin)
            write(39,*) '  zspec_xpt(idtin)=',zspec_xpt(idtin)
            write(39,*) '  zspec_wid(idtin)=',zspec_wid(idtin)
            write(39,*) '  zscal(idtin)=',zscal(idtin)
!
            write(39,*) '  jzproc(idtin)=',jzproc(idtin)
!V090911:
!DEACTIVATED
!R          write(39,*) '  jbaxdi_dtin(idtin)=',jbaxdi_dtin(idtin)
!R          write(39,*) '  nbaxdi_dtin(idtin)=',nbaxdi_dtin(idtin)
!R          write(39,*) '  jzxdi_dtin(idtin)=',jzxdi_dtin(idtin)
!:V090911
            write(39,*) '  jzwid(idtin)=',jzwid(idtin)
            write(39,*) '  lscal(idtin)=',lscal(idtin)
          endif
!
!
          if(                                                           &
     &    zspec_xpt(idtin).le.0.d0.or.                                  &
     &    zspec_wid(idtin).le.0.d0.or.                                  &
     &    zscal(idtin).le.0.d0                                          &
     &    ) then
            errtag='000055'
            call err_term
          endif
!
!       assign species and expt. number to input data pt.
          ispec_dtin(idtin)=ispec
          iexpt_dtin(idtin)=iexpt
        enddo
        idtin_sxf(idtspec,iexpt)=idtin
      enddo
!
      goto 10
!
      goto 979
  970 continue
            errtag='000056'
            call err_term
  979 continue
!
!
   99 continue
      close(22)
!
      ndtin=idtin
!
      if(iexpt.ne.nexpt) then
            errtag='000057'
            call err_term
      endif
!
      write(39,*) 'INPUT FROM "ens.i02" COMPLETED SUCCESSFULLY'
      write(39,*) '  ndtin=',ndtin
      write(39,*) 'LEAVING "idat_xpt", mp_myid=', mp_myid
      write(39,*) ' '
      write(39,*) ' '
!
      close(39)
      inquire(file='ens.o09',exist=fexist)
      if(fexist) then
        open(39,file='ens.o09',status='old')
        iun=39
        call efile(iun)
      else
!BLADE:
!       open(39,file='ens.o09',status='new')
        open(39,file='ens.o09')
!:BLADE
      endif
!!!
!V090911:
      close(39)
      call mp_qfin
!:V090911
!
!!!
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine wwgt_xpt
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
!  calculates and stores exptl. data pt. reweighting factors
!  based on target densities and txpt-windows re-weighting
!  factors specified for each exptl. data input block in in ens.i02
!
      include 'ens.def'
!
! set default window reweighting facotors (=1.0)
      do idtin=1,ndtin
        fwwgt_dtin(idtin)=1.d0
      enddo
!
! set jzwid processing flag to exclude certain input data pts.
! from reweighting
!V090911:
!DEACTIVATED
!R    do idtin=1,ndtin
!R      if(jzwid(idtin).gt.0) then
!R        if(                                                           &
!R   &    jbaxdi_dtin(idtin).gt.0.or.                                   &
!R   &    nbaxdi_dtin(idtin).gt.0.or.                                   &
!R   &    jzxdi_dtin(idtin).gt.0                                        &
!R   &    )                                                             &
!R   &    jzwid(idtin)=jzwid(idtin)+10000
!R      endif
!R    enddo
!:V090911
!
!
      do iexpt=1,nexpt
        do ims=1,nms_spec
          mblok_ms=0
          jwwgt_run=0
          idtspec_run=0
!
          do idtspec=1,ndtspec(iexpt)
            ispec=                                                      &
     &      ispre4name(ierrtag,namespec,nspec                                   &
     &              ,namespec_dtspec(idtspec,iexpt),nspec_y)
!
            if(ierrtag.gt.0) then
              jerrtag=2
              errtag='000120'
              call err_term
            endif
!
!         tabulate all input data blocks for meas. species "ims"
            if(ims.eq.ims_spec(ispec)) then
              mblok_ms=mblok_ms+1
!
              if(mblok_ms.gt.mblok_ms_x) then
            errtag='000058'
            call err_term
              endif
!
              idtspec_blok(mblok_ms)=idtspec
!
!           select input data block to provide global reweighting
!           parameters for meas. species "ims", if
!               200=<jwwgt_dtspec=<299
!           is specified by some block for this species: 1st
!           such block found will be selected.
              if(                                                       &
     &        jwwgt_dtspec(idtspec,iexpt).ge.200                        &
     &        .and.jwwgt_dtspec(idtspec,iexpt).le.299                   &
     &        .and.jwwgt_run.lt.200                                     &
     &        )then
                jwwgt_run=jwwgt_dtspec(idtspec,iexpt)
                idtspec_run=idtspec
              endif
!
!        ...or else, signal whether there is at least
!           one input data block of meas.species "ims" to be
!           reweighted individually: 1st such block found will
!           be selected.
              if(                                                       &
     &        jwwgt_dtspec(idtspec,iexpt).ge.100                        &
     &        .and.jwwgt_dtspec(idtspec,iexpt).le.199                   &
     &        .and.jwwgt_run.lt.100                                     &
     &        )then
                jwwgt_run=jwwgt_dtspec(idtspec,iexpt)
                idtspec_run=idtspec
              endif
            endif
          enddo
!
          ispec=ispec_ms(ims)
!
! 100=<jwwgt_dtspec=<199:
!   single block-by-block reweighting:
!     reweight separately for each input data block
!     from meas.species "ims", using the reweighting parameters
!     (window numbers and sizes, bin sizes)
!     specified separately for each block of that species w/
!       100=<jwwgt_dtspec=<199
! 200=<jwwgt_dtspec=<299:
!   global all-block reweighting:
!     reweight over all data input blocks from same
!     meas.species "ims", excluding only those blocks with
!     jwwgt_dtspec<0, using the reweighting parameters
!     (window numbers and sizes, bin sizes)
!     specified for the 1st block of that species having
!       200=<jwwgt_dtspec=<299
! Priority:
!   "global" overrides "single" block reweighting:
!     if at least one block of meas. species "ims" specifies
!        200=<jwwgt_dtspec=<299
!     then global reweighting over all blocks of that same species
!     and expt. will be performed, regardless of what value of
!     "jwwgt_dtspec>=0" is specified for the other blocks of
!     that species.
! Excluding txpt-windows from reweighting:
!    any txpt-window "iwintx" in any input species block "idtspec"
!    can be excluded from (single block or global) reweighting
!    by setting its
!       jwwgt_win=-1
!
!
          if(mblok_ms.gt.0.and.jwwgt_run.le.299 )then
            if(jwwgt_run.ge.100.and.jwwgt_run.le.199) then
              do iblok=1,mblok_ms
                idtspec=idtspec_blok(iblok)
                idtspec_run=idtspec
                nwintx_run=nwintx(idtspec_run,iexpt)
                jwwgt_run=jwwgt_dtspec(idtspec,iexpt)
!
                if(jwwgt_run.ge.100.and.jwwgt_run.le.199) then
                  do iwintx=1,nwintx_run
                    if(jwwgt_win(iwintx,idtspec,iexpt).eq.-1) goto 190
!
                    call wwgt_inlz
                    idtin_i=idtin_sxi(idtspec,iexpt)
                    idtin_f=idtin_sxf(idtspec,iexpt)
                    call wwgt_accu
                    call wwgt_nmlz
!
  190               continue
                  enddo
                endif
              enddo
              jwwgt_run=-100
            endif
!
            if(jwwgt_run.ge.200.and.jwwgt_run.le.299) then
              nwintx_run=nwintx(idtspec_run,iexpt)
              do iwintx=1,nwintx_run
                call wwgt_inlz
                do iblok=1,mblok_ms
                  idtspec=idtspec_blok(iblok)
                  if(jwwgt_win(iwintx,idtspec,iexpt).eq.-1) goto 291
!
                  idtin_i=idtin_sxi(idtspec,iexpt)
                  idtin_f=idtin_sxf(idtspec,iexpt)
                  call wwgt_accu
!
  291             continue
                enddo
!
                do iblok=1,mblok_ms
                  idtspec=idtspec_blok(iblok)
                  if(jwwgt_win(iwintx,idtspec,iexpt).eq.-1) goto 292
!
                  idtin_i=idtin_sxi(idtspec,iexpt)
                  idtin_f=idtin_sxf(idtspec,iexpt)
                  call wwgt_nmlz
!
  292             continue
                enddo
              enddo
            endif
!
          endif
        enddo
      enddo
!
! reset jzwid to proper pos. value
      do idtin=1,ndtin
        if(jzwid(idtin).gt.10000)                                       &
     &  jzwid(idtin)=jzwid(idtin)-10000
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine wwgt_inlz
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! initialize  exptl. data pt. counter for measuring
! exptl. data pt. density.
!
      include 'ens.def'
!
!
      nct_avg_tot=0
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine wwgt_accu
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! accumulate  exptl. data pt. count within counting
! interval for measuring data pt. density
!
      include 'ens.def'
!
!
      do idtin=idtin_i,idtin_f
        if(                                                             &
     &  time_dtin(idtin)                                                &
     &  .gt.txwin_lo(iwintx,idtspec_run,iexpt)                          &
     &  .and.                                                           &
     &  time_dtin(idtin)                                                &
     &  .le.txwin_hi(iwintx,idtspec_run,iexpt)                          &
!
     &  .and.time_dtin(idtin).ge.time0                                  &
     &  .and.time_dtin(idtin).le.time1                                  &
!
     &  .and.jzwid(idtin).gt.0                                          &
     &  .and.jzwid(idtin).lt.10000                                      &
     &  )then
          nct_avg_tot=nct_avg_tot+1
        endif
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine wwgt_nmlz
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! calculate and store re-weighting factor to target data pt. density
!
      include 'ens.def'
!
      densdtin_run=(1.d0*nct_avg_tot)                                   &
     &            /(txwin_hi(iwintx,idtspec_run,iexpt)                  &
     &             -txwin_lo(iwintx,idtspec_run,iexpt))
!
      if(jwwgt_win(iwintx,idtspec_run,iexpt).eq.0)                      &
     &  denstarg_run=densdtin_run
!
      if(jwwgt_win(iwintx,idtspec_run,iexpt).eq.1)                      &
     &  denstarg_run=denstarg(iwintx,idtspec_run,iexpt)
!
      if(jwwgt_win(iwintx,idtspec_run,iexpt).eq.2)                      &
     &  denstarg_run=1.d0                                               &
     &  /denstarg(iwintx,idtspec_run,iexpt)
!
      fwwgt_run=1.d0
!
      if(nct_avg_tot.gt.0)                                              &
     &  fwwgt_run=                                                      &
     &  fwwgt_win(iwintx,idtspec_run,iexpt)                             &
     &  *denstarg_run/densdtin_run
!
      do idtin=idtin_i,idtin_f
        if(                                                             &
     &  time_dtin(idtin)                                                &
     &  .gt.txwin_lo(iwintx,idtspec_run,iexpt)                          &
     &  .and.                                                           &
     &  time_dtin(idtin)                                                &
     &  .le.txwin_hi(iwintx,idtspec_run,iexpt)                          &
!
     &  .and.time_dtin(idtin).ge.time0                                  &
     &  .and.time_dtin(idtin).le.time1                                  &
!
     &  .and.jzwid(idtin).gt.0                                          &
     &  .and.jzwid(idtin).lt.10000                                      &
     &  )then
          fwwgt_dtin(idtin)=fwwgt_run
        endif
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine cprs_xpt
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
!  averages exptl. data sets of high exptl. time (txpt) density
!  over short txpt-intervals to then use those averages as
!  "effective data pts." in ensemble chisq-calculation
!
      include 'ens.def'
!
! set jzwid processing flag to exclude certain input data pts.
! from averaging
!V090911:
!DEACTIVATED
!R    do idtin=1,ndtin
!R      if(jzwid(idtin).gt.0) then
!R        if(                                                           &
!R   &    jbaxdi_dtin(idtin).gt.0.or.                                   &
!R   &    nbaxdi_dtin(idtin).gt.0.or.                                   &
!R   &    jzxdi_dtin(idtin).gt.0                                        &
!R   &    )                                                             &
!R   &    jzwid(idtin)=jzwid(idtin)+10000
!R      endif
!R    enddo
!:V090911
!
!
      do iexpt=1,nexpt
        do ims=1,nms_spec
          mblok_ms=0
          jcprs_run=0
          idtspec_run=0
!
          do idtspec=1,ndtspec(iexpt)
            ispec=                                                      &
     &      ispre4name(ierrtag,namespec,nspec                                   &
     &              ,namespec_dtspec(idtspec,iexpt),nspec_y)
!
            if(ierrtag.gt.0) then
              jerrtag=3
              errtag='000120'
              call err_term
            endif
!
!         tabulate all input data blocks for meas. species "ims"
            if(ims.eq.ims_spec(ispec)) then
              mblok_ms=mblok_ms+1
!
              if(mblok_ms.gt.mblok_ms_x) then
            errtag='000059'
            call err_term
              endif
!
              idtspec_blok(mblok_ms)=idtspec
!
!           select input data block to provide global averaging
!           parameters for meas. species "ims", if
!             200=<jcprs_dtspec=<299
!           is specified by some block for this species: 1st
!           such block found will be selected.
              if(                                                       &
     &        jcprs_dtspec(idtspec,iexpt).ge.200                        &
     &        .and.jcprs_dtspec(idtspec,iexpt).le.299                   &
     &        .and.jcprs_run.lt.200                                     &
     &        )then
                jcprs_run=jcprs_dtspec(idtspec,iexpt)
                idtspec_run=idtspec
              endif
!
!        ...or else, signal whether there is at least
!           one input data block of meas.species "ims" to be
!           averaged individually: 1st such block found will
!           be selected.
              if(                                                       &
     &        jcprs_dtspec(idtspec,iexpt).ge.100                        &
     &        .and.jcprs_dtspec(idtspec,iexpt).le.199                   &
     &        .and.jcprs_run.lt.100                                     &
     &        )then
                jcprs_run=jcprs_dtspec(idtspec,iexpt)
                idtspec_run=idtspec
              endif
            endif
          enddo
!
          ispec=ispec_ms(ims)
!
! 100=<jcprs_dtspec=<199:
!   single block-by-block averaging:
!     avg./compress separately for each input data block
!     from meas.species "ims", using the averaging parameters
!     (window numbers and sizes, bin sizes)
!     specified separately for each block of that species w/
!     100=<jcprs_dtspec=<199
! 200=<jcprs_dtspec=<299:
!   global all-block averaging:
!     avg./compress over all data input blocks from same
!     meas.species "ims", using the averaging parameters
!     (window numbers and sizes, bin sizes)
!     specified for the 1st block of that species having
!     200=<jcprs_dtspec=<299
! Priority:
!   "global" overrides "single" block averaging:
!     if at least one block of meas. species "ims" specifies
!        200=<jcprs_dtspec=<299
!     then global averaging over all blocks of that same species
!     and expt. will be performed, regardless of what value of
!     "jcprs_dtspec>=0" is specified for the other blocks of
!     that species.
! Excluding txpt-windows from averaging:
!    any txpt-window "iwintx" in any input species block "idtspec"
!    can be excluded from (single block or global) averaging
!    by setting its
!       jcprs_win=-1
!
!
          if(mblok_ms.gt.0.and.jcprs_run.le.299 )then
            if(jcprs_run.ge.100.and.jcprs_run.le.199) then
              do iblok=1,mblok_ms
                idtspec=idtspec_blok(iblok)
                idtspec_run=idtspec
                jcprs_run=jcprs_dtspec(idtspec,iexpt)
                nwintx_run=nwintx(idtspec_run,iexpt)
!
                if(jcprs_run.ge.100.and.jcprs_run.le.199) then
                  do iwintx=1,nwintx_run
                    if(jcprs_win(iwintx,idtspec,iexpt).eq.-1) goto 190
!
                    odtxwin_nbintx                                      &
     &              =1.d0/(txwin_hi(iwintx,idtspec_run,iexpt)           &
     &                    -txwin_lo(iwintx,idtspec_run,iexpt))
                    odtxwin_nbintx=odtxwin_nbintx                       &
     &                        *nbintx(iwintx,idtspec_run,iexpt)
!
   10               continue
                    call cprs_inlz
                    idtin_i=idtin_sxi(idtspec,iexpt)
                    idtin_f=idtin_sxf(idtspec,iexpt)
                    call cprs_accu
                    call cprs_nmlz
!
! repeat averaging cycle, in case there are data pts. of "other" SFC
! which have not yet been averaged in previous cycle(s)
!
                    if(nct_avg_tot.gt.0) goto 10
!
  190               continue
                  enddo
                endif
              enddo
              jcprs_run=-100
            endif
!
!
            if(jcprs_run.ge.200.and.jcprs_run.le.299) then
              nwintx_run=nwintx(idtspec_run,iexpt)
              do iwintx=1,nwintx_run
                odtxwin_nbintx                                          &
     &          =1.d0/(txwin_hi(iwintx,idtspec_run,iexpt)               &
     &                -txwin_lo(iwintx,idtspec_run,iexpt))
                odtxwin_nbintx=odtxwin_nbintx                           &
     &                      *nbintx(iwintx,idtspec_run,iexpt)
!
   20           continue
                call cprs_inlz
                do iblok=1,mblok_ms
                  idtspec=idtspec_blok(iblok)
                  if(jcprs_win(iwintx,idtspec,iexpt).eq.-1) goto 290
!
                  idtin_i=idtin_sxi(idtspec,iexpt)
                  idtin_f=idtin_sxf(idtspec,iexpt)
                  call cprs_accu
!
  290             continue
                enddo
                call cprs_nmlz
!
! repeat averaging cycle, in case there are data pts. of "other" SFC
! which have not yet been averaged in previous averaging cycle(s)
!
                if(nct_avg_tot.gt.0) goto 20
              enddo
            endif
!
          endif
        enddo
      enddo
!
! reset jzwid>10000 to proper pos. value
      do idtin=1,ndtin
        if(jzwid(idtin).gt.10000) jzwid(idtin)=jzwid(idtin)-10000
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine cprs_inlz
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! initialize binned counter and accumulator arrays for
! accumulation of time and conc. averages from a single
! species input data block, delimited by idtin_i, idtin_f
! for single binned window from "cprs_xpt"
!
      include 'ens.def'
!
!
              nct_avg_tot=0
              do ibintx=1,nbintx(iwintx,idtspec_run,iexpt)
                idtin_avg(ibintx)=-1
                lscal_avg(ibintx)=-1
                nct_avg(ibintx)=0
!
                ti_avg(ibintx)=0.d0
                zx_avg(ibintx)=0.d0
                zw_avg(ibintx)=0.d0
              enddo
!
!
      return
      end
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine cprs_accu
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! accumulate scores for time and conc. averages from a single
! species input data block, delimited by idtin_i, idtin_f
! for single binned window from "cprs_xpt"
!
      include 'ens.def'
!
!
                do idtin=idtin_i,idtin_f
                  if(                                                   &
     &            time_dtin(idtin)                                      &
     &            .gt.txwin_lo(iwintx,idtspec_run,iexpt)                &
     &            .and.                                                 &
     &            time_dtin(idtin)                                      &
     &            .le.txwin_hi(iwintx,idtspec_run,iexpt)                &
!
     &            .and.time_dtin(idtin).ge.time0                        &
     &            .and.time_dtin(idtin).le.time1                        &
!
     &            .and.jzwid(idtin).gt.0                                &
     &            .and.jzwid(idtin).lt.10000                            &
     &            )then
!
!                 find bin to accumulate scores into
                    adum1=odtxwin_nbintx*                               &
     &                   (time_dtin(idtin)                              &
     &                   -txwin_lo(iwintx,idtspec_run,iexpt)            &
     &                   )
                    ibintx=adum1
                    ibintx=ibintx+1
                    if(ibintx.lt.1) ibintx=1
                    if(ibintx.gt.nbintx(iwintx,idtspec_run,iexpt))      &
     &              ibintx=nbintx(iwintx,idtspec_run,iexpt)
!
!                 skip over data points having "wrong" SFC for
!                 this bin; they will be processed later, in a repeat
!                 averaging run
                    if(idtin_avg(ibintx).ge.1                           &
     &              .and.lscal_avg(ibintx).ne.lscal(idtin)) goto 89
!
!                 calculate scaled conc. data value
                    xtx=zspec_xpt(idtin)/(zscal(idtin)*glob_scal)
!
!                 calculate weight factor for averaging:
!                 jzwid=1 -> absolute (1/e) Gaussian width of zspec
                    if(jzwid(idtin).eq.1) then
                      wtx                                               &
     &                =zspec_wid(idtin)/(zscal(idtin)*glob_scal)
!
!cc                   yspec_wid(itmx_xpt(ims,itxpt,iexpt))=
!cc  :                dlog(1.d0+xspec_wid(itmx_xpt(ims,itxpt,iexpt))
!cc  :                 /xspec_xpt(itmx_xpt(ims,itxpt,iexpt)))
                    endif
!
!                 jzwid=2 -> relative (1/e) Gaussian width of z/xspec
                    if(jzwid(idtin).eq.2) then
                      wtx=zspec_wid(idtin)*xtx
!cc                   yspec_wid(itmx_xpt(ims,itxpt,iexpt))=
!cc  :                dlog(1.d0+zspec_wid(idtin))
                    endif
!
!                 jzwid=3 -> absolute (1/e) Gaussian width of yspec
                    if(jzwid(idtin).eq.3) then
!cc                   yspec_wid(itmx_xpt(ims,itxpt,iexpt))=zspec_wid(idtin)
                      wtx=                                              &
     &                (dexp(zspec_wid(idtin)                            &
     &                      /(1.d0+zspec_wid(idtin)/dlog(1.0d20))       &
     &                     )                                            &
     &                 -1.d0                                            &
     &                )                                                 &
     &                *xtx
                    endif
!
!                 accumulate sums for averaging and count
!                 total idtin-hits for entire  window
                    ti_avg(ibintx)=ti_avg(ibintx)                       &
     &                            +time_dtin(idtin)/wtx**2
                    zx_avg(ibintx)=zx_avg(ibintx)                       &
     &                            +xtx/wtx**2
                    zw_avg(ibintx)=zw_avg(ibintx)                       &
     &                            +1.d0/wtx**2
                    nct_avg(ibintx)=nct_avg(ibintx)+1
                    nct_avg_tot=nct_avg_tot+1
!
!                 select the "idtin" of 1st data pt. accumulated to serve
!                 as storage for the new, average data pt. from this bin;
!                 the lscal-value of this "lead data pt." will be enforced
!                 for this bin for the entire averaging run, to ensure
!                 that only data pts. of the same SFC will be included in
!                 the average
                    if(idtin_avg(ibintx).eq.-1) then
                      idtin_avg(ibintx)=idtin
                      lscal_avg(ibintx)=lscal(idtin)
                      jzwid(idtin)=10001
                    endif
!
!                 ...or, for all other input data pts. "idtin" being averaged
!                 into this bin,  set jzwid=-10000
                    if(idtin_avg(ibintx).ne.idtin)                      &
     &              jzwid(idtin)=-10000
                  endif
!
!                 Note: jzwid=-10000<0 or jzwid>=10000 signals that this
!                 data pt. has now already been processed into an average
!                 and must not be so processed again in subsequent
!                 averaging runs. jzwid<0 also signals that this
!                 data pt. is now to be excluded from the \chi^2 calculation
!                 in the ensemble MC run.
!
   89             continue
                enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine cprs_nmlz
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! normalize accumulated scores for time and conc. averages from a
! single species input data block, for single binned window
! from "cprs_xpt"
!
      include 'ens.def'
!
! calculate and store averages and resp. new Gaussian (1/e) width
! and set zscal to the appropriate value (1.0)
              do ibintx=1,nbintx(iwintx,idtspec_run,iexpt)
                if(nct_avg(ibintx).gt.0                                 &
     &          .and.idtin_avg(ibintx).ge.1                             &
     &          )then
                  idtin=idtin_avg(ibintx)
                  time_dtin(idtin)=ti_avg(ibintx)/zw_avg(ibintx)
                  zspec_xpt(idtin)=zx_avg(ibintx)/zw_avg(ibintx)
                  zspec_wid(idtin)=dsqrt(dabs(1.d0/zw_avg(ibintx)))
                  zscal(idtin)=1.d0
                endif
              enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine stot_xpt
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! merge, order and tabulate exptl. time points of all measured species
!
      include 'ens.def'
!
!
!   assign input exptl. time points "time_dtin" to
!   common time values "time_xpt"
!
!   tabulate exptl. time points without multiplicities
      ktxpt=0
      do idtin=1,ndtin
        if(jzwid(idtin).gt.0) then
          if(ktxpt.gt.0) then
            do ktxpt0=1,ktxpt
              if(time_xpt_kt(ktxpt0).eq.time_dtin(idtin))               &
     &        goto 310
            enddo
          endif
          ktxpt=ktxpt+1
!
          if(ktxpt.gt.ntxpt_x) then
            ispec=ispec_dtin(idtin)
            iexpt=iexpt_dtin(idtin)
            errtag='000060'
            call err_term
          endif
          time_xpt_kt(ktxpt)=time_dtin(idtin)
!
  310     continue
        endif
      enddo
      mtxpt=ktxpt
!
!   re-store exptl. time points in ascending order
      do ktxpt=1,mtxpt
        ktxpt1=1
        do ktxpt0=1,mtxpt
          if(time_xpt_kt(ktxpt0).lt.time_xpt_kt(ktxpt))                 &
     &    ktxpt1=ktxpt1+1
        enddo
        time_xpt_kt1(ktxpt1)=time_xpt_kt(ktxpt)
      enddo
!
      do ktxpt=1,mtxpt
        time_xpt_kt(ktxpt)=time_xpt_kt1(ktxpt)
      enddo
!
!   tabulate multiplicity "ltxpt_kt" of each different time point,
!   within same species and same expt.
!   merge multiple lists of same species/same expt. here, in the
!   the multiplicity count
      do ktxpt=1,mtxpt
        ltxpt_kt(ktxpt)=0
        do iexpt=1,nexpt
          do idtspec=1,ndtspec(iexpt)
            ltxpt0=0
!
            ispec=                                                      &
     &      ispre4name(ierrtag,namespec,nspec                                   &
     &                ,namespec_dtspec(idtspec,iexpt),nspec_y)
!
            if(ierrtag.gt.0) then
              jerrtag=4
              errtag='000120'
              call err_term
            endif
!
            do idtspec1=1,ndtspec(iexpt)
              ispec1=                                                   &
     &        ispre4name(ierrtag,namespec,nspec                                 &
     &                  ,namespec_dtspec(idtspec1,iexpt),nspec_y)
!
              if(ierrtag.gt.0) then
                jerrtag=5
                errtag='000120'
                call err_term
              endif
!
              if(ispec.eq.ispec1) then
                if(idtspec.gt.idtspec1) goto 390
!
                do idtin=idtin_sxi(idtspec1,iexpt)                      &
     &                  ,idtin_sxf(idtspec1,iexpt)
                  if(jzwid(idtin).gt.0) then
                    if(time_xpt_kt(ktxpt).eq.time_dtin(idtin)           &
     &              )then
                      ltxpt0=ltxpt0+1
                    endif
                  endif
                enddo
              endif
            enddo
!
            if(ltxpt0.gt.ltxpt_kt(ktxpt))                               &
     &      ltxpt_kt(ktxpt)=ltxpt0
!
  390       continue
          enddo
        enddo
!
        if(ltxpt_kt(ktxpt).eq.0) then
            errtag='000061'
            call err_term
        endif
      enddo
!
!   tabulate exptl. time points with their max. multiplicities
!
      itxpt=0
      do ktxpt=1,mtxpt
        itxpt_kt(ktxpt)=itxpt+1
        do ltxpt0=1,ltxpt_kt(ktxpt)
          itxpt=itxpt+1
!
          if(itxpt.gt.ntxpt_x) then
            errtag='000062'
            call err_term
          endif
!
          time_xpt(itxpt)=time_xpt_kt(ktxpt)
        enddo
      enddo
      ntxpt=itxpt
!
!   tabulate "itxpt"-index for each input exptl. data point "idtin"
!   using merged same-species input lists
      do ktxpt=1,mtxpt
        do iexpt=1,nexpt
          do idtspec=1,ndtspec(iexpt)
            itxpt=itxpt_kt(ktxpt)-1
!
            ispec=                                                      &
     &      ispre4name(ierrtag,namespec,nspec                                   &
     &                ,namespec_dtspec(idtspec,iexpt),nspec_y)
!
            if(ierrtag.gt.0) then
              jerrtag=6
              errtag='000120'
              call err_term
            endif
!
            do idtspec1=1,ndtspec(iexpt)
              ispec1=                                                   &
     &        ispre4name(ierrtag,namespec,nspec                                 &
     &                  ,namespec_dtspec(idtspec1,iexpt),nspec_y)
!
              if(ierrtag.gt.0) then
                jerrtag=7
                errtag='000120'
                call err_term
              endif
!
              if(ispec.eq.ispec1) then
                if(idtspec.gt.idtspec1) goto 490
!
                do idtin=idtin_sxi(idtspec1,iexpt)                      &
     &                  ,idtin_sxf(idtspec1,iexpt)
                  if(jzwid(idtin).gt.0) then
                    if(time_xpt_kt(ktxpt).eq.time_dtin(idtin)) then
                      itxpt=itxpt+1
                      itxpt_dtin(idtin)=itxpt
                    endif
                  else
                    itxpt_dtin(idtin)=0
                  endif
                enddo
              endif
            enddo
!
  490       continue
          enddo
        enddo
      enddo
!
!   check for out-of-bounds exptl. time points
      idtin=0
      do iexpt=1,nexpt
        do idtspec=1,ndtspec(iexpt)
          do ldtin=1,ntxpt_dtspec(idtspec,iexpt)
            idtin=idtin+1
            if(jzwid(idtin).gt.0) then
              itxpt=itxpt_dtin(idtin)
              ispec=ispec_dtin(idtin)
              if(time_xpt(itxpt).gt.time1                               &
     &        .or.time_xpt(itxpt).lt.time0) then
                open(31,file='ens.o01',status='old')
                iun=31
                call efile(iun)
                write(31,*) ' WARNING from input file ens.i02'
                write(31,*) ' exptl. time point out of bounds for'
                write(31,*)                                             &
     &          '   iexpt, ispec, itxpt, idtspec, ldtin='               &
     &          ,iexpt, ispec, itxpt, idtspec, ldtin
                write(31,*) '   namespec_dtspec(idtspec,iexpt)='
                write(31,2020)  namespec_dtspec(idtspec,iexpt)
 2020           format(a80)
                write(31,*) '   time0, time1=',time0, time1
                write(31,*)                                             &
     &          '   time_dtin(idtin)=',time_dtin(idtin)
                write(31,*)                                             &
     &          '   zspec_xpt(idtin)=',zspec_xpt(idtin)
                write(31,*)                                             &
     &          '   zspec_wid(idtin)=',zspec_wid(idtin)
                write(31,*)                                             &
     &          ' out-of-bound data pts. will be masked and ignored'
                write(31,*) ' EXECUTION CONTINUED'
                close(31)
              endif
            endif
          enddo
        enddo
      enddo
!
!   find lower and upper within-bounds "itxpt"-limits
      itxpt_min=1
      itxpt_max=ntxpt
!
      do itxpt=1,ntxpt
        if(time_xpt(itxpt).lt.time0)                                    &
     &  itxpt_min=itxpt+1
        if(time_xpt(ntxpt+1-itxpt).gt.time1)                            &
     &  itxpt_max=ntxpt-itxpt
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine form_xpt
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! format exptl. time and conc. data into arrays
!   xspec_xpt, xspec_wid, yspec_xpt, yspec_wid
! for chisq calculations
!
      include 'ens.def'
!
!   sort exptl. input data into "xspec"-arrays and
!   mask all missing or excluded data pts.
!
      do iexpt=1,nexpt
        do ims=1,nms_spec
          do itxpt=1,ntxpt
            itmx_xpt(ims,itxpt,iexpt)=0
!
!c          yspec_wid(itmx_xpt(ims,itxpt,iexpt))=-1.d0
!c          yspec_xpt(itmx_xpt(ims,itxpt,iexpt))= 0.d0
!
!c          xspec_wid(itmx_xpt(ims,itxpt,iexpt))=-1.d0
!c          xspec_xpt(itmx_xpt(ims,itxpt,iexpt))=-1.d0
!
!c          lscal_xpt(itmx_xpt(ims,itxpt,iexpt))=-100
!c          jbaxdi_xpt(itmx_xpt(ims,itxpt,iexpt))=-1
!c          nbaxdi_xpt(itmx_xpt(ims,itxpt,iexpt))=-1
!c          jzxdi_xpt(itmx_xpt(ims,itxpt,iexpt))=-1
          enddo
        enddo
      enddo
!
      yspec_wid(0)=-1.d0
      yspec_xpt(0)= 0.d0
!
      xspec_wid(0)=-1.d0
      xspec_xpt(0)=-1.d0
!
      lscal_xpt(0)=-100
!V090911:
!DEACTIVATED
!R    jbaxdi_xpt(0)=-1
!R    nbaxdi_xpt(0)=-1
!R    jzxdi_xpt(0)=-1
!:V090911
!
      itmx=0
      do iexpt=1,nexpt
        do ims=1,nms_spec
          ispec=ispec_ms(ims)
          itmx_ini(ims,iexpt)=itmx+1
          do itxpt=1,ntxpt
            do idtin=1,ndtin
              if(itxpt.ne.itxpt_dtin(idtin)) goto 590
              if(ispec.ne.ispec_dtin(idtin)) goto 590
              if(iexpt.ne.iexpt_dtin(idtin)) goto 590
              if(jzwid(idtin).gt.0) then
                if(jmsspec_ch(ispec).gt.0                               &
     &          .and.time_dtin(idtin).ge.time0                          &
     &          .and.time_dtin(idtin).le.time1                          &
     &          ) then
                  itmx=itmx+1
!
                  if(itmx.gt.mdtin_x) then
                    iun=31
                    call efile(iun)
                      errtag='000063'
                      call err_term
                  endif
!
                  itmx_xpt(ims,itxpt,iexpt)=itmx
                  itxpt_tmx(itmx)=itxpt
!
                  xspec_xpt(itmx_xpt(ims,itxpt,iexpt))                  &
     &            =zspec_xpt(idtin)/(zscal(idtin)*glob_scal)
!
                  yspec_xpt(itmx_xpt(ims,itxpt,iexpt))=                 &
     &            dlog(dabs(xspec_xpt(itmx_xpt(ims,itxpt,iexpt))))
!
                  lscal_xpt(itmx_xpt(ims,itxpt,iexpt))=lscal(idtin)
!
!V090911:
!DEACTIVATED
!R                jbaxdi_xpt(itmx_xpt(ims,itxpt,iexpt))=                &
!R   &                       jbaxdi_dtin(idtin)
!R                nbaxdi_xpt(itmx_xpt(ims,itxpt,iexpt))=                &
!R   &                       nbaxdi_dtin(idtin)
!R                jzxdi_xpt(itmx_xpt(ims,itxpt,iexpt))=                 &
!R   &                       jzxdi_dtin(idtin)
!:V090911
!
                  fwgt(itmx_xpt(ims,itxpt,iexpt))=1.d0
!
!        Input "zspec_wid" is ...
!
!             jzwid=1 -> ... absolute (1/e) Gaussian width of xspec
                  if(jzwid(idtin).eq.1) then
                    xspec_wid(itmx_xpt(ims,itxpt,iexpt))                &
     &              =zspec_wid(idtin)/(zscal(idtin)*glob_scal)
!
                    yspec_wid(itmx_xpt(ims,itxpt,iexpt))=               &
     &              dlog(1.d0+xspec_wid(itmx_xpt(ims,itxpt,iexpt))      &
     &                       /xspec_xpt(itmx_xpt(ims,itxpt,iexpt))      &
     &                  )
                  endif
!
!             jzwid=2 -> ... relative (1/e) Gaussian width of xspec
                  if(jzwid(idtin).eq.2) then
                    xspec_wid(itmx_xpt(ims,itxpt,iexpt))=               &
     &                        zspec_wid(idtin)                          &
     &                       *xspec_xpt(itmx_xpt(ims,itxpt,iexpt))
!
                    yspec_wid(itmx_xpt(ims,itxpt,iexpt))=               &
     &              dlog(1.d0+zspec_wid(idtin))
                  endif
!
!             jzwid=3 -> ... absolute (1/e) Gaussian width of yspec
                  if(jzwid(idtin).eq.3) then
                    yspec_wid(itmx_xpt(ims,itxpt,iexpt))=               &
     &                       zspec_wid(idtin)
                    xspec_wid(itmx_xpt(ims,itxpt,iexpt))=               &
     &              (dexp(zspec_wid(idtin)                              &
     &                    /(1.d0+zspec_wid(idtin)/dlog(1.0d20))         &
     &                   )                                              &
     &               -1.d0                                              &
     &              )                                                   &
     &              *xspec_xpt(itmx_xpt(ims,itxpt,iexpt))
                  endif
!
!             apply txpt-window data density re-weight factors:
                  yspec_wid(itmx_xpt(ims,itxpt,iexpt))=                 &
     &            yspec_wid(itmx_xpt(ims,itxpt,iexpt))                  &
     &            /dsqrt(dabs(fwwgt_dtin(idtin)))
!
                  xspec_wid(itmx_xpt(ims,itxpt,iexpt))=                 &
     &            xspec_wid(itmx_xpt(ims,itxpt,iexpt))                  &
     &            /dsqrt(dabs(fwwgt_dtin(idtin)))
                endif
              endif
  590         continue
            enddo
          enddo
          itmx_fin(ims,iexpt)=itmx
        enddo
      enddo
!
      mdtin=itmx
!
!
! output exptl. time points
!
      if(mp_myid.eq.0) then
        open(31,file='ens.o01',status='old')
        iun=31
        call efile(iun)
        write(31,*) ' '
        write(31,*) ' '
        write(31,*) ' exptl. time points and multiplicities'
!
        write(31,3110) ndtin, mdtin, ntxpt, itxpt_min, itxpt_max, mtxpt
 3110   format(              &
     &   '   ndtin   mdtin   ntxpt itxpt_min itxpt_max mtxpt'           &
     &  /6i8                                                            &
     &  /'   itxpt        time_xpt'                                     &
       &)
!
        do itxpt=1,ntxpt
          write(31,3112) itxpt, time_xpt(itxpt)
 3112     format(i8,d16.8)
        enddo
!
        write(31,3120)
 3120   format(         &
     &  /'   itxpt        time_xpt itxpt_kt ltxpt_kt'                   &
     &  )
!
        do ktxpt=1,mtxpt
          write(31,3122)                                                &
     &      ktxpt                                                       &
     &    , time_xpt_kt(ktxpt)                                          &
     &    , itxpt_kt(ktxpt)                                             &
     &    , ltxpt_kt(ktxpt)
 3122     format(i8,d16.8,2i8)
        enddo
!
!
        write(31,3130)
 3130   format(         &
     &  /'   idtin   time_dtin    err_txpt itxpt_dtin'                  &
     &  )
!
        do idtin=1,ndtin
          if(jzwid(idtin).gt.0) then
            err_txpt=                                                   &
     &      time_dtin(idtin)-time_xpt(itxpt_dtin(idtin))
            write(31,3132)                                              &
     &        idtin                                                     &
     &      , time_dtin(idtin)                                          &
     &      , err_txpt                                                  &
     &      , itxpt_dtin(idtin)
 3132       format(i8,d16.8,d12.4,i8)
          endif
        enddo
!
        close(31)
      endif
!
!
!V090911:
      call mp_qini
!:V090911
!
      close(39)
      inquire(file='ens.o09',exist=fexist)
      if(fexist) then
        open(39,file='ens.o09',status='old')
        iun=39
        call efile(iun)
      else
!BLADE:
!       open(39,file='ens.o09',status='new')
        open(39,file='ens.o09')
!:BLADE
      endif
!
!
      write(39,*) 'SORTING DATA FROM "ens.i02" COMPLETED SUCCESSFULLY'
      write(39,*) '  ntxpt=',ntxpt
      write(39,*) 'LEAVING "form_xpt", mp_myid=', mp_myid
      write(39,*) ' '
      write(39,*) ' '
!
      close(39)
!
!V090911:
      call mp_qfin
!:V090911
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine alloc_odpen
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! allocate storage for dependents of exptl. data points
!
      include 'ens.def'
!
!
      do iexpt=1,nexpt
        do ims=1,nms_spec
          itmx_ini_odp(ims,iexpt)=itmx_ini(ims,iexpt)
          itmx_fin_odp(ims,iexpt)=itmx_fin(ims,iexpt)
        enddo
      enddo
!
      do ims=1,nms_spec
        ims_PD(ims)=0
      enddo
!
!
      mdtin_odp=mdtin
      ispec_M=0
      do ipriodp=1,ndpen_tot
        idpen=idpen_prio(ipriodp)
        ispec_D=ispec_dpen(idpen)
        if(ispec_D.le.0) goto 190
        if(ispec_D.eq.ispec_M) goto 190
!N180810
        if(jfix(ispec_D).ne.-100.and.jfix(ispec_D).ne.-110) goto 190
!
        ims_D=ims_spec(ispec_D)
        if(ims_D.le.0) goto 190
!
        ispre_D=ispre_dpen(idpen)
        ipm_D=ipm_dpen(idpen)
!
        if(                                                             &
     &  jctspre(ispre_D,ipm_D).ne.30.and.                               &
     &  jctspre(ispre_D,ipm_D).ne.40) goto 190
!
        mparn=mparn_dpen(idpen)
!
        do iparn=1,mparn
          ipm_P=ipm_parn(iparn,idpen)
          ispre_P=ispre_parn(iparn,idpen)
          call tr_spre(ispec_P,ireac_P,ispre_P,nspec)
!
!         find an xspec_xpt or yspec_xpt as parent "ims_P"
!         definining the range of itmx-values for "ims_D"
!
          ims_P=-1
          if(ipm_P.le.-300.and.ipm_P.ge.-309) then
            ims_P=ims_spec(ispec_P)
            goto 20
!c          pmfunc(iparn)=
!c   :      xspec_xpt(itmx_xpt(ims_P,itxpt,iexpt))
          endif
!
          if(ipm_P.le.-400.and.ipm_P.ge.-409) then
            ims_P=ims_spec(ispec_P)
            goto 20
!c          pmfunc(iparn)=
!c   :      yspec_xpt(itmx_xpt(ims_P,itxpt,iexpt))
          endif
        enddo
   20   continue
!
! redundant, see also "Check 7" in "set_fix_dpen":
        if(ims_P.le.0) then
            errtag='000064'
            call err_term
        endif
!
        ims_PD(ims_D)=ims_P
!
!       allocate same itmx-range for the dependent "ims_D" as
!       already allocated for the parent "ims_P"; store new range
!       limits under diff. names: "itmx_ini_odp" and "itmx_fin_odp",
!       attached to the storage of "mdtin" exptl. data points.
        do iexpt=1,nexpt
          itmx_ini_odp(ims_D,iexpt)=mdtin_odp+1
          itmx_fin_odp(ims_D,iexpt)=mdtin_odp+1+                        &
     &    itmx_fin_odp(ims_P,iexpt)-itmx_ini_odp(ims_P,iexpt)
!
          mdtin_odp=itmx_fin_odp(ims_D,iexpt)
          if(mdtin_odp.gt.mdtin_odp_x) then
            errtag='000065'
            call err_term
          endif
        enddo
!
!
        ispec_M=ispec_D
  190   continue
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_sfc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! tabulate scale factor classes
!
      include 'ens.def'
!
!
      iscal=0
      do iexpt=1,nexpt
        do itxpt=1,ntxpt
          do ims=1,nms_spec
            if(iscal.gt.0) then
              do iscal0=1,iscal
                if(lscal_is(iscal0)                                     &
     &          .eq.lscal_xpt(itmx_xpt(ims,itxpt,iexpt)))               &
     &          goto 310
              enddo
            endif
            iscal=iscal+1
!
            if(iscal.gt.niscal_x) then
            errtag='000066'
            call err_term
            endif
!
            lscal_is(iscal)=lscal_xpt(itmx_xpt(ims,itxpt,iexpt))
  310       continue
          enddo
        enddo
      enddo
!
      niscal=iscal
!
! re-tabulate "lscal_is" in ascending order
      do iscal=1,niscal
        iscal1=1
        do iscal0=1,niscal
          if(lscal_is(iscal0).lt.lscal_is(iscal)) then
            iscal1=iscal1+1
          endif
        enddo
        lscal_is1(iscal1)=lscal_is(iscal)
      enddo
!
      do iscal=1,niscal
        lscal_is(iscal)=lscal_is1(iscal)
      enddo
!
! tabulate "iscal"-index for each exptl. data pt.
      do iexpt=1,nexpt
        do itxpt=1,ntxpt
          do ims=1,nms_spec
            iscal_xpt(itmx_xpt(ims,itxpt,iexpt))=0
            do iscal=1,niscal
              if(lscal_is(iscal)                                        &
     &        .eq.lscal_xpt(itmx_xpt(ims,itxpt,iexpt)))                 &
     &        iscal_xpt(itmx_xpt(ims,itxpt,iexpt))=iscal
            enddo
            if(iscal_xpt(itmx_xpt(ims,itxpt,iexpt)).eq.0) then
              errtag='000067.00'
              call err_term
            endif
          enddo
        enddo
      enddo
!
! combine scale factor sub-classes (if any),
! which must be labeled by "lscal" with
!     lscal >= 10000,
! into full scale factor classes, labeled by "mscal".
! All sub-classes "lscal" with
!     mscal <= lscal < mscal+100
! are combined into the same class "mscal" where the value of
! "mscal" is >=10000 and an integer multiple of 100.
! For  lscal<10000, we set
!     mscal=lscal
! i.e. each lscal<10000 labels a full separate class,
! i.e. sub-class=class.
!
      do iscal=1,niscal
        if(lscal_is(iscal).lt.10000) then
          mscal_is(iscal)=lscal_is(iscal)
        else
          idum=lscal_is(iscal)-10000
          idum1=idum/100
          idum2=100*idum1
          mscal_is(iscal)=10000+idum2
        endif
      enddo
!
      kscal=0
      do iscal=1,niscal
        if(kscal.gt.0) then
          do kscal0=1,kscal
            if(mscal_ks(kscal0).eq.mscal_is(iscal)) goto 410
          enddo
        endif
        kscal=kscal+1
        mscal_ks(kscal)=mscal_is(iscal)
  410   continue
      enddo
      nkscal=kscal
!
      do iscal=1,niscal
        do kscal=1,nkscal
          if(mscal_ks(kscal).eq.mscal_is(iscal))                        &
     &    kscal_is(iscal)=kscal
        enddo
      enddo
!
      do iexpt=1,nexpt
        do itxpt=1,ntxpt
          do ims=1,nms_spec
            if(itmx_xpt(ims,itxpt,iexpt).gt.0) then
              kscal_xpt(itmx_xpt(ims,itxpt,iexpt))=                     &
     &        kscal_is(iscal_xpt(itmx_xpt(ims,itxpt,iexpt)))
            else
              kscal_xpt(itmx_xpt(ims,itxpt,iexpt))=0
            endif
          enddo
        enddo
      enddo
!
!
! check that each SFC consists of either purely log-data or
! purely lin-data if SF randomization (jrasf_ctl=2) is to
! be used in any move sequence (imvsequ,jmvloop)
! also tabulate "jmsspec_ch" index by SFC if jrasf_ctl=1,2:
!   jmsspec_ch_ks= 1 <--> log-species SFC
!   jmsspec_ch_ks= 2 <--> lin-species SFC
!   jmsspec_ch_ks=-1 <--> mixed log+lin-species SFC (jrasf_ctl|=2 only)
!
      do kscal=1,nkscal
        jmsspec_ch_ks(kscal)=0
      enddo
!
      do jmvloop=1,2
        do imvsequ=1,nmvsequ(jmvloop)
          if(                                                   &
     &    jrasf_ctl(imvsequ,jmvloop).eq.1.or.                   &
     &    jrasf_ctl(imvsequ,jmvloop).eq.2                       &
     &    ) then
            do iexpt=1,nexpt
              do ims=1,nms_spec
                ispec=ispec_ms(ims)
                do itmx=itmx_ini(ims,iexpt),itmx_fin(ims,iexpt)
                  idum1=jmsspec_ch_ks(kscal_xpt(itmx))
                  idum2=0
                  if(jmsspec_ch(ispec).eq.0) idum2=2
                  if(jmsspec_ch(ispec).eq.1) idum2=1
                  if(jmsspec_ch(ispec).eq.2) idum2=2
                  if(idum2.eq.0)then
                      errtag='000067.01 ILLEGAL jmsspec_ch value'
                      call err_term
                    endif
!
                  if(idum1.eq.0) then
                    jmsspec_ch_ks(kscal_xpt(itmx))=idum2
                  else
                    if(                                         &
     &              idum1.ne.idum2.and.                         &
     &              jrasf_ctl(imvsequ,jmvloop).eq.2             &
     &              )then
                      errtag='000067.02 ILLEGAL log-lin mixing'
                      call err_term
                    endif
!
                    if(                                         &
     &              idum1.ne.idum2.and.                         &
     &              jrasf_ctl(imvsequ,jmvloop).eq.1             &
     &              )then
                      jmsspec_ch_ks(kscal_xpt(itmx))=-1
                    endif
                  endif
                enddo
              enddo
            enddo
            goto 590
          endif
        enddo
      enddo
  590 continue
!
      imvsequ=-1
      jmvloop=-1
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_prex
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! set up tables for pre-summation of exptl. data points
! and do the pre-summation
!
      include 'ens.def'
!
      iipch_tmx(0)=-1
      iipch=-1
!     Note:
!     iipch-label value start at iipch=0
!
      do iexpt=1,nexpt
        do ims=1,nms_spec
          iipch_ini(ims,iexpt)=iipch+1
!
          ispec=ispec_ms(ims)
          if(jmsspec_px(ispec).eq.1) then
            do itxpt=1,ntxpt
              itmx=itmx_xpt(ims,itxpt,iexpt)
!
              if(itmx.gt.0) then
                itime0=itime_xpt(itxpt)
!               Note: using "do itxpt" here in order to
!               make sure "itime0"  is processed in ascending order
!               even if "itxpt_tmx" is not in ascending order...
!
                iscal=iscal_xpt(itmx)
!
                do jsig=0,1
                  itime=itime0+jsig
!
                  jipch_nx=1
                  do iipch0=iipch_ini(ims,iexpt),iipch
                    if(                                                 &
     &              itime_ipch(iipch0).eq.itime.and.                    &
     &              iscal_ipch(iipch0).eq.iscal                         &
     &              )then
                      jipch_nx=0
!
                      if(jsig.eq.0)  iipch_tmx(itmx)=iipch0
!
!c                    if(jsig_ipch(iipch0).ne.jsig)
!c   :                jsig_ipch(iipch0)=2
                    endif
                  enddo
                  if(jipch_nx.eq.0) goto 190
!
                  iipch=iipch+1
                  if(iipch.gt.nipch_x) then
                    errtag='000068'
                    call err_term
                  endif
!
                  itime_ipch(iipch)=itime
!c                jsig_ipch(iipch)=jsig
                  iscal_ipch(iipch)=iscal_xpt(itmx)
                  kscal_ipch(iipch)=kscal_is(iscal_ipch(iipch))
                  if(jsig.eq.0) iipch_tmx(itmx)=iipch
!
  190             continue
                enddo
              endif
            enddo
          endif
          iipch_fin(ims,iexpt)=iipch
        enddo
      enddo
!
      nipch=iipch
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine chi_prex
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! pre-sum exptl. data points for chisq-calculation
!
!
      include 'ens.def'
!
      jrasf_ctl_ij=-1
      if(jmvloop.ge.1.and.jmvloop.le.2) then
        if(imvsequ.ge.1.and.imvsequ.le.nmvsequ(jmvloop))      &
     &  jrasf_ctl_ij=jrasf_ctl(imvsequ,jmvloop)
      endif
!
      do iipch=0,nipch
        dchi21u_ipch(iipch,jfwgt)=0.d0
        dchi220u_ipch(iipch,jfwgt)=0.d0
        dchi221u_ipch(iipch,jfwgt)=0.d0
        dchi11u_ipch(iipch,jfwgt)=0.d0
!
        if(jscal.eq.2.or.jrasf_ctl_ij.ge.0) then
          achig10u_ipch(iipch,jfwgt)=0.d0
          achig11u_ipch(iipch,jfwgt)=0.d0
          achig20u_ipch(iipch,jfwgt)=0.d0
          achig21u_ipch(iipch,jfwgt)=0.d0
!
          achin11u_ipch(iipch,jfwgt)=0.d0
          achin20u_ipch(iipch,jfwgt)=0.d0
          achin21u_ipch(iipch,jfwgt)=0.d0
        endif
      enddo
!
      do iscal=1,niscal
        dchi20u_is(iscal,jfwgt)=0.d0
        dchi10u_is(iscal,jfwgt)=0.d0
        chi0u_is(iscal,jfwgt)=1.d-20
      enddo
!
      achig00u(jfwgt)=0.d0
      achin00u(jfwgt)=0.d0
      do kscal=1,nkscal
        achig01u_ks(kscal,jfwgt)=0.d0
        achig02u_ks(kscal,jfwgt)=0.d0
      enddo
!
!
      do iexpt=1,nexpt
        do ims=1,nms_spec
          ispec=ispec_ms(ims)
          if(jmsspec_px(ispec).eq.1) then
            do itmx=itmx_ini(ims,iexpt),itmx_fin(ims,iexpt)
              iipch0=iipch_tmx(itmx)
              itxpt=itxpt_tmx(itmx)
              iscal=iscal_ipch(iipch0)
!
              rt_sig(1)=rt_xpt(itxpt)
              rt_sig(0)=1.d0-rt_sig(1)
              if(jfwgt.eq.0)                                            &
     &        wgt_log=(1.d0/yspec_wid(itmx))**2
              if(jfwgt.eq.1)                                            &
     &        wgt_log=(fwgt(itmx)/yspec_wid(itmx))**2
!
!
              dchi221u_ipch(iipch0,jfwgt)=                              &
     &        dchi221u_ipch(iipch0,jfwgt)+                              &
     &        2.d0*rt_sig(0)*rt_sig(1)*wgt_log
!
              dchi20u_is(iscal,jfwgt)=                                  &
     &        dchi20u_is(iscal,jfwgt)+                                  &
     &        yspec_xpt(itmx)**2*wgt_log
!
              dchi10u_is(iscal,jfwgt)=                                  &
     &        dchi10u_is(iscal,jfwgt)+                                  &
     &        yspec_xpt(itmx)*wgt_log
!
              if(jscal.eq.2.or.jrasf_ctl_ij.ge.0) then
                if(jfwgt.eq.0)                                          &
     &          wgt_lin=(1.d0/xspec_wid(itmx))**2
                if(jfwgt.eq.1)                                          &
     &          wgt_lin=(fwgt(itmx)/xspec_wid(itmx))**2
!
                if(jmsspec_ch(ispec).eq.1) then
                  achig00u(jfwgt)=                                      &
     &            achig00u(jfwgt)+                                      &
     &            yspec_xpt(itmx)**2*wgt_log
!
                  achig01u_ks(kscal,jfwgt)=                             &
     &            achig01u_ks(kscal,jfwgt)+                             &
     &            (-2.d0)*yspec_xpt(itmx)*wgt_log
!
                  achig02u_ks(kscal,jfwgt)=                             &
     &            achig02u_ks(kscal,jfwgt)+                             &
     &            wgt_log
!
                  achig21u_ipch(iipch0,jfwgt)=                          &
     &            achig21u_ipch(iipch0,jfwgt)+                          &
     &            2.d0*rt_sig(0)*rt_sig(1)*wgt_log
                endif
                if(jmsspec_ch(ispec).eq.2) then
                  achin00u(jfwgt)=                                      &
     &            achin00u(jfwgt)+                                      &
     &            xspec_xpt(itmx)**2*wgt_lin
!
                  achin21u_ipch(iipch0,jfwgt)=                          &
     &            achin21u_ipch(iipch0,jfwgt)+                          &
     &            2.d0*rt_sig(0)*rt_sig(1)*wgt_lin
                endif
              endif
!
              do jsig=0,1
                iipch=iipch0+jsig
!
                dchi21u_ipch(iipch,jfwgt)=                              &
     &          dchi21u_ipch(iipch,jfwgt)+                              &
     &          (-2.d0)*yspec_xpt(itmx)*rt_sig(jsig)*wgt_log
!
                dchi220u_ipch(iipch,jfwgt)=                             &
     &          dchi220u_ipch(iipch,jfwgt)+                             &
     &          rt_sig(jsig)**2*wgt_log
!
                dchi11u_ipch(iipch,jfwgt)=                              &
     &          dchi11u_ipch(iipch,jfwgt)-                              &
     &          rt_sig(jsig)*wgt_log
!
                if(jscal.eq.2.or.jrasf_ctl_ij.ge.0) then
                  if(jmsspec_ch(ispec).eq.1) then
                    achig10u_ipch(iipch,jfwgt)=                         &
     &              achig10u_ipch(iipch,jfwgt)+                         &
     &              (-2.d0)*yspec_xpt(itmx)*rt_sig(jsig)*wgt_log
!
                    achig11u_ipch(iipch,jfwgt)=                         &
     &              achig11u_ipch(iipch,jfwgt)+                         &
     &              2.d0*rt_sig(jsig)*wgt_log
!
                    achig20u_ipch(iipch,jfwgt)=                         &
     &              achig20u_ipch(iipch,jfwgt)+                         &
     &              rt_sig(jsig)**2*wgt_log
                  endif
                  if(jmsspec_ch(ispec).eq.2) then
                    achin11u_ipch(iipch,jfwgt)=                         &
     &              achin11u_ipch(iipch,jfwgt)+                         &
     &              (-2.d0)*xspec_xpt(itmx)*rt_sig(jsig)*wgt_lin
!
                    achin20u_ipch(iipch,jfwgt)=                         &
     &              achin20u_ipch(iipch,jfwgt)+                         &
     &              rt_sig(jsig)**2*wgt_lin
                  endif
                endif
              enddo
            enddo
          endif
!
!
          do itmx=itmx_ini(ims,iexpt),itmx_fin(ims,iexpt)
            iscal=iscal_xpt(itmx)
            if(jfwgt.eq.0)                                              &
     &      wgt_log=(1.d0/yspec_wid(itmx))**2
            if(jfwgt.eq.1)                                              &
     &      wgt_log=(fwgt(itmx)/yspec_wid(itmx))**2
!
            chi0u_is(iscal,jfwgt)=chi0u_is(iscal,jfwgt)+wgt_log
          enddo
        enddo
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_fix
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! set fixed parameter values and tables
!
      include 'ens.def'
!
! set constants
      pi2=8.d0*datan(1.d0)
!
! initialize species and reaction parameter control tables
      call set_fix_pctl
!
! initialize fict. Hamiltonian update tables
      call set_fix_ham
!
! initialize move type tables
      call set_fix_mty
!
! initialize move sequence tables
      call set_fix_imvs
!
! initialize random number generator
      call srandx(imc_ran,iseed2,jrand)
!
! initialize MC sampling-beta
      beta_mc=1.d0/temp_mc
!
! set I/O file names for Theta replicas
      call set_fix_orf
!
! initialize and check parameter + species dependencies
      call set_fix_dpen
!
      call set_fix_blkth
!
      call set_fix_rasf
!
      call set_fix_dcon
!
! initialize reaction network connectivity tables
      call set_fix_reac
!
! initialize Wang-Landau parameters + tables
      call set_fix_wl
!
! initialize time interpolation and conversion tables
      call set_fix_ti
!
! initialize MC scheduling counters
      call set_fix_mcs
!
! initialize boundary contact force and Fourier force params.
      call set_fix_bcft
!
!
      imvsequ=-1
      jmvloop=-1
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_fix_pctl
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! initialize parameter control tables
!
      include 'ens.def'
!
! set constants
!
      pi2=8.d0*datan(1.d0)
!
! tabulate pointers to MC movable "Theta" parameters,
! fixed control "U^f" parameters,
! expt'lly varied "U^v" control parameters
! and max. MC step widths, lo-, hi-limits for Theta parameters
!
      ith=0
      iuf=0
      iuv=0
      ims=0
      ivs=0
      ifs=0
      is_ft=0
      jscal=1
      jprex=0
!
      do ispec=1,nspec
        ims_spec(ispec)=0
        if(jmsspec_ch(ispec).eq.2) jscal=2
!
        if(jmsspec_ch(ispec).ge.1) then
          if(jmsspec_px(ispec).ge.1) jprex=jprex+1
          ims=ims+1
          if(ims.gt.nms_spec_x) then
            errtag='000069'
            call err_term
          endif
          ispec_ms(ims)=ispec
          ims_spec(ispec)=ims
        endif
!
        is_ft_spec(ispec)=0
        if(jmsspec_ft(ispec).ge.1) then
          is_ft=is_ft+1
          if(is_ft.gt.nsft_spec_x) then
            errtag='000070'
            call err_term
          endif
          ispec_sft(is_ft)=ispec
          is_ft_spec(ispec)=is_ft
        endif
!
        ivs_spec(ispec)=0
        if(jfix(ispec).eq.0) then
          ivs=ivs+1
          ispec_vs(ivs)=ispec
          ivs_spec(ispec)=ivs
        endif
!
        ifs_spec(ispec)=0
        if(jfix(ispec).gt.0) then
          ifs=ifs+1
          ispec_fs(ifs)=ispec
          ifs_spec(ispec)=ifs
        endif
!
        do ipm=1,npmspec(ispec)
          if(jctspec(ispec,ipm).ge.0.and.                               &
     &    jctspec(ispec,ipm).lt.10) then
            ith=ith+1
!
            ispec_th(ith)=ispec
            ipmspec_th(ith)=ipm
!
            rlospec(ith)=pmspec(ispec,ipm,1)
            rhispec(ith)=pmspec(ispec,ipm,2)
!
            if(                                                         &
     &      (rlospec(ith).le.0.d0.and.jctspec(ispec,ipm).eq.1).or.      &
     &      (rhispec(ith).le.0.d0.and.jctspec(ispec,ipm).eq.1).or.      &
     &      (rlospec(ith).gt.rhispec(ith))                    .or.      &
!
     &      (rlospec(ith).gt.pmspec(ispec,ipm,4)                        &
     &      .and.jctspec(ispec,ipm).ge.1                                &
!ERR:&      .and.jctspec(ispec,ipm).lt.100)                   .or.      &
     &      .and.jctspec(ispec,ipm).lt.10)                    .or.      &
!
     &      (rhispec(ith).lt.pmspec(ispec,ipm,4)                        &
     &      .and.jctspec(ispec,ipm).ge.1                                &
     &      .and.jctspec(ispec,ipm).lt.10)                    .or.      &
!
     &      (rlospec(ith).gt.pmspec(ispec,ipm,5)                        &
     &      .and.jctspec(ispec,ipm).ge.1                                &
     &      .and.jctspec(ispec,ipm).lt.10)                    .or.      &
!
     &      (rhispec(ith).lt.pmspec(ispec,ipm,5)                        &
     &      .and.jctspec(ispec,ipm).ge.1                                &
     &      .and.jctspec(ispec,ipm).lt.10)                              &
!
     &      )then
              errtag='000071'
            call err_term
            endif
!
            stepspec(ith)=pmspec(ispec,ipm,3)
            if(jst_ini.eq.10) then
              if(jctspec(ispec,ipm).eq.0)                               &
     &        stepspec(ith)=rhispec(ith)-rlospec(ith)
              if(jctspec(ispec,ipm).eq.1)                               &
     &        stepspec(ith)=dlog(rhispec(ith)/rlospec(ith))
            endif
          endif
!
          if(jctspec(ispec,ipm).ge.100.and.                             &
     &    jctspec(ispec,ipm).lt.200) then
            iuf=iuf+1
!
            ispec_uf(iuf)=ispec
            ipmspec_uf(iuf)=ipm
          endif
!
          if(jctspec(ispec,ipm).ge.200.and.                             &
     &    jctspec(ispec,ipm).lt.400) then
            iuv=iuv+1
!
            ispec_uv(iuv)=ispec
            ipmspec_uv(iuv)=ipm
          endif
        enddo
      enddo
      mth_spec=ith
      muf_spec=iuf
      muv_spec=iuv
!
      nms_spec=ims
      if(jprex.ge.1.and.jprex.lt.nms_spec) jprex=1
      if(jprex.eq.nms_spec) jprex=2
!
      nsft_spec=is_ft
      nvs_spec=ivs
      nfs_spec=ifs
      nfs_spec0=0
!
! store log-concentraion limits
      do ivs=1,nvs_spec
        yspec_min_vs(ivs)=dlog(dabs(xspec_min(ispec_vs(ivs))))
        yspec_max_vs(ivs)=dlog(dabs(xspec_max(ispec_vs(ivs))))
      enddo
!
      ith=0
      iuf=0
      iuv=0
      do ireac=1,nreac
        do ipm=1,npmreac(ireac)
          if(jctreac(ireac,ipm).ge.0.and.                               &
     &    jctreac(ireac,ipm).lt.10) then
            ith=ith+1
!
            ireac_th(ith)=ireac
            ipmreac_th(ith)=ipm
!
            rloreac(ith)=pmreac(ireac,ipm,1)
            rhireac(ith)=pmreac(ireac,ipm,2)
!
            if(                                                         &
     &      (rloreac(ith).le.0.d0.and.jctreac(ireac,ipm).eq.1).or.      &
     &      (rhireac(ith).le.0.d0.and.jctreac(ireac,ipm).eq.1).or.      &
     &      (rloreac(ith).gt.rhireac(ith))                    .or.      &
!
     &      (rloreac(ith).gt.pmreac(ireac,ipm,4)                        &
     &      .and.jctreac(ireac,ipm).ge.1                                &
     &      .and.jctreac(ireac,ipm).lt.10)                    .or.      &
!
     &      (rhireac(ith).lt.pmreac(ireac,ipm,4)                        &
     &      .and.jctreac(ireac,ipm).ge.1                                &
     &      .and.jctreac(ireac,ipm).lt.10)                    .or.      &
!
     &      (rloreac(ith).gt.pmreac(ireac,ipm,5)                        &
     &      .and.jctreac(ireac,ipm).ge.1                                &
     &      .and.jctreac(ireac,ipm).lt.10)                    .or.      &
!
     &      (rhireac(ith).lt.pmreac(ireac,ipm,5)                        &
     &      .and.jctreac(ireac,ipm).ge.1                                &
     &      .and.jctreac(ireac,ipm).lt.10)                              &
!
     &      )then
            errtag='000072'
            call err_term
            endif
!
            stepreac(ith)=pmreac(ireac,ipm,3)
            if(jst_ini.eq.10) then
              if(jctreac(ireac,ipm).eq.0)                               &
     &        stepreac(ith)=rhireac(ith)-rloreac(ith)
              if(jctreac(ireac,ipm).eq.1)                               &
     &        stepreac(ith)=dlog(rhireac(ith)/rloreac(ith))
            endif
          endif
!
          if(jctreac(ireac,ipm).ge.100.and.                             &
     &    jctreac(ireac,ipm).lt.200) then
            iuf=iuf+1
!
            ireac_uf(iuf)=ireac
            ipmreac_uf(iuf)=ipm
          endif
!
          if(jctreac(ireac,ipm).ge.200.and.                             &
     &    jctreac(ireac,ipm).lt.400) then
            iuv=iuv+1
!
            ireac_uv(iuv)=ireac
            ipmreac_uv(iuv)=ipm
          endif
        enddo
      enddo
      mth_reac=ith
      muf_reac=iuf
      muv_reac=iuv
!
      mth_tot=mth_spec+mth_reac
      muf_tot=muf_spec+muf_reac
      muv_tot=muv_spec+muv_reac
!
      do iexpt=1,nexpt
        jdokin(iexpt)=1
      enddo
      jckkin=0
!
      if(mth_tot.gt.nthr_x) then
            errtag='000073'
            call err_term
      endif
!
! stepwidth optimizer (SWO) array and output block sizes
!
      mth_swo=mth_tot+100
      inc_swo=20
      mo_swo=mth_swo/inc_swo
      mo_swo=mo_swo+1
!
!     Note: "ith_swo" with ith_swo>mth_tot are used for
!     recording acceptance and optimizing global/population
!     updating stepwidth parameters:
!       ith_swo=mth_tot+1:          "move_thu"
!       ith_swo=mth_tot+11,+12:     "move_ham"
!       ith_swo=mth_tot+21 ...+25:  "move_xst"
!       ith_swo=mth_tot+31 ...+35:  "move_yst"
!       ith_swo=mth_tot+41,+42:     "move_pst"
!
      if(mth_swo.gt.mth_swo_x) then
            errtag='000074'
            call err_term
      endif
!
      do iexpt=1,nexpt
        nspec_o(iexpt)=nspec
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_fix_mty
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! initialize move type tables
!
      include 'ens.def'
!
!
!   ipmty=1:
      mth_ty(1)=mth_reac
!
!   ipmty=2:
      mth_ty(2)=mth_spec
!
!   ipmty=3:
      mth_ty(3)=8
!   Note: ipmty=3 is used for proposal/acceptance
!   counts of global updates, e.g.
!    ith_upd=1: "move_thu"
!    ith_upd=2: "move_ham"
!    ith_upd=3: "move_xst"
!    ith_upd=4: "move_yst"
!    ith_upd=5: "move_pst"
!    ith_upd=6: "move_xge"
!    ith_upd=7: "move_yge"
!    ith_upd=8: "move_pge"
!
!
      do jmvloop=1,2
        ljmty=0
        do imvsequ=1,nmvsequ(jmvloop)
          if(imvsequ.gt.1) then
            do imvsequ0=1,(imvsequ-1)
              if(                                                       &
     &        jmty(imvsequ,jmvloop).eq.jmty(imvsequ0,jmvloop)           &
     &        )then
                ljmty_mvs(imvsequ,jmvloop)                              &
     &          =ljmty_mvs(imvsequ0,jmvloop)
                goto 101
              endif
            enddo
          endif
          ljmty=ljmty+1
          if(ljmty.gt.njmty_x) goto 109
!
          jmty_lj(ljmty,jmvloop)=jmty(imvsequ,jmvloop)
          ljmty_mvs(imvsequ,jmvloop)=ljmty
  101     continue
        enddo
        njmty(jmvloop)=ljmty
      enddo
      ljmty=-1
!
  109 continue
      if(ljmty.gt.njmty_x) then
            errtag='000075'
            call err_term
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_fix_ham
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! variables and arrays for fict. Hamiltonian time evolution
!
      include 'ens.def'
!
      ith_ham=0
      do ith=1,mth_spec
        ispec=ispec_th(ith)
        ipm=ipmspec_th(ith)
!
        ith_ham=ith_ham+1
        jct_ham(ith_ham)=jctspec(ispec,ipm)
        rhi_ham(ith_ham)=rhispec(ith)
        rlo_ham(ith_ham)=rlospec(ith)
        step_ham(ith_ham)=stepspec(ith)
!
        if(jct_ham(ith_ham).eq.0) then
          ahi_ham(ith_ham)=rhi_ham(ith_ham)
          alo_ham(ith_ham)=rlo_ham(ith_ham)
        endif
        if(jct_ham(ith_ham).eq.1) then
          ahi_ham(ith_ham)=dlog(rhi_ham(ith_ham))
          alo_ham(ith_ham)=dlog(rlo_ham(ith_ham))
        endif
      enddo
!
      do ith=1,mth_reac
        ireac=ireac_th(ith)
        ipm=ipmreac_th(ith)
!
        ith_ham=ith_ham+1
        jct_ham(ith_ham)=jctreac(ireac,ipm)
        rhi_ham(ith_ham)=rhireac(ith)
        rlo_ham(ith_ham)=rloreac(ith)
        step_ham(ith_ham)=stepreac(ith)
!
        if(jct_ham(ith_ham).eq.0) then
          ahi_ham(ith_ham)=rhi_ham(ith_ham)
          alo_ham(ith_ham)=rlo_ham(ith_ham)
        endif
        if(jct_ham(ith_ham).eq.1) then
          ahi_ham(ith_ham)=dlog(rhi_ham(ith_ham))
          alo_ham(ith_ham)=dlog(rlo_ham(ith_ham))
        endif
      enddo
      ith_ham=-1
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_fix_imvs
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! initialize move sequence tables
!
      include 'ens.def'
!
!
      do jmvloop=1,2
        do imvsequ=-1,nmvsequ(jmvloop)
          kmvsequ_mvs(imvsequ,jmvloop)=imvsequ
          if(imvsequ.ge.1) then
            do imvsequ0=imvsequ,nmvsequ(jmvloop)
              if(nmove(imvsequ0,jmvloop).gt.0) then
                kmvsequ_mvs(imvsequ,jmvloop)=imvsequ0
                goto 210
              endif
            enddo
          endif
  210     continue
        enddo
      enddo
!
      do jmvloop=1,2
        kmvsequ_ini=1
        do imvsequ=1,nmvsequ(jmvloop)
          levlp_mvs(imvsequ,jmvloop)=0
          nmovr_mvs(imvsequ,jmvloop)=1
          if(nmove(imvsequ,jmvloop).le.0) then
            levlp=-nmove(imvsequ,jmvloop)
            mbase=1000000
            call fdigit(levlp,mbase,jdig,nzdig,ndig_y)
            levlp_mvs(imvsequ,jmvloop)=jdig(2)
            nmovr_mvs(imvsequ,jmvloop)=jdig(1)
          endif
!
          levlp=levlp_mvs(imvsequ,jmvloop)
          levlp_nxt=levlp
!
          if(imvsequ.lt.nmvsequ(jmvloop))                               &
     &    levlp_nxt=levlp_mvs(imvsequ+1,jmvloop)
          kmvsequ=kmvsequ_mvs(imvsequ,jmvloop)
!
          if(                                                           &
     &    levlp.gt.levlp_x.or.levlp.lt.0.or.                            &
     &    (levlp_nxt-levlp).gt.1.or.                                    &
     &    ((imvsequ.eq.kmvsequ.or.imvsequ.eq.kmvsequ_ini).and.          &
     &    levlp.ne.0)                                                   &
     &    )then
            errtag='000076'
            call err_term
          endif
!
          kmvsequ_ini=kmvsequ+1
        enddo
      enddo
!
      do jmvloop=1,2
        kmvsequ_ini=1
        do kmvsequ=1,nmvsequ(jmvloop)
          if(nmove(kmvsequ,jmvloop).gt.0) then
            do levlp=0,levlp_x
              imvsequ_fst_lev(levlp)=-1
              imvsequ_lst_lev(levlp)=-1
              imvsequ_prv_lev(levlp)=-1
              imvsequ_nxt_lev(levlp)=-1
            enddo
!
            do imvsequ=kmvsequ_ini,kmvsequ
              levlp=levlp_mvs(imvsequ,jmvloop)
!
              if(imvsequ.eq.kmvsequ_ini) then
                levlp=0
                imvsequ_fst_lev(levlp)=kmvsequ_ini
              endif
!
              if(imvsequ.eq.kmvsequ) then
                levlp=0
                levlp_nxt=-1
              endif
!
              if(imvsequ.lt.kmvsequ) then
                levlp_nxt=levlp_mvs(imvsequ+1,jmvloop)
              endif
!
              if(levlp_nxt.gt.levlp) then
                imvsequ_fst_lev(levlp_nxt)=imvsequ+1
                imvsequ_prv_lev(levlp_nxt)=-1
              endif
!
              if(levlp_nxt.lt.levlp) then
                do levlp0=(levlp_nxt+1),levlp
                  imvsequ_fst=imvsequ_fst_lev(levlp0)
!
                  if(levlp0.lt.levlp) then
                    imvsequ_lst=imvsequ_prv_lev(levlp0)
!
                    if(imvsequ_lst.lt.kmvsequ_ini)                      &
     &              imvsequ_lst=imvsequ_fst
                  else
                    if(levlp0.eq.levlp)                                 &
     &              imvsequ_lst=imvsequ
                  endif
!
                  imvsequ_lst_lev(levlp0)=imvsequ_lst
!
                  do imvsequ0=imvsequ_fst,imvsequ_lst
                    if(levlp0.eq.levlp_mvs(imvsequ0,jmvloop)) then
                      imvsequ_lst_mvs(imvsequ0,jmvloop)=imvsequ_lst
                      imvsequ_fst_mvs(imvsequ0,jmvloop)=imvsequ_fst
                    endif
                  enddo
                enddo
              endif
!
!
              imvsequ_prv=imvsequ_prv_lev(levlp)
              imvsequ_prv_mvs(imvsequ,jmvloop)=imvsequ_prv
!
              imvsequ_nxt_mvs(imvsequ,jmvloop)=-1
              if(imvsequ_prv.ge.kmvsequ_ini)                            &
     &        imvsequ_nxt_mvs(imvsequ_prv,jmvloop)=imvsequ
!
              imvsequ_prv_lev(levlp)=imvsequ
            enddo
!
!
            do imvsequ=kmvsequ_ini,kmvsequ
              pmvsum(imvsequ,jmvloop)=0.d0
            enddo
!
            do imvsequ=kmvsequ_ini,kmvsequ
              imvsequ_fst=imvsequ_fst_mvs(imvsequ,jmvloop)
              imvsequ_prv=imvsequ_prv_mvs(imvsequ,jmvloop)
!
              if(imvsequ.eq.imvsequ_fst                                 &
     &        .or.imvsequ_prv.lt.kmvsequ_ini                            &
     &        )then
                pmvsum_prv=0.d0
              else
                pmvsum_prv=pmvsum(imvsequ_prv,jmvloop)
              endif
!
              if(                                                       &
     &        pmvtype(imvsequ,jmvloop).gt.0.d0.and.                     &
     &        nmovr_mvs(imvsequ,jmvloop).gt.0                           &
     &        )then
                pmvsum(imvsequ,jmvloop)=pmvsum_prv                      &
     &                                 +pmvtype(imvsequ,jmvloop)
              else
                pmvsum(imvsequ,jmvloop)=pmvsum_prv
              endif
            enddo
!
            kmvsequ_ini=kmvsequ+1
          endif
        enddo
      enddo
!
!
      do ipop=0,npopst_x
        iorst(ipop)=ipop
        jhoodst(ipop)=0
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_fix_orf
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! intialize tables and files for Theta population output
!
      include 'ens.def'
!
!
      morf=3
      norf_max=19
!
      iorf=0
   10 continue
!
      if((jtrepl_x*morf-1).gt.norf_x.or.                                &
     &norf_x.gt.norf_max.or.morf.lt.2) then
            errtag='000077'
            call err_term
      endif
!
!
      do iorf=0,norf_x
        if(iorf.eq. 0) fname_orf(iorf)='ens.o20'
        if(iorf.eq. 1) fname_orf(iorf)='ens.o21'
        if(iorf.eq. 2) fname_orf(iorf)='ens.o22'
        if(iorf.eq. 3) fname_orf(iorf)='ens.o23'
        if(iorf.eq. 4) fname_orf(iorf)='ens.o24'
        if(iorf.eq. 5) fname_orf(iorf)='ens.o25'
        if(iorf.eq. 6) fname_orf(iorf)='ens.o26'
        if(iorf.eq. 7) fname_orf(iorf)='ens.o27'
        if(iorf.eq. 8) fname_orf(iorf)='ens.o28'
        if(iorf.eq. 9) fname_orf(iorf)='ens.o29'
        if(iorf.eq.10) fname_orf(iorf)='ens.o30'
        if(iorf.eq.11) fname_orf(iorf)='ens.o31'
        if(iorf.eq.12) fname_orf(iorf)='ens.o32'
        if(iorf.eq.13) fname_orf(iorf)='ens.o33'
        if(iorf.eq.14) fname_orf(iorf)='ens.o34'
        if(iorf.eq.15) fname_orf(iorf)='ens.o35'
        if(iorf.eq.16) fname_orf(iorf)='ens.o36'
        if(iorf.eq.17) fname_orf(iorf)='ens.o37'
        if(iorf.eq.18) fname_orf(iorf)='ens.o38'
        if(iorf.eq.19) fname_orf(iorf)='ens.o39'
!
        if(iorf.eq. 0) sname_orf(iorf)='ens.s20'
        if(iorf.eq. 1) sname_orf(iorf)='ens.s21'
        if(iorf.eq. 2) sname_orf(iorf)='ens.s22'
        if(iorf.eq. 3) sname_orf(iorf)='ens.s23'
        if(iorf.eq. 4) sname_orf(iorf)='ens.s24'
        if(iorf.eq. 5) sname_orf(iorf)='ens.s25'
        if(iorf.eq. 6) sname_orf(iorf)='ens.s26'
        if(iorf.eq. 7) sname_orf(iorf)='ens.s27'
        if(iorf.eq. 8) sname_orf(iorf)='ens.s28'
        if(iorf.eq. 9) sname_orf(iorf)='ens.s29'
        if(iorf.eq.10) sname_orf(iorf)='ens.s30'
        if(iorf.eq.11) sname_orf(iorf)='ens.s31'
        if(iorf.eq.12) sname_orf(iorf)='ens.s32'
        if(iorf.eq.13) sname_orf(iorf)='ens.s33'
        if(iorf.eq.14) sname_orf(iorf)='ens.s34'
        if(iorf.eq.15) sname_orf(iorf)='ens.s35'
        if(iorf.eq.16) sname_orf(iorf)='ens.s36'
        if(iorf.eq.17) sname_orf(iorf)='ens.s37'
        if(iorf.eq.18) sname_orf(iorf)='ens.s38'
        if(iorf.eq.19) sname_orf(iorf)='ens.s39'
!
!
        if(iorf.gt.19) then
          norf_max=19
          goto 10
        endif
      enddo
!
!
      do jtrepl=1,jtrepl_x
          iout_repl(jtrepl)=-1
          nthr_repl(jtrepl)=-1
          iorf_repl(jtrepl)=-1
      enddo
      jtrepl=-1
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_fix_reac
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!   tabulate species labels "ispec" of all named
!   reactant and product species "nispec", "nospec"
!   for each reaction "ireac"
!
      do ireac=1,nreac
        do ipart=1,nipart(ireac)
          iispec(ipart,ireac)=                                          &
     &    ispre4name(ierrtag,namespec,nspec                                     &
     &              ,nameispec(ipart,ireac),nspec_y)
!
          if(ierrtag.gt.0) then
            jerrtag=8
            errtag='000120'
            call err_term
          endif
        enddo
!
        do ipart=1,nopart(ireac)
          iospec(ipart,ireac)=                                          &
     &    ispre4name(ierrtag,namespec,nspec                                     &
     &              ,nameospec(ipart,ireac),nspec_y)
!
          if(ierrtag.gt.0) then
            jerrtag=9
            errtag='000120'
            call err_term
          endif
!
        enddo
      enddo
!
! Check 8: a species participating in the reaction network, with
!          -- ispec=iispec(ipart,ireac)  or
!          -- ispec=iospec(ipart,ireac)
!          must not be a dependent:
!N180810
!          ** jfix(ispec) >=0  , jfix(ispec) |= -100
!          unless:
!          ** jfix(ispec) = -110
!
      do ireac=1,nreac
        do ipart0=1,(nipart(ireac)+nopart(ireac))
          if(ipart0.le.nipart(ireac)) then
            ipart=ipart0
            ispec=iispec(ipart,ireac)
          else
            ipart=ipart0-nipart(ireac)
            ispec=iospec(ipart,ireac)
          endif
!
!N180810
          if(jfix(ispec).lt.0.and.jfix(ispec).ne.-110) then
            errtag='000078'
            call err_term
          endif
        enddo
      enddo
!
!   tabulate reaction default multiplicities "gimult", "gomult"
!   and default cooperativities "hicoop", "hocoop"
!   of reactant and product species for each reaction "ireac"
!
      do ireac=1,nreac
        do ipart=1,nipart(ireac)
          ispec=iispec(ipart,ireac)
          gimult(ipart,ireac)=0.d0
          do ipart1=1,nipart(ireac)
            if(iispec(ipart1,ireac).eq.ispec)                           &
     &      gimult(ipart,ireac)=                                        &
     &      gimult(ipart,ireac)+1.d0
          enddo
          do ipart1=1,nopart(ireac)
            if(iospec(ipart1,ireac).eq.ispec)                           &
     &      gimult(ipart,ireac)=                                        &
     &      gimult(ipart,ireac)-1.d0
          enddo
        enddo
!
        do ipart=1,nopart(ireac)
          ispec=iospec(ipart,ireac)
          gomult(ipart,ireac)=0.d0
          do ipart1=1,nopart(ireac)
            if(iospec(ipart1,ireac).eq.ispec)                           &
     &      gomult(ipart,ireac)=                                        &
     &      gomult(ipart,ireac)+1.d0
          enddo
          do ipart1=1,nipart(ireac)
            if(iispec(ipart1,ireac).eq.ispec)                           &
     &      gomult(ipart,ireac)=                                        &
     &      gomult(ipart,ireac)-1.d0
          enddo
        enddo
!
!
        do ipart=1,nipart(ireac)
          hicoop(ipart,ireac)=1.d0
          gispec(ipart,ireac)=1.d0
        enddo
        do ipart=1,nopart(ireac)
          hocoop(ipart,ireac)=1.d0
          gospec(ipart,ireac)=1.d0
        enddo
      enddo
!
!
! tabulate species labels "iispec_vs", "iospec_vs" and
! their resp. default multiplicities "gimult_vs", "gomult_vs"
! for only those reactant and product species which evolve
! acc. to diff. rate eqs., excluding externally controlled
! ("chemostatic") species, each species included only once
! in label list, regardless of multiplicity;
! needed for net-"vreac" rate limitation schemes, see
! subprogr. "drivs"
!
!
      do ireac=1,nreac
        ipart_vs=0
        do ipart=1,nipart(ireac)
          if(jfix(iispec(ipart,ireac)).eq.0.and.                        &
     &       gimult(ipart,ireac).gt.1.d-8)                              &
     &    then
            do ipart1=1,(ipart-1)
              if(iispec(ipart1,ireac).eq.iispec(ipart,ireac)) goto 321
            enddo
            ipart_vs=ipart_vs+1
            iispec_vs(ipart_vs,ireac)=iispec(ipart,ireac)
            gimult_vs(ipart_vs,ireac)=gimult(ipart,ireac)
            iivs_vs(ipart_vs,ireac)=                                    &
     &      ivs_spec(iispec(ipart,ireac))
          endif
  321     continue
        enddo
        nipart_vs(ireac)=ipart_vs
!
        ipart_vs=0
        do ipart=1,nopart(ireac)
          if(jfix(iospec(ipart,ireac)).eq.0.and.                        &
     &       gomult(ipart,ireac).gt.1.d-8)                              &
     &    then
            do ipart1=1,(ipart-1)
              if(iospec(ipart1,ireac).eq.iospec(ipart,ireac)) goto 322
            enddo
            ipart_vs=ipart_vs+1
            iospec_vs(ipart_vs,ireac)=iospec(ipart,ireac)
            gomult_vs(ipart_vs,ireac)=gomult(ipart,ireac)
            iovs_vs(ipart_vs,ireac)=                                    &
     &      ivs_spec(iospec(ipart,ireac))
          endif
  322     continue
        enddo
        nopart_vs(ireac)=ipart_vs
      enddo
!
!
!   tabulate inverse reaction multiplicities "ogimult_vs", "ogomult_vs"
!   of only those reactant and product species which evolve
!   acc. to diff. rate eqs., for each reaction "ireac"
!   needed only for "equal-weight" rate limitation schemes
!   (NOT YET IMPLEMENTED in subprogr. "drivs")
!
      do ireac=1,nreac
        do ipart=1,nipart_vs(ireac)
          ogimult_vs(ipart,ireac)=1.d0/(1.d0*gimult_vs(ipart,ireac))
        enddo
!
        do ipart=1,nopart_vs(ireac)
          ogomult_vs(ipart,ireac)=1.d0/(1.d0*gomult_vs(ipart,ireac))
        enddo
      enddo
!
!   tabulate number of input and output reactions
!   "nireac", "noreac" for each species evolving
!   acc. to diff. rate eqs. and corresp. weight
!   factors for rate limitation;
!   needed only for equal-weight-"vfor-vbak" rate
!   limitation schemes
!   (NOT YET IMPLEMENTED in subprogr. "drivs")
!
      do ivs=1,nvs_spec
        nireac_vs(ivs)=0
        noreac_vs(ivs)=0
      enddo
!
      do ireac=1,nreac
        do ipart=1,nipart_vs(ireac)
          nireac_vs(iivs_vs(ipart,ireac))                               &
     &    =nireac_vs(iivs_vs(ipart,ireac))                              &
     &    +1
        enddo
!
        do ipart=1,nopart_vs(ireac)
          noreac_vs(iovs_vs(ipart,ireac))                               &
     &    =noreac_vs(iovs_vs(ipart,ireac))                              &
     &    +1
        enddo
      enddo
!
!
      do ivs=1,nvs_spec
        if(nireac_vs(ivs).gt.0)                                         &
     &  wspec_vs_min(ivs)=1.d0/(dtime_rl*nireac_vs(ivs))
!
        if(noreac_vs(ivs).gt.0)                                         &
     &  wspec_vs_max(ivs)=1.d0/(dtime_rl*noreac_vs(ivs))
      enddo
!
! estimate count of non-zero Jacobian matrix elements
      if(jtime.ge.100.and.jtime.le.299) then
        nnz_lss=0
        do ivs=1,nvs_spec
          nnz_vs=0
          do ivs1=1,nvs_spec
            jnz_vs(ivs1)=0
          enddo
!
          do ireac=1,nreac
            do ipart=1,nipart(ireac)
              if(iispec(ipart,ireac).eq.ispec_vs(ivs)) then
                goto 510
              endif
            enddo
            do ipart=1,nopart(ireac)
              if(iospec(ipart,ireac).eq.ispec_vs(ivs)) then
                goto 510
              endif
            enddo
            goto 519
!
  510       continue
            do ipart=1,nipart(ireac)
              ivs1=ivs_spec(iispec(ipart,ireac))
              if(ivs1.gt.0) then
                if(jnz_vs(ivs1).eq.0) then
                  jnz_vs(ivs1)=1
                  nnz_vs=nnz_vs+1
                endif
              endif
            enddo
            do ipart=1,nopart(ireac)
              ivs1=ivs_spec(iospec(ipart,ireac))
              if(ivs1.gt.0) then
                if(jnz_vs(ivs1).eq.0) then
                  jnz_vs(ivs1)=1
                  nnz_vs=nnz_vs+1
                endif
              endif
            enddo
  519       continue
          enddo
!
          nnz_lss=nnz_lss+nnz_vs
        enddo
!
        if(nnz_lss.gt.nnz_lss_x) then
            errtag='000079'
            call err_term
        endif
!
!
        if(jtime.ge.100.and.jtime.le.199) mf_lss= 10
        if(jtime.ge.200.and.jtime.le.299) mf_lss=222
!cc   later may try instead (???):
!cc     if(jtime.ge.200.and.jtime.le.299) mf_lss= 22
!cc   w/ user-suppl. sparsety structure arrays IA, JA
!
!
        neq_lss(1)=nvs_spec
!
!       lrw_lss_y=lrw_lss_x
!       if(mf_lss.eq. 10)
!    :  lrw_lss_y=20+16*nspec_x*mrw_lss_x
!       if(mf_lss.eq. 22)
!    :  lrw_lss_y=20+(15*nspec_x+3*nnz_lss_x)*mrw_lss_x
!       if(mf_lss.eq.222)
!    :  lrw_lss_y=20+(15*nspec_x+3*nnz_lss_x)*mrw_lss_x
!
!       liw_lss_y=liw_lss_x
!       liw_lss_y=30
!       if(mf_lss.eq. 22) liw_lss_y=31+nspec_x+nnz_lss_x
!
        ido_lss=0
        jfail_lss=0
        itol_lss=2
        rtol_lss(1)=eps_ark
!
        do ivs=1,nvs_spec
          if(jfox(ispec_vs(ivs)).eq.1) then
            atol_lss(ivs)=eps_ark
          else
            atol_lss(ivs)=eps_ark*xspec_min(ispec_vs(ivs))
          endif
        enddo
      endif
!
      if(jtime.ge.10.and.jtime.le.99) then
        jtime_ark=jtime
        jtime_abd=200+jtime
      endif
      if(jtime.ge.110.and.jtime.le.199) then
        jtime_ark=jtime-100
        jtime_abd=jtime
      endif
      if(jtime.ge.210.and.jtime.le.299) then
        jtime_ark=jtime-200
        jtime_abd=jtime
      endif
!
!
!
      do ispec=1,nspec
        xspec_max_lo(ispec)=xspec_max(ispec)*0.999999d0
        xspec_min_hi(ispec)=xspec_min(ispec)*1.000001d0
      enddo
!
      do ivs=1,nvs_spec
        yspec_max_lo_vs(ivs)=dlog(dabs(xspec_max_lo(ispec_vs(ivs))))
        yspec_min_hi_vs(ivs)=dlog(dabs(xspec_min_hi(ispec_vs(ivs))))
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_fix_wl
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
! initialize min. chisq-search, upper chisq- ("energy-") cut-off
! and energy intervals for WL sampling
!
      chisq_th=-1.d20
      chisq_th_min=-1.d20
      chisq_th_max=-1.d20
!
!
      hfour_th=-1.d20
      hfour_th_min=-1.d20
      hfour_th_max=-1.d20
!
      hfous_th=-1.d20
      hfous_th_min=-1.d20
      hfous_th_max=-1.d20
!
      hfout_th=-1.d20
      hfout_th_min=-1.d20
      hfout_th_max=-1.d20
!
      hbxx_th=-1.d20
      hbxx_th_min=-1.d20
      hbxx_th_max=-1.d20
!
      hbxn_th=-1.d20
      hbxn_th_min=-1.d20
      hbxn_th_max=-1.d20
!
      hwall_th=-1.d20
      hwall_th_min=-1.d20
      hwall_th_max=-1.d20
!
      htot_th=-1.d20
      htot_th_min=-1.d20
      htot_th_max=-1.d20
!
!
      chisq_uth_min=-1.d20
      chisq_uth_max=-1.d20
!
!
      alnf_dos=alnf_dos0
!
      ieintv=0
      enrg_ie(0)=enrg_ig(0)
!
      do igintv=1,ngintv
        jdiv=jdv_ig(igintv)
        if(jdv_ig(igintv).gt.100) jdiv=jdv_ig(igintv)-100
!
        deintv=enrg_ig(igintv)-enrg_ig(igintv-1)
        if(deintv.le.0.d0.or.                                           &
     &     (jdiv.eq.2.and.                                              &
     &      enrg_ig(igintv-1)*enrg_ig(igintv).le.0.d0                   &
     &     )                                                            &
     &  ) then
            errtag='000080'
            call err_term
        endif
!
        if(jdiv.eq.1) then
          deintv=(enrg_ig(igintv)-enrg_ig(igintv-1))                    &
     &          *(1.d0/mgintv(igintv))
          do leintv=1,mgintv(igintv)
            ieintv=ieintv+1
            if(ieintv.gt.neintv_x) then
            errtag='000081'
            call err_term
            endif
            enrg_ie(ieintv)=enrg_ie(ieintv-1)+deintv
          enddo
        endif
!
        if(jdiv.eq.2) then
          deintv=dabs(enrg_ig(igintv)/enrg_ig(igintv-1))                &
     &          **(1.d0/mgintv(igintv))
          do leintv=1,mgintv(igintv)
            ieintv=ieintv+1
            if(ieintv.gt.neintv_x) then
            errtag='000082'
            call err_term
            endif
            enrg_ie(ieintv)=enrg_ie(ieintv-1)*deintv
          enddo
        endif
      enddo
      neintv=ieintv
!
!
      do ieintv=1,neintv
        aln_wintv_ie(ieintv)=                                           &
     &  dlog(enrg_ie(ieintv)-enrg_ie(ieintv-1))
      enddo
      aln_wintv_ie(0)=aln_wintv_ie(1)
      aln_wintv_ie(neintv+1)=aln_wintv_ie(neintv)
!
      do ieintv=0,neintv+1
        wintv_ie(ieintv)=                                               &
     &  dexp(aln_wintv_ie(ieintv))
      enddo
!
      wintv_min=enrg_ig(ngintv)-enrg_ig(0)
      do ieintv=0,neintv+1
        if(wintv_min.gt.wintv_ie(ieintv))                               &
     &  wintv_min=wintv_ie(ieintv)
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_fix_ti
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
! set time check points and time interpolation parameters
! for boundary contact fraction calculation
!
      if(jtime.ge.1) then
        dtime10=time1-time0
        dtime=(time1-time0)/(1.d0*ntime)
        eps_time=1.d-8*dabs((time1-time0))
!
        do itime=0,ntime
          time_itim(itime)=time0+dtime*itime
        enddo
!
        onbx_time=1.d0/(1.d0*nbx_time)
        dtime_bx=(time1-time0)*onbx_time
!
        do ibx_time=1,nbx_time
          time_bx(ibx_time)=time0+dtime_bx*(ibx_time-0.5d0)
!
          itlo=(time_bx(ibx_time)-time0)/dtime
          if(itlo.ge.ntime) itlo=ntime-1
          if(itlo.le.0)     itlo=0
!
          itime_bx(ibx_time)=itlo
        enddo
!
!
        do ibx_time=1,nbx_time
          itlo=itime_bx(ibx_time)
          ithi=itlo+1
!
          tlo=time_itim(itlo)
          thi=time_itim(ithi)
!
          rt_qbx(ibx_time)=(time_bx(ibx_time)-tlo)/(thi-tlo)
          if(rt_qbx(ibx_time).gt.1.d0) rt_qbx(ibx_time)=1.d0
          if(rt_qbx(ibx_time).lt.0.d0) rt_qbx(ibx_time)=0.d0
!
          if(time_bx(ibx_time).lt.time0) rt_qbx(ibx_time)=0.d0
          if(time_bx(ibx_time).gt.time1) rt_qbx(ibx_time)=1.d0
        enddo
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_fix_dpen
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! checks species and reaction names and tabulates
! parameter dependence lists
!
!   merge namespec+namereac arrays into namespre array
!   merge npmspec+npmreac arrays into npmspre array
!   merge jctspec+jctreac arrays into jctspre array
!   merge jbcspec+jbcreac arrays into jbcspre array
!
      nspre=nspec+nreac
!
      ispre=0
      do ispec=1,nspec
        ispre=ispre+1
        namespre(ispre)=namespec(ispec)
        npmspre(ispre)=npmspec(ispec)
        do ipm=1,npmspec(ispec)
          jctspre(ispre,ipm)=jctspec(ispec,ipm)
          jbcspre(ispre,ipm)=jbcspec(ispec,ipm)
        enddo
      enddo
!
      do ireac=1,nreac
        ispre=ispre+1
        namespre(ispre)=namereac(ireac)
        npmspre(ispre)=npmreac(ireac)
        do ipm=1,npmreac(ireac)
          jctspre(ispre,ipm)=jctreac(ireac,ipm)
          jbcspre(ispre,ipm)=jbcreac(ireac,ipm)
        enddo
      enddo
!
! define expanded storage address tables for
! iexpt-dependent dependents flagged by
! jctspre=10 or 20, jbcspre=10001
!
      lcrdp0=0
      do idpen=1,ndpen_tot
        ispre=ispre_dpen(idpen)
        ipm=ipm_dpen(idpen)
        call tr_spre(ispec,ireac,ispre,nspec)
!
        if(                                                    &
     &  (jctspre(ispre,ipm).eq.10.or.jctspre(ispre,ipm).eq.20) &
     &  .and.                                                  &
     &  jbcspre(ispre,ipm).eq.10001) then
          do iexpt=1,nexpt
            lcrdp_dpen(idpen,iexpt)=lcrdp0+iexpt
!V090911:
!Fixed lcrdp-Bug:
!!!         if(lcrdp_dpen(idpen,iexpt).gt.ndpen_tot_x) then
            if(lcrdp_dpen(idpen,iexpt).gt.mdpen_tot_x) then
!:V090911
              errtag='000082.001'
              call err_term
            endif
!V090911:
!Fixed lcrdp-Bug:
            iexpt_crdp(lcrdp_dpen(idpen,iexpt))=iexpt
            idpen_crdp(lcrdp_dpen(idpen,iexpt))=idpen
!:V090911
          enddo
        else
          do iexpt=1,nexpt
            lcrdp_dpen(idpen,iexpt)=lcrdp0+1
!V090911:
!Fixed lcrdp-Bug:
!!!         if(lcrdp_dpen(idpen,iexpt).gt.ndpen_tot_x) then
            if(lcrdp_dpen(idpen,iexpt).gt.mdpen_tot_x) then
!:V090911
              errtag='000082.001'
              call err_term
            endif
          enddo
!V090911:
!Fixed lcrdp-Bug:
          iexpt_crdp(lcrdp_dpen(idpen,nexpt))=0
          idpen_crdp(lcrdp_dpen(idpen,nexpt))=idpen
!:V090911
        endif
!
        lcrdp0=lcrdp_dpen(idpen,nexpt)
        if(idpen.eq.ndpen_spec) mdpen_spec=lcrdp0
      enddo
      mdpen_tot=lcrdp0
      mdpen_reac=mdpen_tot-mdpen_spec
!
!
! tabulate "ith" as a function of "ispre,ipm"
!
      do ispre=1,nspre
        do ipm=1,npmspre(ispre)
          ith_spre(ispre,ipm)=-1
        enddo
      enddo
!
      do ith=1,mth_spec
        ispec=ispec_th(ith)
        ipm=ipmspec_th(ith)
        ith_spre(ispec,ipm)=ith
      enddo
!
      do ith=1,mth_reac
        ireac=ireac_th(ith)
        ipm=ipmreac_th(ith)
        ith_spre(ireac+nspec,ipm)=ith
      enddo
!
!   check for parameter naming errors or collisions
!
      do ispre0=1,nspre
        call tr_spre(ispec0,ireac0,ispre0,nspec)
        if(ispec0.gt.0) name0=namespec(ispec0)
        if(ireac0.gt.0) name0=namereac(ireac0)
!
        ispre1=                                                         &
     &  ispre4name(ierrtag,namespre,nspre                                       &
     &            ,name0,nspre_y)
!
        if(ierrtag.gt.0) then
          jerrtag=10
          errtag='000120'
          call err_term
        endif
!
        name1=namespre(ispre1)
        call tr_spre(ispec1,ireac1,ispre1,nspec)
!
        if(ispre1.ne.ispre0) then
            errtag='000083'
            call err_term
        endif
      enddo
!
!
      do ispre0=2,nspre
        call tr_spre(ispec0,ireac0,ispre0,nspec)
        name0=namespre(ispre0)
!
        do ispre1=1,(ispre0-1)
          call tr_spre(ispec1,ireac1,ispre1,nspec)
          name1=namespre(ispre1)
!
          if(eqname(name0,name1)) then
            errtag='000084'
            call err_term
          endif
        enddo
      enddo
!
!   check parent name "nmparn" for uniqueness
!   and parent ipm-ID "ipm_parn" against the npmspre-limit
!   of that parent species/reaction parameter
!
      do idpen=1,ndpen_tot
        ispre=ispre_dpen(idpen)
        ispec=ispec_dpen(idpen)
        ireac=ireac_dpen(idpen)
!c      call tr_spre(ispec,ireac,ispre,nspec)
        ipm=ipm_dpen(idpen)
!
        do iparn=1,mparn_dpen(idpen)
          if(ipm_parn(iparn,idpen).ne.0) then
            call all_name(mname,ispre_nam                               &
     &                     ,nmparn(iparn,idpen)                         &
     &                     ,namespre,nspre,nspre_y)
!
            if(mname.ge.0) then
            errtag='000085'
            call err_term
            endif
!
            if(mname.eq.1) then
              ispre0=ispre_nam(1)
              call tr_spre(ispec0,ireac0,ispre0,nspec)
              if(ispec0.gt.0) npmspre0=npmspec(ispec0)
              if(ireac0.gt.0) npmspre0=npmreac(ireac0)
!
              if(ipm_parn(iparn,idpen).gt.npmspre0) then
            errtag='000086'
            call err_term
              endif
            endif
          endif
        enddo
      enddo
!
!   tabulate parents as function of dependents
!
      jfunc_sibn=500
      jfunc_sibx=599
!
      do idpen=1,ndpen_tot
        jdosib_dpen(idpen)=0
        idum1=jfunc_dpen(idpen)
        if(idum1.ge.0) then
          if(idum1.lt.jfunc_sibn.or.idum1.gt.jfunc_sibx) then
            idum1=-1
          else
            idum1=500
          endif
        else
          aline=namefunc_dpen(idpen)
          idum1=index(aline(1:80),'DOSIB_')
          if(idum1.eq.0) then
            idum1=-1
          else
            idum1=500
          endif
        endif
        if(idum1.eq.500) jdosib_dpen(idpen)=1
!
        do iparn=1,mparn_dpen(idpen)
          ispec_parn(iparn,idpen)=-2
          ireac_parn(iparn,idpen)=-2
          ispre_parn(iparn,idpen)=-2
!
          if(ipm_parn(iparn,idpen).ne.0) then
            ispre=                                                      &
     &      ispre4name(ierrtag,namespre,nspre                           &
     &                ,nmparn(iparn,idpen)                              &
     &                ,nspre_y)
!
            if(ierrtag.gt.0) then
              jerrtag=11
              errtag='000120'
              call err_term
            endif
!
!
            call tr_spre(ispec,ireac,ispre,nspec)
!
            ispec_parn(iparn,idpen)=ispec
            ireac_parn(iparn,idpen)=ireac
            ispre_parn(iparn,idpen)=ispre
          endif
        enddo
      enddo
!
! check dependent and parent lists for consistency
!
!N180810
! Check 1: every t-evol. child
!          either with
!          -- jctspre(ispre,ipm)=20 (model species)
!          or with
!          -- jctspre(ispre,ipm)=30,40 (output exptl. species)
!          must be a species
!          **  ispec>0
!          and must be declared with
!N180810
!          ** jfix(ispec)=-100  or  =-110
!
! Check 2: every non-t-evol. child
!          -- jctspre(ispre,ipm)=10
!          can have only non-t-evol. parents:
!          ** ipm_parn >= 0
!          ** jctspre(ispre_parn,ipm_parn) |= 20,30,40
!
! Check 3: every t-evol. parent
!          -- ipm_parn<0
!          must be a species
!          ** ispec_parn>0
!
! Check 4: every non-t-evol. parent with
!          -- ipm_parn > 0
!          must refer to a non-t-evol. parameter:
!          ** jctspre(ispre_parn,ipm_parn) |=20,30,40
!
!N180810
! Check 5: every t-evol. species child
!          -- ispec>0, jfix(ispec)=-100 or -110,
!          either with
!          -- jctspre(ispre,ipm)=20 (model species)
!          or with
!          -- jctspre(ispre,ipm)=30,40 (output exptl. species)
!          can have both non-t-evol. parents:
!          ** ipm_parn>0 and jctspre(ispre_parn,ipm_parn)=10
!          and/or t-evol. parents:
!N180810
!          ** ipm_parn<0, ispec_parn>0, jfix(ispec_parn)=-100 or -110
!
! Check 6: every t-evol. parent of a model species child w/
!          -- ispec>0, jctspre(ispre,ipm)=20
!          must be addressed with ipm_parn-values in the range
!          **    -299 =< ipm_parn =< -200 (see "get_xdpen")
!
! Check 7: every t-evol. parent of a output expt. species child w/
!          -- ispec>0, jctspre(ispre,ipm)=30,40
!          must be addressed with ipm_parn-values in the range
!          **    -499 =< ipm_parn =< -300 (see "get_odpen")
!          and must be declared as an exptl. observed species
!          **    ims_spec(ispec_parn)>0, ispec_parn>0,
!          but with _no data points_ listed in "ens.i02"
!
! Check 8: a species participating in the reaction network, with
!          -- ispec=iispec(ipart,ireac)  or
!          -- ispec=iospec(ipart,ireac)
!          must not be a dependent:
!N180810
!          ** jfix(ispec) >=0   [i.e. jfix(ispec) |= -100]
!          unless
!          ** jfix(ispec) = -110
!
!N180810
! Check 9: check un-interrupted dependency chains:
!          every dependent parent must be evaluated (from grand parents)
!          before it is used to evaluate a its children
!
!N180810
! Check 10: check contiguous dependency chains for t-evol dependents
!          entering as reactant into rate fcts in "drivs" (jfix=-110).
!          Every t-evol dependent parent (jfix=-110) must be evaluated
!          (from grand parents) before it is used to evaluate a its children
!          Note: combined with Check 9, this is equivalent to checking
!          that every t-evol parent of a t-evol reactant child (jfix=-110)
!          has either  jfix>=0  or else  jfix=-110.
!
!N180810
! Check 11: t-evol dependent reactant species (jfix=-110, jctspec=20)
!           MUST NOT have any siblings, i.e., MUST have msib_dpen=0
!
!
! Check 1 and 2:
      do ispre=1,nspre
        call tr_spre(ispec,ireac,ispre,nspec)
!
        jfix0=9999
        if(ispec.gt.0) jfix0=jfix(ispec)
!
        do ipm=1,npmspre(ispre)
!
! Check 1:
          if(                                                           &
     &    (jctspre(ispre,ipm).eq.20.or.                                 &
     &     jctspre(ispre,ipm).eq.30.or.                                 &
     &     jctspre(ispre,ipm).eq.40)                                    &
     &    .and.                                                         &
     &    (jfix0.ne.-100.and.jfix0.ne.-110)) then
            errtag='000087'
            call err_term
          endif
!
! Check 2:
          if(jctspre(ispre,ipm).eq.10) then
            idpen=idpen_spre(ispre,ipm)
            if(idpen.gt.0) then
              do iparn=1,mparn_dpen(idpen)
                ipm_P=ipm_parn(iparn,idpen)
                ispre_P=ispre_parn(iparn,idpen)
                jctspre_P=9999
                if(ispre_P.gt.0.and.ipm_P.gt.0)                         &
     &          jctspre_P=jctspre(ispre_P,ipm_P)
!
                if(                                                     &
     &          ipm_P.lt.0.or.                                          &
     &          jctspre_P.eq.20.or.                                     &
     &          jctspre_P.eq.30.or.                                     &
     &          jctspre_P.eq.40                                         &
     &          )then
            errtag='000088'
            call err_term
                endif
              enddo
            endif
          endif
        enddo
      enddo
!
!
! Check 3-7:
!
      do idpen=1,ndpen_tot
        ispre=ispre_dpen(idpen)
        ispec=ispec_dpen(idpen)
        ireac=ireac_dpen(idpen)
        ipm=ipm_dpen(idpen)
!
        ims=-1
        if(ispec.gt.0) ims=ims_spec(ispec)
!
        do iparn=1,mparn_dpen(idpen)
          ipm_P=ipm_parn(iparn,idpen)
          ispre_P=ispre_parn(iparn,idpen)
!
          ispec_P=-9999999
          if(ispre_P.gt.0)                                              &
     &    call tr_spre(ispec_P,ireac_P,ispre_P,nspec)
!
          ims_P=-1
          if(ispec_P.ge.1.and.ispec_P.le.nspec)                         &
     &    ims_P=ims_spec(ispec_P)
!
          jctspre_P=9999
          if(ispre_P.gt.0.and.ipm_P.gt.0)                               &
     &    jctspre_P=jctspre(ispre_P,ipm_P)
!
! Check 3:
          idum1=jdosib_dpen(idpen)
          if(ipm_P.lt.0.and.ispec_P.lt.0.and.idum1.eq.0) then
            errtag='000089'
            call err_term
          endif
!
! Check 4:
          if(ipm_P.gt.0.and.                                            &
     &    (jctspre_P.eq.20.or.                                          &
     &     jctspre_P.eq.30.or.                                          &
     &     jctspre_P.eq.40)                                             &
     &    )then
            errtag='000090'
            call err_term
          endif
!
! Check 5:
!
!         Nothing to check!
!
! Check 6:
          if(jctspre(ispre,ipm).eq.20.and.ipm_P.lt.0.and.               &
     &    (.not.(ipm_P.le.-200.and.ipm_P.gt.-300))) then
            errtag='000091'
            call err_term
          endif
!
! Check 7:
!
          if(                                                           &
     &    (                                                             &
     &     (jctspre(ispre,ipm).eq.30.or.jctspre(ispre,ipm).eq.40)       &
     &     .and.ipm_P.lt.0.and.                                         &
     &     (.not.(ipm_P.le.-300.and.ipm_P.gt.-500))                     &
     &    )                                                             &
     &    .or.                                                          &
     &    (                                                             &
     &     (jctspre(ispre,ipm).eq.30.or.jctspre(ispre,ipm).eq.40)       &
     &     .and.ipm_P.lt.0.and.ims_P.le.0                               &
     &    )                                                             &
     &    .or.                                                          &
     &    (                                                             &
     &     (jctspre(ispre,ipm).eq.30.or.jctspre(ispre,ipm).eq.40)       &
     &     .and.ims.le.0                                                &
     &    )                                                             &
     &    )then
            errtag='000092'
            call err_term
          endif
        enddo
      enddo
!
!
! Check 8: see subprogr. "set_fix_reac"
!
!   tabulate dependents' updating priority with
!   updates in order of ascending "jprio_dpen",
!   then ascending "idpen"
!
      do idpen1=1,ndpen_tot
        ipriodp=1
        do idpen0=1,ndpen_tot
          if(jprio_dpen(idpen0).lt.jprio_dpen(idpen1)                   &
     &    .or.                                                          &
     &    (jprio_dpen(idpen0).eq.jprio_dpen(idpen1)                     &
     &     .and.                                                        &
     &     idpen0.lt.idpen1)                                            &
     &    ) ipriodp=ipriodp+1
        enddo
        idpen_prio(ipriodp)=idpen1
      enddo
!
! Check 9:
!
!    check dependent updating order for
!    uninterrupted initialization sequence
!
      do ispre=1,nspre
        do ipm=1,npmspre(ispre)
          jdpenini(ispre,ipm)=1
          if(jctspre(ispre,ipm).eq.10) jdpenini(ispre,ipm)=0
          if(jctspre(ispre,ipm).eq.20) jdpenini(ispre,ipm)=0
          if(jctspre(ispre,ipm).eq.30) jdpenini(ispre,ipm)=0
          if(jctspre(ispre,ipm).eq.40) jdpenini(ispre,ipm)=0
        enddo
      enddo
!
!
      do ipriodp=1,ndpen_tot
        idpen=idpen_prio(ipriodp)
!
        ispre1=ispre_dpen(idpen)
        ispec1=ispec_dpen(idpen)
        ireac1=ireac_dpen(idpen)
        ipm1=ipm_dpen(idpen)
        name1=namespre(ispre1)
!
        if(jdpenini(ispre1,ipm1).gt.0) goto 790
!
        jdpenini0=1
!
        do iparn=1,mparn_dpen(idpen)
          ispre0=ispre_parn(iparn,idpen)
          ipm0=ipm_parn(iparn,idpen)
!
          call tr_spre(ispec0,ireac0,ispre0,nspec)
!
          if(ispre0.le.0.or.ipm0.eq.0) goto 780
!
          if(ispre0.gt.0) then
            name0=namespre(ispre0)
!
            if(ipm0.gt.0) then
              jdpenini0=jdpenini(ispre0,ipm0)
              goto 770
            endif
!
            if(-300.lt.ipm0.and.ipm0.le.-200) then
              if(ispec0.le.0) then
                jdpenini0=0
                goto 770
              endif
!
              if(jfix(ispec0).ge.0) goto 780
!
              if(jfix(ispec0).lt.0) then
                jdpenini0=0
                do ipm00=1,npmspre(ispre0)
                  if(                                                   &
     &            jctspre(ispre0,ipm00).eq.20.and.                      &
     &            jctspre(ispre1,ipm1).eq.20.and.                       &
     &            jdpenini(ispre0,ipm00).gt.0                           &
     &            )then
                    jdpenini0=1
                    goto 780
                  endif
                enddo
              endif
            endif
!
            if(-500.lt.ipm0.and.ipm0.le.-300) then
              if(ispec0.le.0) then
                jdpenini0=0
                goto 770
              endif
!
              if(ims_spec(ispec0).le.0) then
                jdpenini0=0
                goto 770
              endif
!
              if(jfix(ispre0).ge.0) goto 780
!
              if(jfix(ispre0).lt.0) then
                jdpenini0=0
                do ipm00=1,npmspre(ispre0)
                  if(                                                   &
     &            (                                                     &
     &             jctspre(ispre0,ipm00).eq.30.or.                      &
     &             jctspre(ispre0,ipm00).eq.40                          &
     &            )                                                     &
     &            .and.                                                 &
     &            (                                                     &
     &             jctspre(ispre1,ipm1).eq.30.or.                       &
     &             jctspre(ispre1,ipm1).eq.40                           &
     &            )                                                     &
     &            .and.                                                 &
     &            jdpenini(ispre0,ipm00).gt.0                           &
     &            )then
                    jdpenini0=1
                    goto 780
                  endif
                enddo
              endif
            endif
!
            jdpenini0=0
          endif
!
  770     continue
!
          idum1=jdosib_dpen(idpen)
          if(jdpenini0.eq.0.and.idum1.eq.0) then
            errtag='000093'
            call err_term
          endif
!
  780     continue
        enddo
!
        jdpenini(ispre1,ipm1)=1
  790   continue
      enddo
!
!N180810:
!
! Check 10:
!
      do ipriodp=1,ndpen_tot
        idpen=idpen_prio(ipriodp)
!
        ispec1=ispec_dpen(idpen)
        ipm1=ipm_dpen(idpen)
!
        if (ispec1.gt.0.and.ipm1.gt.0) then
          if (jfix(ispec1).eq.-110.and.jctspec(ispec1,ipm1).eq.20) then
!
            do iparn=1,mparn_dpen(idpen)
              ispec2=ispec_parn(iparn,idpen)
              ipm2=ipm_parn(iparn,idpen)
!
              if(ispec2.gt.0.and.ipm2.lt.0) then
                if(jfix(ispec2)<0.and.jfix(ispec2).ne.-110) then
                  errtag='000093.000.001'
                  call err_term
                endif
              endif
!
            enddo
!
          endif
        endif
!
      enddo
!
!:N180810
!
!
! tabulate arrays for child storage of
! species derivatives, integrated fluxes etc.
! in "get_xdpen"
!
      dtime_half=0.5d0*(time1-time0)/(1.d0*ntime)
!
      jtime_drdp=1
      do ispec=1,nspec
        jfox_drdp(ispec)=0
      enddo
!
      do idpen=1,ndpen_tot
        ispre=ispre_dpen(idpen)
        ispec=ispec_dpen(idpen)
        ireac=ireac_dpen(idpen)
!c      call tr_spre(ispec,ireac,ispre,nspec)
        ipm=ipm_dpen(idpen)
!
        msib_dpen(idpen)=0
        jdrdp_dpen(idpen)=0
!
        isib=1
        itimeP_sib(isib,idpen)=0
        ispreP_sib(isib,idpen)=0
        idpen_sib(isib,idpen)=0
        ispec_sib(isib,idpen)=0
        jfunc_sib(isib,idpen)=-1
!
        jfunc=jfunc_dpen(idpen)
        if(jfunc.eq.-1) then
          aline=namefunc_dpen(idpen)
!
          name0='DOSIB_XSPEC'
          if(eqname(aline,name0)) then
            jfunc=500
          endif
!
          name0='DOSIB_VSPEC'
          if(eqname(aline,name0)) then
            jfunc=501
          endif
!
          name0='DOSIB_VFOR'
          if(eqname(aline,name0)) then
            jfunc=502
          endif
!
          name0='DOSIB_VBAK'
          if(eqname(aline,name0)) then
            jfunc=503
          endif
!
          name0='DOSIB_INTEGRAL_VSPEC'
          if(eqname(aline,name0)) then
            jfunc=504
          endif
!
          name0='DOSIB_INTEGRAL_VFOR'
          if(eqname(aline,name0)) then
            jfunc=505
          endif
!
          name0='DOSIB_INTEGRAL_VBAK'
          if(eqname(aline,name0)) then
            jfunc=506
          endif
!
          name0='DOSIB_INTEGRAL_XSPEC'
          if(eqname(aline,name0)) then
            jfunc=507
          endif
!
          name0='DOSIB_OSCIL_TPERIOD'
          if(eqname(aline,name0)) then
            jfunc=520
          endif
!
          name0='DOSIB_OSCIL_AMPLITUDE'
          if(eqname(aline,name0)) then
            jfunc=521
          endif
!
          name0='DOSIB_OSCIL_BASE'
          if(eqname(aline,name0)) then
            jfunc=522
          endif
!
          name0='DOSIB_OSCIL_PHASE'
          if(eqname(aline,name0)) then
            jfunc=523
          endif
!
          name0='DOSIB_OSCIL_TDAMP'
          if(eqname(aline,name0)) then
            jfunc=524
          endif
!
          name0='DOSIB_OSCIL_GDAMP'
          if(eqname(aline,name0)) then
            jfunc=525
          endif
!
          name0='DOSIB_OSCIL_FOUNDA'
          if(eqname(aline,name0)) then
            jfunc=526
          endif
!
          name0='DOSIB_OSCIL_FOUNDB'
          if(eqname(aline,name0)) then
            jfunc=527
          endif
!
          name0='DOSIB_OSCIL_FOUNDG'
          if(eqname(aline,name0)) then
            jfunc=528
          endif
!
          name0='DOSIB_OSCIL_FOUNDP'
          if(eqname(aline,name0)) then
            jfunc=529
          endif
!
          name0='DOSIB_OSCIL_FOUNDT'
          if(eqname(aline,name0)) then
            jfunc=530
          endif
!
!
          if(index(aline,'DOSIB_').ge.1.and.jfunc.le.0) then
            errtag='000093.001'
            call err_term
          endif
!
          isib=1
          jfunc_sib(isib,idpen)=jfunc
          jfunc_dpen(idpen)=jfunc
        endif
!
        iparn=1
        ispre_P=ispre_parn(iparn,idpen)
        ispec_P=ispec_parn(iparn,idpen)
        ireac_P=ireac_parn(iparn,idpen)
        ipm_P=ipm_parn(iparn,idpen)
!
        if(jfunc.ge.jfunc_sibn.and.jfunc.le.jfunc_sibx) then
          msib_dpen(idpen)=1
!
          jdrdp_dpen(idpen)=0
!
          if(jfunc.eq.501) jdrdp_dpen(idpen)=1
          if(jfunc.eq.502) jdrdp_dpen(idpen)=1
          if(jfunc.eq.503) jdrdp_dpen(idpen)=1
          if(jfunc.eq.504) jdrdp_dpen(idpen)=1
          if(jfunc.eq.505) jdrdp_dpen(idpen)=1
          if(jfunc.eq.506) jdrdp_dpen(idpen)=1
!
          iparn=1
          adum1=(1.d0*ntime)*                        &
     &    (ti_parn(iparn,idpen)-time0)/(time1-time0)
          itime_parn=-1
          if(ipm_P.eq.-203) itime_parn=myint(ti_parn(iparn,idpen))
          if(ipm_P.eq.-204) itime_parn=ntime
          if(ipm_P.eq.-207) itime_parn=myint(adum1)
!
          isib=1
          itimeP_sib(isib,idpen)=itime_parn
          ispreP_sib(isib,idpen)=ispre_P
          idpen_sib(isib,idpen)=idpen
          ispec_sib(isib,idpen)=ispec
          jfunc_sib(isib,idpen)=jfunc
!
! jfunc=500: get parent species concentration
!              xspec(ispec_P)
! jfunc=501: get parent net rate
!              vspec(ispec_P)
! jfunc=502: get parent reaction forward rate
!              vfor(ireac_P)
! jfunc=503: get parent reaction backward rate
!              vbak(ireac_P)
! jfunc=504: get species integrated net flux
!              int[vspec](ireac_P)
! jfunc=505: get parent reaction integrated forward flux
!              int[vfor](ireac_P)
! jfunc=506: get parent reaction integrated backward flux
!              int[vbak](ireac_P)
! jfunc=507: get integrated parent species concentration
!              int[xspec](ispec_P)
! jfunc=520: get osc. period from distance between extrema
! jfunc=521: get osc. amplitude from extrema
! jfunc=522: get osc. baseline from extrema
! jfunc=523: get osc. phase from position of extrema
! jfunc=524: get osc. damping time from height of extrema
! jfunc=525: get osc. damping const from height of extrema
! jfunc=526: check osc. amplitude found
! jfunc=527: check osc. baseline found
! jfunc=528: check osc. damping found
! jfunc=529: check osc. phase found
! jfunc=530: check osc. period found
!
          if(                                        &
     &    (jfunc.eq.500.and.ispec_P.le.0).or.        &
     &    (jfunc.eq.501.and.ispec_P.le.0).or.        &
     &    (jfunc.eq.502.and.ireac_P.le.0).or.        &
     &    (jfunc.eq.503.and.ireac_P.le.0).or.        &
     &    (jfunc.eq.504.and.ispec_P.le.0).or.        &
     &    (jfunc.eq.505.and.ireac_P.le.0).or.        &
     &    (jfunc.eq.506.and.ireac_P.le.0).or.        &
     &    (jfunc.eq.507.and.ispec_P.le.0).or.        &
     &    (jfunc.eq.520.and.ispec_P.le.0).or.        &
     &    (jfunc.eq.521.and.ispec_P.le.0).or.        &
     &    (jfunc.eq.522.and.ispec_P.le.0).or.        &
     &    (jfunc.eq.523.and.ispec_P.le.0).or.        &
     &    (jfunc.eq.524.and.ispec_P.le.0).or.        &
     &    (jfunc.eq.525.and.ispec_P.le.0).or.        &
     &    (jfunc.eq.526.and.ispec_P.le.0).or.        &
     &    (jfunc.eq.527.and.ispec_P.le.0).or.        &
     &    (jfunc.eq.528.and.ispec_P.le.0).or.        &
     &    (jfunc.eq.529.and.ispec_P.le.0).or.        &
     &    (jfunc.eq.530.and.ispec_P.le.0)            &
     &    )then
            errtag='000093.002'
            call err_term
          endif
!
          isib=1
          if(                                        &
     &    ispec.le.0.or.                             &
     &    jctspre(ispre,ipm).ne.20.or.               &
     &    (                                          &
     &     ipm_P.ne.-203.and.                        &
     &     ipm_P.ne.-204.and.                        &
     &     ipm_P.ne.-207                             &
     &    ).or.                                      &
     &    itimeP_sib(isib,idpen).gt.ntime.or.        &
     &    itimeP_sib(isib,idpen).lt.0                &
     &    )then
            errtag='000093.003'
            call err_term
          endif
        endif
      enddo
!
! Store blocks of "siblings" of children with
!   jfunc=500,501,502,503,504,505,506,507,
!         520,521,522,523,524,525,526,527,528,529,530
! some of which require evaluation of the kinetics
! rate function by drivs (jfunc=501-506). Children
! are grouped into sibling blocks by jprio_dpen, as follows:
! every sibling no. isib1>1 of "firstborn" isib=1, with
! sibling id idpen1 and firstborn id idpen, must have
! jprio(idpen1) and jprio(idpen) such that
!   jprio(idpen1) =< jprio(idpen)+isib1
! All siblings in the same block are evaluated together,
! in priority order, without other non-siblings intervening,
! by a single call to the rate function drivs (via get_drdp).
! The grouping into sibling blocks is done to reduce
! the number of drivs evaluations: a single call to drivs
! generates the reaction rate data for all siblings in the
! block, instead of requiring a separate drivs eval. for
! for each individual sibling.
!
! It is not allowed for a non-sibling idpenN to be assigned
! a priority jpriodp(idpenN) which intervenes within a
! sibling block, i.e., it is forbidden to have
!       jprio(idpen) =< jprio(idpenN) =< jprio(idpen)+msib
! if idpen is a firstborn and idpenN is not a member
! of the firstborn's block of siblings, i.e. if
! jfunc(idpenN)<500=jfunc_sibn or >599=jfunc_sibx.
!
      do ipriodp=1,ndpen_tot
        idpen=idpen_prio(ipriodp)
        iparn=1
! check if idpen is a firstborn:
        if(msib_dpen(idpen).eq.1) then
          isib=1
! check if idpen has siblings:
          do ipriodp1=(ipriodp+1),ndpen_tot
            idpen1=idpen_prio(ipriodp1)
            if(                                                 &
     &      jprio_dpen(idpen1).le.(jprio_dpen(idpen)+isib).and. &
     &      msib_dpen(idpen1).eq.1.and.                         &
     &      jfunc_sib(1,idpen1).ge.jfunc_sibn.and.              &
     &      jfunc_sib(1,idpen1).le.jfunc_sibx.and.              &
     &      jfunc_sib(1,idpen).ge.jfunc_sibn.and.               &
     &      jfunc_sib(1,idpen).le.jfunc_sibx                    &
     &      )then
! found sibling; count and tabulate its attributes:
              isib=isib+1
              if(isib.gt.msib_dpen_x) then
                errtag='000093.004'
                call err_term
              endif
!
              itimeP_sib(isib,idpen)=itimeP_sib(1,idpen1)
              ispreP_sib(isib,idpen)=ispreP_sib(1,idpen1)
              idpen_sib(isib,idpen)=idpen_sib(1,idpen1)
              ispec_sib(isib,idpen)=ispec_sib(1,idpen1)
              jfunc_sib(isib,idpen)=jfunc_sib(1,idpen1)
!
! enable call to get_drdp/drivs if any sibling requires it:
              if(jdrdp_dpen(idpen1).eq.1) jdrdp_dpen(idpen)=1
!
! set flag that idpen1 is a sibling of firstborn idpen;
! idpen1 will therefore be evaluated jointly with idpen at
! each time slice itime in get_xdpen
              msib_dpen(idpen1)=-idpen
! ...this will also signal for this loop that idpen1 is not
! a firstborn
            endif
          enddo
! store sibling count of current firstborn
          if(msib_dpen(idpen).ge.1) msib_dpen(idpen)=isib
        endif
      enddo
!
!  check for non-siblings illegally intervening
!  in the priority order of sibling blocks
!
      do ipriodp=1,ndpen_tot
        idpen=idpen_prio(ipriodp)
        if(msib_dpen(idpen).ge.1) then
          do ipriodp1=1,ndpen_tot
            idpen1=idpen_prio(ipriodp1)
            if(                                                &
     &      idpen1.ne.idpen.and.                               &
     &      jprio_dpen(idpen1).le.                             &
     &      (jprio_dpen(idpen)+msib_dpen(idpen))               &
     &      .and.                                              &
     &      jprio_dpen(idpen1).ge.jprio_dpen(idpen)            &
     &      .and.                                              &
     &      msib_dpen(idpen1).ne.(-idpen)                      &
     &      )then
              errtag='000093.005.000'
              call err_term
            endif
          enddo
        endif
      enddo
!
!
!N180810:
!
! Check 11:
!
      do ipriodp=1,ndpen_tot
        idpen=idpen_prio(ipriodp)
!
        ispec1=ispec_dpen(idpen)
        ipm1=ipm_dpen(idpen)
!
        if (ispec1.gt.0.and.ipm1.gt.0) then
          if (jfix(ispec1).eq.-110.and.jctspec(ispec1,ipm1).eq.20) then
            if(msib_dpen(idpen).ne.0) then
               errtag='000093.005.001'
               call err_term
            endif
          endif
        endif
!
      enddo
!
!:N180810
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_fix_blkth
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! initialize MC theta move blocks
!
      include 'ens.def'
!
      call set_fix_blkth00
      call set_fix_blkth01
      call set_fix_blkth02
      call set_fix_blkth03
!!    call set_fix_blkth03a
!!    call set_fix_blkth03b
      call set_fix_blkth04
      call set_fix_blkth05
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_fix_blkth00
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! initialize MC theta move blocks
!
      include 'ens.def'
!
!     translate block-limiting species/reaction names into ispre-IDs
      do lblkth=1,lblkth_tot
        ispre_lo_blkth(lblkth)=                                     &
     &  ispre4name(ierrtag,namespre,nspre                           &
     &            ,namespre_lo_blkth(lblkth)                        &
     &            ,nspre_y)
!
        if(ierrtag.gt.0) then
          jerrtag=12
          errtag='000120'
          call err_term
        endif
!
        ispre_hi_blkth(lblkth)=                                     &
     &  ispre4name(ierrtag,namespre,nspre                           &
     &            ,namespre_hi_blkth(lblkth)                        &
     &            ,nspre_y)
!
        if(ierrtag.gt.0) then
          jerrtag=13
          errtag='000120'
          call err_term
        endif
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_fix_blkth01
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! initialize MC theta move blocks
!
      include 'ens.def'
!
!
! tabulate all Theta variables ith within blocks vs. running label kthblk,
! without double-listing and, if requested, in ith-ascending order
      kthblk=0
      kthb_inilb(1)=1
      kthb_finlb(1)=0
!
      do jmvloop=1,2
        do imvsequ=1,nmvsequ(jmvloop)
          do lblkth=lblkth_ini(imvsequ,jmvloop)                  &
     &    ,         lblkth_fin(imvsequ,jmvloop)
            kthb_inilb(lblkth)=kthblk+1
            lblkth_i=lblkth_ini(imvsequ,jmvloop)
!
            do ithc=1,mth_tot
              if(ithc.le.mth_spec) then
                ispec=ispec_th(ithc)
                ipm=ipmspec_th(ithc)
                ispre=ispec
              endif
              if(ithc.gt.mth_spec) then
                ireac=ireac_th(ithc-mth_spec)
                ipm=ipmreac_th(ithc-mth_spec)
                ispre=ireac+nspec
              endif
!
              if(                                   &
     &        ispre.ge.ispre_lo_blkth(lblkth).and.  &
     &        ispre.le.ispre_hi_blkth(lblkth).and.  &
     &        ipm.ge.ipm_lo_blkth(lblkth).and.      &
     &        ipm.le.ipm_hi_blkth(lblkth)           &
     &        )then
!
!               ispre-stride starting from "lo"
                if(jispre_str_blkth(lblkth).eq.1) then
                  idum1=ispre-ispre_lo_blkth(lblkth)
                  adum2=(1.d0*idum1+.01d0)/(1.d0*ispre_str_blkth(lblkth))
                  idum2=adum2
                  idum=idum2*ispre_str_blkth(lblkth)
                  if(idum.ne.idum1) goto 129
                endif
!
!               ispre-stride starting from "hi"
                if(jispre_str_blkth(lblkth).eq.2) then
                  idum1=ispre_hi_blkth(lblkth)-ispre
                  adum2=(1.d0*idum1+.01d0)/(1.d0*ispre_str_blkth(lblkth))
                  idum2=adum2
                  idum=idum2*ispre_str_blkth(lblkth)
                  if(idum.ne.idum1) goto 129
                endif
!
!               ipm-stride starting from "lo"
                if(jipm_str_blkth(lblkth).eq.1) then
                  idum1=ipm-ipm_lo_blkth(lblkth)
                  adum2=(1.d0*idum1+.01d0)/(1.d0*ipm_str_blkth(lblkth))
                  idum2=adum2
                  idum=idum2*ipm_str_blkth(lblkth)
                  if(idum.ne.idum1) goto 129
                endif
!
!               ipm-stride starting from "hi"
                if(jipm_str_blkth(lblkth).eq.2) then
                  idum1=ipm_hi_blkth(lblkth)-ipm
                  adum2=(1.d0*idum1+.01d0)/(1.d0*ipm_str_blkth(lblkth))
                  idum2=adum2
                  idum=idum2*ipm_str_blkth(lblkth)
                  if(idum.ne.idum1) goto 129
                endif
!
!               prevent double-listing of ithc included in
!               overlapping theta blocks of the same move sequence
                do kthblk0=kthb_inilb(lblkth_i),kthblk
                  if(ithc.eq.ithc_thblk(kthblk0)) goto 129
                enddo
!
                kthblk=kthblk+1
                if(kthblk.gt.kthblk_x) then
                  errtag='000093.006'
                  call err_term
                endif
                ithc_thblk(kthblk)=ithc
                ithc_no_thblk(kthblk)=ithc
              endif
!
  129         continue
            enddo
            kthb_finlb(lblkth)=kthblk
          enddo
        enddo
      enddo
      kthblk_tot=kthblk
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_fix_blkth02
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! initialize MC theta move blocks
!
      include 'ens.def'
!
!
! Re-store non-ordered ithc_no_thblk in ascending order: ithc_thblk
      do jmvloop=1,2
        do imvsequ=1,nmvsequ(jmvloop)
          if(jblkth_ord(imvsequ,jmvloop).eq.1) then
            lblkth_i=lblkth_ini(imvsequ,jmvloop)
            kthblk_i=kthb_inilb(lblkth_i)
!
            lblkth_f=lblkth_fin(imvsequ,jmvloop)
            kthblk_f=0
            if(lblkth_f.ge.1) kthblk_f=kthb_finlb(lblkth_f)
!
            do kthblk0=kthblk_i,kthblk_f
              kthblk=kthblk_i
              ithc0=ithc_no_thblk(kthblk0)
              do kthblk1=kthblk_i,kthblk_f
                if(ithc_no_thblk(kthblk1).lt.ithc0) kthblk=kthblk+1
              enddo
              ithc_thblk(kthblk)=ithc0
            enddo
          endif
        enddo
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_fix_blkth03
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! initialize MC theta move blocks
!
      include 'ens.def'
!
!     set Theta block dimensions and kthblk-label bounds for
!     block-global-Theta updates: mthb_tot, kthb_tot_[ini,fin];
!     block-species-Theta updates: mthb_spec, kthb_spec_[ini,fin];
!     block-reaction-Theta updates: mthb_reac, kthb_reac[ini,fin]
!
      do jmvloop=1,2
        do imvsequ=1,nmvsequ(jmvloop)
          mthb_tot(imvsequ,jmvloop)=mth_tot
          kthb_tot_ini(imvsequ,jmvloop)=-1
          kthb_tot_fin(imvsequ,jmvloop)=-2
!
          mthb_spec(imvsequ,jmvloop)=mth_spec
          kthb_spec_ini(imvsequ,jmvloop)=-1
          kthb_spec_fin(imvsequ,jmvloop)=-2
!
          mthb_reac(imvsequ,jmvloop)=mth_reac
          kthb_reac_ini(imvsequ,jmvloop)=-1
          kthb_reac_fin(imvsequ,jmvloop)=-2
!
          if(                                                                &
     &    jblkth_pik(imvsequ,jmvloop).eq.1.and.nblkth(imvsequ,jmvloop).ge.1  &
     &    ) then
!!
!! lblkth_fin(imvsequ,jmvloop).ge.lblkth_ini(imvsequ,jmvloop)
!!
!
            lblkth_i=lblkth_ini(imvsequ,jmvloop)
            kthblk_i=kthb_inilb(lblkth_i)
!
            lblkth_f=lblkth_fin(imvsequ,jmvloop)
            kthblk_f=0
            if(lblkth_f.ge.1) kthblk_f=kthb_finlb(lblkth_f)
!
!          initial mthb_... for block size counting
            mthb_tot(imvsequ,jmvloop)=0
            kthb_tot_ini(imvsequ,jmvloop)=0
            kthb_tot_fin(imvsequ,jmvloop)=-1
!
            mthb_spec(imvsequ,jmvloop)=0
            kthb_spec_ini(imvsequ,jmvloop)=0
            kthb_spec_fin(imvsequ,jmvloop)=-1
!
            mthb_reac(imvsequ,jmvloop)=0
            kthb_reac_ini(imvsequ,jmvloop)=0
            kthb_reac_fin(imvsequ,jmvloop)=-1
!
            if(kthblk_f .ge.kthblk_i) then
              mthb_tot(imvsequ,jmvloop)=kthblk_f-kthblk_i+1
              kthb_tot_ini(imvsequ,jmvloop)=kthblk_i
              kthb_tot_fin(imvsequ,jmvloop)=kthblk_f
!
!            initial kthb_..._[ini,fin] for lower and upper bound search
              kthb_spec_ini(imvsequ,jmvloop)=kthblk_f
              kthb_spec_fin(imvsequ,jmvloop)=kthblk_i
!
              kthb_reac_ini(imvsequ,jmvloop)=kthblk_f
              kthb_reac_fin(imvsequ,jmvloop)=kthblk_i
!
              do kthblk=kthblk_i,kthblk_f
                if(ithc_thblk(kthblk).le.mth_spec) then
                  mthb_spec(imvsequ,jmvloop)=                         &
     &            mthb_spec(imvsequ,jmvloop)+1
!
                  if(kthblk.lt.kthb_spec_ini(imvsequ,jmvloop))        &
     &            kthb_spec_ini(imvsequ,jmvloop)=kthblk
!
                  if(kthblk.gt.kthb_spec_fin(imvsequ,jmvloop))        &
     &            kthb_spec_fin(imvsequ,jmvloop)=kthblk
                else
                  mthb_reac(imvsequ,jmvloop)=                         &
     &            mthb_reac(imvsequ,jmvloop)+1
!
                  if(kthblk.lt.kthb_reac_ini(imvsequ,jmvloop))        &
     &            kthb_reac_ini(imvsequ,jmvloop)=kthblk
!
                  if(kthblk.gt.kthb_reac_fin(imvsequ,jmvloop))        &
     &            kthb_reac_fin(imvsequ,jmvloop)=kthblk
                endif
              enddo
            endif
!
! check that species block labels kthb_spec do not overlap
! reaction block labels kthb_reac, if their ith-labels
! were tabulated vs. kthblk in ascending order
! (if so: progr. error!)
!
            if(jblkth_ord(imvsequ,jmvloop).eq.1) then
              if(                                                  &
     &        (kthb_spec_fin(imvsequ,jmvloop)                      &
     &        -kthb_spec_ini(imvsequ,jmvloop)+1).ge.1.and.         &
     &        mthb_spec(imvsequ,jmvloop).ne.                       &
     &        (kthb_spec_fin(imvsequ,jmvloop)                      &
     &        -kthb_spec_ini(imvsequ,jmvloop)+1)                   &
     &        )then
                errtag='000093.007'
                call err_term
              endif
!
              if(                                                  &
     &        (kthb_reac_fin(imvsequ,jmvloop)                      &
     &        -kthb_reac_ini(imvsequ,jmvloop)+1).ge.1.and.         &
     &        mthb_reac(imvsequ,jmvloop).ne.                       &
     &        (kthb_reac_fin(imvsequ,jmvloop)                      &
     &        -kthb_reac_ini(imvsequ,jmvloop)+1)                   &
     &        )then
                errtag='000093.008'
                call err_term
              endif
            endif
!
          endif
        enddo
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_fix_blkth04
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! initialize MC theta move blocks
!
      include 'ens.def'
!
! tabulate all (ispre,ipm)-variables w/in param. var. blocks vs.
! running label kpmblk, regardless of variable attribute jctspre,
! i.e., including Theta-, control-(U-) and child-variables in listing;
! without double-listing; as needed for special moves, e.g.,
! Gibbs sampler of deconvolution amplitudes
      kpmblk=0
      kpmb_inilb(1)=1
      kpmb_finlb(1)=0
!
      do jmvloop=1,2
        do imvsequ=1,nmvsequ(jmvloop)
          do lblkth=lblkth_ini(imvsequ,jmvloop)                  &
     &    ,         lblkth_fin(imvsequ,jmvloop)
            kpmb_inilb(lblkth)=kpmblk+1
            lblkth_i=lblkth_ini(imvsequ,jmvloop)
            do ispre=1,nspre
              do ipm=1,npmspre(ispre)
                if(                                   &
     &          ispre.ge.ispre_lo_blkth(lblkth).and.  &
     &          ispre.le.ispre_hi_blkth(lblkth).and.  &
     &          ipm.ge.ipm_lo_blkth(lblkth).and.      &
     &          ipm.le.ipm_hi_blkth(lblkth)           &
     &          )then
!
!               ispre-stride starting from "lo"
                  if(jispre_str_blkth(lblkth).eq.1) then
                    idum1=ispre-ispre_lo_blkth(lblkth)
                    adum2=(1.d0*idum1+.01d0)/(1.d0*ispre_str_blkth(lblkth))
                    idum2=adum2
                    idum=idum2*ispre_str_blkth(lblkth)
                    if(idum.ne.idum1) goto 149
                  endif
!
!               ispre-stride starting from "hi"
                  if(jispre_str_blkth(lblkth).eq.2) then
                    idum1=ispre_hi_blkth(lblkth)-ispre
                    adum2=(1.d0*idum1+.01d0)/(1.d0*ispre_str_blkth(lblkth))
                    idum2=adum2
                    idum=idum2*ispre_str_blkth(lblkth)
                    if(idum.ne.idum1) goto 149
                  endif
!
!               ipm-stride starting from "lo"
                  if(jipm_str_blkth(lblkth).eq.1) then
                    idum1=ipm-ipm_lo_blkth(lblkth)
                    adum2=(1.d0*idum1+.01d0)/(1.d0*ipm_str_blkth(lblkth))
                    idum2=adum2
                    idum=idum2*ipm_str_blkth(lblkth)
                    if(idum.ne.idum1) goto 149
                  endif
!
!               ipm-stride starting from "hi"
                  if(jipm_str_blkth(lblkth).eq.2) then
                    idum1=ipm_hi_blkth(lblkth)-ipm
                    adum2=(1.d0*idum1+.01d0)/(1.d0*ipm_str_blkth(lblkth))
                    idum2=adum2
                    idum=idum2*ipm_str_blkth(lblkth)
                    if(idum.ne.idum1) goto 149
                  endif
!
!               prevent double-listing of (ispre,ipm) included in
!               overlapping theta blocks of the same move sequence
                  do kpmblk0=kpmb_inilb(lblkth_i),kpmblk
                    if(                                                &
     &              ispre.eq.ispre_pmblk(kpmblk0).and.                 &
     &              ipm.eq.ipm_pmblk(kpmblk0)                          &
     &              ) goto 149
                  enddo
!
                  kpmblk=kpmblk+1
                  if(kpmblk.gt.kpmblk_x) then
                    errtag='000093.009.000'
                    call err_term
                  endif
                  ispre_pmblk(kpmblk)=ispre
                  ipm_pmblk(kpmblk)=ipm
                endif
!
  149           continue
              enddo  !ipm
            enddo  !ispre
            kpmb_finlb(lblkth)=kpmblk
          enddo  !lblkth
        enddo  !imvsequ
      enddo  !jmvloop
      kpmblk_tot=kpmblk
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_fix_blkth05
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! tabulate param. var. block boundaries vs. imvsequ,jmvloop
!
      include 'ens.def'
!
      do jmvloop=1,2
        do imvsequ=1,nmvsequ(jmvloop)
          lblkth_i=lblkth_ini(imvsequ,jmvloop)
          kpmb_ini(imvsequ,jmvloop)=1
          if(                                                   &
     &    lblkth_i.ge.1.and.                                    &
     &    lblkth_i.le.lblkth_tot                                &
     &    )                                                     &
     &    kpmb_ini(imvsequ,jmvloop)=kpmb_inilb(lblkth_i)
!
          lblkth_f=lblkth_fin(imvsequ,jmvloop)
          kpmb_fin(imvsequ,jmvloop)=kpmb_ini(imvsequ,jmvloop)-1
          if(                                                     &
     &    lblkth_f.ge.1.and.                                      &
     &    lblkth_f.ge.lblkth_i.and.                               &
     &    lblkth_f.le.lblkth_tot                                  &
     &    )                                                       &
     &    kpmb_fin(imvsequ,jmvloop)=kpmb_finlb(lblkth_f)
!
          mpmb_tot(imvsequ,jmvloop)=                                          &
     &    kpmb_fin(imvsequ,jmvloop)-                                          &
     &    kpmb_ini(imvsequ,jmvloop)+1
        enddo
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_fix_rasf
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! initialize SF randomization
!
      include 'ens.def'
!
! translate names for sxplog- or sxplin-theta storage
! to (ispre_rasf,ipm_rasf)
!
! Note: storage of sxplog_ras and sxp_lin_ras as
! theta-variables is NOT YET IMPLEMENTED; hence
! ispre-rasf not yet needed elsewhere in code
!
      do jmvloop=1,2
        do imvsequ=1,nmvsequ(jmvloop)
          if(jrasf_fmt(imvsequ,jmvloop).ge.0) then
            do lrasf=lrasf_ini(imvsequ,jmvloop)                      &
     &      ,        lrasf_fin(imvsequ,jmvloop)
              ispre_rasf(lrasf)=                                     &
     &        ispre4name(ierrtag,namespre,nspre                      &
     &                  ,namespre_rasf(lrasf)                        &
     &                  ,nspre_y)
!
              if(ierrtag.gt.0) then
                jerrtag=12
                errtag='000120'
                call err_term
              endif
            enddo
          endif
        enddo
      enddo
!
!  DEACTIVATED:
      goto 990
!  check: if jrasf_ctl=1 or =2 is used in *any one* jmvty,
!  then jrasf_ctl=1 or =2 must be used in *all* MC-type moves;
!  otherwise ensemble prob. would be different/inconsistent
!  in diff. move types, b/c of the fact that
!             sxplin_avg|=sxplin_chi.
!  for case of lin.-conc. species
!
      jrasf_ctl_ij=-1
      do jmvloop=1,2
        do imvsequ=1,nmvsequ(jmvloop)
          if(jrasf_ctl(imvsequ,jmvloop).eq.1) jrasf_ctl_ij=1
          if(jrasf_ctl(imvsequ,jmvloop).eq.2) jrasf_ctl_ij=1
        enddo
      enddo
!
      if(jrasf_ctl_ij.eq.1) then
        do jmvloop=1,2
          do imvsequ=1,nmvsequ(jmvloop)
            if(                                              &
     &      jrasf_ctl(imvsequ,jmvloop).ne.1.and.             &
     &      jrasf_ctl(imvsequ,jmvloop).ne.2) then
              errtag='000093.009.001'
              call err_term
            endif
          enddo
        enddo
      endif
  990 continue
      jrasf_ctl_ij=-1
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_fix_dcon
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! initialize deconvolution Gibbs sampler MC control tables
!
      include 'ens.def'
!
      call set_fix_dcon01
      call set_fix_dcon02
      call set_fix_dcon03
      call set_fix_dcon04
      call set_fix_dcon05
      call set_fix_dcon06
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_fix_dcon01
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! initialize deconvolution Gibbs sampler MC control tables
!
      include 'ens.def'
!
! translate real-species and pseudo-species names into ispec-IDs
! translate frozen-amplitude names from ispre-IDs
!
      do ldconr=1,ldconr_tot
        irspec_dconr(ldconr)=                                  &
     &  ispre4name(ierrtag,namespre,nspre                      &
     &            ,name_dconr(ldconr)                          &
     &            ,nspre_y)
!
        if(                                                    &
     &  ierrtag.gt.0.or.                                       &
     &  irspec_dconr(ldconr).gt.nspec                          &
     &  )then
          jerrtag=14
          errtag='000120'
          call err_term
        endif
      enddo
!
      do ldconp=1,ldconp_tot
        ipspec_dconp(ldconp)=                                  &
     &  ispre4name(ierrtag,namespre,nspre                      &
     &            ,name_dconp(ldconp)                          &
     &            ,nspre_y)
!
        ims=-1
        if(                                                    &
     &  ipspec_dconp(ldconp).ge.1.and.                         &
     &  ipspec_dconp(ldconp).le.nspec                          &
     &  )                                                      &
     &  ims=ims_spec(ipspec_dconp(ldconp))
!
        if(                                                    &
     &  ierrtag.gt.0.or.                                       &
     &  ipspec_dconp(ldconp).gt.nspec.or.                      &
     &  ipspec_dconp(ldconp).lt.1.or.                          &
     &  ims.le.0                                               &
     &  )then
          jerrtag=15
          errtag='000120'
          call err_term
        endif
      enddo
!
!
      do ldconfz=1,ldconfz_tot
        irspec_dconfz(ldconfz)=                                &
     &  ispre4name(ierrtag,namespre,nspre                      &
     &            ,namerspec_dconfz(ldconfz)                   &
     &            ,nspre_y)
!
        if(ierrtag.gt.0) then
          jerrtag=16
          errtag='000120'
          call err_term
        endif
!
        ipspec_dconfz(ldconfz)=                                 &
     &  ispre4name(ierrtag,namespre,nspre                       &
     &            ,namepspec_dconfz(ldconfz)                    &
     &            ,nspre_y)
!
        if(ierrtag.gt.0) then
          jerrtag=17
          errtag='000120'
          call err_term
        endif
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_fix_dcon02
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! initialize deconvolution Gibbs sampler MC control tables
!
      include 'ens.def'
!
!
!  check that SF Gaussian randmzn is turned on for deconv. moves:
!  for jmty=20 must set jrasf_ctl=2
      do jmvloop=1,2
        do imvsequ=1,nmvsequ(jmvloop)
          if(jmty(imvsequ,jmvloop).eq.20.and.                    &
     &    jrasf_ctl(imvsequ,jmvloop).ne.2) then
            errtag='000093.009.002'
            call err_term
          endif
        enddo
      enddo
!
!
!  check that all pseudo-species are declared in i01 as
!  lin. conc.  species for  chi^2-calc: jmsspec_ch=2
!  and that all pseudo-species are explicit txpt-summation species
!  (do *not* use exptl. data pre-summation) jmsspec_px=0:
      do ldconp=1,ldconp_tot
        if(jmsspec_ch(ipspec_dconp(ldconp)).ne.2) then
          errtag='000093.009.003'
          call err_term
        endif
        if(jmsspec_px(ipspec_dconp(ldconp)).ne.0) then
          errtag='000093.009.004'
          call err_term
        endif
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_fix_dcon03
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! initialize deconvolution Gibbs sampler MC control tables
!
      include 'ens.def'
!
!
!  tabulate ispre, ipm, ith of _all_ (Theta+Control+Child)
!  decon-amplitude block variables vs. label kampdv, running
!  over all (pseudo,real)-species pairs of given deconvolution
!  move sequence, i.e., regardless of "jctspre" attribute
!
      kampdv=0
      do jmvloop=1,2
        do imvsequ=1,nmvsequ(jmvloop)
          kampdv_ini(imvsequ,jmvloop)=kampdv+1
!
          do ldconp=ldconp_ini(imvsequ,jmvloop)                  &
     &    ,         ldconp_fin(imvsequ,jmvloop)
            ipspec=ipspec_dconp(ldconp)
!
            kampdv_inips(ldconp)=kampdv+1
!
            do ldconr=ldconr_ini(imvsequ,jmvloop)                &
     &      ,         ldconr_fin(imvsequ,jmvloop)
              irspec=irspec_dconr(ldconr)
              kampdv=kampdv+1
!
              if(kampdv.gt.kampdv_x) then
                errtag='000093.010'
                call err_term
              endif
!
! needed for "LATER" ampl. block consistency checking
              irspec_ampdv(kampdv)=irspec
              ipspec_ampdv(kampdv)=ipspec
              kpmblk=kampdv-kampdv_ini(imvsequ,jmvloop)        &
     &                       +kpmb_ini(imvsequ,jmvloop)
!
              if(                                              &
     &        kpmblk.lt.kpmb_ini(imvsequ,jmvloop).or.          &
     &        kpmblk.gt.kpmb_fin(imvsequ,jmvloop)              &
     &        )then
                errtag='000093.011.000 INCOMPATIBLE deconv. ampl. block size'
                call err_term
              endif
!
              ispre_ampdv(kampdv)=ispre_pmblk(kpmblk)
              ipm_ampdv(kampdv)=ipm_pmblk(kpmblk)
            enddo  !ldconr
!
            kampdv_finps(ldconp)=kampdv
          enddo  !ldconp
!
          kampdv_fin(imvsequ,jmvloop)=kampdv
          idum1=kampdv_fin(imvsequ,jmvloop)-kampdv_ini(imvsequ,jmvloop)
          idum2=kpmb_fin(imvsequ,jmvloop)-kpmb_ini(imvsequ,jmvloop)
          if(                                                             &
     &    mdconr(imvsequ,jmvloop).gt.0.and.                               &
     &    mdconp(imvsequ,jmvloop).gt.0                                    &
     &    ) then
            if(idum1.ne.idum2) then
              errtag='000093.011.001'
              call err_term
            endif
          endif
        enddo  !imvsequ
      enddo  !jmvloop
!
      kampdv_tot=kampdv
!LATER:
! Add detailed deconv. amplitude block consistency checks:
! --each pseudo-species ipspec must be child of its real-species
!   parents irspec
! --consec. (ispre_ampdv,ipm_ampdv) must be consec. parents of ipspec
! --consec. irspec_ampdv must be consec. parents of ipspec==ipspec_ampdv
! --dependency of ipspec on irspec_ampdv-sequ. and on
!   (ispre_ampdv,ipm_ampdv)-sequ. of parents must be type "DOT_PRODUCT"
!   with order of irspec_ampdv matching (ispre_ampdv,ipm_ampdv)
!   in the corresp. dot product input vectors
! --ipspec must not be a parent of any other observed child species
!   with actual exptl. input data in ens.i02.
! --all ipspec within given move sequ. (imvsequ,jmvloop) must have
!   same no. "mparn/2" of real-species parents (and hence same no.
!   "mparn/2" of corresp. amplitude parents)
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_fix_dcon04
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! initialize deconvolution Gibbs sampler MC control tables
!
      include 'ens.def'
!
!
!  tabulate ispre, ipm, ith of _only_ unfrozen-theta
!  deconv-amplitude block variables
      kampdv=0
      kampdu=0
      do jmvloop=1,2
        do imvsequ=1,nmvsequ(jmvloop)
          kampdu_ini(imvsequ,jmvloop)=kampdu+1
!
          do ldconp=ldconp_ini(imvsequ,jmvloop)                  &
     &    ,         ldconp_fin(imvsequ,jmvloop)
            ipspec=ipspec_dconp(ldconp)
!
            kampdu_inips(ldconp)=kampdu+1
!
            do ldconr=ldconr_ini(imvsequ,jmvloop)                &
     &      ,         ldconr_fin(imvsequ,jmvloop)
              irspec=irspec_dconr(ldconr)
              kampdv=kampdv+1
!
              kampdu_ampdv(kampdv)=-1
!
              ith_ampdv=                                                 &
     &        ith_spre(ispre_ampdv(kampdv),ipm_ampdv(kampdv))
              if(ith_ampdv.le.0) then
                kampdu_ampdv(kampdv)=-2
                goto 29
              endif
!
              do ldconfz=ldconfz_ini(imvsequ,jmvloop)                    &
     &        ,          ldconfz_fin(imvsequ,jmvloop)
                if(                                                      &
     &          irspec_dconfz(ldconfz).eq.irspec.and.                    &
     &          ipspec_dconfz(ldconfz).eq.ipspec                         &
     &          )then
                  kampdu_ampdv(kampdv)=-1
                  goto 29
                endif
              enddo  !ldconfz
!
              kampdu=kampdu+1
              if(kampdu.gt.kampdu_x) then
                errtag='000093.012'
                call err_term
              endif
!
              kampdu_ampdv(kampdv)=kampdu
!
   29         continue
            enddo  !ldconr
!
            mampdu_ps(ldconp)=kampdu-kampdu_inips(ldconp)+1
          enddo  !ldconp
!
          mampdu_tot(imvsequ,jmvloop)=kampdu-kampdu_ini(imvsequ,jmvloop)+1
        enddo  !imvsequ
      enddo  !jmvloop
!
      kampdu_tot=kampdu
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_fix_dcon05
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! initialize deconvolution Gibbs sampler MC control tables
!
      include 'ens.def'
!
!
! store total real-species (rspec, rs) and pseudo-species (pspec, ps))
! dimensions and check their product (rs,ps) matrix dimension
! against total no. of ipm-variables mpmb_tot in corresp. ipm-variable
! block
!
      do jmvloop=1,2
        do imvsequ=1,nmvsequ(jmvloop)
          if(                                                             &
     &    mdconr(imvsequ,jmvloop).gt.0.and.                               &
     &    mdconp(imvsequ,jmvloop).gt.0                                    &
     &    ) then
            mdcon_rpspec=                                                   &
     &      mdconr(imvsequ,jmvloop)*mdconp(imvsequ,jmvloop)
!
            if(                                                             &
     &      mdcon_rpspec.gt.0.and.                                          &
     &      mdcon_rpspec.ne.mpmb_tot(imvsequ,jmvloop)                       &
     &      )then
              errtag='000093.013'
              call err_term
            endif
!
            if(                                                             &
     &      mdcon_rpspec.gt.0                                               &
     &      .and.                                                           &
     &      kthb_tot_ini(imvsequ,jmvloop).le.0                              &
     &      )then
              errtag='000093.014'
              call err_term
            endif
          endif
        enddo
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_fix_dcon06
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! initialize deconvolution Gibbs sampler MC control tables
!
      include 'ens.def'
!
! store total real-species (rspec, rs) and pseudo-species (pspec, ps))
! dimensions and check their product (rs,ps) matrix dimension
! against total no. of ipm-variables mpmb_tot in corresp. ipm-variable
!
! check array size limits:
!
      do jmvloop=1,2
        do imvsequ=1,nmvsequ(jmvloop)
          do ldconr2=ldconr_ini(imvsequ,jmvloop)              &
     &    ,          ldconr_fin(imvsequ,jmvloop)
            idconr2=ldconr2-ldconr_ini(imvsequ,jmvloop)+1
            if(idconr2.gt.mdconr_x.or.idconr2.lt.1) then
              errtag='000093.016'
              call err_term
            endif
!
            do ldconp=ldconp_ini(imvsequ,jmvloop)               &
     &      ,         ldconp_fin(imvsequ,jmvloop)
              if(                                               &
     &        mampdu_ps(ldconp).gt.mdconr_x.or.              &
     &        mampdu_ps(ldconp).lt.1                            &
     &        )then
                errtag='000093.017'
                call err_term
              endif
!
!
              iampdu2=1
              kampdv2=idconr2+kampdv_inips(ldconp)-1
              if(kampdu_ampdv(kampdv2).ge.1) then
                iampdu2=kampdu_ampdv(kampdv2)-kampdu_inips(ldconp)+1
              endif
              if(iampdu2.gt.mdconr_x.or.iampdu2.lt.1) then
!N180810
                errtag='000093.018.000'
                call err_term
              endif
            enddo
          enddo
        enddo
      enddo
!
!
      jmvloop=-1
      imvsequ=-1
      ldconp=-1
      ldconr=-1
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_fix_mcs
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! initialize MC scheduling counters
!
      include 'ens.def'
!
!Db
      jclC=-22222
      jclO=-22222
!Fb
! set constants
! initialize MC scheduling counters
      if(jmc_inir.ge.340.and.jmc_inir.le.399) then
        nmc_smp=1
      else
        nmc_smp=2
      endif
!
      jmvloop=-1
      imc_smp=-1
      imc_rep=-1
      imc_eql=-1
      imc_acc=-1
      imc_upd=-1
      imvsequ=-1
      kmvsequ=-1
      kmvsequ_lp=-1
      kmvsequ_ini=-1
      imove=-1
      kmove=-1
      jkmove=-1
      ith_rk=-1
      ith_cs=-1
!
      jrasf_freez=-1
      jsto_chiras=-1
!
      npopst=-1
      npopst_lst=-1
      ipop=-1
      ipop_upd=-1
      ipop_xch=-1
      ipop_xst=-1
      ipop_yst=-1
      ixst=-1
      fbeta_st=1.d0
      fstep_st=1.d0
!
      npopge=-1
      npopge_lst=-1
      jdo_st4ge=0
!
      jsfxdi=0
      jkrxdi=0
      jupd_abaxdi=0
      jo_abaxdi=0
      jupd_sfxdi=0
!
      mhtot_amb=-1
      ihtot_amb=-1
      imove_amb=-1
      ihtot_amb_ini=0
      jo_amb=0
!
      mhtot_pst=-1
      ihtot_pst=-1
      imove_pst=-1
      ihtot_pst_ini=0
      jo_pst=0
!
      mhtot_pge=-1
      ihtot_pge=-1
      imove_pge=-1
      ihtot_pge_ini=0
      jo_pge=0
!
      lhtot_pst=0
      inc_pst0=0
      inc_pst1=0
      inc_yst=0
      inc_ham=0
      inc_amb=0
!
      jamb_repl=0
!
      iout_th_rst=-1
      jmvloop_rst=-1
      imc_rep_rst=-1
      imc_eql_rst=-1
      imc_acc_rst=-1
      imc_upd_rst=-1
      imvsequ_rst=-1
      jmty_rst=-1
      imove_rst=-1
      kmove_rst=-1
      kmvsequ_rst=-1
!
      iout_th_rsi=-1
      jmvloop_rsi=-1
      imc_rep_rsi=-1
      imc_eql_rsi=-1
      imc_acc_rsi=-1
      imc_upd_rsi=-1
      imvsequ_rsi=-1
      jmty_rsi=-1
      imove_rsi=-1
      kmvsequ_rsi=-1
!
      jamb_rsi=0
      jpst_rsi=0
      jpge_rsi=0
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine tr_spre(ispec,ireac,ispre,nspec)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! translates compound species+reaction label "ispre"
! into species label "ispec" or reaction label "ireac"
!
      implicit none
!
      integer ispec,ireac,ispre,nspec
!
      ispec=-1
      ireac=-1
      if(ispre.le.nspec) ispec=ispre
      if(ispre.gt.nspec) ireac=ispre-nspec
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine get_pdpen
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
      do ipriodp=1,ndpen_tot
        idpen=idpen_prio(ipriodp)
!
        ispec_D=ispec_dpen(idpen)
        ireac_D=ireac_dpen(idpen)
        ispre_D=ispre_dpen(idpen)
        ipm_D=ipm_dpen(idpen)
!
        if(ispec_D.gt.0) cspec(ispec_D,ipm_D)=0.d0
        if(ireac_D.gt.0) rreac(ireac_D,ipm_D)=0.d0
!
        if(jctspre(ispre_D,ipm_D).ne.10) goto 190
!
        jfunc=jfunc_dpen(idpen)
        namefunc=' '
        if(jfunc.eq.-1) namefunc=namefunc_dpen(idpen)
!
        mparn=mparn_dpen(idpen)
!
        do iparn=1,mparn
          ipm=ipm_parn(iparn,idpen)
          if(ipm.gt.0) then
            ispre=ispre_parn(iparn,idpen)
            call tr_spre(ispec,ireac,ispre,nspec)
            if(ispec.gt.0) pmfunc(iparn)=cspec(ispec,ipm)
            if(ireac.gt.0) pmfunc(iparn)=rreac(ireac,ipm)
          else
            pmfunc(iparn)=pmparn(iparn,idpen)
          endif
        enddo
!
!c      ispre_D=ispre_dpen(idpen)
!c      call tr_spre(ispec_D,ireac_D,ispre_D,nspec)
!
        call func_dpen
!            (pmdpen,pmfunc,mparn,jfunc,namefunc)
!
        crdpen(lcrdp_dpen(idpen,iexpt))=pmdpen
!
        if(ispec_D.gt.0) cspec(ispec_D,ipm_D)=pmdpen
        if(ireac_D.gt.0) rreac(ireac_D,ipm_D)=pmdpen
!
!
  190   continue
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine get_xdpen
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! for dependent t-evol. model species:
!N180810
!     jfix(ispec)=-100 or -110, jctspec(ispec,ipm)=20
!
!
      ispec_M=0
      do idpen=1,ndpen_spec
        ispec_D=ispec_dpen(idpen)
        if(ispec_D.le.0) goto 90
        if(ispec_D.eq.ispec_M) goto 90
!N180810
        if(jfix(ispec_D).ne.-100.and.jfix(ispec_D).ne.-110) goto 90
!
        do itime=0,ntime
          xspec(ispec_D,itime)=xspec_min(ispec_D)
        enddo
!
        ispec_M=ispec_D
   90   continue
      enddo
!
!
      do ipriodp=1,ndpen_tot
        idpen=idpen_prio(ipriodp)
!
        if(msib_dpen(idpen).le.-1) goto 190
!
!N180810
        ispre_D=ispre_dpen(idpen)
        call tr_spre(ispec_D,ireac_D,ispre_D,nspec)
        if(ispec_D.le.0) goto 190
!
!N180810
        if(jfix(ispec_D).ne.-100.and.jfix(ispec_D).ne.-110) goto 190
!
        ipm_D=ipm_dpen(idpen)
        if(jctspre(ispre_D,ipm_D).ne.20) goto 190
!
        jfunc=jfunc_dpen(idpen)
        namefunc=' '
        if(jfunc.eq.-1) namefunc=namefunc_dpen(idpen)
!
        mparn=mparn_dpen(idpen)
!
        do itime=0,ntime
          itime_parn=0
          idpenS=idpen
          do iparn=1,mparn
            call get_xparn
          enddo
!
          call func_dpen
!
          if(msib_dpen(idpen).eq.0) then
            xspec(ispec_D,itime)=pmdpen
            if(itime.eq.ntime)                               &
     &      crdpen(lcrdp_dpen(idpen,iexpt))=pmdpen
            goto 180
          endif
!
! For all idpen==idpen_sib, ispec==ispec_sib store
! at selected time slice itime_parn in child variable crdpen
! at at all time slices itime in xspec(ispec,itime):
!
          if(msib_dpen(idpen).ge.1) then
            call get_xsib
          endif
!
  180     continue
        enddo
!
  190   continue
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine get_xparn
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! get parent parameter for given parent iparn  for t-dep.
! child (jctspec=20) idpenS=(ispec,ipm), itime from get_xdpen
!
      ipm=ipm_parn(iparn,idpenS)
      ispre=ispre_parn(iparn,idpenS)
      call tr_spre(ispec,ireac,ispre,nspec)
!
      if(ipm.gt.0) then
!N180810
        if(ispec.gt.0) then
          pmfunc(iparn)=cspec(ispec,ipm)
          goto 990
        endif
        if(ireac.gt.0) then
          pmfunc(iparn)=rreac(ireac,ipm)
          goto 990
        endif
      else
        if(ipm.eq.0) then
          pmfunc(iparn)=pmparn(iparn,idpenS)
          goto 990
        endif
!
        if(ipm.eq.-200) then
          itime_parn=itime
          pmfunc(iparn)=                                        &
     &    xspec(ispec,itime_parn)
          goto 990
        endif
!
        if(ipm.le.-201.and.ipm.ge.-299) then
          if(ipm.ge.-209) then
            if(ipm.le.-201.and.ipm.ge.-204) then
              itime_parn=myint(ti_parn(iparn,idpenS))
!
              if(ipm.eq.-201) itime_parn=itime-itime_parn
              if(ipm.eq.-202) itime_parn=itime+itime_parn
              if(ipm.eq.-203) itime_parn=itime_parn
            endif
!
            if(ipm.eq.-204) itime_parn=ntime
!
            if(ipm.le.-205.and.ipm.ge.-209) then
              adum1=                                              &
     &              odtime*(ti_parn(iparn,idpenS)-time0)
              itime_parn=myint(adum1)
!
              if(ipm.eq.-205) itime_parn=itime-itime_parn
              if(ipm.eq.-206) itime_parn=itime+itime_parn
              if(ipm.eq.-207) itime_parn=itime_parn
            endif
!
  100       continue
            if(itime_parn.gt.ntime) then
              itime_parn=itime_parn-(ntime+1)
              goto 100
            endif
            if(itime_parn.lt.0) then
              itime_parn=itime_parn+(ntime+1)
              goto 100
            endif
!
            pmfunc(iparn)=                                        &
     &      xspec(ispec,itime_parn)
            goto 990
          endif
!
!N180810
          if(ipm.le.-210.and.ipm.ge.-217) then
            if(ipm.eq.-210) pmfunc(iparn)=time0
            if(ipm.eq.-211) pmfunc(iparn)=time1
            if(ipm.eq.-212) pmfunc(iparn)=time_itim(itime)
            if(ipm.eq.-213) pmfunc(iparn)=time_itim(itime)-time0
            if(ipm.eq.-214) pmfunc(iparn)=time1-time_itim(itime)
            if(ipm.eq.-215) pmfunc(iparn)=time0+ti_parn(iparn,idpenS)
            if(ipm.eq.-216) pmfunc(iparn)=time1-ti_parn(iparn,idpenS)
            if(ipm.eq.-217) pmfunc(iparn)=time1-time0
            goto 990
          endif
        endif
      endif
!
!N180810
        errtag='000093.018.001'
        call err_term
  990 continue
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine get_xsib
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! if jfunc_sib=500: selected parent species conc.
!   crdpen(lcrd(idpen),iexpt)=xspec(ispec_parn,itime_parn)
!          xspec(ispec,itime)=xspec(ispec_parn,itime)
!
! if jfunc_sib=501: selected parent species net rate
!   crdpen(lcrd(idpen),iexpt)=vspec(ispec_parn,itime_parn)
!          xspec(ispec,itime)=vspec(ispec_parn,itime)
!
! if jfunc_sib=502: selected parent reaction forward rate
!   crdpen(lcrd(idpen),iexpt)=vfor(ireac_parn,itime_parn)
!          xspec(ispec,itime)=vfor(ireac_parn,itime)
!
! if jfunc_sib=503: selected parent reaction backward rate
!   crdpen(lcrd(idpen),iexpt)=vbak(ireac_parn,itime_parn)
!          xspec(ispec,itime)=vbak(ireac_parn,itime)
!
! if jfunc_sib=504: selected species net integrated flux
!   crdpen(lcrd(idpen),iexpt)=int[vspec](ispec_parn,itime_parn)
!          xspec(ispec,itime)=int[vspec](ispec_parn,itime)
! with integration by trapezoidal rule over time steps dtime
!
! if jfunc_sib=505: selected parent reaction backward integrated flux
!   crdpen(lcrd(idpen),iexpt)=int[vfor](ireac_parn,itime_parn)
!          xspec(ispec,itime)=int[vfor](ireac_parn,itime)
! with integration by trapezoidal rule over time steps dtime
!
! if jfunc_sib=506: selected parent reaction forward integrated flux
!   crdpen(lcrd(idpen),iexpt)=int[vbak](ireac_parn,itime_parn)
!          xspec(ispec,itime)=int[vbak](ireac_parn,itime)
! with integration by trapezoidal rule over time steps dtime
!
! if jfunc_sib=507: selected parent species conc. integral
!   crdpen(lcrd(idpen),iexpt)=int[xspec](ispec_parn,itime_parn)
!          xspec(ispec,itime)=int[xspec](ispec_parn,itime)
! with integration by trapezoidal rule over time steps dtime
!
! if jfunc_sib=520: selected parent species osc. period
!   crdpen(lcrd(idpen),iexpt)=period[xspec](ispec_parn)
!
! if jfunc_sib=521: selected parent species osc. amplitude
!   crdpen(lcrd(idpen),iexpt)=amplitude[xspec](ispec_parn)
!
! if jfunc_sib=522: selected parent species osc. baseline
!   crdpen(lcrd(idpen),iexpt)=base[xspec](ispec_parn)
!
! if jfunc_sib=523: selected parent species osc. phase
!   crdpen(lcrd(idpen),iexpt)=phase[xspec](ispec_parn)
!
! if jfunc_sib=524: selected parent species osc. damping time
!   crdpen(lcrd(idpen),iexpt)=tdamping[xspec](ispec_parn)
!
! if jfunc_sib=525: selected parent species osc. damping const
!   crdpen(lcrd(idpen),iexpt)=gdamping[xspec](ispec_parn)
!
! if jfunc_sib=526: check if parent species osc. amplitude found
!   crdpen(lcrd(idpen),iexpt)=0.d0(==no),1.d0(==yes)
!
! if jfunc_sib=527: check if parent species osc. baseline found
!   crdpen(lcrd(idpen),iexpt)=0.d0(==no),1.d0(==yes)
!
! if jfunc_sib=528: check if parent species osc. damping found
!   crdpen(lcrd(idpen),iexpt)=0.d0(==no),1.d0(==yes)
!
! if jfunc_sib=529: check if parent species osc. phase found
!   crdpen(lcrd(idpen),iexpt)=0.d0(==no),1.d0(==yes)
!
! if jfunc_sib=530: check if parent species osc. period found
!   crdpen(lcrd(idpen),iexpt)=0.d0(==no),1.d0(==yes)
!
!    set default for itime-storage control parameter ="on":
      jsto_itsib=1
!
      do isib=1,msib_dpen(idpen)
! corrected coding error from V080113-2219, V080116-0947:
! replace
!   jfunc-->jfunc_sib(isib,idpen)
! must use jfunc_sib(isib,idpen), _not_ jfunc==jfunc_sib(1,idpen),
! since different siblings of same family may have different jfunc_sib
        jfunc0=jfunc_sib(isib,idpen)
!
        if(                                                 &
     &  jfunc0.eq.500.or.                                   &
     &  jfunc0.eq.501.or.                                   &
     &  jfunc0.eq.502.or.                                   &
     &  jfunc0.eq.503                                       &
     &  )then
          xspec_sib(isib,itime)=                            &
     &    pmdpen_sib(isib)
        endif
!
        if(                                                 &
     &  jfunc0.eq.504.or.                                   &
     &  jfunc0.eq.505.or.                                   &
     &  jfunc0.eq.506.or.                                   &
     &  jfunc0.eq.507                                       &
     &  )then
          if(itime.eq.0)                                    &
     &    xspec_sib(isib,itime)=0.d0
!
          if(itime.ge.1)                                   &
     &    xspec_sib(isib,itime)=                           &
     &    xspec_sib(isib,itime-1)+                         &
     &    (pmdpen_sib(isib)+pmdpen_prev_sib(isib))*        &
     &    dtime_half
!
          pmdpen_prev_sib(isib)=pmdpen_sib(isib)
        endif
!
        if(jfunc0.ge.520.and.jfunc0.le.530) then
          xspec_sib(isib,itime)=                            &
     &    pmdpen_sib(isib)
        endif
!
!
!      perform itime-storage
        if(mparn_dpen(idpen_sib(isib,idpen)).ge.2) then
          idpenS=idpen_sib(isib,idpen)
          iparn=2
          call get_xparn
          jsto_itsib=pmfunc(iparn)
        endif
        if(jsto_itsib.eq.1) then
          xspec(ispec_sib(isib,idpen),itime)=               &
     &    xspec_sib(isib,itime)
        endif
!
!      perform crdpen-storage
        if(itime.eq.ntime) then
          if(jfunc0.ge.500.and.jfunc0.le.507) then
            call sto_cint
          endif
!
          if(jfunc0.ge.520.and.jfunc0.le.530) then
            itime_parn=itimeP_sib(isib,idpen)
            crdpen(lcrdp_dpen(idpen_sib(isib,idpen),iexpt))= &
     &      xspec_sib(isib,itime_parn)
          endif
        endif
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine sto_cint
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
! --------------------------------------------------------------
! pmfunc(iparn) Inputs to Rate and Integral DOSIB_-Functions:
! --------------------------------------------------------------
! This input format applies to all functions
!   DOSIB_fff and DOSIB_INTEGRAL_fff
! where
!   fff=XSPEC, VSPEC, VFOR, VBAK
!
! No. of inputs pmfunc(iparn):
!   mparn=1,2,3,4, or 5  for any isib=1,...msib
!
! pmfunc(iparn) for iparn=1,...mparn(isib) _must_ be declared
! individually for each sibling.
!
! pmfunc(1):
!   iparn=1 is used to specify name of input parent species or
!   reaction for which function value, rate, time integral
!   or time average is to be calculated
!   Must set mparn(isib)>=1 and
!     ipm_parn(1)=-203,-204 or -207 (at iparn=1) for
!   each sibling isib to specify input species or reaction name.
!   Value of  pmfunc(1) is then determined by ipm_parn(1) and
!   tiparn(1). If mparn(isib)=<2, pmfunc(1)=t_hi will
!   be used as the time t_hi to evaluate DOSIB_-function value
!   to be stored in crdpen_spec; see pmfunc(3,4,5) below.
! pmfunc(2)=jsto_itsib:
!   controls how child's DOSIB_ function value is stored,
!   in "itime-storage":
!   jsto_itsib=0: store only as single value in crdpen
!   jsto_itsib=1: store for all times "itime" in child species
!                 xspec(...,itime) and also as single value
!                 in in crdpen
!   Note: jsto_itsib must be re-set for each sibling if
!   its mparn(isib)>=2; else if mparn(isib)<2 jsto_itsib-value from
!   preceding sibling (isib-1) is used for sibling no. isib.
!   If mparn(isib)<2 for isib=1, the starting default value is
!   jsto_itsib=1 ==> itime-storage "on".
! pmfunc(3), pmfunc(4):
!   determine lower and upper limits, t_lo and t_hi, of
!   time-integration or time-averaging interval [t_lo,t_hi],
!   or input time t_hi for rate function evaluation,
!   dependent on mparn(isib). This [t_lo,t_hi] interval or t_hi
!   will only be used for the time integral or time average
!   or rate function value to be stored in crdpen_spec.
!   [For the itime-dep. value stored in child species
!   xspec(...,itime) the integration interval is [time0,t(itime)]
!   or rate eval. time is t(itime) where t(itime)=time0+itime*dtime].
!   Times t_lo, t_hi are determined as follows:
!   if mparn(isib)=<2:
!     time0=t_lo, pmfunc(1)=t_hi
!   if mparn(isib)=3:
!     time0=t_lo, pmfunc(3)=t_hi
!   if mparn(isib)>=4:
!     pmfunc(3)=t_lo, pmfunc(4)=t_hi
! pmfunc(5) = jtavg_xsib:
!   time-averaging option, for value to be stored in crdpen_spec only:
!     jtavg_xsib=0=default for mparn(isib)=<4:
!       mparn(isib)=<3: crdpen_spec =  x(t_hi)
!       mparn(isib)=4:  crdpen_spec =  x(t_hi)-x(t_lo)
!     jtavg_xsib=1:     crdpen_spec = [x(t_hi)-x(t_lo)] / (t_hi-t_lo)
!   where x(t) is either rate function value at time t (for DOSIB_fff)
!   or time integral value over interval [time0,t] (for DOSIB_INTEGRAL_fff).
!   If t is off the itime-grid, x(t) is estimated by lin. interpolation
!   from nearest grid pts.
! Note: itime-dependent value stored in child species for jsto_itsib=1
!   is always
!     xspec(...,itime) = x(t(itime))  w/  t(itime)==time0+dtime*itime
!   regardless of mparn(isib), jtavg_xsib.
!
! --------------------------------------------------------------
!
            if(mparn_dpen(idpen_sib(isib,idpen)).le.2) then
              itime_parn=itimeP_sib(isib,idpen)
              crdpen(lcrdp_dpen(idpen_sib(isib,idpen),iexpt))= &
     &        xspec_sib(isib,itime_parn)
            endif
!
            if(mparn_dpen(idpen_sib(isib,idpen)).ge.3) then
              iparn_min=3
              iparn_max=3
              if(mparn_dpen(idpen_sib(isib,idpen)).ge.4) iparn_max=4
!
              idpenS=idpen_sib(isib,idpen)
              do iparn=iparn_min,iparn_max
                call get_xparn
!
!!              time_tint=pmfunc(iparn)
                adum1=(pmfunc(iparn)-time0)/dtime
                itlo=adum1
                if(itlo.ge.ntime) itlo=ntime-1
                if(itlo.le.0)     itlo=0
                ithi=itlo+1
!
                tlo=time_itim(itlo)
                thi=time_itim(ithi)
!
                rt_tint=(pmfunc(iparn)-tlo)/(thi-tlo)
                if(rt_tint.gt.1.d0) rt_tint=1.d0
                if(rt_tint.lt.0.d0) rt_tint=0.d0
                if(pmfunc(iparn).lt.time0) rt_tint=0.d0
                if(pmfunc(iparn).gt.time1) rt_tint=1.d0
!
                xtint(iparn-iparn_min)=                    &
     &          xspec_sib(isib,itlo)                       &
     &          +(xspec_sib(isib,ithi)                     &
     &           -xspec_sib(isib,itlo))                    &
     &          *rt_tint
              enddo
              if(mparn_dpen(idpen_sib(isib,idpen)).eq.3)       &
     &        crdpen(lcrdp_dpen(idpen_sib(isib,idpen),iexpt))= &
     &        xtint(0)
!
              if(mparn_dpen(idpen_sib(isib,idpen)).ge.4)       &
     &        crdpen(lcrdp_dpen(idpen_sib(isib,idpen),iexpt))= &
     &        xtint(1)-xtint(0)
!
              if(mparn_dpen(idpen_sib(isib,idpen)).ge.5) then
                idpenS=idpen_sib(isib,idpen)
                iparn=5
                call get_xparn
                jtavg_xsib=myint(pmfunc(5))
                if(jtavg_xsib.eq.1) then
                  crdpen(lcrdp_dpen(idpen_sib(isib,idpen),iexpt))= &
     &            (xtint(1)-xtint(0))/(pmfunc(4)-pmfunc(3))
                endif
              endif
            endif
!
!
      return
      end
!
!N180810:
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine get_rdpen(time_drv,xspec_drv)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'

      real*8 time_drv
      real*8 xspec_drv(1:(nspec_x+nms_spec_x))
!
!N180810
! for dependent t-evol. model species used as reactants inside "drivs"
!     jfix(ispec)=-110, jctspec(ispec,ipm)=20
!
!
      ispec_M=0
      do idpen=1,ndpen_spec
        ispec_D=ispec_dpen(idpen)
        ipm_D=ipm_dpen(idpen)
!
        if(ispec_D.le.0) goto 90
        if(ispec_D.eq.ispec_M) goto 90
!N180810
        if(jfix(ispec_D).ne.-110) goto 90
        if(jctspec(ispec_D,ipm_D).ne.20) goto 90
!
        xspec_drv(ispec_D)=xspec_min(ispec_D)
!
        ispec_M=ispec_D
   90   continue
      enddo
!
!
      do ipriodp=1,ndpen_tot
        idpen=idpen_prio(ipriodp)
!
!N180810
        ispre_D=ispre_dpen(idpen)
        call tr_spre(ispec_D,ireac_D,ispre_D,nspec)
        if(ispec_D.le.0) goto 190
!
!N180810
        if(jfix(ispec_D).ne.-110) goto 190
!
        ipm_D=ipm_dpen(idpen)
        if(jctspre(ispre_D,ipm_D).ne.20) goto 190
!
        jfunc=jfunc_dpen(idpen)
        namefunc=' '
        if(jfunc.eq.-1) namefunc=namefunc_dpen(idpen)
!
        mparn=mparn_dpen(idpen)
!
        itime_parn=0
        idpenS=idpen
        do iparn=1,mparn
          call get_rparn(time_drv,xspec_drv)
        enddo
!
!N180810
        call func_dpen_lo
!
!N180810
        xspec_drv(ispec_D)=pmdpen
!
  190   continue
      enddo
!
!
      return
      end
!
!:N180810
!
!
!N180810:
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine get_rparn(time_drv,xspec_drv)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'

      real*8 time_drv
      real*8 xspec_drv(1:(nspec_x+nms_spec_x))
!
! get parent parameter for given parent iparn for t-dep.
! child (jctspec=20) idpenS=(ispec,ipm), from get_rdpen, in order to
! evaluate child species entering as reactant in rate fct "drivs"
!
      ipm=ipm_parn(iparn,idpenS)
      ispre=ispre_parn(iparn,idpenS)
      call tr_spre(ispec,ireac,ispre,nspec)
!
      if(ipm.gt.0) then
        if(ispec.gt.0) then
          pmfunc(iparn)=cspec(ispec,ipm)
          goto 990
        endif
        if(ireac.gt.0) then
          pmfunc(iparn)=rreac(ireac,ipm)
          goto 990
        endif
      else
        if(ipm.eq.0) then
          pmfunc(iparn)=pmparn(iparn,idpenS)
          goto 990
        endif
!
        if(ipm.eq.-200) then
          pmfunc(iparn)=xspec_drv(ispec)
          goto 990
        endif
!
        if(ipm.le.-210.and.ipm.ge.-217) then
          if(ipm.eq.-210) pmfunc(iparn)=time0
          if(ipm.eq.-211) pmfunc(iparn)=time1
          if(ipm.eq.-212) pmfunc(iparn)=time_drv
          if(ipm.eq.-213) pmfunc(iparn)=time_drv-time0
          if(ipm.eq.-214) pmfunc(iparn)=time1-time_drv
          if(ipm.eq.-215) pmfunc(iparn)=time0+ti_parn(iparn,idpenS)
          if(ipm.eq.-216) pmfunc(iparn)=time1-ti_parn(iparn,idpenS)
          if(ipm.eq.-217) pmfunc(iparn)=time1-time0
          goto 990
        endif
      endif
!
!N180810
        errtag='000093.018.003'
        call err_term
  990 continue
!
!
      return
      end
!
!:N180810
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine get_odpen
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! For dependent t-evol. exptl. output species, declared with
!   jfix(ispec_D)=-100,
!   jctspec(ispec_D,ipm_D)=30 or =40, for at least one "ipm_D".
!
! The dependent species "ispec_D" MUST also be declared as
! measured species,
!   jmsspec(ispec_D)>0,
! but MUST NOT have any exptl. data listed in "ens.i02".
!
! The exptl. data values (xspec_xpt if jctspec=30 and/or
! yspec_xpt if jctspec=40) for this species "ispec_D"
! will instead be calculated here, in "get_odpen", as dependents
! of the exptl. data values of a parent species "ispec_P, ipm_P",
! with
!   -409=< ipm_P =<400   or   -309=< ipm_P =< -300
! Other parent parameter types "ipm_P" are also allowed.
!
! Note:
! (1) "get_odpen" is called only for final output, after completion
! of all ensemble/chi^2 calculations, and (2) the the exptl. data
! values of dependent exptl. output species "ispec_D" [with
! jctspec(ispec_d,ipm_D)=30 or =40] are masked in chi^2 calculations
! prior to call of get_odpen; therefore. these dependent exptl. data
! values will NOT be included in any chi^2 calculation.
!
!
! include depedent exptl. output species storage in
! "itmx"-storage allocation
      do iexpt=1,nexpt
        do ims=1,nms_spec
          ims_P=ims_PD(ims)
          if(ims_P.gt.0) then
            itmx_ini(ims,iexpt)=itmx_ini_odp(ims,iexpt)
            itmx_fin(ims,iexpt)=itmx_fin_odp(ims,iexpt)
          endif
        enddo
      enddo
!
      do iexpt=1,nexpt
        do ims=1,nms_spec
          ims_P=ims_PD(ims)
          if(ims_P.gt.0) then
            do itxpt=1,ntxpt
              itmx_xpt(ims,itxpt,iexpt)=0
!
              if(itmx_xpt(ims_P,itxpt,iexpt).gt.0) then
                itmx_xpt(ims,itxpt,iexpt)=                              &
     &          itmx_xpt(ims_P,itxpt,iexpt)                             &
     &          -itmx_ini(ims_P,iexpt)                                  &
     &          +itmx_ini(ims,iexpt)
              endif
            enddo
          endif
        enddo
      enddo
!
! set preliminary SCF and exptl. data values
      iscal1=-1
      do iscal=1,niscal
        if(lscal_is(iscal).eq.-100) iscal1=iscal
      enddo
!
      ispec_M=0
      do idpen=1,ndpen_spec
        ispec_D=ispec_dpen(idpen)
        if(ispec_D.le.0) goto 90
        if(ispec_D.eq.ispec_M) goto 90
!N180810
        if(jfix(ispec_D).ne.-100.and.jfix(ispec_D).ne.-110) goto 90
        ims_D=ims_spec(ispec_D)
        if(ims_D.le.0) goto 90
!
        ipm_D=ipm_dpen(idpen)
!
        if(                                                             &
     &  jctspec(ispec_D,ipm_D).ne.30.and.                               &
     &  jctspec(ispec_D,ipm_D).ne.40) goto 90
!
        do iexpt=1,nexpt
          do itxpt=1,ntxpt
            if(itmx_xpt(ims_D,itxpt,iexpt).gt.0) then
              xspec_xpt(itmx_xpt(ims_D,itxpt,iexpt))=                   &
     &        xspec_min(ispec_D)
              yspec_xpt(itmx_xpt(ims_D,itxpt,iexpt))=                   &
     &        dlog(dabs(xspec_min(ispec_D)))
!
!c            yspec_wid(itmx_xpt(ims_D,itxpt,iexpt))=+1.d-6
              lscal_xpt(itmx_xpt(ims_D,itxpt,iexpt))=-100
              iscal_xpt(itmx_xpt(ims_D,itxpt,iexpt))=iscal1
            endif
          enddo
        enddo
!
        ispec_M=ispec_D
   90   continue
      enddo
!
!
      do ipriodp=1,ndpen_tot
        idpen=idpen_prio(ipriodp)
        ispec_D=ispec_dpen(idpen)
        if(ispec_D.le.0) goto 190
!N180810
        if(jfix(ispec_D).ne.-100.and.jfix(ispec_D).ne.-110) goto 190
!
        ims_D=ims_spec(ispec_D)
        if(ims_D.le.0) goto 190
!
        ispre_D=ispre_dpen(idpen)
        ipm_D=ipm_dpen(idpen)
!
        if(                                                             &
     &  jctspre(ispre_D,ipm_D).ne.30.and.                               &
     &  jctspre(ispre_D,ipm_D).ne.40) goto 190
!
        jfunc=jfunc_dpen(idpen)
        namefunc=' '
        if(jfunc.eq.-1) namefunc=namefunc_dpen(idpen)
!
        mparn=mparn_dpen(idpen)
!
        do iexpt=1,nexpt
        do itxpt=1,ntxpt
          if(itmx_xpt(ims_D,itxpt,iexpt).le.0)                          &
     &    goto 180
!
          itime=itime_xpt(itxpt)
!
          do iparn=1,mparn
            ipm_P=ipm_parn(iparn,idpen)
            ispre_P=ispre_parn(iparn,idpen)
            call tr_spre(ispec_P,ireac_P,ispre_P,nspec)
!
            if(ipm_P.gt.0) then
              idpen_P=idpen_spre(ispre_P,ipm_P)
              jctspre_P=jctspre(ispre_P,ipm_P)
              ith_P=ith_spre(ispre_P,ipm_P)
!
              ipow=1
!
              if(jctspre_P.ge.0.and.jctspre_P.lt.10) then
!               Note: ith_P>0 for jctspre_P=0,1,...9:
                if(ispec_P.gt.0) then
                  pmfunc(iparn)=ar_cspec(ith_P,ipow)
                else
                  pmfunc(iparn)=ar_rreac(ith_P,ipow)
                endif
              endif
!
              if(jctspre_P.eq.10) then
!               Note: idpen_P>0 for jctspre_P=10,20,30,40:
                pmfunc(iparn)=                                         &
     &          ar_crdpen(lcrdp_dpen(idpen_P,iexpt),ipow)
              endif
!
              if(jctspre_P.ge.100.and.jctspre_P.le.300) then
                ivpm=1
                if(jctspre_P.ge.200) ivpm=iexpt
!
                if(ispec_P.gt.0) then
                  pmfunc(iparn)=pmspec(ispec_P,ipm_P,ivpm)
                else
                  pmfunc(iparn)=pmreac(ireac_P,ipm_P,ivpm)
                endif
              endif
            else
              if(ipm_P.eq.0)                                            &
     &        pmfunc(iparn)=pmparn(iparn,idpen)
!
!
              if(ipm_P.le.-300.and.ipm_P.gt.-400) then
                if(ipm_P.ge.-309) then
                  ims=ims_spec(ispec_P)
                  if(itmx_xpt(ims,itxpt,iexpt).le.0)                    &
     &            goto 170
                  pmfunc(iparn)=                                        &
     &            xspec_xpt(itmx_xpt(ims,itxpt,iexpt))
                endif
!
                if(ipm_P.eq.-310) pmfunc(iparn)=time0
                if(ipm_P.eq.-311) pmfunc(iparn)=time1
                if(ipm_P.eq.-312) pmfunc(iparn)=time_itim(itime)
                if(ipm_P.eq.-313) pmfunc(iparn)=time_itim(itime)-time0
                if(ipm_P.eq.-314) pmfunc(iparn)=time1-time_itim(itime)
                if(ipm_P.eq.-315)                                       &
     &          pmfunc(iparn)=time0+ti_parn(iparn,idpen)
                if(ipm_P.eq.-316)                                       &
     &          pmfunc(iparn)=time1-ti_parn(iparn,idpen)
              endif
!
!
              if(ipm_P.le.-400.and.ipm_P.gt.-500) then
                if(ipm_P.ge.-409) then
                  ims=ims_spec(ispec_P)
                  if(itmx_xpt(ims,itxpt,iexpt).le.0)                    &
     &            goto 170
                  pmfunc(iparn)=                                        &
     &            yspec_xpt(itmx_xpt(ims,itxpt,iexpt))
                endif
!
                if(ipm_P.eq.-410) pmfunc(iparn)=time0
                if(ipm_P.eq.-411) pmfunc(iparn)=time1
                if(ipm_P.eq.-412) pmfunc(iparn)=time_itim(itime)
                if(ipm_P.eq.-413) pmfunc(iparn)=time_itim(itime)-time0
                if(ipm_P.eq.-414) pmfunc(iparn)=time1-time_itim(itime)
                if(ipm_P.eq.-415)                                       &
     &          pmfunc(iparn)=time0+ti_parn(iparn,idpen)
                if(ipm_P.eq.-416)                                       &
     &          pmfunc(iparn)=time1-ti_parn(iparn,idpen)
              endif
            endif
          enddo
!
          call func_dpen
!              (pmdpen,isdpen,pmfunc,mparn,jfunc,namefunc)
!
          if(jfunc.eq.-100) then
            iparn=1
            ipm_P=ipm_parn(iparn,idpen)
            ispre_P=ispre_parn(iparn,idpen)
            call tr_spre(ispec_P,ireac_P,ispre_P,nspec)
!
            iscal=-1
!
            if(ipm_P.gt.0) goto 180
!
            if(ipm_P.eq.0)                                              &
     &      iscal=pmparn(iparn,idpen)+1.d-4
!
            if(ipm_P.lt.0)                                              &
     &      iscal=                                                      &
     &      iscal_xpt(itmx_xpt(ims_spec(ispec_P),itxpt,iexpt))
!
            iscal_xpt(itmx_xpt(ims_D,itxpt,iexpt))=iscal
            if(iscal.le.0) goto 170
!
            lscal_xpt(itmx_xpt(ims_D,itxpt,iexpt))=                     &
     &      lscal_is(iscal)
            goto 180
          endif
!
          if(jctspre(ispre_D,ipm_D).eq.30)                              &
     &    xspec_xpt(itmx_xpt(ims_D,itxpt,iexpt))=                       &
     &    pmdpen
!
          if(jctspre(ispre_D,ipm_D).eq.40)                              &
     &    yspec_xpt(itmx_xpt(ims_D,itxpt,iexpt))=                       &
     &    pmdpen
!
          goto 180
!
  170   continue
          itmx_xpt(ims_D,itxpt,iexpt)=0
!c        yspec_wid(itmx_xpt(ims_D,itxpt,iexpt))=-1.d6
  180   continue
        enddo
        enddo
!
  190   continue
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine func_dpen
!                (pmdpen,pmfunc,mparn,jfunc,namefunc)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
      call func_dpen_lo
      if(jfunc.ge.500) call func_dpen_hi
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine func_dpen_lo
!                (pmdpen,pmfunc,mparn,jfunc,namefunc)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
      if(jfunc.eq.-1) then
        aline=namefunc
!
        name0='DO_SUM_LIN'
        if(eqname(aline,name0)) then
          jfunc=0
        endif
!
        name0='DO_SUM_LOG'
        if(eqname(aline,name0)) then
          jfunc=1
        endif
!
        name0='DO_SUBTRACT_LIN'
        if(eqname(aline,name0)) then
          jfunc=2
        endif
!
        name0='DO_SUBTRACT_LOG'
        if(eqname(aline,name0)) then
          jfunc=3
        endif
!
        name0='DO_PRODUCT'
        if(eqname(aline,name0)) then
          jfunc=10
        endif
!
        name0='DO_DIVIDE'
        if(eqname(aline,name0)) then
          jfunc=11
        endif
!
        name0='DO_POWER'
        if(eqname(aline,name0)) then
          jfunc=12
        endif
!
        name0='DO_ABSOLUTE'
        if(eqname(aline,name0)) then
          jfunc=13
        endif
!
        name0='DO_SUM_LOG10'
        if(eqname(aline,name0)) then
          jfunc=14
        endif
!
        name0='DO_DOT_PRODUCT'
        if(eqname(aline,name0)) then
          jfunc=30
        endif
!
        name0='DO_DOT_PRODUCT_S'
        if(eqname(aline,name0)) then
          jfunc=30
        endif
!
        name0='DO_DOT_PRODUCT_L'
        if(eqname(aline,name0)) then
          jfunc=31
        endif
!
        name0='DO_PM1*EXP_DOT_PRODUCT'
        if(eqname(aline,name0)) then
          jfunc=32
        endif
!
        name0='DO_PM1*EXP_DOT_PRODUCT_S'
        if(eqname(aline,name0)) then
          jfunc=32
        endif
!
        name0='DO_PM1*EXP_DOT_PRODUCT_L'
        if(eqname(aline,name0)) then
          jfunc=33
        endif
!
        name0='DO_EXP_SUM'
        if(eqname(aline,name0)) then
          jfunc=34
        endif
!
        name0='DO_YPOS'
        if(eqname(aline,name0)) then
          jfunc=35
        endif
!
        name0='DO_YNEG'
        if(eqname(aline,name0)) then
          jfunc=36
        endif
!
        name0='DO_MINUS'
        if(eqname(aline,name0)) then
          jfunc=37
        endif
!
!CHG190219-1941:
        name0='DO_CUTLIN'
        if(eqname(aline,name0)) then
          jfunc=38
        endif
!:CHG190219-1941
!
        name0='DO_POLYNOM((PM1-PM2)/PM3)'
        if(eqname(aline,name0)) then
          jfunc=40
        endif
!
        name0='DO_PM4*EXP_POLYNOM((PM1-PM2)/PM3)'
        if(eqname(aline,name0)) then
          jfunc=41
        endif
!
!CHG180810-0051:
        name0='DO_RATFUNC((PM1-PM2)/PM3)'
        if(eqname(aline,name0)) then
          jfunc=42
        endif
!:CHG180810-0051
!
!CHG190503-2139:
        name0='DO_HILL_REG'
        if(eqname(aline,name0)) then
          jfunc=43
        endif
!:CHG190503-2139
!
        name0='DO_GAS_REAC'
        if(eqname(aline,name0)) then
          jfunc=181
        endif
!
        name0='DO_LRIBO_L'
        if(eqname(aline,name0)) then
          jfunc=191
        endif
!
        name0='DO_LRIBO_S'
        if(eqname(aline,name0)) then
          jfunc=192
        endif
!
        name0='DO_LRIBO_L_V2'
        if(eqname(aline,name0)) then
          jfunc=193
        endif
!
        name0='DO_LRIBO_S_V2'
        if(eqname(aline,name0)) then
          jfunc=194
        endif
!
!
        name0='DO_FOURGD'
        if(eqname(aline,name0)) then
          jfunc=201
        endif
!
! this is not really needed, since these
! jfunc values are already set in set_fix_dpen
        name0='DOSIB_XSPEC'
        if(eqname(aline,name0)) then
          jfunc=500
        endif
!
        name0='DOSIB_VSPEC'
        if(eqname(aline,name0)) then
          jfunc=501
        endif
!
        name0='DOSIB_VFOR'
        if(eqname(aline,name0)) then
          jfunc=502
        endif
!
        name0='DOSIB_VBAK'
        if(eqname(aline,name0)) then
          jfunc=503
        endif
!
        name0='DOSIB_INTEGRAL_VSPEC'
        if(eqname(aline,name0)) then
          jfunc=504
        endif
!
        name0='DOSIB_INTEGRAL_VFOR'
        if(eqname(aline,name0)) then
          jfunc=505
        endif
!
        name0='DOSIB_INTEGRAL_VBAK'
        if(eqname(aline,name0)) then
          jfunc=506
        endif
!
        name0='DOSIB_INTEGRAL_XSPEC'
        if(eqname(aline,name0)) then
          jfunc=507
        endif
!
        name0='DOSIB_OSCIL_TPERIOD'
        if(eqname(aline,name0)) then
          jfunc=520
        endif
!
        name0='DOSIB_OSCIL_AMPLITUDE'
        if(eqname(aline,name0)) then
          jfunc=521
        endif
!
        name0='DOSIB_OSCIL_BASE'
        if(eqname(aline,name0)) then
          jfunc=522
        endif
!
        name0='DOSIB_OSCIL_PHASE'
        if(eqname(aline,name0)) then
          jfunc=523
        endif
!
        name0='DOSIB_OSCIL_TDAMP'
        if(eqname(aline,name0)) then
          jfunc=524
        endif
!
        name0='DOSIB_OSCIL_GDAMP'
        if(eqname(aline,name0)) then
          jfunc=525
        endif
!
        name0='DOSIB_OSCIL_FOUNDA'
        if(eqname(aline,name0)) then
          jfunc=526
        endif
!
        name0='DOSIB_OSCIL_FOUNDB'
        if(eqname(aline,name0)) then
          jfunc=527
        endif
!
        name0='DOSIB_OSCIL_FOUNDG'
        if(eqname(aline,name0)) then
          jfunc=528
        endif
!
        name0='DOSIB_OSCIL_FOUNDP'
        if(eqname(aline,name0)) then
          jfunc=529
        endif
!
        name0='DOSIB_OSCIL_FOUNDT'
        if(eqname(aline,name0)) then
          jfunc=530
        endif
!V091218:
!
        name0='DO_IMSTORE'
        if(eqname(aline,name0)) then
          jfunc=600
        endif
!
        name0='DO_FOLSOL_GENERIC'
        if(eqname(aline,name0)) then
          jfunc=610
        endif
!
        name0='DO_FOLSOL_GENEREG_MAND'
        if(eqname(aline,name0)) then
          jfunc=611
        endif
!
!! NYI:
!!      name0='DO_FOLSOL_GENEREG_AOR'
!!      if(eqname(aline,name0)) then
!!        jfunc=612
!!      endif
!
!! NYI:
!!      name0='DO_FOLSOL_GENEREG_AOR_MAND'
!!      if(eqname(aline,name0)) then
!!        jfunc=613
!!      endif
!
        name0='DO_FOLSOL_TRANSSL'
        if(eqname(aline,name0)) then
          jfunc=614
        endif
!
!! NYI:
!!      name0='DO_INTEGRAL_SUM'
!!      if(eqname(aline,name0)) then
!!        jfunc=620
!!      endif
!
!! NYI:
!!      name0='DO_INTEGRAL_PRODUCT'
!!      if(eqname(aline,name0)) then
!!        jfunc=621
!!      endif
!
!! NYI:
!!      name0='DO_INTEGRAL_DOT_PRODUCT_S'
!!      if(eqname(aline,name0)) then
!!        jfunc=622
!!      endif
!
!! NYI:
!!      name0='DO_INTEGRAL_DOT_PRODUCT_L'
!!      if(eqname(aline,name0)) then
!!        jfunc=623
!!      endif
!
!:V091218
!
        name0='LOOK4_PM_IEXPT'
        if(eqname(aline,name0)) then
          jfunc=1010
        endif
!
        name0='LOOK4_PM_ICLASS_FIX_IEXPT'
        if(eqname(aline,name0)) then
          jfunc=1012
        endif
!
        name0='LOOK4_PM_ICLASS_VAR_IEXPT'
        if(eqname(aline,name0)) then
          jfunc=1014
        endif
!
        name0='SET_SCAL'
        if(eqname(aline,name0)) then
          jfunc=-100
        endif
      endif
!
!
      if(jfunc.eq.0) then
        pmdpen=0.d0
        do iparn=1,mparn
          pmdpen=pmdpen+pmfunc(iparn)
        enddo
        goto 990
      endif
!
!
      if(jfunc.eq.1) then
        pmdpen=0.d0
        do iparn=1,mparn
          pmdpen=pmdpen+dloyy(dabs(pmfunc(iparn)),1.d-30)
        enddo
        goto 990
      endif
!
!
      if(jfunc.eq.2) then
        pmdpen=pmfunc(1)
        do iparn=2,mparn
          pmdpen=pmdpen-pmfunc(iparn)
        enddo
        goto 990
      endif
!
!
      if(jfunc.eq.3) then
        pmdpen=dloyy(dabs(pmfunc(1)),1.d-30)
        do iparn=2,mparn
          pmdpen=pmdpen-dloyy(dabs(pmfunc(iparn)),1.d-30)
        enddo
        goto 990
      endif
!
!
      if(jfunc.eq.10) then
        pmdpen=1.d0
        do iparn=1,mparn
          pmdpen=pmdpen*pmfunc(iparn)
        enddo
        goto 990
      endif
!
!
      if(jfunc.eq.11) then
        pmdpen=pmfunc(1)
        do iparn=2,mparn
          pmdpen=pmdpen/pmfunc(iparn)
        enddo
        goto 990
      endif
!
!
      if(jfunc.eq.12) then
        pmdpen=pmfunc(1)
        do iparn=2,mparn
          pmdpen=pmdpen**pmfunc(iparn)
        enddo
        goto 990
      endif
!
!
      if(jfunc.eq.13) then
        pmdpen=dabs(pmfunc(1))
        goto 990
      endif
!
      if(jfunc.eq.14) then
        pmdpen=0.d0
        do iparn=1,mparn
          if(dabs(pmfunc(iparn)).lt.1.d-30) then
            pmdpen=pmdpen-30.d0
          else
            pmdpen=pmdpen                            &
     &            +dlog(dabs(pmfunc(iparn)))         &
     &            /dlog(10.d0)
          endif
        enddo
        goto 990
      endif
!
      if(jfunc.eq.30) then
        pmdpen=0.d0
        mparnh=mparn/2
        do iparn=1,mparnh
          pmdpen=pmdpen+pmfunc(2*iparn-1)*pmfunc(2*iparn)
        enddo
        goto 990
      endif
!
!
      if(jfunc.eq.31) then
        pmdpen=0.d0
        mparnh=mparn/2
        do iparn=1,mparnh
          pmdpen=pmdpen+pmfunc(iparn)*pmfunc(iparn+mparnh)
        enddo
        goto 990
      endif
!
!
      if(jfunc.eq.32) then
        pmdpen=0.d0
        mparnh=(mparn-1)/2
        do iparn=1,mparnh
          pmdpen=pmdpen+pmfunc(2*iparn)*pmfunc(2*iparn+1)
        enddo
!c      adum2=dlog(1.d-25)
        adum2=-57.564627d0
!c      adum3=dlog(1.d+25)
        adum3=+57.564627d0
        pmdpen=dexxp(pmdpen,adum2,adum3)*pmfunc(1)
        goto 990
      endif
!
!
      if(jfunc.eq.33) then
        pmdpen=0.d0
        mparnh=(mparn-1)/2
        do iparn=1,mparnh
          pmdpen=pmdpen+pmfunc(iparn+1)*pmfunc(iparn+1+mparnh)
        enddo
!c      adum2=dlog(1.d-25)
        adum2=-57.564627d0
!c      adum3=dlog(1.d+25)
        adum3=+57.564627d0
        pmdpen=dexxp(pmdpen,adum2,adum3)*pmfunc(1)
        goto 990
      endif
!
!
      if(jfunc.eq.34) then
        pmdpen=0.d0
        do iparn=1,mparn
          pmdpen=pmdpen+pmfunc(iparn)
        enddo
!c      adum2=dlog(1.d-25)
        adum2=-57.564627d0
!c      adum3=dlog(1.d+25)
        adum3=+57.564627d0
        pmdpen=dexxp(pmdpen,adum2,adum3)
        goto 990
      endif
!
!
      if(jfunc.eq.35) then
        pmdpen=pmfunc(1)
!CORR> 181020-1414, Yue Wu
        if(pmdpen.lt.0.d0) then
          pmdpen=0.d0
        endif
!<CORR 181020-1414, Yue Wu
        goto 990
      endif
!
!
      if(jfunc.eq.36) then
        pmdpen=pmfunc(1)
!CORR> 181020-1414, Yue Wu
        if(pmdpen.gt.0.d0) then
          pmdpen=0.d0
        endif
!<CORR 181020-1414, Yue Wu
        goto 990
      endif
!
!
      if(jfunc.eq.37) then
        pmdpen=-pmfunc(1)
        goto 990
      endif
!
!
!CHG190219-1941:
      if(jfunc.eq.38) then
!       x=pmfunc(1)
!       xMax=pmfunc(2)
!       pmdpen=x if x<xMax
!       pmdpen=xMax if x>=xMax
        if(pmfunc(1).lt.pmfunc(2)) then
          pmdpen=pmfunc(1)
        else
          pmdpen=pmfunc(2)
        endif
!
        goto 990
      endif
!:CHG190219-1941
!
!
      if(jfunc.eq.40) then
!       result:
!         F(x)=M^th degree polynomial, M=mparn-4
!       where:
!
!       F(x):= a_M*s^M +... a_1*s + a_0
!       s:(x-x0)/xw
!       x:=pmfunc(1)
!       x0:=pmfunc(2)
!       xw:=pmfunc(3)
!       a_i:=pmfunc(4+i) for i=0,1,...M
!       a_0:=pmfunc(4)   for i=0
!       a_M:=pmfunc(4+M) for i=M
!           =pmfunc(mparn)
!       M:=mparn-4
!
        adum1=(pmfunc(1)-pmfunc(2))/pmfunc(3)
        pmdpen=pmfunc(mparn)
        do iparn=1,(mparn-4)
          pmdpen=pmdpen*adum1+pmfunc(mparn-iparn)
        enddo
        goto 990
      endif
!
!
      if(jfunc.eq.41) then
!       result:
!         F(x)=pre-multiplied cut-off exponential
!              of M^th degree polynomial, M=mparn-5
!       where:
!       F(x):= c*exp[ Cut(P(x)) ]
!       P(x):= a_M*s^M +... a_1*s + a_0
!       s:(x-x0)/xw
!       x:=pmfunc(1)
!       x0:=pmfunc(2)
!       xw:=pmfunc(3)
!       c:=pmfunc(4)
!       a_i:=pmfunc(5+i)    for i=0,1,...M
!       a_0:=pmfunc(5)      for i=0
!       a_M:=pmfunc(5+M)    for i=M
!           =pmfunc(mparn)
!       M:=mparn-5
!
!       Cut(p):= p if ln(1.d-25) < p < ln(1.d25)
!       Cut(p):= ln(1.d-25) if p =< ln(1.d-25)
!       Cut(p):= ln(1.d25)  if p >= ln(1.d25)
!
        adum1=(pmfunc(1)-pmfunc(2))/pmfunc(3)
        pmdpen=pmfunc(mparn)
        do iparn=1,(mparn-5)
          pmdpen=pmdpen*adum1+pmfunc(mparn-iparn)
        enddo
!c      adum2=dlog(1.d-25)
        adum2=-57.564627d0
!c      adum3=dlog(1.d+25)
        adum3=+57.564627d0
        pmdpen=dexxp(pmdpen,adum2,adum3)*pmfunc(4)
        goto 990
      endif
!
!
!CHG180810-0051:
      if(jfunc.eq.42) then
!       result:
!         F(x)=(M,N)^th degree rational fct, M+N=mparn-6
!       where:
!
!       F(x):= G(x)/H(x)
!       G(x):= a_M*s^M +... a_1*s + a_0
!       H(x):= b_N*s^N +... b_1*s + b_0
!       s:(x-x0)/xw
!       x:=pmfunc(1)
!       x0:=pmfunc(2)
!       xw:=pmfunc(3)
!       N:=pmfunc(4)
!       M=:mparn-6-N
!
!       a_i:=pmfunc(5+i)   for i=0,1,...M
!       a_0:=pmfunc(5)     for i=0
!       a_M:=pmfunc(5+M)   for i=M
!
!       b_i:=pmfunc(6+M+i) for i=0,1,...N
!       b_0:=pmfunc(6+M)   for i=0
!           =pmfunc(mparn-N)
!       b_N:=pmfunc(6+M+N) for i=N
!           =pmfunc(mparn)
!
!       store M,N in mparn, pmfunc(4)
        nratf=myint(pmfunc(4))
        mratf=mparn-nratf-6

!       store s in adum1
        adum1=(pmfunc(1)-pmfunc(2))/pmfunc(3)
!
!       store G(x) in bdum1
        bdum1=pmfunc(mratf+5)
        do iparn=1,mratf
          bdum1=bdum1*adum1+pmfunc(mratf+5-iparn)
        enddo
!
!       store H(x) in bdum2
        bdum2=pmfunc(mparn)
        do iparn=1,nratf
          bdum1=bdum1*adum1+pmfunc(mparn-iparn)
        enddo
!
        pmdpen=bdum1/bdum2
        goto 990
      endif
!:CHG180810-0051
!
!CHG190503-2139:
      if(jfunc.eq.43) then
!       Hill fctn
!       f_Hill= (c/K)^alpha/[1+(c/K)^alpha]
!       pmfunc(1)=c
!       pmfunc(2)=K
!       pmfunc(3)=alpha
!
        pmdpen=(pmfunc(2)/pmfunc(1))**pmfunc(3)
        pmdpen=1.d0/(1.d0+pmdpen)
        goto 990
      endif
!:CHG190503-2139
!
!
      if(jfunc.eq.181) then
!       Gas Reaction Coeff:
!         R=a* (T/300)**b * exp(c/T)
!       with
!         a=pmfunc(1) ->iparn=1
!         b=pmfunc(2) ->iparn=2
!        -c=pmfunc(3) ->iparn=3
!         T=pmfunc(4) ->iparn=4
!
!c      adum2=dlog(1.d-25)
        adum2=-57.564627d0
!c      adum3=dlog(1.d+25)
        adum3=+57.564627d0
!
        pmdpen=0.d0
        pmdpen=pmfunc(1)*(pmfunc(4)/300.d0)**pmfunc(2)                  &
     &        *dexxp(-pmfunc(3)/pmfunc(4),adum2,adum3)
        goto 990
      endif
!
      if(jfunc.eq.191) then
!      A_L =  exp(-Delta_a / T) /(1+r_SL)
!     where
!      r_SL= (q**al1 - q**al2) / (1 - q**al1)
!     and
!      q=1 - p_inf * exp(-Delta_p / T)
!     and
!      p_inf   =pmfunc(1)
!      T       =pmfunc(2)+273.15d0
!      Delta_p =pmfunc(3)
!      Delta_a =pmfunc(4)
!      al1     =pmfunc(5)
!      al2     =pmfunc(6)
!      A_L     =pmdpen
!
!c      adum2=dlog(1.d-25)
        adum2=-57.564627d0
!c      adum3=dlog(1.d+25)
        adum3=+57.564627d0
!
!      calculate Kelvin temp "T" from Celsius temp:
        adum1=pmfunc(2)+273.15d0
!
!      calculate "q":
        bdum1=dabs(1.d0        &
     &       -pmfunc(1)   &
     &       *dexxp(-pmfunc(3)/adum1,adum2,adum3))
!
!      calculate "r_SL":
        if(dabs(bdum1-1.d0).gt.1.d-8) then
          bdum2=dabs((bdum1**pmfunc(5)-bdum1**pmfunc(6)) &
     &         /(1.d0-bdum1**pmfunc(5)))
        else
          bdum2=dabs((bdum1**pmfunc(5))         &
     &         *(pmfunc(6)-pmfunc(5))/pmfunc(5))
        endif
!
!      calculate final function value "A_L":
        pmdpen=dexxp(-pmfunc(4)/adum1,adum2,adum3) &
     &        / (1.d0+bdum2)
        goto 990
      endif
!
!
      if(jfunc.eq.192) then
!      A_S =  r_SL * exp(-Delta_a / T) /(1+r_SL)
!     where
!      r_SL= (q**al1 - q**al2) / (1 - q**al1)
!     and
!      q=1 - p_inf * exp(-Delta_p / T)
!     and
!      p_inf   =pmfunc(1)
!      T       =pmfunc(2)+273.15d0
!      Delta_p =pmfunc(3)
!      Delta_a =pmfunc(4)
!      al1     =pmfunc(5)
!      al2     =pmfunc(6)
!      A_S     =pmdpen
!
!c      adum2=dlog(1.d-25)
        adum2=-57.564627d0
!c      adum3=dlog(1.d+25)
        adum3=+57.564627d0
!
!      calculate Kelvin temp "T" from Celsius temp:
        adum1=pmfunc(2)+273.15d0
!
!      calculate "q":
        bdum1=dabs(1.d0        &
     &       -pmfunc(1)   &
     &       *dexxp(-pmfunc(3)/adum1,adum2,adum3))
!
!      calculate "r_SL":
        if(dabs(bdum1-1.d0).gt.1.d-8) then
          bdum2=dabs((bdum1**pmfunc(5)-bdum1**pmfunc(6)) &
     &         /(1.d0-bdum1**pmfunc(5)))
        else
          bdum2=dabs((bdum1**pmfunc(5))         &
     &         *(pmfunc(6)-pmfunc(5))/pmfunc(5))
        endif
!
!      calculate final function value "A_S":
        pmdpen=bdum2         &
     &        *dexxp(-pmfunc(4)/adum1,adum2,adum3) &
     &        / (1.d0+bdum2)
        goto 990
      endif
!
      if(jfunc.eq.193) then
!      A_L =  exp(-Delta_a / T) *p_L
!     where
!      p_L= (1 - q**al1)
!     and
!      q=1 - p_inf * exp(-Delta_p / T)
!     and
!      p_inf   =pmfunc(1)
!      T       =pmfunc(2)+273.15d0
!      Delta_p =pmfunc(3)
!      Delta_a =pmfunc(4)
!      al1     =pmfunc(5)
!      al2     =pmfunc(6)
!      A_L     =pmdpen
!
!c      adum2=dlog(1.d-25)
        adum2=-57.564627d0
!c      adum3=dlog(1.d+25)
        adum3=+57.564627d0
!
!      calculate Kelvin temp "T" from Celsius temp:
        adum1=pmfunc(2)+273.15d0
!
!      calculate "q":
        bdum1=dabs(1.d0        &
     &       -pmfunc(1)   &
     &       *dexxp(-pmfunc(3)/adum1,adum2,adum3))
!
!      calculate "p_L":
          bdum2=dabs(1.d0-bdum1**pmfunc(5))
!
!      calculate final function value "A_L":
        pmdpen=dexxp(-pmfunc(4)/adum1,adum2,adum3)* bdum2
        goto 990
      endif
!
      if(jfunc.eq.194) then
!      A_S =  exp(-Delta_a / T) *p_S
!     where
!      p_S= (q**al1 - q**al2)
!     and
!      q=1 - p_inf * exp(-Delta_p / T)
!     and
!      p_inf   =pmfunc(1)
!      T       =pmfunc(2)+273.15d0
!      Delta_p =pmfunc(3)
!      Delta_a =pmfunc(4)
!      al1     =pmfunc(5)
!      al2     =pmfunc(6)
!      A_S     =pmdpen
!
!c      adum2=dlog(1.d-25)
        adum2=-57.564627d0
!c      adum3=dlog(1.d+25)
        adum3=+57.564627d0
!
!      calculate Kelvin temp "T" from Celsius temp:
        adum1=pmfunc(2)+273.15d0
!
!      calculate "q":
        bdum1=dabs(1.d0        &
     &       -pmfunc(1)   &
     &       *dexxp(-pmfunc(3)/adum1,adum2,adum3))
!
!      calculate "p_S":
          bdum2=dabs(bdum1**pmfunc(5)-bdum1**pmfunc(6))
!
!      calculate final function value "A_S":
        pmdpen=dexxp(-pmfunc(4)/adum1,adum2,adum3)* bdum2
        goto 990
      endif
!
      if(jfunc.eq.201) then
!      geneneralized damped Fourier sum
!       (mparn-1)/5=ndpfour=no. of Fourier terms to be summed
!      with
!       pmfunc(1)=time tifour
!      and for idpfour=0,...ndpfour-1:
!       pmfunc(5*idpfour+2)=amplitude amfour
!       pmfunc(5*idpfour+3)=period tpfour
!       pmfunc(5*idpfour+4)=phase phfour in period units
!       pmfunc(5*idpfour+5)=damping constant gmfour
!       pmfunc(5*idpfour+6)=constant baseline
!      where phfour must be given in period units, i.e., as fraction
!      of a period, not in degrees or radians
!
!c      adum2=dlog(1.d-25)
        adum2=-57.564627d0
!c      adum3=dlog(1.d+25)
        adum3=+57.564627d0
!
        pmdpen=0.d0
!
        ndpfour=(mparn-1)/5
        tifour=pmfunc(1)
        do idpfour=0,(ndpfour-1)
          amfour=pmfunc(idpfour*5+2)
          tpfour=pmfunc(idpfour*5+3)
          phfour=pmfunc(idpfour*5+4)
          gmfour=pmfunc(idpfour*5+5)
          blfour=pmfunc(idpfour*5+6)
!
          pmdpen=pmdpen+blfour+                             &
     &    amfour*dexxp(-gmfour*tifour,adum2,adum3)          &
     &    *dcos(pi2*(tifour/(1.d-25+dabs(tpfour))-phfour))
        enddo
        goto 990
      endif
!
!
!
      if(jfunc.ge.500.or.jfunc.eq.-100) goto 990
        errtag='000094'
        call err_term
  990 continue
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine func_dpen_hi
!                (pmdpen,pmfunc,mparn,jfunc,namefunc)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
!N180810
!Split func_dpen here:
! Move sibling depend. part with "call get_drdp_" -> "call drivs" into separate sub
! Use/call only non-sibling part for eval of dependent reactant species (jctspec=20, jfix=-110)
!
! Also: in set_fix_dpen:
!   Do error check: jfix=-110 species MUST NOT have sibling dependencies.
!   Do error check: jfix=-110 species MUST have jctspec=20, but not =30 or =40.
!
! Evaluate sibling dependencies
!
      if(                           &
     &jfunc.eq.500.or.              &
     &jfunc.eq.501.or.              &
     &jfunc.eq.502.or.              &
     &jfunc.eq.503.or.              &
     &jfunc.eq.504.or.              &
     &jfunc.eq.505.or.              &
     &jfunc.eq.506.or.              &
     &jfunc.eq.507.or.              &
     &jfunc.eq.520.or.              &
     &jfunc.eq.521.or.              &
     &jfunc.eq.522.or.              &
     &jfunc.eq.523.or.              &
     &jfunc.eq.524.or.              &
     &jfunc.eq.525.or.              &
     &jfunc.eq.526.or.              &
     &jfunc.eq.527.or.              &
     &jfunc.eq.528.or.              &
     &jfunc.eq.529.or.              &
     &jfunc.eq.530                  &
     &)then
        if(jdrdp_dpen(idpen).eq.1) then
          call get_drdp
        endif
!
        do isib=1,msib_dpen(idpen)
!
          if(                                                 &
     &    jfunc_sib(isib,idpen).eq.500.or.                    &
     &    jfunc_sib(isib,idpen).eq.501.or.                    &
     &    jfunc_sib(isib,idpen).eq.502.or.                    &
     &    jfunc_sib(isib,idpen).eq.503.or.                    &
     &    jfunc_sib(isib,idpen).eq.504.or.                    &
     &    jfunc_sib(isib,idpen).eq.505.or.                    &
     &    jfunc_sib(isib,idpen).eq.506.or.                    &
     &    jfunc_sib(isib,idpen).eq.507                        &
     &    )then
!
            if(jfunc_sib(isib,idpen).eq.500)                    &
     &      pmdpen_sib(isib)=xspec(ispreP_sib(isib,idpen),itime)
!
            if(jfunc_sib(isib,idpen).eq.501)                    &
     &      pmdpen_sib(isib)=vspec_drdp(ispreP_sib(isib,idpen))
!
            if(jfunc_sib(isib,idpen).eq.502)                    &
     &      pmdpen_sib(isib)=vfor_drdp(ispreP_sib(isib,idpen)-nspec)
!
            if(jfunc_sib(isib,idpen).eq.503)                    &
     &      pmdpen_sib(isib)=vbak_drdp(ispreP_sib(isib,idpen)-nspec)
!
            if(jfunc_sib(isib,idpen).eq.504)                    &
     &      pmdpen_sib(isib)=vspec_drdp(ispreP_sib(isib,idpen))
!
            if(jfunc_sib(isib,idpen).eq.505)                    &
     &      pmdpen_sib(isib)=vfor_drdp(ispreP_sib(isib,idpen)-nspec)
!
            if(jfunc_sib(isib,idpen).eq.506)                    &
     &      pmdpen_sib(isib)=vbak_drdp(ispreP_sib(isib,idpen)-nspec)
!
            if(jfunc_sib(isib,idpen).eq.507)                    &
     &      pmdpen_sib(isib)=xspec(ispreP_sib(isib,idpen),itime)
          endif
!
          if(                                                 &
     &    jfunc_sib(isib,idpen).eq.520.or.                    &
     &    jfunc_sib(isib,idpen).eq.521.or.                    &
     &    jfunc_sib(isib,idpen).eq.522.or.                    &
     &    jfunc_sib(isib,idpen).eq.523.or.                    &
     &    jfunc_sib(isib,idpen).eq.524.or.                    &
     &    jfunc_sib(isib,idpen).eq.525.or.                    &
     &    jfunc_sib(isib,idpen).eq.526.or.                    &
     &    jfunc_sib(isib,idpen).eq.527.or.                    &
     &    jfunc_sib(isib,idpen).eq.528.or.                    &
     &    jfunc_sib(isib,idpen).eq.529.or.                    &
     &    jfunc_sib(isib,idpen).eq.530                        &
     &    )then
!
            if(itime.eq.ntime) then
              call get_oscil
!
              if(jfunc_sib(isib,idpen).eq.520)                    &
     &        pmdpen_sib(isib)=oscil_tper
!
              if(jfunc_sib(isib,idpen).eq.521)                    &
     &        pmdpen_sib(isib)=oscil_ampl
!
              if(jfunc_sib(isib,idpen).eq.522)                    &
     &        pmdpen_sib(isib)=oscil_base
!
              if(jfunc_sib(isib,idpen).eq.523)                    &
     &        pmdpen_sib(isib)=oscil_phase
!
              if(jfunc_sib(isib,idpen).eq.524)                    &
     &        pmdpen_sib(isib)=oscil_tdamp
!
              if(jfunc_sib(isib,idpen).eq.525)                    &
     &        pmdpen_sib(isib)=oscil_gdamp
!
              if(jfunc_sib(isib,idpen).eq.526)                    &
     &        pmdpen_sib(isib)=oscil_founda
!
              if(jfunc_sib(isib,idpen).eq.527)                    &
     &        pmdpen_sib(isib)=oscil_foundb
!
              if(jfunc_sib(isib,idpen).eq.528)                    &
     &        pmdpen_sib(isib)=oscil_foundg
!
              if(jfunc_sib(isib,idpen).eq.529)                    &
     &        pmdpen_sib(isib)=oscil_foundp
!
              if(jfunc_sib(isib,idpen).eq.530)                    &
     &        pmdpen_sib(isib)=oscil_foundt
            endif
          endif
        enddo
!
        goto 990
      endif
!
!
!V091218:
      if(jfunc.eq.600) then
        pmdpen=0.d0
        goto 990
      endif
!
!
      if(jfunc.eq.610) then
!
! General purpose first-order linear (FOL) ODE solver:
!   dY/dt = -QY +P
! solved by:
!   Y(t) = Y(T_0)exp[-R(t)] + S(t)
!   R(t) =\int_{T_0}^t dt' Q(t')
!   S(t) =\int_{T_0}^t dt' P(t')exp[R(t')-R(t)]
!
!   Num. R- and S-integral evaluation in "get_folsol":
!   Default: trapezoidal rule with dtime-interval being
!   subdivided into N_intfol ddtime-intervals
!     ddtime = dtime / N_intfol = (T_1-T_0)/(N_time*N_intfol)
!   Other num. integration options: not yet implemented (NYI)
!
!  Set in "get_folsol":
!   Option parameters:
!     jfol_opt1=pmfunc(1), void(NYI), set=0
!     jfol_opt2=pmfunc(2), void(NYI), set=0
!   No. of ddtime integration sub-intervals:
!     nintfol=pmfunc(3)
!
!  Set here (in "func_dpen"):
!   Initial value of Y:
!     yfol0=pmfunc(4)==Y(T_0)
!   P- and Q-species at time t_f:=itime*dtime:
!     pfol_f=pmfunc(5)==xspec(ispec_PFOL,itime)==P(t_f)
!     qfol_f=pmfunc(6)==xspec(ispec_QFOL,itime)==Q(t_f)
!
        if(itime.eq.0) then
          yfol0=pmfunc(4)
        endif
!
        pfol_f=pmfunc(5)
        qfol_f=pmfunc(6)
!
        call get_folsol
        goto 990
      endif
!
!
      if(jfunc.eq.611) then
!
! Gene activation first-order linear (FOL) ODE solver:
!   dY/dt = -QY +P
! for Multiplicative-AND (MAND) activation-deactivation module:
!   G_0 + Ac --> G_1 + Ac    (activation)
!   G_1 + Bc --> G_0 + Bc    (deactivation)
! where
!   Y(t)==G_0(t)=G_t-G_1(t)==off-gene conc.
!   G_t=tot. gene conc.
!   G_t=G_0(t)+G_1(t)=const. ;
! and
!   Ac == Ma_1*A_1 + ... +Ma_{Na}*A_{Na}
! is the AND activation complex with Na activators A_i
! of coop. Ma_i (i=1,...Na) and activation rate coeff. A_0; and
!   Bc == Mb_1*B_1 + ... +Mb_{Nb}*B_{Nb}
! is the AND deactivation complex with Nb deactivators B_i
! of coop. Mb_i (i=1,...Nb) and deactivation rate coeff. B_0; and
!   P=BG_t
!   Q=A+B
! with "MAND" logic:
!   A=A_0*(A_1)^(Ma_1)*...(A_{Na})^(Ma_{Na})
!   B=B_0*(B_1)^(Mb_1)*...(B_{Nb})^(Mb_{Nb})
!
! Module is solved by:
!   Y(t) = Y(T_0)exp[-R(t)] + S(t)
!   R(t) =\int_{T_0}^t dt' Q(t')
!   S(t) =\int_{T_0}^t dt' P(t')exp[R(t')-R(t)]
!
!   Num. R- and S-integral evaluation in "get_folsol":
!   Default: trapezoidal rule with dtime-interval being
!   subdivided into N_intfol ddtime-intervals
!     ddtime = dtime / N_intfol = (T_1-T_0)/(N_time*N_intfol)
!   Other num. integration options: not yet implemented (NYI)
!
!  Set in "get_folsol":
!   Option parameters:
!     jfol_opt1=pmfunc(1), void(NYI), set=0
!     jfol_opt2=pmfunc(2), void(NYI), set=0
!   No. of ddtime integration sub-intervals:
!     nintfol=pmfunc(3)
!
!  Set here (in "func_dpen"):
!   Initial value of total gene conc G_t:
!     yfolt=pmfunc(4)==G_t==G_0(T_0)+G_1(T_0)
!   Initial value of off-gene fraction G_0(T_0)/G_t:
!     yfol0/yfolt=pmfunc(5)==G_0(T_0)/G_t
!   Initial value of G_0:
!     yfol0=pmfunc(4)*pmfunc(5)==G_0(T_0)
!   No. of A- and B-regulator species:
!     nagene=pmfunc(6)==Na
!     nbgene=pmfunc(7)==Nb
!   A- and B-rate coeffs:
!     agene0=pmfunc(8)==A_0
!     bgene0=pmfunc(9)==B_0
!   A- and B-species and coop. exponents at time t_f:=itime*dtime:
!     A_1=pmfunc(9+1),        Ma_1=pmfunc(9+2)
!     ...
!     A_{Na}=pmfunc(9+2Na-1), Ma_{Na}=pmfunc(9+2Na)
!
!     B_1=pmfunc(9+2Na+1),        Mb_1=pmfunc(9+2Na+2)
!     ...
!     B_{Nb}=pmfunc(9+2Na+2Nb-1), Mb_{Nb}=pmfunc(9+2Na+2Nb)
!
        if(itime.eq.0) then
          yfolt=pmfunc(4)
          yfol0=yfolt*pmfunc(5)
!
          nagene=myint(pmfunc(6))
          nbgene=myint(pmfunc(7))
        endif
!
        agene=pmfunc(8)
        bgene=pmfunc(9)
!
        iparn=10
!
        do igene=1,nagene
          agene=agene*(dabs(pmfunc(iparn))**pmfunc(iparn+1))
          iparn=iparn+2
        enddo
!
        do igene=1,nbgene
          bgene=bgene*(pmfunc(iparn)**pmfunc(iparn+1))
          iparn=iparn+2
        enddo
!
        iparn=iparn-1
        if(iparn.ne.mparn) then
          errtag='000093.019'
          call err_term
        endif
!
        pfol_f=bgene*yfolt
        qfol_f=agene+bgene
!
        call get_folsol
        goto 990
      endif
!
!
      if(jfunc.eq.614) then
!
! Transcription/Translation (S/L) first-order linear (FOL) ODE solver:
!   dY/dt = -QY +P
! for Additive-OR (AOR) S/L module:
!   P_i --> Y + P_i    (S/L-production by agent P_i, i=1,...Np)
!   Y + Q_i --> Q_i    (degradation by agent Q_i, i=1,...Nq)
! where
!   Y==S/L product==RNA for S; protein for L
!   P_i==production agents==gene states for S, RNA states for L
!   Q_i==degradation agents
! with
!  Kp_i==production rate coeffs, i=1,...Np;
!  Kq_i==degradation rate coeffs, i=1,...Nq;
! and "AOR" logic:
!   P=Kp_1*P_1 + ... +K_{Np}*P_{Np}
!   Q=Kq_1*Q_1 + ... +K_{Nq}*Q_{Nq}
!
! Module is solved by:
!   Y(t) = Y(T_0)exp[-R(t)] + S(t)
!   R(t) =\int_{T_0}^t dt' Q(t')
!   S(t) =\int_{T_0}^t dt' P(t')exp[R(t')-R(t)]
!
!   Num. R- and S-integral evaluation in "get_folsol":
!   Default: trapezoidal rule with dtime-interval being
!   subdivided into N_intfol ddtime-intervals
!     ddtime = dtime / N_intfol = (T_1-T_0)/(N_time*N_intfol)
!   Other num. integration options: not yet implemented (NYI)
!
!  Set in "get_folsol":
!   Option parameters:
!     jfol_opt1=pmfunc(1), void(NYI), set=0
!     jfol_opt2=pmfunc(2), void(NYI), set=0
!   No. of ddtime integration sub-intervals:
!     nintfol=pmfunc(3)
!
!  Set here (in "func_dpen"):
!   Initial value of S/L product:
!     yfol0=pmfunc(4)==Y(T_0)
!   No. of producer (P_i)- and degrader (Q_i-) species:
!     npprod=pmfunc(5)==Np
!     nqdegr=pmfunc(6)==Nq
!   P- and Q-species and rate coeffs. at time t_f:=itime*dtime:
!     P_1=pmfunc(6+1),        Kp_1=pmfunc(6+2)
!     ...
!     P_{Np}=pmfunc(6+2Np-1), Kp_{Np}=pmfunc(6+2Np)
!
!     Q_1=pmfunc(6+2Np+1),        Kq_1=pmfunc(6+2Np+2)
!     ...
!     Q_{Nq}=pmfunc(6+2Np+2Nq-1), Kq_{Nq}=pmfunc(6+2Np+2Nq)
!
!
        if(itime.eq.0) then
          yfol0=pmfunc(4)
!
          npprod=myint(pmfunc(5))
          nqdegr=myint(pmfunc(6))
        endif
!
        iparn=7
!
        pfol_f=0.d0
        do igene=1,npprod
          pfol_f=pfol_f+(pmfunc(iparn)*pmfunc(iparn+1))
          iparn=iparn+2
        enddo
!
        qfol_f=0.d0
        do igene=1,nqdegr
          qfol_f=qfol_f+(pmfunc(iparn)*pmfunc(iparn+1))
          iparn=iparn+2
        enddo
!
        call get_folsol
        goto 990
      endif
!
!:V091218
!
!
      if(jfunc.eq.1010) then
        nclass=mparn
        iclass=iexpt
 1010   continue
        if(iclass.gt.nclass) then
          iclass=iclass-nclass
          goto 1010
        endif
        pmdpen=pmfunc(iclass)
        goto 990
      endif
!
      if(jfunc.eq.1012) then
        nclass=mparn-1
        mclass=myint(pmfunc(mparn))
!
        iclass=(iexpt-1)/mclass
        iclass=iclass+1
 1012   continue
        if(iclass.gt.nclass) then
          iclass=iclass-nclass
          goto 1012
        endif
        pmdpen=pmfunc(iclass)
        goto 990
      endif
!
      if(jfunc.eq.1014) then
        nclass=mparn/2
        idum2=0
 1014   continue
        do iclass=1,nclass
          adum2=idum2+pmfunc(2*iclass-1)
          idum2=myint(adum2)
          if(idum2.ge.iexpt) goto 1015
        enddo
        goto 1014
 1015   continue
        pmdpen=pmfunc(2*iclass)
        goto 990
      endif
!
      if(jfunc.eq.-100) goto 990
            errtag='000094'
            call err_term
  990 continue
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine get_drdp
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! calculates rate function
! for storage as t-evol. dependent by func_dpen
!
          time_xr=time_itim(itime)
          do ispec_drdp=1,nspec
            xspec_itim(ispec_drdp)=xspec(ispec_drdp,itime)
          enddo
!
! Note that xspec_i, time_i_fs are not needed as inputs
! to drivs when jtime=1,2, since all species conc. are
! evaluated _only_ "on-grid", i.e. for times time_itim(itime).
! For these "on-grid" times, all fixed-spec concs. (jfix>0) are
! already stored in xspec, by "fix_spec" being called in "kin_ini".
!
          call drivs(time_xr,xspec_itim,vspec_drdp                      &
!
     &              ,time_i_fs,xspec_i                                  &
     &              ,vfor_drdp,vbak_drdp,xspec_min,xspec_max            &
     &              ,yspec_min_vs,yspec_max_vs                          &
     &              ,wspec_vs_min,wspec_vs_max                          &
     &              ,frlim_vs_min,frlim_vs_max                          &
     &              ,rkfor,rkbak,rkfor2,rkbak2                          &
     &              ,odtime,jkin,jrlim                                  &
     &              ,lvfor,lvbak,lvreac                                 &
     &              ,iispec,iospec,nipart,nopart                        &
     &              ,hicoop,hocoop                                      &
     &              ,iispec_vs,iospec_vs,nipart_vs,nopart_vs            &
     &              ,gimult_vs,gomult_vs,iivs_vs,iovs_vs                &
     &              ,nspec,nreac,nfs_spec0,nvs_spec                     &
     &              ,ispec_fs,ispec_vs,nlim_drv,n_drv,k_drv             &
     &              ,jtime_drdp,jfox_drdp,jfix,npulse,nperiod           &
     &              ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod      &
     &              ,npmspec_y                                          &
     &              ,nspec_y,nreac_y,npart_y,ntime_y,nms_spec_y)
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine get_oscil
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! find period, phase and amplitude of oscillatory concentration
! within specified time window
!
! --------------------------------------------------------------
! pmfunc(iparn) Inputs to Oscil. Analyzer DOSIB_-Functions:
! --------------------------------------------------------------
! This input format applies to all functions
!   DOSIB_OSCIL_fff
! where
!   fff= TPERIOD, AMPLITUDE, BASE, PHASE, TDAMP, GDAMP,
!        FOUNDA, FOUNDB, FOUNDG, FOUNDP, FOUNDT
!
! No. of inputs pmfunc(iparn):
!   mparn= 13       for isib=1
!   mparn= 1 or 2   for isib>=2
!
! pmfunc(1) _must_ be declared individually for each sibling;
! pmfunc(2) _can_ be, but is not required to be declared
! individually for each sibling (see below).
!
! pmfunc(iparn) for iparn=3,4,...13 must be declared for first-born
! sibling (isib=1) only; same values will then be applied for _all_
! siblings (isib=1,...msib) in same family having oscil. analyzer
! functions; isib=1 _must_ have oscil. analyzer function in order
! to declare pmfunc(3),...pmfunc(13).
!
! pmfunc(1):
!   pmfunc(1)-value not used; iparn=1 is used only to specify
!   name of oscillating input parent species, ==ispec_osc, for
!   which osc. parameters (period, amplitude, ...) are to be
!   determined.
!   Must set mparn>=1 and
!     ipm_parn(iparn)=-203,-204 or -207 for iparn=1 and all siblings
!   isib to specify input species name for each sibling; and must set
!     mparn>=13 for firstborn (==lowest jprio) sibling (isib=1)
!   to specify the (at least) 13 control parameters for calc. of
!   osc. variables, to be used for all siblings
! pmfunc(2)=jsto_itsib:
!   controls how child's DOSIB_ function value is stored,
!   in "itime-storage":
!   jsto_itsib=0: store only as single value in crdpen
!   jsto_itsib=1: store for all times "itime" in child species
!                 xspec(...,itime) and also as single value
!                 in in crdpen
!   Note: jsto_itsib must be re-set for each sibling if
!   its mparn(isib)>=2; else if mparn(isib)<2 jsto_itsib-value from
!   preceding sibling (isib-1) is used for sibling no. isib.
!   If mparn(isib)<2 for isib=1, the starting default value is
!   jsto_itsib=1 ==> itime-storage "on".
! pmfunc(3):
!   determines lo-boundary tosc_wlo for osc. window,
!   together with josc_twlo==pmfunc(7), see below
! pmfunc(4):
!   determines hi-boundary tosc_whi for osc. window,
!   together with josc_twhi==pmfunc(8), see below
! pmfunc(5)=tosc_phzero:
!   determines zero-phase time tosc_phzero: phase is measured
!   as time difference between 1st osc. max. and tosc_phzero;
!   therefore, phase is zero if 1st osc. max. coincides with tosc_phzero
! pmfunc(6)=josc_find:
!   osc. finder option; currently only josc_find=1 allowed
! pmfunc(7)=josc_twlo:
!   osc. window lo-boundary option, see below
! pmfunc(8)=josc_twhi:
!   osc. window hi-boundary option, see below
! pmfunc(9)=josc_tper:
!   period finder option, see below for josc_tper=1,2,3,4,5
! pmfunc(10)=kosc_hper:
!   number of half-periods (=min-max or max-min intervals)
!   to be included in period, baseline, amplitude or
!   damping calculations; must set kosc_hper>=2 and integer;
!   is used to limit half-period number only if total number
!   of osc. extrema in osc. window, kosc_xtr+1, exceeds kosc_hper
!   and then only if josc_tper>=2 or josc_tdamp0>=2 (see below)
! pmfunc(11)=josc_tdamp=josc_tdamp0+100*josc_tdamp1:
!   phase finder option, see below for josc_tdamp0=0,1,2,3,4,5
!   and josc_tdamp1=0,1,2
! pmfunc(12)=josc_phas:
!   phase finder option, see below for josc_phas=1,2,3,4
! pmfunc(13)=josc_ampl:
!   amplitude finder option, see below for josc_ampl=1,2,3,4,5
!
! --------------------------------------------------------------
!
      if(isib.gt.1) then
        if(                                                      &
     &  ispreP_sib(isib,idpen).eq.ispreP_sib(isib-1,idpen)       &
     &  )then
          if(                                                   &
     &    jfunc_sib(isib-1,idpen).eq.520.or.                    &
     &    jfunc_sib(isib-1,idpen).eq.521.or.                    &
     &    jfunc_sib(isib-1,idpen).eq.522.or.                    &
     &    jfunc_sib(isib-1,idpen).eq.523.or.                    &
     &    jfunc_sib(isib-1,idpen).eq.524.or.                    &
     &    jfunc_sib(isib-1,idpen).eq.525.or.                    &
     &    jfunc_sib(isib-1,idpen).eq.526.or.                    &
     &    jfunc_sib(isib-1,idpen).eq.527.or.                    &
     &    jfunc_sib(isib-1,idpen).eq.528.or.                    &
     &    jfunc_sib(isib-1,idpen).eq.529.or.                    &
     &    jfunc_sib(isib-1,idpen).eq.530                        &
     &    )then
            return
          endif
        endif
      endif
!
! set default output values, if no full period can be found
      oscil_tper=-1.d0
      oscil_phase=0.d0
!
      oscil_tdamp=-1.d0
      oscil_gdamp=-1.d0
!
      oscil_ampl=-1.d0
      oscil_base=0.d0
      josc_dbase=-1
!
      oscil_founda=0.d0
      oscil_foundb=0.d0
      oscil_foundg=0.d0
      oscil_foundp=0.d0
      oscil_foundt=0.d0
!
!
      ispec_osc=ispreP_sib(isib,idpen)
!
      tosc_phzero=pmfunc(5)
!
      josc_find=myint(pmfunc(6))
      josc_twlo=myint(pmfunc(7))
      josc_twhi=myint(pmfunc(8))
!
      josc_tper=myint(pmfunc(9))
      kosc_hper=myint(pmfunc(10))
      if(kosc_hper.gt.kosc_hper_x) kosc_hper=kosc_hper_x
!
      josc_tdamp=myint(pmfunc(11))
      josc_phas=myint(pmfunc(12))
      josc_ampl=myint(pmfunc(13))
!
!
      if(josc_find.eq.1) then
        if(josc_twlo.eq.1) then
          tosc_wlo=pmfunc(3)
        endif
        if(josc_twlo.eq.2) then
          tosc_wlo=time0+pmfunc(3)
        endif
        if(josc_twlo.eq.3) then
          tosc_wlo=time0+dtime*pmfunc(3)
        endif
!
        if(josc_twhi.eq.1) then
          tosc_whi=pmfunc(4)
        endif
        if(josc_twhi.eq.2) then
          tosc_whi=time0+pmfunc(4)
        endif
        if(josc_twhi.eq.3) then
          tosc_whi=time0+dtime*pmfunc(4)
        endif
!
        itosc_wlo=(tosc_wlo-time0-1.d-6*dtime)/dtime
        itosc_whi=(tosc_whi-time0+1.d-6*dtime)/dtime
        itosc_whi=itosc_whi+1
        if(itosc_wlo.le.0) itosc_wlo=1
        if(itosc_whi.ge.ntime) itosc_whi=ntime-1
!
! count and tabulate extrema
        josc_udamp=0
        call get_oscxtr
        if(kosc_xtr.gt.kosc_hper_x) kosc_xtr=kosc_hper_x
        if(kosc_xtr.le.0) goto 990
!
! find period, baseline, phase, 1/e-damping time or -damping rate coeff.
! and amplitude.
!
! calculate period as...
!      ...2*avg. of all half-periods found in time window
        if(josc_tper.eq.1) then
          kosc_ini=0
          kosc_fin=kosc_xtr
          akosc=kosc_xtr
        endif
!
!      ...2*avg. of first "kosc_hper" half periods found in time window,
!      starting from first osc. maximum
        if(josc_tper.eq.2) then
          kosc_ini=josc_xtr(0)-1
          kosc_fin=kosc_hper+kosc_ini
          if(kosc_fin.gt.kosc_xtr) goto 990
          akosc=kosc_hper
        endif
!
!      ...2*avg. of first "kosc_hper" half periods found in time window,
!      starting from first osc. minimum
        if(josc_tper.eq.3) then
          kosc_ini=2-josc_xtr(0)
          kosc_fin=kosc_hper+kosc_ini
          if(kosc_fin.gt.kosc_xtr) goto 990
          akosc=kosc_hper
        endif
!
!      ...2*avg. of last "kosc_hper" half periods found in time window,
!      ending with last osc. maximum
        if(josc_tper.eq.4) then
          kosc_fin=kosc_xtr-(josc_xtr(kosc_xtr)-1)
          kosc_ini=-kosc_hper+kosc_fin
          if(kosc_ini.lt.0) goto 990
          akosc=kosc_hper
        endif
!
!      ...2*avg. of last "kosc_hper" half periods found in time window,
!      ending with last osc. minimum
        if(josc_tper.eq.5) then
          kosc_fin=kosc_xtr-(2-josc_xtr(kosc_xtr))
          kosc_ini=-kosc_hper+kosc_fin
          if(kosc_ini.lt.0) goto 990
          akosc=kosc_hper
        endif
!
        oscil_tper=2.d0*(tosc_xtr(kosc_fin)-tosc_xtr(kosc_ini))/akosc
        oscil_foundt=1.d0
!
! calculate baseline assuming undamped oscillations
        buosc=0.d0
        do kosc=(kosc_ini+1),kosc_fin
          buosc=buosc+0.5d0*(xosc_xtr(kosc-1)+xosc_xtr(kosc  ))
        enddo
        buosc=buosc/(1.d-20+kosc_fin-kosc_ini)
        josc_dbase=0
!
! calculate damping rate constant and damping time from
! mean of subsequent extremal-x osc. log-ratios ...
!
!     ...setting damping rate to almost zero, damping time almost infinite
        oscil_tdamp=1.d6*oscil_tper
        oscil_gdamp=1.d0/oscil_tdamp
!
        if(kosc_xtr.lt.2.or.josc_tdamp.eq.0) then
          goto 390
        endif
!
        epsxosc=1.d-20*(                                       &
     &  dabs(xosc_xtr(0))+dabs(xosc_xtr(1))+dabs(xosc_xtr(2))  &
     &  )
        epstosc=1.d-6*dabs(oscil_tper)
        epsgosc=1.d-6/dabs(oscil_tper)
!
        josc_tdamp0=josc_tdamp
        josc_tdamp1=0
        if(josc_tdamp.gt.100) then
          josc_tdamp0=josc_tdamp-100
          josc_tdamp1=1
        endif
        if(josc_tdamp.gt.200) then
          josc_tdamp0=josc_tdamp-200
          josc_tdamp1=2
        endif
!
!      ...avg'ed over all half periods found in time window
        if(josc_tdamp0.eq.1) then
          kosc_ini=2
          kosc_fin=kosc_xtr
          goto 310
        endif
!
!      ...avg'ed over first "kosc_hper" half periods found in time window,
!      starting from first osc. maximum
        if(josc_tdamp0.eq.2) then
          kosc_ini=2+(josc_xtr(0)-1)
          kosc_fin=kosc_hper+kosc_ini
          if(kosc_fin.gt.kosc_xtr) goto 390
          goto 310
        endif
!
!      ...avg'ed over first "kosc_hper" half periods found in time window,
!      starting from first osc. minimum
        if(josc_tdamp0.eq.3) then
          kosc_ini=2+(2-josc_xtr(0))
          kosc_fin=kosc_hper+kosc_ini
          if(kosc_fin.gt.kosc_xtr) goto 390
          goto 310
        endif
!
!      ...avg'ed over last "kosc_hper" half periods found in time window,
!      ending with last osc. maximum
        if(josc_tdamp0.eq.4) then
          kosc_fin=kosc_xtr-(josc_xtr(kosc_xtr)-1)
          kosc_ini=-kosc_hper+kosc_fin
          if(kosc_ini.lt.2) goto 390
          goto 310
        endif
!
!      ...avg'ed over last "kosc_hper" half periods found in time window,
!      ending with last osc. minimum
        if(josc_tdamp0.eq.5) then
          kosc_fin=kosc_xtr-(2-josc_xtr(kosc_xtr))
          kosc_ini=-kosc_hper+kosc_fin
          if(kosc_ini.lt.2) goto 390
          goto 310
        endif
!
  310   continue
!
        bdosc=0.d0
        eosclg=0.d0
        eosc0=0.d0
        eosc1=0.d0
        do kosc=kosc_ini,kosc_fin
          dxosc0=dabs(xosc_xtr(kosc-2)-xosc_xtr(kosc-1))
          dxosc1=dabs(xosc_xtr(kosc-1)-xosc_xtr(kosc  ))
!
          sxosc0=0.5d0*(xosc_xtr(kosc-2)+xosc_xtr(kosc-1))
          sxosc1=0.5d0*(xosc_xtr(kosc-1)+xosc_xtr(kosc  ))
!
          rosc=(epsxosc+dxosc0)/(epsxosc+dxosc1)
          bdosc=bdosc+sxosc1-(sxosc1-sxosc0)/(1.d0+rosc)
!
          rosclg=dlog(rosc)
          gosclg=2.d0*rosclg/(tosc_xtr(kosc)-tosc_xtr(kosc-2))
!
          if(josc_tdamp1.eq.0) then
            eosclg=eosclg+gosclg
          endif
!
          if(josc_tdamp1.eq.1) then
            eosclg=eosclg+rosclg
          endif
!
          if(josc_tdamp1.eq.2) then
            eosc0=eosc0+dxosc0
            eosc1=eosc1+dxosc1
          endif
        enddo
!
        if(josc_tdamp1.eq.0) then
          oscil_gdamp=eosclg/(1.d0+kosc_fin-kosc_ini)
          oscil_foundg=1.d0
        endif
!
        if(josc_tdamp1.eq.1) then
          oscil_gdamp=2.d0*eosclg/((1.d0+kosc_fin-kosc_ini)*oscil_tper)
          oscil_foundg=1.d0
        endif
!
        if(josc_tdamp1.eq.2) then
          oscil_tdamp=                                                       &
     &    2.d0*dlog((epsxosc+eosc0)/(epsxosc+eosc1))/oscil_tper
          oscil_foundg=1.d0
        endif
!
        if(dabs(oscil_gdamp).gt.epsgosc) then
          oscil_tdamp=1.d0/oscil_gdamp
        else
          oscil_tdamp=1.d6*oscil_tper
          oscil_gdamp=1.d0/oscil_tdamp
        endif
!
        bdosc=bdosc/(1.d0+kosc_fin-kosc_ini)
        josc_dbase=1
  390   continue
!
! set oscillation baseline, assuming either damped, if damping
! was found and calculated, or else, assuming undamped oscillation
!
        if(josc_dbase.eq.0) then
          oscil_base=buosc
          oscil_foundb=1.d0
        endif
        if(josc_dbase.eq.1) then
          oscil_base=bdosc
          oscil_foundb=1.d0
        endif
!
! find and tabulate undamped extrema of xspec(ispec_osc)
        josc_udamp=1
        call get_oscxtr
        if(kosc_xtr.gt.kosc_hper_x) kosc_xtr=kosc_hper_x
        if(kosc_xtr.le.0) goto 490
!
! calculate phase as time of earliest damping-corrected osc. max.,
! measured from zero-phase time tosc_phzero...
!      ...in period units, i.e., as fraction of a full period
        if(josc_phas.eq.1) then
          oscil_phase=(tosc_xtr(josc_xtr(0)-1)-tosc_phzero)/oscil_tper
          oscil_foundp=1.d0
        endif
!
!      ...in time units
        if(josc_phas.eq.2) then
          oscil_phase=tosc_xtr(josc_xtr(0)-1)-tosc_phzero
          oscil_foundp=1.d0
        endif
!
!      ...in radians, i.e., as fraction of full 2*pi phase angle
        if(josc_phas.eq.3) then
          oscil_phase=pi2*(tosc_xtr(josc_xtr(0)-1)-tosc_phzero)/oscil_tper
          oscil_foundp=1.d0
        endif
!
!      ...in degrees, i.e., as fraction of full 360^o phase angle
        if(josc_phas.eq.4) then
          oscil_phase=360.d0*(tosc_xtr(josc_xtr(0)-1)-tosc_phzero)/oscil_tper
          oscil_foundp=1.d0
        endif
!
!
! calculate amplitude as half max-min difference of a half-period
!      ...avg'ed over all half-periods found in time window
        if(josc_ampl.eq.1) then
          kosc_ini=0
          kosc_fin=kosc_xtr
        endif
!
!      ...avg'ed over first "kosc_hper" half periods found in time window,
!      starting from first osc. maximum
        if(josc_ampl.eq.2) then
          kosc_ini=josc_xtr(0)-1
          kosc_fin=kosc_hper+kosc_ini
          if(kosc_fin.gt.kosc_xtr) goto 490
        endif
!
!      ...avg'ed over first "kosc_hper" half periods found in time window,
!      starting from first osc. minimum
        if(josc_ampl.eq.3) then
          kosc_ini=2-josc_xtr(0)
          kosc_fin=kosc_hper+kosc_ini
          if(kosc_fin.gt.kosc_xtr) goto 490
        endif
!
!      ...avg'ed over last "kosc_hper" half periods found in time window,
!      ending with last osc. maximum
        if(josc_ampl.eq.4) then
          kosc_fin=kosc_xtr-(josc_xtr(kosc_xtr)-1)
          kosc_ini=-kosc_hper+kosc_fin
          if(kosc_ini.lt.0) goto 490
        endif
!
!      ...avg'ed over last "kosc_hper" half periods found in time window,
!      ending with last osc. minimum
        if(josc_ampl.eq.5) then
          kosc_fin=kosc_xtr-(2-josc_xtr(kosc_xtr))
          kosc_ini=-kosc_hper+kosc_fin
          if(kosc_ini.lt.0) goto 490
        endif
!
        aosc=0.d0
        do kosc=(kosc_ini+1),kosc_fin
          aosc=aosc                                             &
     &        +0.5d0*(xosc_xtr(kosc-1)-xosc_xtr(kosc  ))        &
     &              *(2*josc_xtr(kosc)-3)
        enddo
        oscil_ampl=aosc/(1.d-25+kosc_fin-kosc_ini)
        oscil_founda=1.d0
!
  490   continue
      endif ! josc_find==1
!
  990 continue
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine get_oscxtr
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! find and tabulate extrema of xspec(ispec_osc,...)
!
!c    adum2=dlog(1.d-25)
      adum2=-57.564627d0
!c    adum3=dlog(1.d+25)
      adum3=+57.564627d0
!
      kosc_xtr=-1
      do itosc=itosc_wlo,itosc_whi
        josc_xtr0=0
        if(josc_udamp.eq.0) then
          udosc1=1.0d0
          udosct=1.0d0
          blosc=0.d0
        endif
        if(josc_udamp.eq.1) then
          udosc1=oscil_gdamp*dtime
          udosct=oscil_gdamp*(dtime*itosc+time0)
          udosc1=dexxp(udosc1,adum2,adum3)
          udosct=dexxp(udosct,adum2,adum3)
          blosc=oscil_base
        endif
!
        x0=(xspec(ispec_osc,itosc)-blosc)*udosct
        xm=(xspec(ispec_osc,itosc-1)-blosc)*udosct/udosc1
        xp=(xspec(ispec_osc,itosc+1)-blosc)*udosct*udosc1
        dx1=x0-xm
        dx2=xp-x0
!
!      check for maximum
        if(dx1.gt.0.d0.and.dx2.lt.0.d0) then
          kosc_xtr=kosc_xtr+1
          if(kosc_xtr.le.kosc_hper_x) then
            josc_xtr(kosc_xtr)=1
            josc_xtr0=1
          endif
        endif
!
!      check for minimum
        if(dx1.lt.0.d0.and.dx2.gt.0.d0) then
          kosc_xtr=kosc_xtr+1
          if(kosc_xtr.le.kosc_hper_x) then
            josc_xtr(kosc_xtr)=2
            josc_xtr0=2
          endif
        endif
!
!      calculate position tosc_xtr and value xosc_xtr
!      of extremum by quadratic interpolation
        if(josc_xtr0.ge.1) then
          if(kosc_xtr.le.kosc_hper_x) then
            dtx=dtime*(-0.5d0+dx1/(dx1-dx2))
            tosc_xtr(kosc_xtr)=time0+itosc*dtime+dtx
            a0=(0.5d0*(xp+xm)-x0)*odtime**2
            xosc_xtr(kosc_xtr)=x0-a0*dtx**2
          endif
        endif
      enddo ! itosc=itosc_wlo,itosc_whi
!
!
      return
      end
!
!V091218:
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine get_folsol
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! accumulates R- and S-integral for first-order linear (FOL) ODE
! solution from interval [t_i,t_f]:==[(itime-1)*dtime , itime*dtime];
! then calculates ODE solution at t_f and stores it as pmdpen
!
! Note re data flow:
! 1) pfol_f, qfol_f get pre-updated
!    to P- and Q-value at latest itime, incl. at itime=0,
!    in "func_dpen" before start of "get_folsol";
! 2) pfol_i, qfol_i get post-updated
!    to P- and Q-value at latest itime = next itime-1,
!    below at end of "get_folsol". This includes initialization
!    at itime=0. At itime=0, R- and S-integral are trivially
!    known (=0); so pfol_i and qfol_i are not needed at
!    itime=0, but only for itime>=1.
!
        if(itime.eq.0) then
          jfol_opt1=myint(pmfunc(1))
          jfol_opt2=myint(pmfunc(2))
          nintfol=myint(pmfunc(3))
!
          onintfol=1.d0/(1.d0*nintfol)
          ddtime_half=dtime_half*onintfol
!
!! NOT NEEDED HERE:
!!        pfol_i=pfol_f
!!        qfol_i=qfol_f
!
          rfol=0.d0
          sfol=0.d0
          rfol_p=rfol
          sfol_p=sfol
        endif
!
        if(itime.ge.1) then
          pfol_p=pfol_i
          qfol_p=qfol_i
!
          dpfol=(pfol_f-pfol_i)*onintfol
          dqfol=(qfol_f-qfol_i)*onintfol
!
          do iintfol=1,nintfol
            pfol=pfol_p+dpfol
            qfol=qfol_p+dqfol
!
            drfol=ddtime_half*(qfol_p+qfol)
            rfol=rfol_p+drfol
            expdrfol=dexp(-drfol)
            sfol=ddtime_half*(pfol_p*expdrfol+pfol)+sfol_p*expdrfol
!
            pfol_p=pfol
            qfol_p=qfol
            rfol_p=rfol
            sfol_p=sfol
          enddo
        endif
!
        pmdpen=yfol0*dexp(-rfol)+sfol
        pfol_i=pfol_f
        qfol_i=qfol_f
!
!
      return
      end
!
!:V091218
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_fix_bcft
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! initialize boundary contact force and Fourier weight force params.
!
      kmvsequ_lp=-1
      if(nmvsequ(1).gt.0) then
        imvsequ=1
        jmvloop=1
        kmvsequ=kmvsequ_mvs(imvsequ,jmvloop)
      else
        if(nmvsequ(2).gt.0) then
          imvsequ=1
          jmvloop=2
          kmvsequ=kmvsequ_mvs(imvsequ,jmvloop)
        else
          imvsequ=-1
          kmvsequ=-1
          jmvloop=-1
        endif
      endif
!
      call sch_fbound
      call sch_ffour
!
      jmvloop=-1
      imc_rep=-1
      imc_eql=-1
      imc_acc=-1
      imc_upd=-1
      imvsequ=-1
      kmvsequ=-1
      kmvsequ_lp=-1
      imove=-1
      kmove=-1
      jkmove=-1
      ith_rk=-1
      ith_cs=-1
!
      ihtot_amb=-1
      ihtot_pst=-1
      ihtot_pge=-1
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_vxpt
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! set+mask exptl. time points, set Gaussian widths and scale factor
! class for virtual expts.
!
!
!   find lower and upper within-bounds "itxpt"-limits
!   and total number of exptl. data points;
!   for virt. expts. only; for real expts., see "idat_xpt"
      itxpt_min=1
      itxpt_max=ntxpt
!
      do itxpt=1,ntxpt
        if(time_xpt(itxpt).lt.time0)                                    &
     &    itxpt_min=itxpt+1
        if(time_xpt(ntxpt+1-itxpt).gt.time1)                            &
     &    itxpt_max=ntxpt-itxpt
      enddo
!
! mask out of bounds exptl. time pts.
!
      do itxpt=1,ntxpt
        if(   &
     &  time_xpt(itxpt).gt.time1.or.                             &
     &  time_xpt(itxpt).lt.time0    &
     &  )then
          if(mp_myid.eq.mp_mrid) then
            open(31,file='ens.o01',status='old')
            iun=31
            call efile(iun)
            write(31,*) ' WARNING from input file ens.i01'
            write(31,*) ' exptl. time point out of bounds for'
            write(31,*)                                                   &
     &        '   itxpt=', itxpt
            write(31,*) '   time0, time1=',time0, time1
            write(31,*)                                                   &
     &        '   time_xpt(itxpt)=',   time_xpt(itxpt)
            write(31,*)                                                   &
     &        ' out-of-bound data pts. will be masked and ignored'
            write(31,*) ' EXECUTION CONTINUED'
            close(31)
          endif
!
          do iexpt=1,nexpt
            do ims=1,nms_spec
              itmx_xpt(ims,itxpt,iexpt)=0
            enddo
          enddo
        else
          do iexpt=1,nexpt
            do ims=1,nms_spec
              itmx_xpt(ims,itxpt,iexpt)=-1
            enddo
          enddo
        endif
      enddo
!
! mask exptl. dependent species of exptl. data (jctspec=30,40)
!
      do ims=1,nms_spec
        ispec=ispec_ms(ims)
        do idpen=1,ndpen_spec
          ispec_D=ispec_dpen(idpen)
          if(ispec_D.ne.ispec) goto 90
!
          ipm_D=ipm_dpen(idpen)
!
          if(                                                           &
     &    jctspec(ispec_D,ipm_D).eq.30.or.                              &
     &    jctspec(ispec_D,ipm_D).eq.40                                  &
     &    )then
            do iexpt=1,nexpt
              do itxpt=1,ntxpt
                itmx_xpt(ims,itxpt,iexpt)=0
              enddo
            enddo
            goto 92
          endif
!
   90     continue
        enddo
   92   continue
      enddo
!
! tabulate exptl. data point label "itmx"
!
      itmx=0
      do iexpt=1,nexpt
        do ims=1,nms_spec
          ispec=ispec_ms(ims)
          itmx_ini(ims,iexpt)=itmx+1
!
          do itxpt=1,ntxpt
            if(itmx_xpt(ims,itxpt,iexpt).eq.-1) then
              itmx=itmx+1
!
              if(itmx.gt.mdtin_x) then
                errtag='000095.000'
                call err_term
              endif
!
              itmx_xpt(ims,itxpt,iexpt)=itmx
              itxpt_tmx(itmx)=itxpt
!
              yspec_wid(itmx_xpt(ims,itxpt,iexpt))=                     &
     &        dabs(widlog_spec)
            endif
          enddo
          itmx_fin(ims,iexpt)=itmx
        enddo
      enddo
      mdtin=itmx
!
      yspec_wid(0)=-1.d0
      yspec_xpt(0)= 0.d0
!
      xspec_wid(0)=-1.d0
      xspec_xpt(0)=-1.d0
!
      lscal_xpt(0)=-100
!V090911:
!DEACTIVATED
!R    jbaxdi_xpt(0)=-1
!R    nbaxdi_xpt(0)=-1
!R    jzxdi_xpt(0)=-1
!:V090911
!
! scale factor class table for virtual experiments
!
      do iexpt=1,nexpt
        do itxpt=1,ntxpt
          do ims=1,nms_spec
            if(itmx_xpt(ims,itxpt,iexpt).gt.0) then
              lscal_xpt(itmx_xpt(ims,itxpt,iexpt))=jxpt-100
            else
              if(itmx_xpt(ims,itxpt,iexpt).lt.0) then
                errtag='000095.001'
                call err_term
              endif
              lscal_xpt(itmx_xpt(ims,itxpt,iexpt))=-100
            endif
          enddo
        enddo
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_tint
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! set time integration parameters
!
! check total number of available exptl. data points.
!
      if(mdtin.le.0) then
            errtag='000096'
            call err_term
      endif
!
!
!   set kinetics integrator and time interpolation parameters
!
      dtime10=time1-time0
      dtime=(time1-time0)/(1.d0*ntime)
      odtime=1.d0/dtime
      time0_o=time0-eps_time*ntime
      time1_o=time1+eps_time*ntime
!
      if(jtime.ge.1) then
        if(jtime.ge.10.and.jtime.le.299) then
          odtime_rl=1.d0/dtime_rl
          dtime_ark=dtime/(1.d0*nstp_ark)
!
          hini_ark= dtime_ark*rhini_ark
          hmin1_ark=dtime_ark*rhmin1_ark
          hmin2_ark=dtime_ark*rhmin2_ark
          hmin0_ark=hmin1_ark+hmin2_ark
          dtime_sto=dtime_ark*rdtsto_ark*2.000002d0
!
          nsto_ark=0
          if(jsto_ark.eq.1) nsto_ark=nsto_ark_y
!
          call set_ark_ck
!
          istate_lss=0
          call set_lss_ini
!
!c        itask_lss=1
!c        iopt_lss=1
!c        do idum=5,10
!c          iwork_lss(idum)=0
!c          rwork_lss(idum)=0.d0
!c        enddo
!ccc      rwork_lss(5)=hini_ark
!c        rwork_lss(7)=hmin0_ark
!c        iwork_lss(6)=nstp_ark
        endif
!
! tabulate equidistant ODE solution t-grid
! and linear inetrpolation factors for exptl. t-points
        do itime=0,ntime
          time_itim(itime)=time0+dtime*itime
        enddo
!
        do itxpt=1,ntxpt
          itlo=(time_xpt(itxpt)-time0)/dtime
          if(itlo.ge.ntime) itlo=ntime-1
          if(itlo.le.0)     itlo=0
!
          itime_xpt(itxpt)=itlo
!
          jrkit_xpt(itxpt)=-10
          jtgri_xpt(itxpt)=-10
        enddo
!
        do itxpt=1,ntxpt
          itlo=itime_xpt(itxpt)
          ithi=itlo+1
!
          tlo=time_itim(itlo)
          thi=time_itim(ithi)
!
          rt_xpt(itxpt)=(time_xpt(itxpt)-tlo)/(thi-tlo)
          if(rt_xpt(itxpt).gt.1.d0) rt_xpt(itxpt)=1.d0
          if(rt_xpt(itxpt).lt.0.d0) rt_xpt(itxpt)=0.d0
!
          if(time_xpt(itxpt).lt.time0) rt_xpt(itxpt)=0.d0
          if(time_xpt(itxpt).gt.time1) rt_xpt(itxpt)=1.d0
        enddo
!
!     merge exptl. and equidistant grid time points
!     for "expt.-inclusive" ARK and ABD solvers
!
        irkit=-1
        txpt0=time0-dabs(time1-time0)
!
        itxpt=itxpt_min
        do itime=0,ntime
          if(time0_o.le.time_itim(itime) .and.                          &
     &       time1_o.ge.time_itim(itime)                                &
     &      )                                                           &
     &    then
            irkit=irkit+1
            if(irkit.gt.nrkit_x) goto 190
            itime_rki(irkit)=itime
            itxpt_rki(irkit)=-1
          endif
!
  110     continue
          if(itxpt.le.itxpt_max) then
            if(itime.eq.itime_xpt(itxpt)) then
              irkit=irkit+1
              if(irkit.gt.nrkit_x) goto 190
!
              itime_rki(irkit)=itime
              itxpt_rki(irkit)=itxpt
!
              jrkit_xpt(itxpt)=-1
!
              if(dabs(time_xpt(itxpt)-time_itim(itime)).le.             &
     &          eps_time) then
                jrkit_xpt(itxpt)=0
              endif
!
              if(dabs(time_xpt(itxpt)-txpt0).le.                        &
     &          eps_time) then
                jrkit_xpt(itxpt)=1
              endif
!
              if(dabs(time_xpt(itxpt)-time_itim(itime+1)).le.           &
     &          eps_time) then
                jrkit_xpt(itxpt)=2
              endif
!
              txpt0=time_xpt(itxpt)
              itxpt=itxpt+1
              goto 110
            endif
          endif
!
  190     continue
          if(irkit.gt.nrkit_x) then
            errtag='000097'
            call err_term
          endif
        enddo
        nrkit=irkit
!
!     alternative expt.-inclusive grid
!     merge exptl. and model integration grid time points
!     for "expt.-inclusive" ARK solver
!
        itgri=-1
        txpt0=time0-dabs(time1-time0)
!
        itxpt=itxpt_min
        do itime=0,ntime
!
!       include equidistant t-pts.:
          if(time0_o.le.time_itim(itime) .and.                          &
     &       time1_o.ge.time_itim(itime)                                &
     &      )                                                           &
     &    then
            itgri=itgri+1
            if(itgri.gt.ntgri_x) goto 290
            itime_tgr(itgri)=itime
            time_tgr(itgri)=time_itim(itime)
            itxpt_tgr(itgri)=-1
          endif
!
!       ...then skip over epxtl. t-pts. if needed:
          if(jtime.eq.10.or.jtime.eq.20                                 &
     &    .or.jtime.eq.110.or.jtime.eq.120                              &
     &    .or.jtime.eq.210.or.jtime.eq.220) goto 290
!
!       ...or include exptl. t-pts. and label non-included
!        (nearly) degenerate exptl. t-points:
  210     continue
          if(itxpt.le.itxpt_max) then
            if(itime.eq.itime_xpt(itxpt)) then
              jtgri_xpt(itxpt)=-1
!
              if(dabs(time_xpt(itxpt)-time_itim(itime)).le.             &
     &          eps_time) then
                jtgri_xpt(itxpt)=0
              endif
!
              if(dabs(time_xpt(itxpt)-txpt0).le.                        &
     &          eps_time) then
                jtgri_xpt(itxpt)=3+itgri
              endif
!
              if(dabs(time_xpt(itxpt)-time_itim(itime+1)).le.           &
     &          eps_time) then
                jtgri_xpt(itxpt)=2
              endif
!
              if(jtgri_xpt(itxpt).eq.-1) then
                itgri=itgri+1
                if(itgri.gt.ntgri_x) goto 290
!
                itime_tgr(itgri)=itime
                time_tgr(itgri)=time_xpt(itxpt)
                itxpt_tgr(itgri)=itxpt
                txpt0=time_xpt(itxpt)
              endif
              itxpt=itxpt+1
              goto 210
            endif
          endif
!
  290     continue
          if(itgri.gt.ntgri_x) then
            errtag='000098'
            call err_term
          endif
        enddo
        ntgri=itgri
!
!
!     merge exptl. and model-output time points
!     for xspec-output; control list of t-points
!     for averaging and output of model species
!     concentrations by jo_sxt:
!
!     jo_sxt=0:
!       output equid. model t-grid and exptl. t-points
!     jo_sxt=1:
!       suppress equid. model t-grid, output exptl. t-points
!     jo_sxt=2:
!       output equid. model t-grid, suppress exptl. t-points
!     where jo_sxt is the 1000-digit of input param. jo_xspec:
!       jo_xpec=1000*jo_sxt+100*jo_cfi+10*jo_xdi+1*jo_xko
!     example:
!       jo_xspec=2001 --> jo_sxt=2, jo_cfi=0, jo_xdi=0, jo_xko=1
!     standard choices:
!       jo_xspec=0000 (--> jo_sxt=0)
!       jo_xspec=2000 (--> jo_sxt=2)
!
        io_time=0
        itxpt=itxpt_min
        mtime=-1
        do itime=0,ntime
!
! set jo_sxt=1 to suppress output of model equidist. grid t-pts.
          if(jo_sxt.eq.1) goto 301
            mtime=mtime+1
            if(mtime.eq.ntskip) mtime=0
            if(mtime.eq.0.or.itime.eq.ntime) then
              if(time0_o.le.time_itim(itime) .and.                      &
     &           time1_o.ge.time_itim(itime)                            &
     &        )                                                         &
     &        then
                io_time=io_time+1
                if(io_time.gt.no_time_x) goto 390
                itime_o(io_time)=itime
                itxpt_o(io_time)=-1
              endif
            endif
  301     continue
!
! set jo_sxt=2 to suppress output of exptl. t-pts.
          if(jo_sxt.eq.2) goto 312
  310       continue
            if(itxpt.le.itxpt_max) then
              if(itime.eq.itime_xpt(itxpt)) then
                io_time=io_time+1
                if(io_time.gt.no_time_x) goto 390
                itime_o(io_time)=itime
                itxpt_o(io_time)=itxpt
                itxpt=itxpt+1
                goto 310
              endif
            endif
  312     continue
        enddo
!
        goto 392
  390   continue
        if(io_time.gt.no_time_x) then
            errtag='000099.000'
            call err_term
        endif
  392   continue
        no_time=io_time
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_txdcon
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! store exptl. obs. times for pseudo-species deconvolution
! by expt. and real-species
!
      itsxdc=0
      do iexpt=1,nexpt
        do ispec=1,nspec
          itsxdc_ini(ispec,iexpt)=itsxdc+1
!
          do jmvloop=1,2
            do imvsequ=1,nmvsequ(jmvloop)
              do ldconr=ldconr_ini(imvsequ,jmvloop)              &
     &  ,               ldconr_fin(imvsequ,jmvloop)
                irspec=irspec_dconr(ldconr)
                if(irspec.eq.ispec) goto 49
              enddo
              goto 69
   49         continue
!
              do ldconp=ldconp_ini(imvsequ,jmvloop)            &
     &,                 ldconp_fin(imvsequ,jmvloop)
                ipspec=ipspec_dconp(ldconp)
                ims=ims_spec(ipspec)
!              Note: ims>0 for all ipspec_dconp has already been checked!
!
                do itmx=itmx_ini(ims,iexpt),itmx_fin(ims,iexpt)
                  itxpt=itxpt_tmx(itmx)
                  do itsxdc0=itsxdc_ini(ispec,iexpt),itsxdc
                    if(itxpt_tsxdc(itsxdc0).eq.itxpt) goto 59
                  enddo
!
                  itsxdc=itsxdc+1
                  if(itsxdc.gt.ntsxdc_x) then
                    errtag='000099.001'
                    call err_term
                  endif
                  irspec_tsxdc(itsxdc)=ispec
                  itxpt_tsxdc(itsxdc)=itxpt
!
   59             continue
                enddo !itmx
              enddo !ldconp
!
   69         continue
            enddo !imvsequ
          enddo !jmvloop
          itsxdc_fin(ispec,iexpt)=itsxdc
        enddo !ispec
      enddo !iexpt
!
      ntsxdc_tot=itsxdc
!
!
      mtsxdc_max=0
      do iexpt=1,nexpt
        mtsxdc_xpt(iexpt)=                                    &
     &  itsxdc_fin(nspec,iexpt)-itsxdc_ini(1,iexpt)+1
!
        itsxdc_inixp(iexpt)=itsxdc_ini(1,iexpt)
        itsxdc_finxp(iexpt)=itsxdc_fin(nspec,iexpt)
!
        if(mtsxdc_xpt(iexpt).gt.mtsxdc_max)                   &
     &  mtsxdc_max=mtsxdc_xpt(iexpt)
      enddo !iexpt
!
!
! check consistency of itsxdc-labeling:
! for given pseudo-species, list itmx_itxdc(itsxdc)
! should be the same for all parent real-species
!
      do jmvloop=1,2
        do imvsequ=1,nmvsequ(jmvloop)
          do ldconp=ldconp_ini(imvsequ,jmvloop)            &
     &,             ldconp_fin(imvsequ,jmvloop)
            ipspec=ipspec_dconp(ldconp)
            ims=ims_spec(ipspec)
!
            do itxdc=1,ntxdc_x
              itmx0_txdc(itxdc)=-1
              itmx_txdc(itxdc)=-1
            enddo
!
            ntxdc=-1
            ntxdc0=-1
            do ldconr2=ldconr_ini(imvsequ,jmvloop)              &
     &  ,              ldconr_fin(imvsequ,jmvloop)
              idconr2=ldconr2-ldconr_ini(imvsequ,jmvloop)+1
              irspec2=irspec_dconr(ldconr2)
!
              itxdc=0
              do iexpt=1,nexpt
                do itmx=itmx_ini(ims,iexpt),itmx_fin(ims,iexpt)
                  itxdc=itxdc+1
                  if(itxdc.gt.ntxdc_x) then
                    errtag='000099.002: itxdc too large'
                    call err_term
                  endif
!
                  itxpt=itxpt_tmx(itmx)
                  do itsxdc2=itsxdc_ini(irspec2,iexpt),itsxdc_fin(irspec2,iexpt)
                    if(itxpt.eq.itxpt_tsxdc(itsxdc2)) goto 119
                  enddo
                  errtag='000099.003: itxpt_tsxdc NOT FOUND'
                  call err_term
  119             continue
!
!!                xspec_txdcr(itxdc,idconr2)=xspec_tsxdc(jmsip,itsxdc2)
                  itmx0_txdc(itxdc)=itmx_txdc(itxdc)
                  itmx_txdc(itxdc)=itmx
                enddo
              enddo
              ntxdc0=ntxdc
              ntxdc=itxdc
!
              if(idconr2.gt.1) then
                if(ntxdc0.ne.ntxdc) then
                  errtag='000099.004: ntxdc from diff. real species INCOMPATIBLE'
                  call err_term
                endif
!
                do itxdc=1,ntxdc_x
                  if(itmx0_txdc(itxdc).ne.itmx_txdc(itxdc)) then
                    errtag='000099.005: itmx_txdc from diff. real species INCOMPATIBLE'
                    call err_term
                  endif
                enddo
              endif
            enddo
          enddo
        enddo
      enddo
!
!
      imvsequ=-1
      jmvloop=-1
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_lss_ini
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
      if(istate_lss.eq.1                                                &
     &.or.jtime.lt.100.or.jtime.gt.299) return
!
      istate_lss=1
      itask_lss=1
      iopt_lss=1
      do idum=5,10
        iwork_lss(idum)=0
        rwork_lss(idum)=0.d0
      enddo
!c    rwork_lss(5)=hini_ark
      rwork_lss(7)=hmin0_ark
      iwork_lss(6)=nstp_ark
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_four
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! store Fourier time interpolation look-up tables and
! time segment lists
!
      include 'ens.def'
!
!
      do iexpt=1,nexpt
        do isegft=1,nsegft(iexpt)
          dtime_ft=(time_ftf(isegft,iexpt)                              &
     &             -time_fti(isegft,iexpt))                             &
     &             /(1.d0*nft_time(isegft,iexpt))
!
          do ift_time=0,nft_time(isegft,iexpt)
            time_ft=dtime_ft*ift_time                                   &
     &             +time_fti(isegft,iexpt)
            itlo=(time_ft-time0)/dtime
            if(itlo.ge.ntime) itlo=ntime-1
            if(itlo.le.0)     itlo=0
!
            itime_ft(ift_time,isegft,iexpt)=itlo
          enddo
!
          do ift_time=0,nft_time(isegft,iexpt)
            time_ft=dtime_ft*ift_time                                   &
     &             +time_fti(isegft,iexpt)
            itlo=itime_ft(ift_time,isegft,iexpt)
            ithi=itlo+1
!
            tlo=time_itim(itlo)
            thi=time_itim(ithi)
!
            rt_ft(ift_time,isegft,iexpt)=(time_ft-tlo)/(thi-tlo)
!
            if(rt_ft(ift_time,isegft,iexpt).gt.1.d0)                    &
     &      rt_ft(ift_time,isegft,iexpt)=1.d0
!
            if(rt_ft(ift_time,isegft,iexpt).lt.0.d0)                    &
     &      rt_ft(ift_time,isegft,iexpt)=0.d0
!
            if(time_ft.lt.time0)                                        &
     &      rt_ft(ift_time,isegft,iexpt)=0.d0
!
            if(time_ft.gt.time1)                                        &
     &      rt_ft(ift_time,isegft,iexpt)=1.d0
          enddo
!
!
!V090911:
! DEACTIVATED
!R        do is_ft=1,nsft_spec
!R          ispec=ispec_sft(is_ft)
!R          is_xdi=is_xdi_spec(ispec,iexpt)
!
!R          isegxd_sft(is_ft,isegft,iexpt)=0
!
!R          if(is_xdi.gt.0) then
!R            do isegxd=1,nsegxd(is_xdi,iexpt)
!R              time_i=time_itim(itime_xdii(isegxd,is_xdi,iexpt))
!R              time_f=time_itim(itime_xdif(isegxd,is_xdi,iexpt))
!R              if(time_i.le.time_fti(isegft,iexpt).and.                &
!R   &             time_f.ge.time_ftf(isegft,iexpt))                    &
!R   &          isegxd_sft(is_ft,isegft,iexpt)=isegxd
!R            enddo
!R          endif
!R        enddo
!:V090911
!
        enddo
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_xdi
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! store exptl. data interpolation look-up tables and
! time segment lists
!
      include 'ens.def'
!
!
!
      open(31,file='ens.o01',status='old')
      iun=31
      call efile(iun)
!
!
      if(jxpt.ge.100.and.jxpt.lt.200) then
        do iexpt=1,nexpt
          do ims=1,nms_spec
            do itxpt=1,ntxpt
              if(itmx_xpt(ims,itxpt,iexpt).gt.0) then
                jbaxdi_xpt(itmx_xpt(ims,itxpt,iexpt))=0
                nbaxdi_xpt(itmx_xpt(ims,itxpt,iexpt))=0
                jzxdi_xpt(itmx_xpt(ims,itxpt,iexpt))=0
              endif
            enddo
!
            if(                                                         &
     &      itmx_xpt(ims,    1,iexpt).eq.0                              &
     &      .or.                                                        &
     &      itmx_xpt(ims,nexpt,iexpt).eq.0                              &
     &      )then
              if(itmx_xpt(ims,ntxpt,iexpt).eq.0) itxpt=ntxpt
              if(itmx_xpt(ims,    1,iexpt).eq.0) itxpt=1
            errtag='000100'
            call err_term
            endif
            nbaxdi_xpt(itmx_xpt(ims,    1,iexpt))=ntxpt/4
            nbaxdi_xpt(itmx_xpt(ims,ntxpt,iexpt))=ntxpt/4
             jzxdi_xpt(itmx_xpt(ims,    1,iexpt))=1
             jzxdi_xpt(itmx_xpt(ims,ntxpt,iexpt))=2
          enddo
        enddo
      endif
!
!
! exptl. interpolation species look-up tables
!
      do iexpt=1,nexpt
        is_xdi=0
        do ispec=1,nspec
          is_xdi_spec(ispec,iexpt)=0
          ispecX_spec(ispec,iexpt)=0
!
          ims=ims_spec(ispec)
          if(ims.le.0) goto 312
          do itxpt=1,ntxpt
            if(                                                         &
     &      jzxdi_xpt(itmx_xpt(ims,itxpt,iexpt)).ge.1.and.              &
     &      jzxdi_xpt(itmx_xpt(ims,itxpt,iexpt)).le.2                   &
     &      ) goto 310
          enddo
!
          goto 312
  310     continue
            is_xdi=is_xdi+1
            if(is_xdi.gt.nms_spec_x) then
            errtag='000101'
            call err_term
            endif
!
            ispec_xdi(is_xdi,iexpt)=ispec
            ispecX_xdi(is_xdi,iexpt)=nspec+is_xdi
            ispecX_spec(ispec,iexpt)=nspec+is_xdi
            is_xdi_spec(ispec,iexpt)=is_xdi
  312     continue
        enddo
!
        nsxdi_spec(iexpt)=is_xdi
!
!
!
        do ivs=1,nvs_spec
          ispecX_vs(ivs,iexpt)=0
          is_xdi_vs(ivs,iexpt)=0
        enddo
!
        do is_xdi=1,nsxdi_spec(iexpt)
          ispec=ispec_xdi(is_xdi,iexpt)
          ivs=ivs_spec(ispec)
          if(ivs.gt.0) then
            ispecX_vs(ivs,iexpt)=ispecX_xdi(is_xdi,iexpt)
            is_xdi_vs(ivs,iexpt)=is_xdi
          endif
        enddo
      enddo
!
!
! exptl. data insertion (XDI) time segment look-up tables
!
!   Note:
!   In input file "ens.i02", exptl. data points for each measured
!   species (ispec) and each expt. (iexpt) are marked for
!   inclusion/exclusion in SVD-fit data interpolation as follows:
!     jzxdi=1: begin XDI time segment here,
!              incl. this itxpt=:itxpt_xdii(ispec,iexpt)
!     jzxdi=2: terminate XDI time segment here,
!              incl. this itxpt=:itxpt_xdif(ispec,iexpt)
!     jzxdi=0: include data pt. at this "itxpt" if located
!              between itxpt_xdii and its subsequ. itxpt_xdif;
!              otherwise exclude
!     jzxdi=9: exclude data pt. at this "itxpt" from SVD-fit
!              data interpolation, regardless of location
!              relative to itxpt_xdii and itxpt_xdif
!   Note also that jzxdi has no effect on exclusion/inclusion of
!   a data pt. in the \chi^2-summmation; the latter is controlled
!   by jzwid. However, if a data pt. is excluded from
!   \chi^2-summation due to jzwid=<0, then it is also excluded
!  from SVD-fit data interpolation.
!
      do iexpt=1,nexpt
        do is_xdi=1,nsxdi_spec(iexpt)
          ispec=ispec_xdi(is_xdi,iexpt)
          jseg_on=0
          isegxd=0
!
          ims=ims_spec(ispec)
          if(ims.gt.0) then
            do itxpt=1,ntxpt
              if(jzxdi_xpt(itmx_xpt(ims,itxpt,iexpt)).eq.1) then
                if(jseg_on.eq.1) then
            errtag='000102'
            call err_term
                endif
!
                isegxd=isegxd+1
                if(isegxd.gt.nsegxd_x) then
            errtag='000103'
            call err_term
                endif
!
                jseg_on=1
                itime_xdii(isegxd,is_xdi,iexpt)=itime_xpt(itxpt)
                itxpt_xdii(isegxd,is_xdi,iexpt)=itxpt
              endif
!
              if(jzxdi_xpt(itmx_xpt(ims,itxpt,iexpt)).eq.2) then
                if(jseg_on.eq.0) then
            errtag='000104'
            call err_term
                endif
!
                jseg_on=0
                itime_xdif(isegxd,is_xdi,iexpt)=itime_xpt(itxpt)+1
                itxpt_xdif(isegxd,is_xdi,iexpt)=itxpt
              endif
!
              if(itxpt.eq.ntxpt.and.jseg_on.eq.1) then
            errtag='000105'
            call err_term
              endif
            enddo
          endif
!
          nsegxd(is_xdi,iexpt)=isegxd
!
!
        enddo
      enddo
!
!
      do iexpt=1,nexpt
        do is_xdi=1,nsxdi_spec(iexpt)
          ispec=ispec_xdi(is_xdi,iexpt)
          ims=ims_spec(ispec)
!
          if(ims.eq.0) then
            errtag='000106'
            call err_term
          endif
!
!
          do isegxd=1,nsegxd(is_xdi,iexpt)
            time_i=time_itim(itime_xdii(isegxd,is_xdi,iexpt))
            time_f=time_itim(itime_xdif(isegxd,is_xdi,iexpt))
            time_xdii(isegxd,is_xdi,iexpt)=time_i
            otime_xdifi(isegxd,is_xdi,iexpt)=                           &
     &      1.0d0/(fdtxdi*(time_f-time_i))
!
            itxpt_i=itxpt_xdii(isegxd,is_xdi,iexpt)
            itxpt_f=itxpt_xdif(isegxd,is_xdi,iexpt)
!
!cc        nbas=nbas1+nbas2:
            nbaxdi(0,isegxd,is_xdi,iexpt)=                              &
     &       nbaxdi_xpt(itmx_xpt(ims,itxpt_i,iexpt))                    &
     &      +nbaxdi_xpt(itmx_xpt(ims,itxpt_f,iexpt))
!
!
            if(nbaxdi(0,isegxd,is_xdi,iexpt).gt.nbaxdi_x) then
            errtag='000107'
            call err_term
            endif
!
!cc        nbas1:
            nbaxdi(1,isegxd,is_xdi,iexpt)=                              &
     &      nbaxdi_xpt(itmx_xpt(ims,itxpt_i,iexpt))
!
            jbaxdi(isegxd,is_xdi,iexpt)=                                &
     &      jbaxdi_xpt(itmx_xpt(ims,itxpt_i,iexpt))
!
            it_xdi=0
            do itxpt=itxpt_i,itxpt_f
              if(jzxdi_xpt(itmx_xpt(ims,itxpt,iexpt)).ne.9.and.         &
     &        itmx_xpt(ims,itxpt,iexpt).gt.0                            &
     &        ) then
                it_xdi=it_xdi+1
                yspec_xdi(it_xdi,isegxd,is_xdi,iexpt)=                  &
     &          yspec_xpt(itmx_xpt(ims,itxpt,iexpt))
!
                sspec_xdi(it_xdi,isegxd,is_xdi,iexpt)=                  &
     &          yspec_wid(itmx_xpt(ims,itxpt,iexpt))
!
                txpt_xdi(it_xdi,isegxd,is_xdi,iexpt)=                   &
     &          time_xpt(itxpt)
              endif
            enddo
            ntxdi(isegxd,is_xdi,iexpt)=it_xdi
          enddo
        enddo
      enddo
!
!  expand ivs-ispec-is_xdi conversion tables and namelist
!
      do iexpt=1,nexpt
        if(jo_xdi.eq.3) then
!c        nvs_spec_o(iexpt)=nvs_spec+nsxdi_spec(iexpt)
          nspec_o(iexpt)=nspec+nsxdi_spec(iexpt)
        else
!c        nvs_spec_o(iexpt)=nvs_spec
          nspec_o(iexpt)=nspec
        endif
!
!
        do ispec=1,nspec
          is_xdi=is_xdi_spec(ispec,iexpt)
          if(is_xdi.gt.0) then
            is_xdi_spec(nspec+is_xdi,iexpt)=is_xdi
            is_xdi_vs(nvs_spec+is_xdi,iexpt)=is_xdi
!
            ivs_spec(nspec+is_xdi)=nvs_spec+is_xdi
            ispec_vs(nvs_spec+is_xdi)=nspec+is_xdi
!
            namespec_o(nspec+is_xdi,iexpt)=namespec(ispec)
          endif
          namespec_o(ispec,iexpt)=namespec(ispec)
        enddo
      enddo
!
!
      if(nexpt.eq.1) then
        do ispec=1,nspec
          do itime=0,ntime
            jsegxd(ispec,itime)=0
          enddo
!
          is_xdi=is_xdi_spec(ispec,1)
          if(is_xdi.gt.0) then
            do isegxd=1,nsegxd(is_xdi,1)
              do itime=                                                 &
     &         itime_xdii(isegxd,is_xdi,1)                              &
     &        ,itime_xdif(isegxd,is_xdi,1)
                jsegxd(ispec,itime)=isegxd
              enddo
            enddo
          endif
        enddo
      endif
!
!
      write(31,*) ' '
      close(31)
!
! zero sxplog for initial start-up of XDI MC updates
!
      do kscal=1,nkscal
        sxplog_ks_th(kscal)=0.d0
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine get_xdi
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
! calculate amplitudes exptl data fit amplitudes "abaxdi" for
! linear superposition of interpolation basis functions
! and find frequencies of max. Fourier weight in exptl. data
!
! Note:
!  At beginning of simulation, abaxdi gets initialized once
!  by forced calls to
!    store_sfxdi     with jsfxdi=0
!      -> setting all sxplog_xdi=0
!    get_xdi         with jsfxdi=0, jkrxdi=8, all sxplog_xdi=0
!
!  After that, jkrxdi and jsfxdi are set by the move schedule,
!  via jtmp_mc, with
!    jkrxdi=jtmp_kx  and  jsfxdi=jtmp_sx
!  and with the following updating options:
!
!    jkrxdi=0:
!      XDI turned off
!
!    jkrxdi=1
!      XDI turned on, abaxdi frozen at last/initial setting
!
!    jkrxdi=2
!      abaxdi updated, by call to get_xdi, at the beginning of
!      each MC move sequence (imove=1), with the then-available
!      sxplog-values
!
!    jkrxdi=3
!      abaxdi updated, by call to get_xdi, at the beginning of
!      each MC move sweep (ith_rk,_cs=1), with the then-available
!      sxplog-values
!
!    jkrxdi>=4
!      abaxdi updated, by call to get_xdi, at the beginning of
!      each individual MC move step with the then-available
!      sxplog-values
!
! For updates of the abaxdi-amplitudes to be done with the latest
! values of sxplog_th, you must set
!        jsfxdi|=0 and jsfxdi|=9;
! otherwise, the sxplog-values used by get_xdi, for the updates
! will be frozen at "0" (jsfxdi=0) or at the last/initial value
! (jsfxdi=9)
!
      if(jkrxdi.eq.8) goto 10
      if(jkrxdi.eq.9) goto 10
      if(jkrxdi.eq.18) goto 10
      if(jkrxdi.eq.19) goto 10
!
      if(jkrxdi.le.1) return
      if(jkrxdi.ge.10.and.jkrxdi.le.11) return
!
      if(jmvloop.ge.1.and.kmvsequ.ge.1) then
        if(jkrxdi.eq.2.and.imove.gt.1) return
        if(jkrxdi.eq.12.and.imove.gt.1) return
!
        if(jkrxdi.eq.3.and.(ith_rk.gt.1.or.ith_cs.gt.1)) return
        if(jkrxdi.eq.13.and.(ith_rk.gt.1.or.ith_cs.gt.1)) return
      endif
!
   10 continue
!
!
      jupd_abaxdi=1
      jo_abaxdi=1
!
      do iexpt=1,nexpt
        do is_xdi=1,nsxdi_spec(iexpt)
          ispec=ispec_xdi(is_xdi,iexpt)
!
          do isegxd=1,nsegxd(is_xdi,iexpt)
            do it_xdi=1,ntxdi(isegxd,is_xdi,iexpt)
                y_xdi(it_xdi)=                                          &
     &          yspec_xdi(it_xdi,isegxd,is_xdi,iexpt)                   &
     &          -sxplog_xdi(it_xdi,isegxd,is_xdi,iexpt)
!
                s_xdi(it_xdi)=                                          &
     &          sspec_xdi(it_xdi,isegxd,is_xdi,iexpt)
!
                t_xdi(it_xdi)=                                          &
     &          txpt_xdi(it_xdi,isegxd,is_xdi,iexpt)
            enddo
!
            nbas=nbaxdi(0,isegxd,is_xdi,iexpt)
            nbas1=nbaxdi(1,isegxd,is_xdi,iexpt)
            ndat=ntxdi(isegxd,is_xdi,iexpt)
            jbas=jbaxdi(isegxd,is_xdi,iexpt)
!
            if(nbas.gt.ndat) then
              errtag='000108'
              call err_term
            endif
!
            call svdfit(                                                &
     &                  t_xdi,y_xdi,s_xdi,ndat                          &
     &                 ,abas_vec,nbas,nbas1                             &
     &                 ,umat                                            &
     &                 ,vmat                                            &
     &                 ,wbas_vec                                        &
     &                 ,chisq_xdi(isegxd,is_xdi,iexpt)                  &
     &                 ,time_xdii(isegxd,is_xdi,iexpt)                  &
     &                 ,otime_xdifi(isegxd,is_xdi,iexpt)                &
     &                 ,jbas                                            &
     &                 ,ntxpt_y                                         &
     &                 ,nbaxdi_y                                        &
     &                 ,ntxpt_y                                         &
     &                 ,nbaxdi_y,ierrtag                               &
     &                 ,sbaxdi)
!
            if(ierrtag.gt.0) then
              errtag='000122'
              call err_term
            endif
!
!
!  Note:
!     sbrt.   svdfit
!  invokes
!     sbrt.   sbaxdi(
!    1                time,time_i,otime_fi
!    1               ,fbas_vec,nbas,nbas1i,jbas
!    1               ,nbas_y)
!
            do ibas=1,nbas
              abaxdi(ibas,isegxd,is_xdi,iexpt)=                         &
     &        abas_vec(ibas)
            enddo
          enddo
        enddo
      enddo
!
!
!V090911:
!DEACTIVATED
!R    call get_xdfour
!
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine get_xdfour
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
! find Fourier weight at all frequencies in SVD-fitted exptl. data
!
      if(jsft_xd_imv.le.0) return
!
      isig_ft=+1
      do iexpt=1,nexpt
        do isegft=1,nsegft(iexpt)
          nft_htime=nft_time(isegft,iexpt)/2
          onft_time=1.d0/(1.d0*nft_time(isegft,iexpt)+1.d-20)
          o2nft_time=1.d0/(1.d0*nft_time(isegft,iexpt)+1.d-20)**2
!
          is_ft_max=0
          do is_ft=1,nsft_spec
            ispec=ispec_sft(is_ft)
            is_xdi=is_xdi_spec(ispec,iexpt)
!
            isegxd=isegxd_sft(is_ft,isegft,iexpt)
            if(is_xdi.gt.0.and.isegxd.gt.0) is_ft_max=is_ft
!
            do ift_freq=0,nft_htime
              pfour_xd(ift_freq,is_ft,isegft,iexpt)=-1.d0
            enddo
          enddo
!
          iodd=2
          do is_ft=1,nsft_spec
            ispec=ispec_sft(is_ft)
            is_xdi=is_xdi_spec(ispec,iexpt)
            isegxd=isegxd_sft(is_ft,isegft,iexpt)
!
            if(is_xdi.gt.0.and.isegxd.gt.0) then
              iodd=3-iodd
!             (Note: iodd=1,2,1,2,1,2,...)
!
              if(iodd.eq.1) is_ft1=is_ft
!
              dtime_ft=(time_ftf(isegft,iexpt)                          &
     &                 -time_fti(isegft,iexpt))                         &
     &                 /(1.d0*nft_time(isegft,iexpt))
              do ift_time=0,nft_time(isegft,iexpt)
                time_ft=dtime_ft*ift_time                               &
     &                 +time_fti(isegft,iexpt)
!
                xspec_FT(ift_time)=                                     &
     &          xxdi(time_ft,isegxd,is_xdi,iexpt                        &
     &                    ,abaxdi,time_xdii,otime_xdifi                 &
     &                    ,nbaxdi,jbaxdi                                &
     &                    ,nbaxdi_y,nsegxd_y,nsxdi_y,nexpt_y)
              enddo
!
!
              if(jsft_ln_imv.eq.0) then
                dyspec_fft=(dexp(xspec_FT(nft_time(isegft,iexpt)))      &
     &                     -dexp(xspec_FT(0))                    )      &
     &                    *onft_time
!
                do ift_time=0,(nft_time(isegft,iexpt)-1)
                  yspec_fft(2*ift_time+iodd)=                           &
     &            dexp(xspec_FT(ift_time))                              &
     &            -(ift_time-nft_htime)*dyspec_fft
                enddo
              endif
!
              if(jsft_ln_imv.eq.1) then
                dyspec_fft=( xspec_FT(nft_time(isegft,iexpt))           &
     &                     - xspec_FT(0)                     )          &
     &                    *onft_time
!
                do ift_time=0,(nft_time(isegft,iexpt)-1)
                  yspec_fft(2*ift_time+iodd)=                           &
     &            xspec_FT(ift_time)                                    &
     &            -(ift_time-nft_htime)*dyspec_fft
                enddo
              endif
!
              if(iodd.eq.2.or.is_ft.eq.is_ft_max) then
                if(iodd.eq.1) then
                  do ift_time=0,(nft_time(isegft,iexpt)-1)
                    yspec_fft(2*ift_time+2)=0.d0
                  enddo
                endif
!
                call four1(yspec_fft,nft_time(isegft,iexpt),isig_ft)
!
                if(iodd.eq.2) then
                  do ift_freq=0,nft_htime
                    iftp=ift_freq
                    iftm=nft_time(isegft,iexpt)-ift_freq
                    if(iftp.eq.0) iftm=0
                    y1re= 0.5d0*(yspec_fft(2*iftp+1)                    &
     &                          +yspec_fft(2*iftm+1))
                    y1im= 0.5d0*(yspec_fft(2*iftp+2)                    &
     &                          -yspec_fft(2*iftm+2))
                    y2re= 0.5d0*(yspec_fft(2*iftp+2)                    &
     &                          +yspec_fft(2*iftm+2))
                    y2im=-0.5d0*(yspec_fft(2*iftp+1)                    &
     &                          -yspec_fft(2*iftm+1))
!
                    pfour_xd(ift_freq,is_ft1,isegft,iexpt)=             &
     &              (y1re**2+y1im**2)*o2nft_time
                    pfour_xd(ift_freq,is_ft ,isegft,iexpt)=             &
     &              (y2re**2+y2im**2)*o2nft_time
                  enddo
                else
                  do ift_freq=0,nft_htime
                    iftp=ift_freq
                    iftm=nft_time(isegft,iexpt)-ift_freq
                    if(iftp.eq.0) iftm=0
                    y1re= 0.5d0*(yspec_fft(2*iftp+1)                    &
     &                          +yspec_fft(2*iftm+1))
                    y1im= 0.5d0*(yspec_fft(2*iftp+2)                    &
     &                          -yspec_fft(2*iftm+2))
!cc                 y2re= 0.5d0*(yspec_fft(2*iftp+2)
!cc  1                          +yspec_fft(2*iftm+2))
!cc                 y2im=-0.5d0*(yspec_fft(2*iftp+1)
!cc  1                          -yspec_fft(2*iftm+1))
!
                    pfour_xd(ift_freq,is_ft ,isegft,iexpt)=             &
     &              (y1re**2+y1im**2)*o2nft_time
                  enddo
                endif
              endif
            endif
          enddo
!
          do is_ft=1,nsft_spec
            pfour_xd_tot(is_ft,isegft,iexpt)=                           &
     &      +0.5d0*(pfour_xd(0        ,is_ft,isegft,iexpt)              &
     &             +pfour_xd(nft_htime,is_ft,isegft,iexpt))
!
            do ift_freq=1,(nft_htime-1)
              pfour_xd_tot(is_ft,isegft,iexpt)=                         &
     &        pfour_xd_tot(is_ft,isegft,iexpt)                          &
     &        +pfour_xd(ift_freq,is_ft,isegft,iexpt)
            enddo
!
            pfour_xd_tot(is_ft,isegft,iexpt)=                           &
     &      2.d0*pfour_xd_tot(is_ft,isegft,iexpt)
          enddo
        enddo
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine setpm_th
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! set "Theta" model parameters
! for species concentration schedule
! and reaction rates
!
!
      include 'ens.def'
!
! input: ivpm_th, jinipm_th
!
      if(jinipm_th.eq.0) return
!
!
      do ith=1,mth_spec
        ispec=ispec_th(ith)
        ipm=ipmspec_th(ith)
        idum1=0
!
        if(jinipm_th.eq.1) then
          cspec(ispec,ipm)=pmspec(ispec,ipm,ivpm_th)
          idum1=1
        endif
!
        if(jinipm_th.eq.3) then
          rstep=randx()
          if(jctspec(ispec,ipm).eq.0) then
            cspec(ispec,ipm)=                                           &
     &        rlospec(ith)                                              &
     &      +((rhispec(ith)-rlospec(ith))*rstep)
            idum1=1
          endif
          if(jctspec(ispec,ipm).eq.1) then
            cspec(ispec,ipm)=                                           &
     &        rlospec(ith)                                              &
     &      *((rhispec(ith)/rlospec(ith))**rstep)
            idum1=1
          endif
        endif
!
        if(idum1.eq.0) then
            errtag='000109'
            call err_term
        endif
!
      enddo
!
!
      do ith=1,mth_reac
        ireac=ireac_th(ith)
        ipm=ipmreac_th(ith)
        idum1=0
!
        if(jinipm_th.eq.1) then
          rreac0=pmreac(ireac,ipm,ivpm_th)
          idum1=1
        endif
!
        if(jinipm_th.eq.3) then
          if(jctreac(ireac,ipm).eq.0) then
            rstep=randx()
            rreac0=                                                     &
     &        rloreac(ith)                                              &
     &      +((rhireac(ith)-rloreac(ith))*rstep)
            idum1=1
          endif
          if(jctreac(ireac,ipm).eq.1) then
            rstep=randx()
            rreac0=                                                     &
     &        rloreac(ith)                                              &
     &      *((rhireac(ith)/rloreac(ith))**rstep)
            idum1=1
          endif
        endif
!
!
        if(idum1.eq.0) then
            errtag='000110.000'
            call err_term
        endif
!
!
        rreac(ireac,ipm) =rreac0
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine setpm_uf
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
!
! set fixed control parameters "U^f"
! for species concentration schedule
! and reaction rates
!
!
      include 'ens.def'
!
! input: ivpm_uf
!
      do iuf=1,muf_spec
        ispec=ispec_uf(iuf)
        ipm=ipmspec_uf(iuf)
        cspec(ispec,ipm)=pmspec(ispec,ipm,ivpm_uf)
      enddo
!
      do iuf=1,muf_reac
        ireac=ireac_uf(iuf)
        ipm=ipmreac_uf(iuf)
        rreac(ireac,ipm) =pmreac(ireac,ipm,ivpm_uf)
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine setpm_uv
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
!
! set expt'lly varied control parameters "U^e"
! for species concentration schedule
! and reaction rates
!
!
      include 'ens.def'
!
! input: ivpm_uv
!
!
      do iuv=1,muv_spec
        ispec=ispec_uv(iuv)
        ipm=ipmspec_uv(iuv)
        cspec(ispec,ipm)=pmspec(ispec,ipm,ivpm_uv)
      enddo
!
      do iuv=1,muv_reac
        ireac=ireac_uv(iuv)
        ipm=ipmreac_uv(iuv)
        rreac(ireac,ipm)=pmreac(ireac,ipm,ivpm_uv)
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine setdokin
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! sets the kinsolver skip option parameter jdokin
!
      mp_mexpt_dokin=0
!
      do iexpt=1,nexpt
        jdokin(iexpt)=1
!
        if(jckkin.eq.1) then
          idokin=idokin_spre(ispec_upd,ipm_upd)
          if(idokin.gt.0) jdokin(iexpt)=jdokin_expt(iexpt,idokin)
        endif
!
        if(jckkin.eq.2) then
          idokin=idokin_spre(ireac_upd+nspec,ipm_upd)
          if(idokin.gt.0) jdokin(iexpt)=jdokin_expt(iexpt,idokin)
        endif
!
        if(jmp_kin.eq.2.or.jmp_kin.eq.3) jdokin(iexpt)=1
!
        if(jdokin(iexpt).ge.1) mp_mexpt_dokin=mp_mexpt_dokin+1
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine chi_accu
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! accumulates exptl. data point sums chi2, chi1, chi0
! with either unit (1.d0) or modified (fwgt) data weight
! modulation factors (jfwgt=0: unit, jfwgt=1: fwgt);
!
! using either:
! exptl.-time model log-conc. "yspec_chi"
! and exptl. data log-conc. "yspec_xpt"
! with exptl. error  width "yspec_wid";
! or:
! exptl.-time model lin-conc. "xspec_chi"
! and exptl. data lin-conc. "xspec_xpt"
! with exptl. error  width "xspec_wid";
! excluding data with  itmx_xpt(ims,itxpt,iexpt) < 0;
!
! for species with jmsspec_px=1, pre-summed weight factors
! (from pre-summation over exptl. data pts. by "chi_prex")
! will be used to sum over equidist. model grid t-pts.;
! for species with jmsspec_px=0, direct summation over
! exptl. data pt. residue squares from [x,y]spec_xpt
! and [x,yspec]_chi will be done.
!
!
!LATER:
!Following "j..._ij" calc should be moved to "mc_mvsched"
!and to "set_fix_mcs" (for case j..._ij=-1)
!and expanded to include other "..._ij" settings
      jrasf_ctl_ij=-1
      jrasf_fmt_ij=-1
      jrasf_xch_ij=-1
      if(jmvloop.ge.1.and.jmvloop.le.2) then
        if(imvsequ.ge.1.and.imvsequ.le.nmvsequ(jmvloop)) then
          jrasf_ctl_ij=jrasf_ctl(imvsequ,jmvloop)
          jrasf_fmt_ij=jrasf_fmt(imvsequ,jmvloop)
          jrasf_xch_ij=jrasf_xch(imvsequ,jmvloop)
        endif
      endif
!
      chisq_g0t=0.d0
      chisq_n0t=0.d0
      do kscal=1,nkscal
        chisq_g1t(kscal)=0.d0
        chisq_g2t(kscal)=0.d0
!
        chisq_n1t(kscal)=0.d0
        chisq_n2t(kscal)=0.d0
      enddo
!
      do iscal=1,niscal
        chi2u_is(iscal)=dchi20u_is(iscal,jfwgt)
        chi1u_is(iscal)=dchi10u_is(iscal,jfwgt)
      enddo
!
      if(jscal.eq.2.or.jrasf_ctl_ij.ge.0) then
        chisq_g0u=achig00u(jfwgt)
        chisq_n0u=achin00u(jfwgt)
        do kscal=1,nkscal
          chisq_g1u(kscal)=achig01u_ks(kscal,jfwgt)
          chisq_g2u(kscal)=achig02u_ks(kscal,jfwgt)
!
          chisq_n1u(kscal)=0.d0
          chisq_n2u(kscal)=0.d0
        enddo
      endif
!
      do iexpt=1,nexpt
        do ims=1,nms_spec
          ispec=ispec_ms(ims)
!
          if(jmsspec_px(ispec).eq.0) then
            do itmx=itmx_ini(ims,iexpt),itmx_fin(ims,iexpt)
              if(jfwgt.eq.0)                                            &
     &        wgt_log=(1.d0/yspec_wid(itmx))**2
              if(jfwgt.eq.1)                                            &
     &        wgt_log=(fwgt(itmx)/yspec_wid(itmx))**2
!
              dchi2=                                                    &
     &         (                                                        &
     &          (                                                       &
     &           yspec_chi(itmx)                                        &
     &          -yspec_xpt(itmx)                                        &
     &          )                                                       &
!c   :          /(yspec_wid(itmx))
     &         )**2                                                     &
     &         *wgt_log
!
              dchi1=                                                    &
     &         -(                                                       &
     &           yspec_chi(itmx)                                        &
     &          -yspec_xpt(itmx)                                        &
     &          )                                                       &
!c   :          /(yspec_wid(itmx))**2
     &         *wgt_log
!
              iscal=iscal_xpt(itmx)
              chi2_is(iscal)=chi2_is(iscal)+dchi2
              chi1_is(iscal)=chi1_is(iscal)+dchi1
!
              if(jmsspec_ch(ispec).eq.1) then
                chisq_g0t=chisq_g0t                                     &
     &          +dchi2
                chisq_g1t(kscal_xpt(itmx))=chisq_g1t(kscal_xpt(itmx))   &
     &          -2.d0*dchi1
                chisq_g2t(kscal_xpt(itmx))=chisq_g2t(kscal_xpt(itmx))   &
     &          +wgt_log
              endif
!
              if(jmsspec_ch(ispec).eq.2) then
                if(jfwgt.eq.0)                                          &
     &          wgt_lin=(1.d0/xspec_wid(itmx))**2
                if(jfwgt.eq.1)                                          &
     &          wgt_lin=(fwgt(itmx)/xspec_wid(itmx))**2
!
                chisq_n0t=chisq_n0t                                     &
     &          +wgt_lin*xspec_xpt(itmx)**2
                chisq_n1t(kscal_xpt(itmx))=chisq_n1t(kscal_xpt(itmx))   &
     &          -2.d0*wgt_lin*xspec_chi(itmx)*xspec_xpt(itmx)
                chisq_n2t(kscal_xpt(itmx))=chisq_n2t(kscal_xpt(itmx))   &
     &          +wgt_lin*xspec_chi(itmx)**2
              endif
            enddo
          endif
!
          if(jmsspec_px(ispec).eq.1) then
            do iipch=iipch_ini(ims,iexpt),iipch_fin(ims,iexpt)
              iipch1=iipch+1
              if(iipch1.gt.nipch) iipch1=nipch
              iscal=iscal_ipch(iipch)
!
              if(jmsspec_ch(ispec).eq.1) then
                yspec0=zspec_ipch(iipch)
                yspec1=zspec_ipch(iipch1)
!
!c              xspec0=dexp(yspec0)
!c              xspec1=dexp(yspec1)
!c              Not needed!
              endif
!
              if(jmsspec_ch(ispec).eq.2) then
                xspec0=zspec_ipch(iipch)
                xspec1=zspec_ipch(iipch1)
!
                yspec0=dlog(dabs(xspec0))
                yspec1=dlog(dabs(xspec1))
              endif
!
              chi2u_is(iscal)=chi2u_is(iscal)                           &
     &        +dchi21u_ipch(iipch,jfwgt)*yspec0                         &
     &        +dchi220u_ipch(iipch,jfwgt)*yspec0**2                     &
     &        +dchi221u_ipch(iipch,jfwgt)*yspec0*yspec1
!
              chi1u_is(iscal)=chi1u_is(iscal)                           &
     &        +dchi11u_ipch(iipch,jfwgt)*yspec0
!
!
              if(jscal.eq.2.or.jrasf_ctl_ij.ge.0) then
                kscal=kscal_ipch(iipch)
                if(jmsspec_ch(ispec).eq.1) then
                  chisq_g0u=chisq_g0u                                   &
     &            +achig20u_ipch(iipch,jfwgt)*yspec0**2                 &
     &            +achig21u_ipch(iipch,jfwgt)*yspec0*yspec1             &
     &            +achig10u_ipch(iipch,jfwgt)*yspec0
!
                  chisq_g1u(kscal)=chisq_g1u(kscal)                     &
     &            +achig11u_ipch(iipch,jfwgt)*yspec0
!
!c                chisq_g2u(kscal)=chisq_g2u(kscal)
!c                Nothing to add!
                endif
!
                if(jmsspec_ch(ispec).eq.2) then
!c                chisq_n0u=chisq_n0u
!c                Nothing to add!
!
                  chisq_n1u(kscal)=chisq_n1u(kscal)                     &
     &            +achin11u_ipch(iipch,jfwgt)*xspec0
!
                  chisq_n2u(kscal)=chisq_n2u(kscal)                     &
     &            +achin20u_ipch(iipch,jfwgt)*xspec0**2                 &
     &            +achin21u_ipch(iipch,jfwgt)*xspec0*xspec1
                endif
              endif
            enddo
          endif
        enddo
      enddo
!
      do iscal=1,niscal
        chi2_is(iscal)=chi2_is(iscal)+chi2u_is(iscal)
        chi1_is(iscal)=chi1_is(iscal)+chi1u_is(iscal)
        chi0_is(iscal)=               chi0u_is(iscal,jfwgt)
      enddo
!
      call chi_scal
      call chi_rasf
!
      if(jscal.eq.2.or.jrasf_ctl_ij.ge.0) then
!
      if(jrasf_xch_ij.eq.1) then
        chisq=chisq_g0u+chisq_n0u                      &
     &       +chisq_g0t+chisq_n0t
        do kscal=1,nkscal
          chisq=chisq                                  &
!
     &       +(chisq_g1u(kscal)+chisq_g1t(kscal))      &
     &       *(sxplog_ras(kscal))                      &
!
     &       +(chisq_g2u(kscal)+chisq_g2t(kscal))      &
     &       *(sxplog_ras(kscal))**2                   &
!
     &       +(chisq_n1u(kscal)+chisq_n1t(kscal))      &
     &       *(sxplin_ras(kscal))                      &
!
     &       +(chisq_n2u(kscal)+chisq_n2t(kscal))      &
     &       *(sxplin_ras(kscal))**2
        enddo
        goto 990
      endif
!
!  ...else:
      chisq=chisq_g0u+chisq_n0u
      do kscal=1,nkscal
        chisq=chisq                                                     &
     &       +chisq_g1u(kscal)*(sxplog_ras(kscal))    &
     &       +chisq_g2u(kscal)*(sxplog_ras(kscal))**2  &
!
     &       +chisq_n1u(kscal)*(sxplin_ras(kscal))    &
     &       +chisq_n2u(kscal)*(sxplin_ras(kscal))**2
      enddo
!
      do iexpt=1,nexpt
        do ims=1,nms_spec
          ispec=ispec_ms(ims)
!
          if(jmsspec_px(ispec).eq.0) then
            if(jmsspec_ch(ispec).eq.1) then
              do itmx=itmx_ini(ims,iexpt),itmx_fin(ims,iexpt)
                if(jfwgt.eq.0)                                          &
     &          wgt_log=(1.d0/yspec_wid(itmx))**2
                if(jfwgt.eq.1)                                          &
     &          wgt_log=(fwgt(itmx)/yspec_wid(itmx))**2
                dchi2=                                                  &
     &           (                                                      &
     &            (                                                     &
     &             yspec_chi(itmx)                                      &
     &            +sxplog_ras(kscal_xpt(itmx))                          &
     &            -yspec_xpt(itmx)                                      &
     &            )                                                     &
!c   :            /(yspec_wid(itmx))
     &           )**2                                                   &
     &           *wgt_log
!
                chisq=chisq+dchi2
              enddo
            endif
!
            if(jmsspec_ch(ispec).eq.2) then
              do itmx=itmx_ini(ims,iexpt),itmx_fin(ims,iexpt)
                if(jfwgt.eq.0)                                          &
     &          wgt_lin=(1.d0/xspec_wid(itmx))**2
                if(jfwgt.eq.1)                                          &
     &          wgt_lin=(fwgt(itmx)/xspec_wid(itmx))**2
                dchi2=                                                  &
     &           (                                                      &
     &            (                                                     &
     &             xspec_chi(itmx)                                      &
     &            *sxplin_ras(kscal_xpt(itmx))                          &
     &            -xspec_xpt(itmx)                                      &
     &            )                                                     &
!c   :            /xspec_wid(itmx)
     &           )**2                                                   &
     &           *wgt_lin
!
                chisq=chisq+dchi2
              enddo
            endif
          endif
!
        enddo
      enddo
!
!
      endif
  990 continue
!
      jDB_chi_accu=0
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine chi_rasf
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
!DB090822
      integer ir, nr, jgauss
      real*8 stglog1, stglog2, stglin1, stglin2
      real*8 srglog1, srglog2, srglin1, srglin2
      data jgauss,nr /1,10000/
      save jgauss,nr
!FB090822
!
! store Theta-dep. ensem.-averaged sxplog_chi and/or sxplin_chi
! into sxplog_ras and/or sxplin_ras, resp., for final chisq-calc;
! if required (jrasf_ctl=2): do Gaussian randomization of sxplog_ras
! and/or sxplin_ras. SF-values in sxplog_ras and sxplin_ras will
! then be used to calculate final chisq-value in "chi_accu".
!
      if(jrasf_freez.eq.1) return
!
      jrasf_ctl_ij=-1
      jrasf_fmt_ij=-1
      sxplog_lo_ij=dlog(1.d-20)
      sxplog_hi_ij=-sxplog_lo_ij
      sxplin_lo_ij=1.d-20
      sxplin_hi_ij=1.d+20
!
      if(jmvloop.ge.1.and.jmvloop.le.2) then
        if(imvsequ.ge.1.and.imvsequ.le.nmvsequ(jmvloop)) then
          jrasf_ctl_ij=jrasf_ctl(imvsequ,jmvloop)
          jrasf_fmt_ij=jrasf_fmt(imvsequ,jmvloop)
!
          sxplog_lo_ij=dlog(dabs(sxplog_nlo(imvsequ,jmvloop))+1.d-40)
          sxplog_hi_ij=dlog(dabs(sxplog_nhi(imvsequ,jmvloop))+1.d-40)
          sxplin_lo_ij=sxplin_nlo(imvsequ,jmvloop)+1.d-40
          sxplin_hi_ij=sxplin_nhi(imvsequ,jmvloop)+1.d-40
        endif
      endif
!
      jrasf_ctl_log=-1
      jrasf_ctl_lin=-1
      if(jrasf_fmt_ij.eq.-1) then
        jrasf_ctl_log=jrasf_ctl_ij
        jrasf_ctl_lin=jrasf_ctl_ij
      endif
!
! generate and store log-conc. SFs, sxplog_ras
!
      if(jrasf_ctl_log.eq.-2) goto 490
!
      iodd=-1
      do kscal=1,nkscal
        c2sxplog=-1.d0
        c1sxplog=0.d0
!
        if(mscal_ks(kscal).le.0) then
          sxplog_ras(kscal)=0.d0
          goto 190
        endif
!
        if(jrasf_ctl_log.eq.-1) then
          sxplog_ras(kscal)=sxplog_chi(kscal)
          goto 190
        endif
!
        if(jrasf_ctl_log.eq.0) then
          sxplog_ras(kscal)=0.d0
          goto 190
        endif
!
        c2sxplog=chisq_g2u(kscal)+chisq_g2t(kscal)
        c1sxplog=chisq_g1u(kscal)+chisq_g1t(kscal)
!
        jinfin_rasf=0
        if(dsqrt(dabs(c2sxplog)).lt.1.d-20) then
          jinfin_rasf=1
          sxplog_avg=0.d0
        else
          sxplog_avg=-0.5d0*c1sxplog/c2sxplog
!!        if(sxplog_avg.gt.sxplog_hi_ij) then
!!          sxplog_avg=sxplog_hi_ij
!!          jinfin_rasf=2
!!        endif
!!        if(sxplog_avg.lt.sxplog_lo_ij) then
!!          sxplog_avg=sxplog_lo_ij
!!          jinfin_rasf=2
!!        endif
        endif
!
        if(jrasf_ctl_log.eq.1) then
          sxplog_ras(kscal)=sxplog_avg
          goto 190
        endif
!
!
        if(jrasf_ctl_log.eq.2) then
!DB090822
          if(jgauss.eq.0) then
!FB090822
            idum1=0
  110       continue
            idum1=idum1+1
            if(idum1.gt.100000) then
              sxplog_ras(kscal)=0.5d0*(sxplog_lo_ij+sxplog_hi_ij)
              goto 190
            endif
!           Better solution: use inv. error-function
!           to get exact truncated Gaussian distrib.
!           between lo and hi-limits
!
            iodd=-iodd
            if(iodd.eq.1) then
              r1=randx()
              r2=randx()
              r1=dsqrt(dabs(dlog(dabs(r1)+1.d-20)))
              rgauss=r1*dcos(pi2*r2)
            else
              rgauss=r1*dsin(pi2*r2)
            endif
!
            if(jinfin_rasf.eq.0) then
              sxplog_ras(kscal)=sxplog_avg                                 &
     &        +                 rgauss/dsqrt(dabs(c2sxplog))
              if(sxplog_ras(kscal).lt.sxplog_lo_ij) goto 110
              if(sxplog_ras(kscal).gt.sxplog_hi_ij) goto 110
            else
              sxplog_ras(kscal)=sxplog_avg
            endif
!DB090822
          else  ! jgauss|=0
            if(jinfin_rasf.eq.0) then
              ort2=dsqrt(dabs(2.d0*c2sxplog))
              zlo=(sxplog_lo_ij-sxplog_avg)*ort2
              zhi=(sxplog_hi_ij-sxplog_avg)*ort2
              jclev=0
              jpoiss=0
              if(zlo.gt.50.d0.or.zhi.lt.-50.d0) jpoiss=1
!
              call tgauss(zprob,zlo,zhi,jpoiss,jclev,jerrivn,jerrtg)
              if(jerrtg.gt.0.or.jerrivn.ne.0) then
                errtag='000110.001,jerrtg,jerrivn='
                call err_term
              endif
!
              sxplog_ras(kscal)=sxplog_avg+zprob/ort2
            else
              sxplog_ras(kscal)=sxplog_avg
            endif
          endif
!FB090822
          goto 190
        endif
!
  190   continue
        sxplog_ras_th(kscal)=sxplog_ras(kscal)
        c2sxplog_ras_th(kscal)=c2sxplog
        c1sxplog_ras_th(kscal)=c1sxplog
      enddo
!
!
! generate and store lin-conc. SFs, sxplin_ras
!
  490 continue
      if(jrasf_ctl_lin.eq.-2) goto 990
!
      iodd=-1
      do kscal=1,nkscal
        c2sxplin=-1.d0
        c1sxplin=0.d0
!
        if(mscal_ks(kscal).le.0) then
          sxplin_ras(kscal)=1.d0
          goto 590
        endif
!
        if(jrasf_ctl_lin.eq.-1) then
          sxplin_ras(kscal)=sxplin_chi(kscal)
          goto 590
        endif
!
        if(jrasf_ctl_lin.eq.0) then
          sxplin_ras(kscal)=1.d0
          goto 590
        endif
!
        c2sxplin=chisq_n2u(kscal)+chisq_n2t(kscal)
        c1sxplin=chisq_n1u(kscal)+chisq_n1t(kscal)
!
        jinfin_rasf=0
        if(dsqrt(dabs(c2sxplin)).lt.1.d-20) then
          jinfin_rasf=1
          sxplin_avg=1.d0
        else
          sxplin_avg=-0.5d0*c1sxplin/c2sxplin
!!        if(sxplin_avg.gt.sxplin_hi_ij) then
!!          sxplin_avg=sxplin_hi_ij
!!          jinfin_rasf=2
!!        endif
!!        if(sxplin_avg.lt.sxplin_lo_ij) then
!!          sxplin_avg=sxplin_lo_ij
!!          jinfin_rasf=2
!!        endif
        endif
!
        if(jrasf_ctl_lin.eq.1) then
          sxplin_ras(kscal)=sxplin_avg
          goto 590
        endif
!
!
        if(jrasf_ctl_lin.eq.2) then
!DB090822
          if(jgauss.eq.0) then
!FB090822
            idum1=0
  510       continue
            idum1=idum1+1
            if(idum1.gt.100000) then
              sxplin_ras(kscal)=0.5d0*(sxplin_lo_ij+sxplin_hi_ij)
              goto 590
            endif
!           Better solution: use inv. error-function
!           to get exact truncated Gaussian distrib.
!           between lo and hi-limits
!
            iodd=-iodd
            if(iodd.eq.1) then
              r1=randx()
              r2=randx()
              r1=dsqrt(dabs(dlog(dabs(r1)+1.d-20)))
              rgauss=r1*dcos(pi2*r2)
            else
              rgauss=r1*dsin(pi2*r2)
            endif
!
            if(jinfin_rasf.eq.0) then
              sxplin_ras(kscal)=sxplin_avg                                 &
     &        +                 rgauss/dsqrt(dabs(c2sxplin))
              if(sxplin_ras(kscal).lt.sxplin_lo_ij) goto 510
              if(sxplin_ras(kscal).gt.sxplin_hi_ij) goto 510
            else
              sxplin_ras(kscal)=sxplin_avg
            endif
!DB090822
          else  ! jgauss|=0
            if(jinfin_rasf.eq.0) then
              ort2=dsqrt(dabs(2.d0*c2sxplin))
              zlo=(sxplin_lo_ij-sxplin_avg)*ort2
              zhi=(sxplin_hi_ij-sxplin_avg)*ort2
              jclev=0
              jpoiss=0
              if(zlo.gt.50.d0.or.zhi.lt.-50.d0) jpoiss=1
!
              call tgauss(zprob,zlo,zhi,jpoiss,jclev,jerrivn,jerrtg)
              if(jerrtg.gt.0.or.jerrivn.ne.0) then
                errtag='000110.002,jerrtg,jerrivn='
                call err_term
              endif
!
              sxplin_ras(kscal)=sxplin_avg+zprob/ort2
            else
              sxplin_ras(kscal)=sxplin_avg
            endif
          endif
!FB090822
          goto 590
        endif
!
  590   continue
        sxplin_ras_th(kscal)=sxplin_ras(kscal)
        c2sxplin_ras_th(kscal)=c2sxplin
        c1sxplin_ras_th(kscal)=c1sxplin
      enddo
!
!
  990 continue
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine chi_acct
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! accumulates exptl. data points into partial chisq,
! and data pt. counts mxpt:
! a) by exptl. time:              chisq_tx,   mdtin_tx
! b) by meas. species:            chisq_ms,   mdtin_ms
! c) by expt.:                    chisq_xp,   mdtin_xp
! d) by expt. and meas. species:  chisq_msxp, mdtin_msxp
! using unit (1.d0) data weight modif.factors
! for exptl.-time model log-conc. "yspec_chi"
! and exptl. data log-conc. "yspec_xpt"
! with exptl. error  width "yspec_wid"
!
      if(jo_th_wg.eq.0) return
!
      if((jo_th_wg.eq.2).or.(jo_th_wg.eq.3)) then
        do iexpt=1,nexpt
          do ims=1,nms_spec
            chisq_msxp(ims,iexpt)=0.d0
            fwgt_msxp(ims,iexpt)=0.d0
            mdtin_msxp(ims,iexpt)=0
          enddo
        enddo
!
        do iexpt=1,nexpt
          chisq_xp(iexpt)=0.d0
          fwgt_xp(iexpt)=0.d0
          mdtin_xp(iexpt)=0
        enddo
!
        do ims=1,nms_spec
          chisq_ms(ims)=0.d0
          fwgt_ms(ims)=0.d0
          mdtin_ms(ims)=0
        enddo
      endif
!
      if((jo_th_wg.eq.1).or.(jo_th_wg.eq.3)) then
        do itxpt=1,ntxpt
          chisq_tx(itxpt)=0.d0
          fwgt_tx(itxpt)=0.d0
          mdtin_tx(itxpt)=0
        enddo
      endif
!
!
      do iexpt=1,nexpt
        do ims=1,nms_spec
          ispec=ispec_ms(ims)
!
          if(jmsspec_px(ispec).eq.0) then
            do itmx=itmx_ini(ims,iexpt),itmx_fin(ims,iexpt)
              if(jmsspec_ch(ispec).eq.1) then
                dchi2=                                                  &
     &          +(                                                      &
     &            (                                                     &
     &             yspec_chi(itmx)                                      &
     &            +sxplog_ras(kscal_xpt(itmx))                          &
     &            -yspec_xpt(itmx)                                      &
     &            )                                                     &
     &            /yspec_wid(itmx)                                      &
     &           )**2
              endif
              if(jmsspec_ch(ispec).eq.2) then
                dchi2=                                                  &
     &          +(                                                      &
     &            (                                                     &
     &             xspec_chi(itmx)                                      &
     &            *sxplin_ras(kscal_xpt(itmx))                          &
     &            -xspec_xpt(itmx)                                      &
     &            )                                                     &
     &            /xspec_wid(itmx)                                      &
     &           )**2
              endif
!
              if(jo_th_wg.eq.1.or.jo_th_wg.eq.3) then
                itxpt=itxpt_tmx(itmx)
                chisq_tx(itxpt)=chisq_tx(itxpt)+dchi2
                fwgt_tx(itxpt)=fwgt_tx(itxpt)+fwgt(itmx)
                mdtin_tx(itxpt)=mdtin_tx(itxpt)+1
              endif
!
              if(jo_th_wg.eq.2.or.jo_th_wg.eq.3) then
                chisq_ms(ims)=chisq_ms(ims)+dchi2
                fwgt_ms(ims)=fwgt_ms(ims)+fwgt(itmx)
                mdtin_ms(ims)=mdtin_ms(ims)+1
!
                chisq_xp(iexpt)=chisq_xp(iexpt)+dchi2
                fwgt_xp(iexpt)=fwgt_xp(iexpt)+fwgt(itmx)
                mdtin_xp(iexpt)=mdtin_xp(iexpt)+1
!
                chisq_msxp(ims,iexpt)=chisq_msxp(ims,iexpt)+dchi2
                fwgt_msxp(ims,iexpt)=fwgt_msxp(ims,iexpt)+fwgt(itmx)
                mdtin_msxp(ims,iexpt)=mdtin_msxp(ims,iexpt)+1
              endif
            enddo
          endif
!
          if(jmsspec_px(ispec).eq.1) then
            do itmx=itmx_ini(ims,iexpt),itmx_fin(ims,iexpt)
              itxpt=itxpt_tmx(itmx)
              iipch0=iipch_tmx(itmx)
              iipch1=iipch0+1
              zspec0=zspec_ipch(iipch0)                                 &
     &             +(zspec_ipch(iipch1)-zspec_ipch(iipch0))             &
     &             *rt_xpt(itxpt)
!
              if(jmsspec_ch(ispec).eq.1) then
                dchi2=                                                  &
     &          +(                                                      &
     &            (                                                     &
     &             zspec0                                               &
     &            +sxplog_ras(kscal_xpt(itmx))                          &
     &            -yspec_xpt(itmx)                                      &
     &            )                                                     &
     &            /yspec_wid(itmx)                                      &
     &           )**2
              endif
!
              if(jmsspec_ch(ispec).eq.2) then
                dchi2=                                                  &
     &          +(                                                      &
     &            (                                                     &
     &             zspec0                                               &
     &            *sxplin_ras(kscal_xpt(itmx))                          &
     &            -xspec_xpt(itmx)                                      &
     &            )                                                     &
     &            /xspec_wid(itmx)                                      &
     &           )**2
              endif
!
              if(jo_th_wg.eq.1.or.jo_th_wg.eq.3) then
!c              itxpt=itxpt_tmx(itmx)
                chisq_tx(itxpt)=chisq_tx(itxpt)+dchi2
                fwgt_tx(itxpt)=fwgt_tx(itxpt)+fwgt(itmx)
                mdtin_tx(itxpt)=mdtin_tx(itxpt)+1
              endif
!
              if(jo_th_wg.eq.2.or.jo_th_wg.eq.3) then
                chisq_ms(ims)=chisq_ms(ims)+dchi2
                fwgt_ms(ims)=fwgt_ms(ims)+fwgt(itmx)
                mdtin_ms(ims)=mdtin_ms(ims)+1
!
                chisq_xp(iexpt)=chisq_xp(iexpt)+dchi2
                fwgt_xp(iexpt)=fwgt_xp(iexpt)+fwgt(itmx)
                mdtin_xp(iexpt)=mdtin_xp(iexpt)+1
!
                chisq_msxp(ims,iexpt)=chisq_msxp(ims,iexpt)+dchi2
                fwgt_msxp(ims,iexpt)=fwgt_msxp(ims,iexpt)+fwgt(itmx)
                mdtin_msxp(ims,iexpt)=mdtin_msxp(ims,iexpt)+1
              endif
            enddo
          endif
        enddo
      enddo
!
      return
!
      if(jo_th_wg.eq.1.or.jo_th_wg.eq.3) then
        do itxpt=1,ntxpt
          if(mdtin_tx(itxpt).gt.0) then
            chisq_tx(itxpt)=                                            &
     &      chisq_tx(itxpt)/(1.d0)
!c   :      chisq_tx(itxpt)/(1.d0*mdtin_tx(itxpt))
          else
            chisq_tx(itxpt)=-1.d0
          endif
        enddo
      endif
!
      if(jo_th_wg.eq.2.or.jo_th_wg.eq.3) then
        do ims=1,nms_spec
          if(mdtin_ms(ims).gt.0) then
            chisq_ms(ims)=                                              &
     &      chisq_ms(ims)/(1.d0)
!c   :      chisq_ms(ims)/(1.d0*mdtin_ms(ims))
          else
            chisq_ms(ims)=-1.d0
          endif
        enddo
!
        do iexpt=1,nexpt
          if(mdtin_xp(iexpt).gt.0) then
            chisq_xp(iexpt)=                                            &
     &      chisq_xp(iexpt)/(1.d0)
!c   :      chisq_xp(iexpt)/(1.d0*mdtin_xp(iexpt))
          else
            chisq_xp(iexpt)=-1.d0
          endif
        enddo
!
        do iexpt=1,nexpt
          do ims=1,nms_spec
            if(mdtin_msxp(ims,iexpt).gt.0) then
              chisq_msxp(ims,iexpt)=                                    &
     &        chisq_msxp(ims,iexpt)/(1.d0)
!c   :        chisq_msxp(ims,iexpt)/(1.d0*mdtin_msxp(ims,iexpt))
            else
              chisq_msxp(ims,iexpt)=-1.d0
            endif
          enddo
        enddo
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine chi_zero
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! zeroes scale factor accumulators
!
        do iscal=1,niscal
          chi2_is(iscal)=0.d0
          chi1_is(iscal)=0.d0
!c        chi0_is(iscal)=1.d-20
        enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine chi_scal
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! calculates exptl. data rescaling factors and
! chisq of log-concentrations
! (Note: If chisq of lin-concentrations is to be used
! for the ensemble weight then chisq will be re-calculated
! accordingly later on
!
! input: chi2_is, chi1_is, chi0_is
! output: chisq, sxplog_is, sxplog_ks
!         sxplog_chi, sxplin_chi
!
!
        chisq=0.d0
        do kscal=1,nkscal
          chi2_ks(kscal)=0.d0
          chi1_ks(kscal)=0.d0
          chi0_ks(kscal)=0.d0
        enddo
!
        do iscal=1,niscal
          chi2_ks(kscal_is(iscal))=                                     &
     &    chi2_ks(kscal_is(iscal))                                      &
     &   +chi2_is(iscal)
!
          chi1_ks(kscal_is(iscal))=                                     &
     &    chi1_ks(kscal_is(iscal))                                      &
     &   +chi1_is(iscal)
!
          chi0_ks(kscal_is(iscal))=                                     &
     &    chi0_ks(kscal_is(iscal))                                      &
     &   +chi0_is(iscal)
        enddo
!
        do iscal=1,niscal
          sxplog_is(iscal)=                                             &
     &    chi1_is(iscal)/chi0_ks(kscal_is(iscal))
        enddo
!
        chisq=0.d0
        do kscal=1,nkscal
          chisq=chisq+chi2_ks(kscal)
!
          if(mscal_ks(kscal).gt.0)                                      &
     &    chisq=chisq                                                   &
     &    -chi1_ks(kscal)**2/chi0_ks(kscal)
!
          sxplog_ks(kscal)=                                             &
     &    chi1_ks(kscal)/chi0_ks(kscal)
!
          sxplog_chi(kscal)=0.d0
          if(mscal_ks(kscal).gt.0)                                      &
     &    sxplog_chi(kscal)=sxplog_ks(kscal)
!
          sxplin_chi(kscal)=dexp(sxplog_chi(kscal))
        enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine chi_htot
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! calculates total ensemble weight "energy" function "htot"
! including xspec_max, xspec_min boundary contact energies
! and freq.-filtering Fourier weight energies
!
      call hbx_accu
!
      hwall=hbxx+hbxn
!
      call hft_accu
!
      hfour=hfous+hfout
!
      htot=chisq+hwall+hfour
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine hbx_accu
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! calculates model conc. boundary contact energy
! from solution of kin. rate eq. model
!
! Note:
! qbx[x,n](ivs), ivs=1,...nvs_spec:
!   =boundary contact fraction for (variable) species no. "ivs"
! qbx[x,n](0), ivs=0
!   =boundary contact fraction averaged over all
!    species ivs=1,...nvs_spec
!
       qbxx(0)=0.d0
       qbxn(0)=0.d0
!
       do ivs=1,nvs_spec
         qbxx(ivs)=0.d0
         qbxn(ivs)=0.d0
!
!cc      if(jmvloop.gt.0) then
!cc        if(jbxx_nf(imvsequ,jmvloop).le.0) goto 100
!cc        jbx_qb0=jbxx_qb(imvsequ,jmvloop)
!cc      else
!cc        jbx_qb0=1
!cc        if(nmvsequ(1).gt.0) then
!cc          if(jbxx_nf(1,1).le.0) goto 100
!cc          jbx_qb0=jbxx_qb(1,1)
!cc        else
!cc          if(nmvsequ(2).gt.0) then
!cc            if(jbxx_nf(1,2).le.0) goto 100
!cc            jbx_qb0=jbxx_qb(1,2)
!cc          endif
!cc        endif
!cc      endif
!
         if(jbxx_nf_imv.le.0) goto 100
         jbx_qb0=jbxx_qb_imv
!
         do iexpt=1,nexpt
           do ibx_time=1,nbx_time
             qbxx(ivs)=qbxx(ivs)                                        &
     &                +dqbx(yspec_qbx(ivs,ibx_time,iexpt)               &
     &                     ,ybxx_lo(ivs)                                &
     &                     ,ybxx_ct(ivs)                                &
     &                     ,ybxx_hi(ivs)                                &
     &                     ,sbxx(ivs)                                   &
     &                     ,jbx_qb0                                     &
     &                     )
           enddo
         enddo
  100    continue
!
!
!cc      if(jmvloop.gt.0) then
!cc        if(jbxn_nf(imvsequ,jmvloop).le.0) goto 200
!cc        jbx_qb0=jbxn_qb(imvsequ,jmvloop)
!cc      else
!cc        jbx_qb0=1
!cc        if(nmvsequ(1).gt.0) then
!cc          if(jbxn_nf(1,1).le.0) goto 200
!cc          jbx_qb0=jbxn_qb(1,1)
!cc        else
!cc          if(nmvsequ(2).gt.0) then
!cc            if(jbxn_nf(1,2).le.0) goto 200
!cc            jbx_qb0=jbxn_qb(1,2)
!cc          endif
!cc        endif
!cc      endif
!
         if(jbxn_nf_imv.le.0) goto 200
         jbx_qb0=jbxn_qb_imv
!
         do iexpt=1,nexpt
           do ibx_time=1,nbx_time
             y_qbx=-yspec_qbx(ivs,ibx_time,iexpt)
             y_lo=-ybxn_hi(ivs)
             y_ct=-ybxn_ct(ivs)
             y_hi=-ybxn_lo(ivs)
!
             qbxn(ivs)=qbxn(ivs)                                        &
     &                +dqbx(y_qbx                                       &
     &                     ,y_lo                                        &
     &                     ,y_ct                                        &
     &                     ,y_hi                                        &
     &                     ,sbxn(ivs)                                   &
     &                     ,jbx_qb0                                     &
     &                     )
!
!cc  1                +dqbx(-yspec_qbx(ivs,ibx_time,iexpt)
!cc  1                     ,-ybxn_hi(ivs)
!cc  1                     ,-ybxn_ct(ivs)
!cc  1                     ,-ybxn_lo(ivs)
!cc  1                     ,sbxn(ivs)
!cc  1                     ,jbx_qb0
!cc  1                     )
!
           enddo
         enddo
  200    continue
!
        qbxx(ivs)=qbxx(ivs)*onbx_time
        qbxn(ivs)=qbxn(ivs)*onbx_time
!
        qbxx(0)=qbxx(0)+qbxx(ivs)
        qbxn(0)=qbxn(0)+qbxn(ivs)
      enddo
!
      qbxx(0)=qbxx(0)/nvs_spec
      qbxn(0)=qbxn(0)/nvs_spec
!
!
      hbxx=0.d0
      hbxn=0.d0
      do ivs=0,nvs_spec
        hbxx=hbxx+fbxx(ivs)*qbxx(ivs)
        hbxn=hbxn+fbxn(ivs)*qbxn(ivs)
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine hft_accu
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
!
      include 'ens.def'
!
! Fourier weight energy contribution to htot
! from solution of kin. rate eq.
!
!
      hfous=0.d0
      hfout=0.d0
!
      if(jsft_mc_imv.lt.0) return
!
      do iexpt=1,nexpt
        do isegft=1,nsegft(iexpt)
          pfour_seg(isegft,iexpt)=0.d0
          qfour_seg(isegft,iexpt)=0.d0
          nfour_seg=0
!
          do is_ft=1,nsft_spec
            if(                                                         &
     &      pfour_sfil(is_ft,isegft,iexpt).gt.0.d0.and.                 &
     &      pfour_stot(is_ft,isegft,iexpt).gt.0.d0) then
              nfour_seg=nfour_seg+1
!
              if(jsft_pf_imv.eq.0.or.jsft_pf_imv.eq.2) then
                pfour_seg(isegft,iexpt)=                                &
     &          pfour_seg(isegft,iexpt)                                 &
     &          +pfour_sfil(is_ft,isegft,iexpt)                         &
     &          *gfour_spec(ispec_sft(is_ft),isegft,iexpt)
!
                qfour_seg(isegft,iexpt)=                                &
     &          qfour_seg(isegft,iexpt)                                 &
     &          +dsqrt(dabs(pfour_sfil(is_ft,isegft,iexpt)              &
     &                     *gfour_spec(ispec_sft(is_ft),isegft,iexpt)))
              endif
!
              if(jsft_pf_imv.eq.1.or.jsft_pf_imv.eq.3) then
                pfour_seg(isegft,iexpt)=                                &
     &          pfour_seg(isegft,iexpt)                                 &
     &          +(pfour_sfil(is_ft,isegft,iexpt)                        &
     &           /pfour_stot(is_ft,isegft,iexpt))                       &
     &          *gfour_spec(ispec_sft(is_ft),isegft,iexpt)
!
                qfour_seg(isegft,iexpt)=                                &
     &          qfour_seg(isegft,iexpt)                                 &
     &          +dsqrt(dabs((pfour_sfil(is_ft,isegft,iexpt)             &
     &                      /pfour_stot(is_ft,isegft,iexpt))            &
     &                     *gfour_spec(ispec_sft(is_ft),isegft,iexpt)))
              endif
            endif
          enddo
!
          hfous=hfous                                                   &
     &         +ffour_imv*pfour_seg(isegft,iexpt)
!
          if(nfour_seg.gt.0) then
            qfour_seg(isegft,iexpt)=                                    &
     &      qfour_seg(isegft,iexpt)**2/(1.d0*nfour_seg)
          endif
!
          if(nfour_seg.gt.0.and.jsft_pf_imv.ge.2) then
            hfout=hfout                                                 &
     &           +efour_imv                                             &
     &           *(pfour_seg(isegft,iexpt)-qfour_seg(isegft,iexpt))
          endif
        enddo
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine kin_xpt
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! interpolates and/or stores model log- or lin.-conc. at or near
! exptl. time points from solution of kin. rate eq. model
!
      do ims=1,nms_spec
        ispec=ispec_ms(ims)
        ispecB=ispec_ms(ims)
!
!       Note: Must use kin-evolved model prediction for "xspec"
!       in calculating \chi^2, hence: ...
!c      if(jkrxdi.ge.1.and.jkrxdi.le.9                                  &
!c   &  .and.ispecX_spec(ispec,iexpt).gt.0)                             &
!c   &  ispec=ispecX_spec(ispec,iexpt)
!
        if(jmsspec_px(ispecB).eq.0) then
          if(                                                           &
     &    (jtime.ne.11.and.jtime.ne.21                                  &
     &    .and.jtime.ne.19.and.jtime.ne.119.and.jtime.ne.219            &
     &    .and.jtime.ne.111.and.jtime.ne.121                            &
     &    .and.jtime.ne.211.and.jtime.ne.221)                           &
!N180810
     &    .or.(jfix(ispecB).eq.-100.or.jfix(ispecB).eq.-110)            &
     &    )then
            do itmx=itmx_ini(ims,iexpt),itmx_fin(ims,iexpt)
              itxpt=itxpt_tmx(itmx)
              itlo=itime_xpt(itxpt)
              ithi=itlo+1
              if(                                                       &
     &        jmsspec_ip(ispecB).eq.0.or.                               &
     &        jmsspec_ip(ispecB).eq.2                                   &
     &        )then
                xspec_chi(itmx)=                                        &
     &          xspec(ispec,itlo)                                       &
     &          +(xspec(ispec,ithi)-xspec(ispec,itlo))                  &
     &          *rt_xpt(itxpt)
                goto 19
              endif
!
              if(jmsspec_ip(ispecB).eq.1) then
                xspec_chi(itmx)=                                        &
     &          xspec(ispec,itlo)                                       &
     &          *(dabs(xspec(ispec,ithi)/xspec(ispec,itlo)))            &
     &          **rt_xpt(itxpt)
              endif
!
   19         continue
              yspec_chi(itmx)=dlog(dabs(xspec_chi(itmx)))
            enddo
          else
            do itmx=itmx_ini(ims,iexpt),itmx_fin(ims,iexpt)
              yspec_chi(itmx)=dlog(dabs(xspec_chi(itmx)))
            enddo
          endif
        endif
!
!
        if(jmsspec_px(ispecB).eq.1) then
          if(jmsspec_ch(ispecB).eq.1) then
            do iipch=iipch_ini(ims,iexpt),iipch_fin(ims,iexpt)
              zspec_ipch(iipch)=                                        &
     &        dlog(dabs(xspec(ispec,itime_ipch(iipch))))
            enddo
          endif
          if(jmsspec_ch(ispecB).eq.2) then
            do iipch=iipch_ini(ims,iexpt),iipch_fin(ims,iexpt)
              zspec_ipch(iipch)=                                        &
     &        xspec(ispec,itime_ipch(iipch))
            enddo
          endif
        endif
      enddo
!
! For jmty(imvsequ,jmvloop)=Gibbs sampler update of deconv. amplitudes:
! Evaluate interpolated real-species conc.
!     X_s(e,t) at exptl. obs. times (itxpt,ispec,iexpt)
! of the corresp. pseudo-species child(ren)
!
! Note:
! Sending of imvsequ,jmvloop to Sv included
! already, in iexpt-send package, see:
!        subrt. mpm_pak_theta
!        subrt. mps_upk_theta
!
      jmty_ij=-1
      if(jmvloop.ge.1.and.jmvloop.le.2) then
        if(imvsequ.ge.1.and.imvsequ.le.nmvsequ(jmvloop)) then
          jmty_ij=jmty(imvsequ,jmvloop)
        endif
      endif
!
      if(jmty_ij.eq.20) then
        do itsxdc=itsxdc_inixp(iexpt),itsxdc_finxp(iexpt)
          irspec=irspec_tsxdc(itsxdc)
          itxpt=itxpt_tsxdc(itsxdc)
          itlo=itime_xpt(itxpt)
          ithi=itlo+1
!
!     for jmsspec_ip(ipspec)=1:
          xspec_tsxdc(1,itsxdc)=                                     &
     &    xspec(irspec,itlo)                                         &
     &    *(dabs(xspec(irspec,ithi)/xspec(irspec,itlo)))             &
     &    **rt_xpt(itxpt)
!
!     for jmsspec_ip(ipspec)=0 or jmsspec_ip(ipspec)=2:
          xspec_tsxdc(2,itsxdc)=                                     &
     &    xspec(irspec,itlo)                                         &
     &    +(xspec(irspec,ithi)-xspec(irspec,itlo))                   &
     &    *rt_xpt(itxpt)
        enddo !itsxdc
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine kin_qbx
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! stores model conc. and log-conc. at boundary check time points,
! from solution of kin. rate eq. model
!
      do ibx_time=1,nbx_time
        itlo=itime_bx(ibx_time)
        ithi=itlo+1
        do ivs=1,nvs_spec
          ispec=ispec_vs(ivs)
!
!        Note: Must use kin-evolved model prediction for "xspec"
!         in calculating \chi^2, hence: ...
!c        if(jkrxdi.ge.1.and.jkrxdi.le.9                                &
!c   &    .and.ispecX_spec(ispec,iexpt).gt.0)                           &
!c   &    ispec=ispecX_spec(ispec,iexpt)
!
          xspec_qbx=                                                    &
     &     xspec(ispec,itlo)                                            &
     &    +(xspec(ispec,ithi)-xspec(ispec,itlo))*rt_qbx(ibx_time)
!
          yspec_qbx(ivs,ibx_time,iexpt)=dlog(dabs(xspec_qbx))
        enddo
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine kin_four
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! calculates freq.-filtered Fourier weights for FT-selected species
! from solution of kin. rate eq. model
!
      if(jsft_mc_imv.lt.0) return
!
!
      isig_ft=+1
        do isegft=1,nsegft(iexpt)
          nft_htime=nft_time(isegft,iexpt)/2
          onft_time=1.d0/(1.d0*nft_time(isegft,iexpt)+1.d-20)
          o2nft_time=1.d0/(1.d0*nft_time(isegft,iexpt)+1.d-20)**2
!
          iodd=2
          do is_ft=1,nsft_spec
            ispec=ispec_sft(is_ft)
!
!c          if(jkrxdi.ge.1.and.jkrxdi.le.8                              &
!c   &      .and.ispecX_spec(ispec,iexpt).gt.0)                         &
!c   &      ispec=ispecX_spec(ispec,iexpt)
!
            iodd=3-iodd
!           (Note: iodd=1,2,1,2,1,2,...)
!
            if(iodd.eq.1) is_ft1=is_ft
!
            pfour_stot(is_ft,isegft,iexpt)=-1.d0
!
            do ift_time=0,nft_time(isegft,iexpt)
              itlo=itime_ft(ift_time,isegft,iexpt)
              ithi=itlo+1
!
              xspec_FT(ift_time)=                                       &
     &        xspec(ispec,itlo)                                         &
     &        +(xspec(ispec,ithi)-xspec(ispec,itlo))                    &
     &       *rt_ft(ift_time,isegft,iexpt)
            enddo
!
            if(jsft_ln_imv.eq.0) then
              dyspec_fft=                                               &
     &        (xspec_FT(nft_time(isegft,iexpt))                         &
     &                   -xspec_FT(0)         )                         &
     &                  *onft_time
!
              do ift_time=0,(nft_time(isegft,iexpt)-1)
                yspec_fft(2*ift_time+iodd)=                             &
     &          xspec_FT(ift_time)                                      &
     &          -(ift_time-nft_htime)*dyspec_fft
              enddo
            endif
!
            if(jsft_ln_imv.eq.1) then
              dyspec_fft=                                               &
     &        dlog(dabs( xspec_FT(nft_time(isegft,iexpt))               &
     &                 / xspec_FT(0)                                    &
     &            )    )                                                &
     &                  *onft_time
!
              do ift_time=0,(nft_time(isegft,iexpt)-1)
                yspec_fft(2*ift_time+iodd)=                             &
     &          dlog( dabs(xspec_FT(ift_time) ) )                       &
     &          -(ift_time-nft_htime)*dyspec_fft
              enddo
            endif
!
            if(iodd.eq.2.or.is_ft.eq.nsft_spec) then
              if(iodd.eq.1) then
                do ift_time=0,(nft_time(isegft,iexpt)-1)
                  yspec_fft(2*ift_time+2)=0.d0
                enddo
              endif
!
              call four1(yspec_fft,nft_time(isegft,iexpt),isig_ft)
!
              if(iodd.eq.2) then
                pfour_sfil(is_ft1,isegft,iexpt)=0.d0
                pfour_sfil(is_ft ,isegft,iexpt)=0.d0
                do ifil_frq=1,nfil_frq(isegft,iexpt)
                  iftp=ift_freq_fil(ifil_frq,isegft,iexpt)
                  iftm=nft_time(isegft,iexpt)-iftp
                  if(iftp.eq.0) iftm=0
                  y1re= (yspec_fft(2*iftp+1)+yspec_fft(2*iftm+1))
                  y1im= (yspec_fft(2*iftp+2)-yspec_fft(2*iftm+2))
                  y2re= (yspec_fft(2*iftp+2)+yspec_fft(2*iftm+2))
                  y2im=-(yspec_fft(2*iftp+1)-yspec_fft(2*iftm+1))
!
                  pfour_sfil(is_ft1,isegft,iexpt)=                      &
     &            pfour_sfil(is_ft1,isegft,iexpt)                       &
     &            +(y1re**2+y1im**2)                                    &
     &             *wfour_sfil(ifil_frq,isegft,iexpt)
!
                  pfour_sfil(is_ft ,isegft,iexpt)=                      &
     &            pfour_sfil(is_ft ,isegft,iexpt)                       &
     &            +(y2re**2+y2im**2)                                    &
     &             *wfour_sfil(ifil_frq,isegft,iexpt)
                enddo
!
                pfour_sfil(is_ft1,isegft,iexpt)=                        &
     &          0.25d0*pfour_sfil(is_ft1,isegft,iexpt)                  &
     &          *o2nft_time
!
                pfour_sfil(is_ft ,isegft,iexpt)=                        &
     &          0.25d0*pfour_sfil(is_ft ,isegft,iexpt)                  &
     &          *o2nft_time
!
                ift0=0
                ifth=nft_htime
                pfour_stot(is_ft1,isegft,iexpt)=                        &
     &          2.0d0*(yspec_fft(2*ift0+1)**2                           &
     &                +yspec_fft(2*ifth+1)**2)
                pfour_stot(is_ft ,isegft,iexpt)=                        &
     &          2.0d0*(yspec_fft(2*ift0+2)**2                           &
     &                +yspec_fft(2*ifth+2)**2)
!
                do ift_freq=1,(nft_htime-1)
                  iftp=ift_freq
                  iftm=nft_time(isegft,iexpt)-iftp
!
                  y1re= (yspec_fft(2*iftp+1)+yspec_fft(2*iftm+1))
                  y1im= (yspec_fft(2*iftp+2)-yspec_fft(2*iftm+2))
                  y2re= (yspec_fft(2*iftp+2)+yspec_fft(2*iftm+2))
                  y2im=-(yspec_fft(2*iftp+1)-yspec_fft(2*iftm+1))
!
                  pfour_stot(is_ft1,isegft,iexpt)=                      &
     &            pfour_stot(is_ft1,isegft,iexpt)                       &
     &            +y1re**2+y1im**2
!
                  pfour_stot(is_ft ,isegft,iexpt)=                      &
     &            pfour_stot(is_ft ,isegft,iexpt)                       &
     &            +y2re**2+y2im**2
                enddo
!
                pfour_stot(is_ft1,isegft,iexpt)=                        &
     &          0.5d0*pfour_stot(is_ft1,isegft,iexpt)                   &
     &          *o2nft_time
!
                pfour_stot(is_ft ,isegft,iexpt)=                        &
     &          0.5d0*pfour_stot(is_ft ,isegft,iexpt)                   &
     &          *o2nft_time
              else
                pfour_sfil(is_ft ,isegft,iexpt)=0.d0
                do ifil_frq=1,nfil_frq(isegft,iexpt)
                  iftp=ift_freq_fil(ifil_frq,isegft,iexpt)
                  iftm=nft_time(isegft,iexpt)-iftp
                  if(iftp.eq.0) iftm=0
                  y1re= (yspec_fft(2*iftp+1)                            &
     &                  +yspec_fft(2*iftm+1))
                  y1im= (yspec_fft(2*iftp+2)                            &
     &                  -yspec_fft(2*iftm+2))
!
                  pfour_sfil(is_ft ,isegft,iexpt)=                      &
     &            pfour_sfil(is_ft ,isegft,iexpt)                       &
     &            +(y1re**2+y1im**2)                                    &
     &             *wfour_sfil(ifil_frq,isegft,iexpt)
                enddo
!
                pfour_sfil(is_ft ,isegft,iexpt)=                        &
     &          0.25d0*pfour_sfil(is_ft ,isegft,iexpt)                  &
     &          *o2nft_time
!
                ift0=0
                ifth=nft_htime
                pfour_stot(is_ft ,isegft,iexpt)=                        &
     &          2.0d0*(yspec_fft(2*ift0+1)**2                           &
     &                +yspec_fft(2*ifth+1)**2)
!
                do ift_freq=1,(nft_htime-1)
                  iftp=ift_freq
                  iftm=nft_time(isegft,iexpt)-iftp
!
                  y1re= (yspec_fft(2*iftp+1)+yspec_fft(2*iftm+1))
                  y1im= (yspec_fft(2*iftp+2)-yspec_fft(2*iftm+2))
!
                  pfour_stot(is_ft ,isegft,iexpt)=                      &
     &            pfour_stot(is_ft ,isegft,iexpt)                       &
     &            +y1re**2+y1im**2
                enddo
!
                pfour_stot(is_ft ,isegft,iexpt)=                        &
     &          0.5d0*pfour_stot(is_ft ,isegft,iexpt)                   &
     &          *o2nft_time
              endif
            endif
          enddo
        enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine kin_xspec_o
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! stores model conc. and log-conc. at exptl. time points and
! model-output time points, from solution of kin. rate eq. model
!
! Note:
!   jo_xdi=0: Use for regular, unforced kinetics; jkrxdi=0;
!     store t-dep. concentrations "xspec" in regular,
!     intra-bounds (1=< ispec =<  nspec) "xspec_o"-locations
!   jo_xdi=1: Use for exptl. insertion-forced kinetics; jkrxdi>=1;
!     Do store _Kin-Evolved_ t-dep. species concentrations (KEV) in
!     regular intra-bounds (ispec=< nspec) "xspec_o"-locations.
!     Do Not store _Insert-Forced_ t-dep. species concentrations (XDI).
!   jo_xdi=2: Use for exptl. insertion-forced kinetics; jkrxdi>=1.
!     Do store _Insert-Forced_ t-dep. species concentrations (XDI)
!     in regular (ispec=< nspec) "xspec_o"-locations.
!     Do Not store _Kin-Evolved_ t-dep. species concentrations (KEV).
!   jo_xdi=3: Use for exptl. insertion-forced kinetics; jkrxdi>=1.
!     Do store _Kin-Evolved_ t-dep. species concentrations (KEV) in
!     regular intra-bounds (ispec=< nspec) "xspec_o"-locations.
!     Do store _Insert-Forced_ t-dep. species concentrations (XDI)
!     in extra-bounds (nspec+1 =< ispec =< nspec+nsxdi_spec)
!     "xspec_o"-locations. Note that the "xspec_o" / "yspec_o"-storage
!     of XDI and KEV data is a "switch" from their "xspec"-storage
!     used internally, in "kin_sol_*": in "xspec"-storage XDI-data are
!     stored intra-bound (ispec=<nspec) and KEV-data are stored
!     extra-bound (ispec>nspec).
!
      do io_time=1,no_time
        itime=itime_o(io_time)
        itxpt=itxpt_o(io_time)
!
        itlo=itime
        ithi=itlo+1
!
        do ispecB=1,nspec
          ispec=ispecB
          ims=ims_spec(ispecB)
!
          if(jfix(ispec).ge.1) then
            if(jfix(ispec).ge.5000) then
              if(itxpt.gt.0) then
                time_i=time_xpt(itxpt)
              else
                time_i=time_itim(itime)
              endif
!
              xspec_o(ispecB,io_time,iexpt)=                                  &
     &        fspec_ti(                                                 &
     &                 time_i,jfix,ispec,xspec_min,xspec_max            &
     &                ,npulse,nperiod                                   &
     &                ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod    &
     &                ,nspec_x,npmspec_x                                &
     &                )
            else
              if(itxpt.gt.0) then
                if(                                                     &
     &          jmsspec_ip(ispecB).eq.0.or.                             &
     &          jmsspec_ip(ispecB).eq.2)                                &
     &          xspec_o(ispecB,io_time,iexpt)=                                &
     &           xspec(ispec,itlo)                                      &
     &          +(xspec(ispec,ithi)-xspec(ispec,itlo))                  &
     &           *rt_xpt(itxpt)
!
                if(                                                     &
     &          jmsspec_ip(ispecB).eq.1)                                &
     &          xspec_o(ispecB,io_time,iexpt)=                                &
     &           xspec(ispec,itlo)                                      &
     &          *dabs((xspec(ispec,ithi)/xspec(ispec,itlo)))            &
     &           **rt_xpt(itxpt)
              else
                xspec_o(ispecB,io_time,iexpt)=                                &
     &          xspec(ispec,itime)
              endif
            endif
!
            yspec_o(ispecB,io_time,iexpt)=                                    &
     &      dloyy(dabs(xspec_o(ispecB,io_time,iexpt)),1.d-30)
!
            goto 89
          endif
!
!c        if(jkrxdi.ge.1.and.jkrxdi.le.9.and.jo_xdi.eq.1                &
!c   &    .and.ispecX_spec(ispecB,iexpt).gt.0) then
!c          ispec=ispecX_spec(ispecB,iexpt)
!c        endif
!
          if(itxpt.gt.0) then
            if(                                                         &
     &      (jtime.eq.11.or.jtime.eq.111.or.jtime.eq.211                &
!db
     &      .or.jtime.eq.19.or.jtime.eq.119.or.jtime.eq.219             &
!fb
     &      .or.jtime.eq.21.or.jtime.eq.121.or.jtime.eq.221)            &
     &      .and.ims.gt.0                                               &
     &      .and.itmx_xpt(ims,itxpt,iexpt).gt.0                         &
!N180810
     &      .and.(jfix(ispecB).ne.-100.and.jfix(ispecB).ne.-110)) then
              xspec_o(ispecB,io_time,iexpt)=                            &
     &        xspec_chi(itmx_xpt(ims,itxpt,iexpt))
            else
              if(                                                       &
     &        jmsspec_ip(ispecB).eq.0.or.                               &
     &        jmsspec_ip(ispecB).eq.2)                                  &
     &        xspec_o(ispecB,io_time,iexpt)=                                  &
     &        xspec(ispec,itlo)                                         &
     &        +(xspec(ispec,ithi)-xspec(ispec,itlo))                    &
     &        *rt_xpt(itxpt)
!
              if(                                                       &
     &        jmsspec_ip(ispecB).eq.1)                                  &
     &        xspec_o(ispecB,io_time,iexpt)=                                  &
     &        xspec(ispec,itlo)                                         &
     &        *dabs((xspec(ispec,ithi)/xspec(ispec,itlo)))              &
     &        **rt_xpt(itxpt)
            endif
          else
            xspec_o(ispecB,io_time,iexpt)=                                    &
     &      xspec(ispec,itime)
          endif
!
          yspec_o(ispecB,io_time,iexpt)=                                      &
     &    dloyy(dabs(xspec_o(ispecB,io_time,iexpt)),1.d-30)
!
!
!c        if(jkrxdi.ge.1.and.jkrxdi.le.9.and.jo_xdi.eq.3                &
!c   &    .and.ispecX_spec(ispec,iexpt).gt.0) then
!c          ispecX=ispecX_spec(ispec,iexpt)
!c          xspec_o(ispecX,io_time,iexpt)                               &
!c   &      =xspec_o(ispecB,io_time,iexpt)
!c          yspec_o(ispecX,io_time,iexpt)                               &
!c   &      =yspec_o(ispecB,io_time,iexpt)
!
!c          if(itxpt.gt.0) then
!c            if(                                                       &
!c   &        jmsspec_ip(ispecB).eq.0.or.                               &
!c   &        jmsspec_ip(ispecB).eq.2)                                  &
!c   &        xspec_o(ispecB,io_time,iexpt)=                                  &
!c   &        xspec(ispecX,itlo)                                        &
!c   &        +(xspec(ispecX,ithi)-xspec(ispecX,itlo))                  &
!c   &        *rt_xpt(itxpt)
!
!c            if(                                                       &
!c   &        jmsspec_ip(ispecB).eq.1)                                  &
!c   &        xspec_o(ispecB,io_time,iexpt)=                                  &
!c   &        xspec(ispecX,itlo)                                        &
!c   &        *dabs((xspec(ispecX,ithi)/xspec(ispecX,itlo)))            &
!c   &        **rt_xpt(itxpt)
!c          else
!c            xspec_o(ispecB,io_time,iexpt)=                                  &
!c   &        xspec(ispecX,itime)
!c          endif
!
!c          yspec_o(ispecB,io_time,iexpt)=                                    &
!c   &      dlog(dabs(xspec_o(ispecB,io_time,iexpt)))
!c        endif
!
   89     continue
        enddo
      enddo
!
!
      return
      end
!
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine kin_dptru
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! store dependents for tru Theta parameters
!
      do idpen=1,ndpen_tot
        ipm=ipm_dpen(idpen)
        ispre=ispre_dpen(idpen)
        ispec=ispec_dpen(idpen)
        ireac=ireac_dpen(idpen)
!c      call tr_spre(ispec,ireac,ispre,nspec)
        if(ispec.gt.0) pmspec(ispec,ipm,5)=cspec(ispec,ipm)
        if(ireac.gt.0) pmreac(ireac,ipm,5)=rreac(ireac,ipm)
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine kin_truv
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! store zero-noise true-Theta solution for species concentrations
! at exptl. time points, if available
!
        do ims=1,nms_spec
          ispec=ispec_ms(ims)
          if(jmsspec_px(ispec).eq.0) then
            do itmx=itmx_ini(ims,iexpt),itmx_fin(ims,iexpt)
              xspec_tru(itmx)=xspec_chi(itmx)
              yspec_tru(itmx)=yspec_chi(itmx)
            enddo
          endif
!
          if(jmsspec_px(ispec).eq.1) then
            do itmx=itmx_ini(ims,iexpt),itmx_fin(ims,iexpt)
              itxpt=itxpt_tmx(itmx)
              itlo=itime_xpt(itxpt)
              ithi=itlo+1
!
              if(                                                       &
     &        jmsspec_ip(ispec).eq.0.or.                                &
     &        jmsspec_ip(ispec).eq.2)                                   &
     &        xspec_tru(itmx)=                                          &
     &        xspec(ispec,itlo)                                         &
     &        +(xspec(ispec,ithi)-xspec(ispec,itlo))                    &
     &        *rt_xpt(itxpt)
!
              if(                                                       &
     &        jmsspec_ip(ispec).eq.1)                                   &
     &        xspec_tru(itmx)=                                          &
     &        xspec(ispec,itlo)                                         &
     &        *dabs((xspec(ispec,ithi)/xspec(ispec,itlo)))              &
     &        **rt_xpt(itxpt)
!
              yspec_tru(itmx)=dlog(dabs(xspec_tru(itmx)))
            enddo
          endif
        enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine kin_truz
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
!     zero true-Theta solution arrays
!
!c    if(jxpt.ge.0.and.jxpt.lt.100) then
        do ims=1,nms_spec
          do iexpt=1,nexpt
            do itmx=itmx_ini(ims,iexpt),itmx_fin(ims,iexpt)
              yspec_tru(itmx)=0.d0
              xspec_tru(itmx)=-1.d0
            enddo
          enddo
        enddo
!c    endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine kin_noi
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!   in virt. expt., adds Gaussian noise to the
!   "true-Theta" exptl.-time model log-conc.s
!
      pi2=8.d0*datan(1.d0)
      rgauss=0.d0
!
      do iexpt=1,nexpt
        do itxpt=1,ntxpt
          do ims=1,nms_spec
            if(itmx_xpt(ims,itxpt,iexpt).gt.0) then
              ispec=ispec_ms(ims)
!
              if(jwidxpt.eq.1) then
                r1=randx()
                r2=randx()
                rgauss=dsqrt(dabs(dlog(dabs(r1)+1.d-20)))*dcos(pi2*r2)
              endif
!
              yspec_xpt(itmx_xpt(ims,itxpt,iexpt))=                     &
     &        yspec_tru(itmx_xpt(ims,itxpt,iexpt))                      &
     &        +yspec_wid(itmx_xpt(ims,itxpt,iexpt))*rgauss
!
              yspec_xpt(itmx_xpt(ims,itxpt,iexpt))=                     &
     &        yspec_xpt(itmx_xpt(ims,itxpt,iexpt))-dlog(glob_scal)
!
              xspec_xpt(itmx_xpt(ims,itxpt,iexpt))=                     &
     &        dexp(yspec_xpt(itmx_xpt(ims,itxpt,iexpt)))
!
              wtx=yspec_wid(itmx_xpt(ims,itxpt,iexpt))
              xspec_wid(itmx_xpt(ims,itxpt,iexpt))=               &
     &        (dexp(wtx                                           &
     &              /(1.d0+wtx             /dlog(1.0d20))         &
     &             )                                              &
     &         -1.d0                                              &
     &        )                                                   &
     &        *xspec_xpt(itmx_xpt(ims,itxpt,iexpt))
            endif
          enddo
        enddo
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine get_xpt
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! either...
!     read in and format real exptl. data
!
      if(jxpt.ge.0.and.jxpt.lt.100) then
!
!V090911:
!!!     call mp_qini
!:V090911
!
!       read exptl. data from "ens.i02"
        call idat_xpt
!
!       re-weight exptl. data pts. acc. to txpt-window
!       data density and window re-weighting factors:
        call wwgt_xpt
!
!       compress exptl. data by averaging over time-bins
        call cprs_xpt
!
!       merge, order and tabulate all exptl. time points
        call stot_xpt
!
!       format exptl. data for chisq-calculation
        call form_xpt
!
!       allocate storage for dependents of exptl. data points
        call alloc_odpen
!
!       store time integrator and interpolation arrays
        call set_tint
!
!       store scale factor class arrays
        call set_sfc
!
!       store exptl. data point pre-summation arrays
        call set_prex
!
!       store deconv. real-species look-up arrays at
!       pseudo-species obs. times
        call set_txdcon
!
!       initialize exptl. data insertion arrays
!V090911:
!DEACTIVATED
!!!     call set_xdi
!:V090911
!
!       initialize Fourier transform arrays
        call set_four
!
!       zero true-Theta solution arrays
        call kin_truz
!
!       pre-sum exptl. data points
        jfwgt=0
        call chi_prex
!
!V090911:
!!!     call mp_qfin
!:V090911
      endif
!
! or...
!     generate virtual exptl. data ...
!
!     ...by solving rate eqs. for given control
!     parameters and given Theta^tru (ivpm=5),
!     then superimpose Gaussian noise on model log-conc.
!     at prescibed virt. exptl. time points
!
      if(jxpt.ge.100.and.jxpt.lt.200) then
!       initialize random number generator for virt. expts.
        call srandx(ixpt_ran,iseed2,jrand)
!
!       sort+mask exptl. time points, set Gaussian widths
        call set_vxpt
!
!       allocate storage for dependents of exptl. data points
        call alloc_odpen
!
!       initialize time integrator and interpolation arrays
        call set_tint
!
!       store deconv. real-species look-up arrays at
!       pseudo-species obs. times
        call set_txdcon
!
        ivpm_th=5
        jinipm_th=1
        call setpm_th
!
        ivpm_uf=1
        call setpm_uf
!
!       store scale factor class arrays
        call set_sfc
!
!       store exptl. data point pre-summation arrays
        call set_prex
!
!       initialize exptl. data insertion arrays
!V090911:
!DEACTIVATED
!!!     call set_xdi
!:V090911
!
!       initialize Fourier transform arrays
        call set_four
!
        jkrxdi=0
!c
!c      parallelized:
!c      ------------
        jmp_task=1
        call mp_kin_pki
!
! Mr code:
        if(mp_myid.eq.mp_mrid) then
!           ... run kinsolver for all expts
          jmp_kin=4
          call mpm_getkin ! get_xpt-01
          call kin_noi
!
!           ... terminate mps_getkin:
          jmp_kin=0
          call mpm_kin_send_theta
! Sv code:
        else
!           ... run kinsolver for expts sent by Mr
          call mps_getkin
          return
        endif
!
!c      serial:
!
!c      do iexpt=1,nexpt
!c        ivpm_uv=iexpt
!c        call setpm_uv
!c        call kin_ini
!c        call kin_run
!c        call kin_xpt
!c        call kin_qbx
!c        call kin_four
!c        call kin_truv
!c      enddo
!c      call kin_dptru
!c      call kin_noi
!
        jfwgt=0
        call chi_prex
!
        call chi_zero
        jfwgt=0
        jDB_chi_accu=1
        call chi_accu
        call chi_htot
!
        chisq_tru=chisq
        chi1_tru=chi1_ks(1)
        chi2_tru=chi2_ks(1)
        sxplog_tru=sxplog_ks(1)
!
        hfour_tru=hfour
        hfous_tru=hfous
        hfout_tru=hfout
        hbxx_tru=hbxx
        hbxn_tru=hbxn
        hwall_tru=hwall
        htot_tru=htot
!
        do ivs=0,nvs_spec
          qbxx_tru(ivs)=qbxx(ivs)
          qbxn_tru(ivs)=qbxn(ivs)
        enddo
!
        do iexpt=1,nexpt
          do isegft=1,nsegft(iexpt)
            pfour_seg_tru(isegft,iexpt)=                                &
     &      pfour_seg(isegft,iexpt)
            qfour_seg_tru(isegft,iexpt)=                                &
     &      qfour_seg(isegft,iexpt)
            do is_ft=1,nsft_spec
              pfour_sfil_tru(is_ft,isegft,iexpt)=                       &
     &        pfour_sfil(is_ft,isegft,iexpt)
!
              pfour_stot_tru(is_ft,isegft,iexpt)=                       &
     &        pfour_stot(is_ft,isegft,iexpt)
            enddo
          enddo
        enddo
      endif
!
      jsfxdi=0
!c    call store_sfxdi
!
      jkrxdi=18
!c    call get_xdi
      jkrxdi=0
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mc_run_r
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
      jmc_ini_rst=0
      imc_rep=-1
      imc_eql=-1
      imc_acc=-1
      imc_upd=-1
      jmvloop=-1
      imvsequ=-1
      kmvsequ=-1
      kmvsequ_lp=-1
      imove=-1
      kmove=-1
      jkmove=-1
      ith_rk=-1
      ith_cs=-1
!
      ihtot_amb=-1
      ihtot_pst=-1
      ihtot_pge=-1
!
!
      if(.not.(jmc_inir.eq.142.or.jmc_inir.eq.143)) then
        call zero_dos
        call zero_his
      endif
      call zero_wlit
!
!
      do imc_rep=1,nmc_rep
!
        if(imc_rep.eq.1) then
!
!       initialization:
!
          jmvloop=0
!
          call mc_ini_m
!
          call mc_ini_swopt
          call mc_ini_fbxa
!
          jclO=10
          call odat_th ! mc_run_r-01
!
!       equilibration loop:
!
          jmvloop=1
          do imc_eql=1,nmc_eql
            call mc_mvsched ! mc_run_r-01
!
            jclO=11
            if(jo_th.eq.21) call odat_th ! mc_run_r-02
          enddo
          imc_eql=-1
        endif
!
        if(imc_rep.gt.1.and.                                            &
     &  (jmc_eql.ge.10.and.jmc_eql.le.29)) then
          if(jmc_eql.ge.20.and.jmc_eql.le.29) call mc_ini_m
          if(jmc_eql.eq.11.or.jmc_eql.eq.21)  then
            call mc_ini_swopt
            call mc_ini_fbxa
          endif
!
          jmvloop=1
          do imc_eql=1,nmc_eql
            call mc_mvsched ! mc_run_r-02
!
            jclO=12
            if(jo_th.eq.21) call odat_th ! mc_run_r-03
          enddo
          imc_eql=-1
        endif
!
        call mc_zero_m ! mc_run_r-01
!
!     accumulation loop:
!
        do imc_acc=1,nmc_acc
!
!       updating loop:
!
          jmvloop=2
          do imc_upd=1,nmc_upd
            call mc_mvsched ! mc_run_r-03
!
            jclO=13
            if(jo_th.eq.11.or.jo_th.eq.21) call odat_th ! mc_run_r-04
          enddo
          imc_upd=-1
!
          call mc_accu_m
!
          jclO=14
          if(jo_th.eq.1) call odat_th ! mc_run_r-05
        enddo
        imc_acc=-1
!
        call mc_accu_r
!
        if(imc_smp.eq.1.and.jrstart.eq.1) jmc_ini_rst=1
      enddo
      imc_rep=-1
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mc_mvsched
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
      ith_cs=-1
      ith_rk=-1
      imove=-1
      kmove=-1
      jkmove=-1
      imvsequ=-1
      kmvsequ=-1
      kmvsequ_lp=-1
      jo_mvsequ=1
!
      ihtot_amb=0
      ihtot_pst=0
      ihtot_pge=0
!
      jpst_sch=-1
      jtmpst_lst=-1
!
      jpge_sch=-1
!
!   execute "nmvsequ" move types in order prescribed by "jmty"
!
      kmvsequ_ini=1
      do kmvsequ=1,nmvsequ(jmvloop)
        if(dabs(raccp_hi(kmvsequ,jmvloop)+101.d0).lt.1.d-2) then
          call zero_his
        endif
        if(dabs(raccp_hi(kmvsequ,jmvloop)+102.d0).lt.1.d-2) then
          call zero_dos
        endif
        if(dabs(raccp_hi(kmvsequ,jmvloop)+103.d0).lt.1.d-2) then
          call zero_wlit
        endif
!
        if(nmove(kmvsequ,jmvloop).gt.0) then
          jpst_sch=1
          jpge_sch=1
          call fmvsequ_ini
!
!-------->
          imove=0
          kmove=0
!c        do kmove=1,nmove(kmvsequ,jmvloop)
  110     continue
          imove=imove+1
!---------->
!
            call fmvsequ_rand
            kmove=kmove+jkmove
!
            if(kmove.gt.nmove(kmvsequ,jmvloop)) goto 190
!
            call fmvsequ_repl
!
            jupd_chi=0
            call sch_fts
            call sch_fwgt
            call sch_fbound
            call sch_ffour
!
            call sch_pge
            call sch_pst
!
            if(jrstart.eq.0) then
              if(jupd_chi.eq.1) then
                call reset_yspec
                if(jwgt_mc(kmvsequ,jmvloop).eq.-1) then
                  jDB_sum_chi=1
                  call sum_chi_u
                else
                  jDB_sum_chi=2
                  call sum_chi_w
                endif
                call store_chi_th
              endif
              if(jupd_chi.eq.2) then
                jDB_get_chi=3
                call get_chi ! mc_mvsched-01
!
!DRLIM190524-2244:
!               Will likely have mlimdrv==0 here, since Theta is an already
!               accepted read-in from a previous run.
!:DRLIM190524-2244
!
!CHG190527-2223:
                call zero_arkabd ! mc_mvsched-01
!:CHG190527-2223
!
!
                call store_chi_th
                jupd_sfxdi=0
                jupd_abaxdi=0
              endif
            endif
            jupd_chi=0
!
            call mc_mvtype ! mc_mvsched-01
!
            if(jrstart.eq.0) then
              call mc_swopt
!
              jclO=141
              if(jo_th.eq.41) call odat_th ! mc_mvsched-01
              call ck_stop_swp
              if(jcv_dos.ne.0) goto 190
            endif
!
            ihtot_amb=-1
            mhtot_amb=-1
            ihtot_pst=-1
            mhtot_pst=-1
            ihtot_pge=-1
            mhtot_pge=-1
!
            goto 110
!---------->
!c        enddo
  190     continue
!-------->
!
          ith_cs=-1
          ith_rk=-1
          imove=-1
          kmove=-1
          jkmove=-1
!
          if(jrstart.eq.0.or.                                           &
     &      (jmc_inir.ge.340.and.jmc_inir.le.399)                       &
     &    )then
            if(jrstart.eq.0) call odat_dos
!
            jclO=131
            if(jo_th.eq.31) call odat_th ! mc_mvsched-02
            call ck_stop_swp
          endif
!
          kmvsequ_lp=kmvsequ
          kmvsequ_ini=kmvsequ+1
        endif
      enddo
!
      jpst_sch=-1
      imvsequ=-1
      kmvsequ=-1
      kmvsequ_ini=-1
      kmvsequ_lp=-1
      jo_mvsequ=-1
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine fmvsequ_ini
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! initialize loop counters for new move sequence
!
      include 'ens.def'
!
!
      do levlp=0,levlp_x
        imvsequ_lev(levlp)=-1
      enddo
!
      do imvsequ=kmvsequ_ini,kmvsequ
        imovr_mvs(imvsequ)=0
      enddo
!
      levlp=0
      imvsequ=-1
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine fmvsequ_rand
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! Find sequential or random "imvsequ"-value distributed acc. to
! pmvtype(...) for current "kmvsequ" and "imove"
!
      include 'ens.def'
!
      jkmove=0
!
      if(levlp.eq.0.and.imvsequ.lt.kmvsequ_ini) then
        imvsequ=kmvsequ_ini
        goto 310
      endif
!
  110 continue
      if(imvsequ.ge.kmvsequ_ini.and.                                    &
     &imvsequ.le.kmvsequ                                                &
     &)then
!
! check for incompletion of current move sequence
        if(imovr_mvs(imvsequ).lt.nmovr_mvs(imvsequ,jmvloop)) then
          imovr_mvs(imvsequ)=imovr_mvs(imvsequ)+1
!
! descend to next lower loop level
          if(imvsequ.lt.kmvsequ) then
            if(levlp_mvs(imvsequ+1,jmvloop).gt.levlp) then
              levlp=levlp+1
              imvsequ=imvsequ+1
              goto 310
            endif
          endif
!
! exit w/ current imvsequ-value
          goto 410
        endif
!
! check for presence of attached move sequence
! to a just completed sequence at current loop level
        if(imovr_mvs(imvsequ).ge.nmovr_mvs(imvsequ,jmvloop)) then
          imovr_mvs(imvsequ)=0
          imvsequ_nxt=imvsequ_nxt_mvs(imvsequ,jmvloop)
          if(imvsequ_nxt.ge.kmvsequ_ini.and.                            &
     &    imvsequ_nxt.le.kmvsequ) then
            if(pmvtype(imvsequ_nxt,jmvloop).lt.0.d0) then
              imvsequ=imvsequ_nxt
              imvsequ_lev(levlp)=imvsequ
              imovr_mvs(imvsequ)=0
              goto 110
            else
              goto 210
            endif
          else
            goto 210
          endif
        endif
      endif
!
! ascend to previous higher loop level
  210 continue
      if(levlp.gt.0) then
        imvsequ_lev(levlp)=-1
        levlp=levlp-1
        imvsequ=imvsequ_lev(levlp)
        goto 110
      else
        goto 310
      endif
!
! select random imvsequ at current loop level
  310 continue
      if(levlp.eq.0) jkmove=1
!
      imvsequ_fst=imvsequ_fst_mvs(imvsequ,jmvloop)
      imvsequ_lst=imvsequ_lst_mvs(imvsequ,jmvloop)
!
      rmvtype=randx()
      rmvtype=pmvsum(imvsequ_lst,jmvloop)*rmvtype
      if(rmvtype.gt.pmvsum(imvsequ_lst,jmvloop))                        &
     &rmvtype=pmvsum(imvsequ_lst,jmvloop)
!
      do imvsequ=imvsequ_fst,imvsequ_lst
        if(levlp_mvs(imvsequ,jmvloop).eq.levlp) then
          if(pmvtype(imvsequ,jmvloop).gt.0.d0) then
            if(pmvsum(imvsequ,jmvloop).ge.rmvtype) goto 320
          endif
        endif
      enddo
      imvsequ=imvsequ_lst
  320 continue
      imvsequ_lev(levlp)=imvsequ
      imovr_mvs(imvsequ)=0
      goto 110
!
!
  410 continue
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mc_mvtype
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!   skip move sequence if flagged for omission either after or during
!   1st run thru repeat loop and/or equil. loop
!
      ith_rk=-1
      ith_cs=-1
      ith_upd=-1
!
      if(jrstart.eq.1) then
        nskip12=nrskip12
        if(jcl_rstart.eq.0) then
          nskip12=nrskip12+n0skip12
        endif
        jcl_rstart=jcl_rstart+1
!
        do iskip12=1,nskip12
          call idat_rstart
          if(jrstart.eq.0) goto 29
        enddo
   29   continue
        if(jrstart.eq.1) then
          jmc_ini_rst=0
          return
        endif
!
        if(jrstart.eq.0) then
          mbase=100000
          call fdigit(jmc_inii                                              &
     &               ,mbase,jdig,nzdig,ndig_y)
          jmc_inir=jdig(1)
          if(jmc_ini_rst.eq.1) then
            if(jmc_eql.ge.20.and.jmc_eql.le.29) call mc_ini_m
            if(jmc_eql.eq.11.or.jmc_eql.eq.21)  then
              call mc_ini_swopt
              call mc_ini_fbxa
            endif
          endif
          jmc_ini_rst=0
!
          jkrxdi_rst=jkrxdi
          jkrxdi=18
          jDB_get_chi=4
          call get_chi ! mc_mvtype-01
!DRLIM190524-2244:
!         Will likely have mlimdrv==0 here, since Theta is an already
!         accepted read-in from a previous run.
!:DRLIM190524-2244
!
!CHG190527-2223:
          call zero_arkabd ! mc_mvtype-01
!:CHG190527-2223
!
          call store_chi_th
          jkrxdi=jkrxdi_rst
        endif
      endif
!
! skip updating for certain jmty-values ("null moves")
! and or when specified at or after start-value
! of imc_rep and/or imc_eql
      if(jmty(imvsequ,jmvloop).le.0) return
      if(jmty(imvsequ,jmvloop).eq.1000) return
      if(jmty(imvsequ,jmvloop).eq.3000) return
!
      if(jnorep(imvsequ,jmvloop).eq.1.and.imc_rep.gt.1)                 &
     &  return
      if(jnorep(imvsequ,jmvloop).eq.2.and.imc_eql.gt.1)                 &
     &  return
      if(jnorep(imvsequ,jmvloop).eq.3.and.                              &
     &  (imc_eql.gt.1.or.imc_rep.gt.1))                                 &
     &  return
      if(jnorep(imvsequ,jmvloop).eq.4.and.                              &
     &  (imc_eql.gt.1.and.imc_rep.gt.1))                                &
     &  return
!
!
      if(jnorep(imvsequ,jmvloop).eq.5.and.imc_rep.eq.1)                 &
     &  return
      if(jnorep(imvsequ,jmvloop).eq.6.and.imc_eql.eq.1)                 &
     &  return
      if(jnorep(imvsequ,jmvloop).eq.7.and.                              &
     &  (imc_eql.eq.1.or.imc_rep.eq.1))                                 &
     &  return
      if(jnorep(imvsequ,jmvloop).eq.8.and.                              &
     &  (imc_eql.eq.1.and.imc_rep.eq.1))                                &
     &  return
!
!Db
      jclC=0
!Fb
!
!CHG190527-2223:
      call zero_arkabd ! mc_mvtype-02
!:CHG190527-2223
!
!
!   move 1 randomly selected species concentration variable
!
      if(jmty(imvsequ,jmvloop).eq.1) then
        call move_cs1
        call ck_chimin
        return
      endif
!
!   move "mth_spec" randomly selected species concentration
!   variables
!
      if(jmty(imvsequ,jmvloop).eq.2) then
!!      do ith_cs=1,mth_spec
        do ith_cs=1,mthb_spec(imvsequ,jmvloop)
          call move_cs1
          call ck_chimin
          if(jcv_dos.ne.0) return
        enddo
        ith_cs=-1
        return
      endif
!
!   move 1 randomly selected reaction rate variable
!
      if(jmty(imvsequ,jmvloop).eq.3) then
        call move_rk1
        call ck_chimin
        return
      endif
!
!   move "mth_reac" randomly selected reaction rate variables
!
      if(jmty(imvsequ,jmvloop).eq.4) then
!!      do ith_rk=1,mth_reac
        do ith_rk=1,mthb_reac(imvsequ,jmvloop)
          call move_rk1
          call ck_chimin
          if(jcv_dos.ne.0) return
        enddo
        ith_rk=-1
        return
      endif
!
!   move "mth_reac" randomly selected reaction rate and then
!   "mth_spec randomly selected" species concentration variables
!
      if(jmty(imvsequ,jmvloop).eq.5) then
!!      do ith_rk=1,mth_reac
        do ith_rk=1,mthb_reac(imvsequ,jmvloop)
          call move_rk1
          call ck_chimin
          if(jcv_dos.ne.0) return
        enddo
        ith_rk=-1
!
!!      do ith_cs=1,mth_spec
        do ith_cs=1,mthb_spec(imvsequ,jmvloop)
          call move_cs1
          call ck_chimin
          if(jcv_dos.ne.0) return
        enddo
        ith_cs=-1
        return
      endif
!
!   move "mth_spec" randomly selected species concentration variables
!   and then "mth_reac" randomly selected reaction rate variables
!
      if(jmty(imvsequ,jmvloop).eq.6) then
!!      do ith_cs=1,mth_spec
        do ith_cs=1,mthb_spec(imvsequ,jmvloop)
          call move_cs1
          call ck_chimin
          if(jcv_dos.ne.0) return
        enddo
        ith_cs=-1
!
!!      do ith_rk=1,mth_reac
        do ith_rk=1,mthb_reac(imvsequ,jmvloop)
          call move_rk1
          call ck_chimin
          if(jcv_dos.ne.0) return
        enddo
        ith_rk=-1
        return
      endif
!
!   move 1 randomly selected species concentration
!   or reaction rate variable
!
      if(jmty(imvsequ,jmvloop).eq.7) then
        r1=randx()
!!      r1=r1*mth_tot
        r1=r1*mthb_tot(imvsequ,jmvloop)
!!      if(r1.lt.mth_spec) then
        if(r1.lt.mthb_spec(imvsequ,jmvloop)) then
          call move_cs1
        else
          call move_rk1
        endif
        call ck_chimin
        return
      endif
!
!   move "mth_tot" randomly selected species concentration
!   or reaction rate variables
!
      if(jmty(imvsequ,jmvloop).eq.8) then
!!      do ith_cs=1,mth_tot
        do ith_cs=1,mthb_tot(imvsequ,jmvloop)
          r1=randx()
!!        r1=r1*mth_tot
          r1=r1*mthb_tot(imvsequ,jmvloop)
!!        if(r1.lt.mth_spec) then
          if(r1.lt.mthb_spec(imvsequ,jmvloop)) then
            call move_cs1
          else
            call move_rk1
          endif
          call ck_chimin
          if(jcv_dos.ne.0) return
        enddo
        ith_cs=-1
        return
      endif
!
!   move all "mth_tot" species concentration
!   and reaction rate variables by "Amoeba"
!   algorithm for "chisq"-minimization
!
      if(jmty(imvsequ,jmvloop).eq.10) then
        call move_amb
!c      call ck_chimin
        return
      endif
!
!   move Theta globally along 1 randomly selected
!   unit vector direction in Theta-space
!
      if(jmty(imvsequ,jmvloop).eq.11) then
        call move_thu
        call ck_chimin
        return
      endif
!
!   move Theta globally along "mth_tot" randomly selected
!   unit vector directions in Theta-space
!
      if(jmty(imvsequ,jmvloop).eq.12) then
!!      do ith_rk=1,mth_tot
        do ith_rk=1,mthb_tot(imvsequ,jmvloop)
          call move_thu
          call ck_chimin
          if(jcv_dos.ne.0) return
        enddo
        ith_rk=-1
        return
      endif
!
!   move all "mth_tot" species concentration
!   and reaction rate variables simultaneously
!   by fictitious Hamiltonian time evolution,
!   executed only once.
!
      if(jmty(imvsequ,jmvloop).eq.13) then
        call move_ham
        call ck_chimin
        return
      endif
!
!   move all "mth_tot" species concentration
!   and reaction rate variables simultaneously
!   by fictitious Hamiltonian time evolution,
!   executed "mth_tot" times
!
      if(jmty(imvsequ,jmvloop).eq.14) then
        do ith_rk=1,mth_tot
          call move_ham
          call ck_chimin
          if(jcv_dos.ne.0) return
        enddo
        ith_rk=-1
        return
      endif
!
      if(jmty(imvsequ,jmvloop).eq.20) then
!!      do ith_rk=1,mampdu_tot(imvsequ,jmvloop)
          call move_dcon
          call ck_chimin
          if(jcv_dos.ne.0) return
!!       enddo
        ith_rk=-1
        return
      endif
!
!
      if(jmty(imvsequ,jmvloop).eq.101) then
        jDB_get_chi=5
        call get_chi ! mc_mvtype-02
!
!DRLIM190524-2244:
!       Will likely have mlimdrv==0 here, since Theta is an already
!       accepted update from a prior MC move
!:DRLIM190524-2244
!
        call ck_chimin
        return
      endif
!
!
! Theta population moves
!
!   population simulated tempering (PST) moves
!
      if(jmty(imvsequ,jmvloop).ge.1000.and.                             &
     &   jmty(imvsequ,jmvloop).le.2999                                  &
     &)then
        call move_pst
!Db
      jclC=1
!Fb
        call ck_chimin
        return
      endif
!
!
!   population genetic/evolutionary (PGE) algorithm  moves
!
      if(jmty(imvsequ,jmvloop).ge.3000.and.                             &
     &   jmty(imvsequ,jmvloop).le.4999                                  &
     &)then
        call move_pge
!c      call fin_ge
!c      call ck_chimin
        return
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine fin_st
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
      ipop_upd=-1
      ipop_xch=-1
!
      fbeta_st=1.d0
      fstep_st=1.d0
!
      if(jdo_st4ge.eq.0) call reord_st
!
      call store_st2repl
!
      ipop_upd=0
      call store_st2th ! fin_st-01
      jDB_get_chi=6
      call get_chi ! fin_st-01
!
!DRLIM190524-2244:
!     Will likely have mlimdrv==0 here, since Theta is an already
!     accepted update from a prior MC move
!:DRLIM190524-2244
!
      call store_chi_th
!
      ipop=-1
      ipop_upd=-1
      ipop_xch=-1
!
      npopst_lst=npopst
!
!c Do not change "npopst" here: value may still be needed
!c    npopst=-1
!
      jo_pst=0
!
      ihtot_pst_ini=0
      lhtot_pst=0
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine fin_ge
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
      call store_ge2repl
!
      call htmin_ge
      call store_ge2th
!
      ipop=-1
      ipop_upd=-1
      ipop_xch=-1
!
      npopge_lst=npopge
!
!c Do not change "npopge" here: value may still be needed
!c    npopge=-1
!
      jo_pge=0
!
      ihtot_pge_ini=0
!c    lhtot_pge=0
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine htord_ge
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! sort population in order of ascending energy htot_ge
!
      do ipop1=0,npopge
        ipop_blo=0
        do ipop2=0,npopge
          if(htot_ge(ipop2).lt.htot_ge(ipop1))                          &
     &    ipop_blo=ipop_blo+1
!
          if(                                                           &
     &    htot_ge(ipop2).eq.htot_ge(ipop1).and.                         &
     &    ipop2.lt.ipop1                                                &
     &    )                                                             &
     &    ipop_blo=ipop_blo+1
        enddo
        iorge(ipop_blo)=ipop1
      enddo
!
!
      do ipop=0,npopge
        ipop_orge(iorge(ipop))=ipop
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine htmin_ge
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! search population for minimal htot_ge,
! store ipop-ID for that minimum in ipop_upd
!
      ipop_upd=0
      do ipop2=0,npopge
        ipop1=npopge-ipop2
        if(htot_ge(iorge(ipop1)).lt.htot_ge(iorge(ipop_upd)))           &
     &  ipop_upd=ipop1
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ck_chimin
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! check for min-, max-chisq \Theta-configuration and store it for output
!
      chisq_th_min0=chisq_th_min
!
      if(chisq_th_min.lt.0.d0) then
        chisq_th_min=chisq_th
        chisq_th_min0=chisq_th
      endif
      if(chisq_th_max.lt.0.d0) chisq_th_max=chisq_th
      if(chisq_th_max.lt.chisq_th) chisq_th_max=chisq_th
!
      if(chisq_th_min.gt.chisq_th) then
        chisq_th_min=chisq_th
!
        jclO=100
        call odat_th ! ck_chimin-01
        chisq_th_min0=chisq_th
      endif
!
!
      if(hfour_th_min.eq.-1.d20) hfour_th_min=hfour_th
      if(hfour_th_min.gt.hfour_th) hfour_th_min=hfour_th
!
      if(hfour_th_max.eq.-1.d20) hfour_th_max=hfour_th
      if(hfour_th_max.lt.hfour_th) hfour_th_max=hfour_th
!
      if(hfous_th_min.eq.-1.d20) hfous_th_min=hfous_th
      if(hfous_th_min.gt.hfous_th) hfous_th_min=hfous_th
!
      if(hfous_th_max.eq.-1.d20) hfous_th_max=hfous_th
      if(hfous_th_max.lt.hfous_th) hfous_th_max=hfous_th
!
      if(hfout_th_min.eq.-1.d20) hfout_th_min=hfout_th
      if(hfout_th_min.gt.hfout_th) hfout_th_min=hfout_th
!
      if(hfout_th_max.eq.-1.d20) hfout_th_max=hfout_th
      if(hfout_th_max.lt.hfout_th) hfout_th_max=hfout_th
!
      if(hbxx_th_min.eq.-1.d20) hbxx_th_min=hbxx_th
      if(hbxx_th_min.gt.hbxx_th) hbxx_th_min=hbxx_th
!
      if(hbxx_th_max.eq.-1.d20) hbxx_th_max=hbxx_th
      if(hbxx_th_max.lt.hbxx_th) hbxx_th_max=hbxx_th
!
!
      if(hbxn_th_min.eq.-1.d20) hbxn_th_min=hbxn_th
      if(hbxn_th_min.gt.hbxn_th) hbxn_th_min=hbxn_th
!
      if(hbxn_th_max.eq.-1.d20) hbxn_th_max=hbxn_th
      if(hbxn_th_max.lt.hbxn_th) hbxn_th_max=hbxn_th
!
!
      if(hwall_th_min.eq.-1.d20) hwall_th_min=hwall_th
      if(hwall_th_min.gt.hwall_th) hwall_th_min=hwall_th
!
      if(hwall_th_max.eq.-1.d20) hwall_th_max=hwall_th
      if(hwall_th_max.lt.hwall_th) hwall_th_max=hwall_th
!
!
      if(htot_th_min.eq.-1.d20) htot_th_min=htot_th
      if(htot_th_min.gt.htot_th) htot_th_min=htot_th
!
      if(htot_th_max.eq.-1.d20) htot_th_max=htot_th
      if(htot_th_max.lt.htot_th) htot_th_max=htot_th
!
!Db
      jclC=-11111
!Fb
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ck_chimin_u
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! check for min-, max-chisq \Theta-configuration and store it for output
!
      chisq_uth_min0=chisq_uth_min
!
      if(chisq_uth_min.lt.0.d0) then
        chisq_uth_min=chisq_uth
        chisq_uth_min0=chisq_uth
      endif
      if(chisq_uth_max.lt.0.d0) chisq_uth_max=chisq_uth
!
      if(chisq_uth_max.lt.chisq_uth) chisq_uth_max=chisq_uth
!
      if(chisq_uth_min.gt.chisq_uth) chisq_uth_min=chisq_uth
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mc_swopt
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! optimize MC max. stepwidths to get acceptance ratios
! within pre-set range
!
!DB090908
!!    write(*,*) ' '
!!    write(*,*)                                                  &
!!   &'============================================================'
!!    write(*,*) 'mc_swopt:>START,mp_myid=',mp_myid
!!    write(*,*) 'jmvloop,imvsequ,jmty,imove,kmove,ith_cs,ith_rk='
!!    write(*,*)  jmvloop,imvsequ,jmty(imvsequ,jmvloop)           &
!!   &                                ,imove,kmove,ith_cs,ith_rk
!
!!    write(*,*) 'raccp_lo,raccp_hi='                             &
!!   &           ,raccp_lo(imvsequ,jmvloop)                       &
!!   &           ,raccp_hi(imvsequ,jmvloop)
!
!!    write(*,*) 'mpr_swo,jac_swo=', mpr_swo,jac_swo
!
!!    write(*,*) 'ith_swo, naccp_swo,nprop_swo'
!!    write(*,*) '  /  raccp_swo, fstp_swo'
!!    write(*,*) '    /    namespre'
!!    do ith_swo=1,mth_swo
!!     if(ith_swo.lt.(mth_spec+1)) goto 9010
!!     if(ith_swo.gt.mth_tot) goto 9010
!
!!     if(ith_swo.eq.1) write(*,*) 'Species>START:'
!!     if(ith_swo.eq.(mth_spec+1)) write(*,*) 'Reactions>START:'
!!     if(ith_swo.eq.(mth_tot+1)) write(*,*) 'Non-local Moves>START:'
!
!!      write(*,*)                                              &
!!   &  ith_swo                                                 &
!!   & ,naccp_swo(ith_swo)                                      &
!!     ,naccp_up_swo(ith_swo)
!!   & ,nprop_swo(ith_swo)
!!     ,nprop_up_swo(ith_swo)
!
!!      write(*,*) '           '                                &
!!   & ,raccp_swo(ith_swo)                                      &
!!   & ,fstp_swo(ith_swo)
!
!!     if(ith_swo.le.mth_spec) then
!!       write(*,2010) namespec(ispec_th(ith_swo))
!2010    format(a80)
!!       goto 9010
!!     endif
!
!!     if(ith_swo.gt.mth_spec.and.ith_swo.le.mth_tot) then
!!       write(*,2010) namereac(ireac_th(ith_swo-mth_spec))
!!       goto 9010
!!     endif
!
!!     write(*,*) 'non-local move type'
!9010 continue
!!    enddo
!FB090808
!
      ra_swo_lo=raccp_lo(imvsequ,jmvloop)
      ra_swo_hi=raccp_hi(imvsequ,jmvloop)
!
      if(dabs(dabs(ra_swo_lo)-100.d0).lt.1.d-4) then
!V090908:
        goto 990
!:V090808
      endif
!
      if(dabs(dabs(ra_swo_lo)-101.d0).lt.1.d-4) then
        do ith_swo=1,mth_swo
          fstp_swo(ith_swo)=1.d0
        enddo
!V090908:
        goto 990
!:V090808
      endif
!
      if(dabs(dabs(ra_swo_lo)-102.d0).lt.1.d-4) then
        do ith_swo=1,mth_swo
          naccp_swo(ith_swo)=0
          naccp_up_swo(ith_swo)=0
          nprop_swo(ith_swo)=0
          nprop_up_swo(ith_swo)=0
        enddo
!V090908:
        goto 990
!:V090808
      endif
!
      if(dabs(dabs(ra_swo_lo)-103.d0).lt.1.d-4) then
        do ith_swo=1,mth_swo
          fstp_swo(ith_swo)=1.d0
!
          naccp_swo(ith_swo)=0
          naccp_up_swo(ith_swo)=0
          nprop_swo(ith_swo)=0
          nprop_up_swo(ith_swo)=0
        enddo
!V090908:
        goto 990
!:V090808
      endif
!
      do ith_swo=1,mth_swo
        if(                                                             &
     &  (jac_swo.eq.1.and.nprop_swo(ith_swo).ge.mpr_swo)                &
     &  .or.                                                            &
     &  (jac_swo.eq.2.and.nprop_up_swo(ith_swo).ge.mpr_swo)             &
     &  ) then
!
          raccp_swo0=raccp_swo(ith_swo)
!
          if(jac_swo.eq.1)                                              &
     &    raccp_swo(ith_swo)=                                           &
     &    naccp_swo(ith_swo)/(1.d0*nprop_swo(ith_swo))
!
          if(jac_swo.eq.2)                                              &
     &    raccp_swo(ith_swo)=                                           &
     &    naccp_up_swo(ith_swo)/(1.d0*nprop_up_swo(ith_swo))
!
          if(raccp_swo0.ge.0.99999d0.and.                               &
     &       raccp_swo(ith_swo).ge.0.99999d0)                           &
     &    raccp_swo(ith_swo)=raccp_swo0+1.d0
!
!
          if(dabs(dabs(ra_swo_lo)-112.d0).lt.1.d-4) goto 180
          if(dabs(dabs(ra_swo_lo)-111.d0).lt.1.d-4) goto 190
!
!
          jstp_swo0=jstp_swo(ith_swo)
          jstp_swo(ith_swo)=0
!
!
          if(raccp_swo(ith_swo).gt.ra_swo_hi) then
            jstp_swo(ith_swo)=+1
!
            if(jstp_swo0.lt.0) then
              astp_swo(ith_swo)=astp_swo(ith_swo)*0.75d0
              jstp_swo(ith_swo)=+1
            endif
!
            if(jstp_swo0.eq.1) then
              jstp_swo(ith_swo)=+2
            endif
!
            if(jstp_swo0.eq.2) then
              astp_swo(ith_swo)=astp_swo(ith_swo)*1.25d0
              jstp_swo(ith_swo)=+2
            endif
!
            if(astp_swo(ith_swo).lt.0.05d0) astp_swo(ith_swo)=0.05d0
            if(astp_swo(ith_swo).gt.5.00d0) astp_swo(ith_swo)=5.00d0
!
            fstp_swo(ith_swo)=fstp_swo(ith_swo)                         &
     &                 *(1.d0+astp_swo(ith_swo))
!
            fstp_swo_max=1.d20
            if(ith_swo.le.mth_tot) then
              fstp_swo_max=                                             &
     &         2.d0*(ahi_ham(ith_swo)-alo_ham(ith_swo))                 &
     &        /(dabs(step_ham(ith_swo)*fstp_mc(imvsequ,jmvloop))        &
     &         +1.d-20)
            endif
            if(ith_swo.eq.(mth_tot+1)) then
              fstp_swo_max=1000.d0
            endif
            if(ith_swo.eq.(mth_tot+11)) then
              fstp_swo_max=1000.d0
            endif
            if(ith_swo.eq.(mth_tot+12)) then
              fstp_swo_max=1000.d0
            endif
!
            if(ith_swo.ge.(mth_tot+21).and.                             &
     &      ith_swo.le.(mth_tot+25)) then
              fstp_swo_max=1000.d0
            endif
!
            if(ith_swo.ge.(mth_tot+31).and.                             &
     &      ith_swo.le.(mth_tot+35)) then
              fstp_swo_max=1000.d0
            endif
!
            if(ith_swo.ge.(mth_tot+41).and.                             &
     &      ith_swo.le.(mth_tot+45)) then
              fstp_swo_max=1000.d0
            endif
!
!
            if(fstp_swo(ith_swo).gt.fstp_swo_max)                       &
     &      fstp_swo(ith_swo)=fstp_swo_max
          endif
!
!
          if(raccp_swo(ith_swo).lt.ra_swo_lo) then
            jstp_swo(ith_swo)=-1
!
            if(jstp_swo0.gt.0) then
              astp_swo(ith_swo)=astp_swo(ith_swo)*0.75d0
              jstp_swo(ith_swo)=-1
            endif
!
            if(jstp_swo0.eq.-1) then
              jstp_swo(ith_swo)=-2
            endif
!
            if(jstp_swo0.eq.-2) then
              astp_swo(ith_swo)=astp_swo(ith_swo)*1.25d0
              jstp_swo(ith_swo)=-2
            endif
!
            if(astp_swo(ith_swo).lt.0.05d0) astp_swo(ith_swo)=0.05d0
            if(astp_swo(ith_swo).gt.5.00d0) astp_swo(ith_swo)=5.00d0
!
            fstp_swo(ith_swo)=fstp_swo(ith_swo)                         &
     &                 /(1.d0+astp_swo(ith_swo))
!
            if(fstp_swo(ith_swo).lt.1.d-20) fstp_swo(ith_swo)=1.d-20
          endif
!
!
          if(jstp_swo(ith_swo).eq.0) astp_swo(ith_swo)=0.5d0
!
  180     continue
          naccp_swo(ith_swo)=0
          naccp_up_swo(ith_swo)=0
          nprop_swo(ith_swo)=0
          nprop_up_swo(ith_swo)=0
  190     continue
!
        endif
      enddo
!
!V090908:
  990 continue
!:V090808
!
!DB090908
!!    write(*,*)                                                  &
!!   &'============================================================'
!!    write(*,*) 'mc_swopt:<RETURN,mp_myid=',mp_myid
!!    write(*,*) 'jmvloop,imvsequ,jmty,imove,kmove,ith_cs,ith_rk='
!!    write(*,*)  jmvloop,imvsequ,jmty(imvsequ,jmvloop)           &
!!   &                                ,imove,kmove,ith_cs,ith_rk
!
!!    write(*,*) 'raccp_lo,raccp_hi='                             &
!!   &           ,raccp_lo(imvsequ,jmvloop)                       &
!!   &           ,raccp_hi(imvsequ,jmvloop)
!
!!    write(*,*) 'mpr_swo,jac_swo=', mpr_swo,jac_swo
!
!!    write(*,*) 'ith_swo, naccp_swo,nprop_swo'
!!    write(*,*) '  /  raccp_swo, fstp_swo'
!!    write(*,*) '    /    namespre'
!!    do ith_swo=1,mth_swo
!!     if(ith_swo.lt.(mth_spec+1)) goto 9020
!!     if(ith_swo.gt.mth_tot) goto 9020
!
!!     if(ith_swo.eq.1) write(*,*) 'Species<RETURN:'
!!     if(ith_swo.eq.(mth_spec+1)) write(*,*) 'Reactions<RETURN:'
!!     if(ith_swo.eq.(mth_tot+1)) write(*,*) 'Non-local Moves<RETURN:'
!
!!      write(*,*)                                              &
!!   &  ith_swo                                                 &
!!   & ,naccp_swo(ith_swo)                                      &
!!     ,naccp_up_swo(ith_swo)
!!   & ,nprop_swo(ith_swo)
!!     ,nprop_up_swo(ith_swo)
!
!!      write(*,*) '           '                                &
!!   & ,raccp_swo(ith_swo)                                      &
!!   & ,fstp_swo(ith_swo)
!
!!     if(ith_swo.le.mth_spec) then
!!       write(*,2010) namespec(ispec_th(ith_swo))
!!       goto 9020
!!     endif
!
!!     if(ith_swo.gt.mth_spec.and.ith_swo.le.mth_tot) then
!!       write(*,2010) namereac(ireac_th(ith_swo-mth_spec))
!!       goto 9020
!!     endif
!
!!     write(*,*) 'non-local move type'
!9020  continue
!!    enddo
!!    write(*,*)                                                  &
!!   &'============================================================'
!!    write(*,*) ' '
!FB090808
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mc_fbxa
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! DEACTIVATED
      return
! boundary contact force adjuster: updates boundary contact forces
! so as to keep concentration boundary contact for each species
! below the limit specified in "qqbxx" for upper, "qqbxn" for
! lower boundary
!
      neq_fbx=neq_fbx+1
      if(neq_fbx.ge.meq_fbx) then
        nac_fbx=nac_fbx+1
        do ivs=0,nvs_spec
          qbxx_fbx(ivs)=qbxx_fbx(ivs)+qbxx_th(ivs)
          q2bxx_fbx(ivs)=q2bxx_fbx(ivs)+qbxx_th(ivs)**2
!
          qbxn_fbx(ivs)=qbxn_fbx(ivs)+qbxn_th(ivs)
          q2bxn_fbx(ivs)=q2bxn_fbx(ivs)+qbxn_th(ivs)**2
        enddo
      endif
!
!
      if(nac_fbx.ge.mac_fbx.and.mac_fbx.gt.0) then
        do ivs=0,nvs_spec
          qbxx_fbx(ivs)=qbxx_fbx(ivs)/(1.d0*nac_fbx)
          q2bxx_fbx(ivs)=q2bxx_fbx(ivs)/(1.d0*nac_fbx)
!
          qbxn_fbx(ivs)=qbxn_fbx(ivs)/(1.d0*nac_fbx)
          q2bxn_fbx(ivs)=q2bxn_fbx(ivs)/(1.d0*nac_fbx)
!
          jaf=jbxx_af_imv
          jnf=jbxx_nf_imv
!
          if(                                                           &
     &    (ivs.eq.0.and.jnf.eq.2).or.                                   &
     &    (ivs.eq.0.and.jnf.eq.3).or.                                   &
     &    (ivs.ge.1.and.jnf.eq.1).or.                                   &
     &    (ivs.ge.1.and.jnf.eq.3)                                       &
     &    ) then
!
!       adjust upper boundary contact forces
!
            if(jaf.ge.1) then
              q1bxx=qbxx_fbx(ivs)
              c1bxx=q2bxx_fbx(ivs)-q1bxx**2
              if(c1bxx.lt.1.d-20) c1bxx=1.d-20
!
!
              if(q1bxx.gt.qqbxx_imv) then
                redbxx=redbxx_imv
                qqbxx=qqbxx_imv
                afbxx_max=afbxx_max_imv
!
!        jaf=1: linear extrapolation
!               using force susceptibility and avg. boundary contact
                if(jaf.eq.1) then
                  afbxx=                                                &
     &            ((q1bxx-qqbxx)/c1bxx)*redbxx
                  if(afbxx.gt.afbxx_max) afbxx=afbxx_max
!
                  fbxx(ivs)=fbxx(ivs)+afbxx
                endif
!
!        jaf=2: exponential extrapolation
!               using force susceptibility and avg. boundary contact
   20           continue
                if(jaf.eq.2) then
                  afbxx=                                                &
     &            dlog(q1bxx/qqbxx)*(q1bxx/c1bxx)*redbxx
                  if(afbxx.gt.afbxx_max) afbxx=afbxx_max
!
                  fbxx(ivs)=fbxx(ivs)+afbxx
                endif
!
!        jaf=3: inverse 1st power law extrapolation
!               using avg. boundary contact only
!               Warning: requires initial fbxx>0!
                if(jaf.eq.3) then
                  if(fbxx(ivs).eq.0.d0) goto 20
!
                  afbxx=                                                &
     &            ((q1bxx/qqbxx)-1.d0)*fbxx(ivs)*redbxx
                  if(afbxx.gt.afbxx_max) afbxx=afbxx_max
!
                  fbxx(ivs)=fbxx(ivs)+afbxx
                endif
!
!        jaf=4: inverse power law extrapolation
!               using force susceptibility and avg. boundary contact
!               Warning: requires initial fbxx>0! Use jaf=2 if fbxx=0
                if(jaf.eq.4) then
                  if(fbxx(ivs).eq.0.d0) goto 20
!
                  ebxx=fbxx(ivs)*c1bxx/q1bxx
                  ebxx_lo=dlog(q1bxx/qqbxx)/dlog(1.0d20)
                  if(ebxx.lt.ebxx_lo) ebxx=ebxx_lo
                  afbxx=                                                &
     &            ((q1bxx/qqbxx)**(1.d0/ebxx)-1.d0)*fbxx(ivs)*redbxx
                  if(afbxx.gt.afbxx_max) afbxx=afbxx_max
!
                  fbxx(ivs)=fbxx(ivs)+afbxx
                endif
!
!        jaf=5: incremental exponential suppression factor
!               using avg. boundary contact only
                if(jaf.eq.5) then
                  afbxx=                                                &
     &            dlog(q1bxx/qqbxx)*redbxx
                  if(afbxx.gt.afbxx_max) afbxx=afbxx_max
!
                  fbxx(ivs)=fbxx(ivs)+afbxx
                endif
              endif
            endif
          endif
!
!       adjust lower boundary contact forces
!
          jaf=jbxn_af_imv
          jnf=jbxn_nf_imv
!
          if(                                                           &
     &    (ivs.eq.0.and.jnf.eq.2).or.                                   &
     &    (ivs.eq.0.and.jnf.eq.3).or.                                   &
     &    (ivs.ge.1.and.jnf.eq.1).or.                                   &
     &    (ivs.ge.1.and.jnf.eq.3)                                       &
     &    ) then
!
            if(jaf.ge.1) then
              q1bxn=qbxn_fbx(ivs)
              c1bxn=q2bxn_fbx(ivs)-q1bxn**2
              if(c1bxn.lt.1.d-20) c1bxn=1.d-20
!
!
              if(q1bxn.gt.qqbxn_imv) then
                redbxn=redbxn_imv
                qqbxn=qqbxn_imv
                afbxn_max=afbxn_max_imv
!
!        jaf=1: linear extrapolation
!               using force susceptibility and avg. boundary contact
                if(jaf.eq.1) then
                  afbxn=                                                &
     &            ((q1bxn-qqbxn)/c1bxn)*redbxn
                  if(afbxn.gt.afbxn_max) afbxn=afbxn_max
!
                  fbxn(ivs)=fbxn(ivs)+afbxn
                endif
!
!        jaf=2: exponential extrapolation
!               using force susceptibility and avg. boundary contact
   22           continue
                if(jaf.eq.2) then
                  afbxn=                                                &
     &            dlog(q1bxn/qqbxn)*(q1bxn/c1bxn)*redbxn
                  if(afbxn.gt.afbxn_max) afbxn=afbxn_max
!
                  fbxn(ivs)=fbxn(ivs)+afbxn
                endif
!
!        jaf=3: inverse 1st power law extrapolation
!               using avg. boundary contact only
!               Warning: requires initial fbxn>0!
                if(jaf.eq.3) then
                  if(fbxn(ivs).eq.0.d0) goto 22
!
                  afbxn=                                                &
     &            ((q1bxn/qqbxn)-1.d0)*fbxn(ivs)*redbxn
                  if(afbxn.gt.afbxn_max) afbxn=afbxn_max
!
                  fbxn(ivs)=fbxn(ivs)+afbxn
                endif
!
!        jaf=4: inverse power law extrapolation
!               using force susceptibility and avg. boundary contact
!               Warning: requires initial fbxn>0! Use jaf=2 if fbxn=0
                if(jaf.eq.4) then
                  if(fbxn(ivs).eq.0.d0) goto 22
!
                  ebxn=fbxn(ivs)*c1bxn/q1bxn
                  ebxn_lo=dlog(q1bxn/qqbxn)/dlog(1.0d20)
                  if(ebxn.lt.ebxn_lo) ebxn=ebxn_lo
                  afbxn=                                                &
     &            ((q1bxn/qqbxn)**(1.d0/ebxn)-1.d0)*fbxn(ivs)*redbxn
                  if(afbxn.gt.afbxn_max) afbxn=afbxn_max
!
                  fbxn(ivs)=fbxn(ivs)+afbxn
                endif
!
!        jaf=5: incremental exponential suppression factor
!               using avg. boundary contact only
                if(jaf.eq.5) then
                  afbxn=                                                &
     &            dlog(q1bxn/qqbxn)*redbxn
                  if(afbxn.gt.afbxn_max) afbxn=afbxn_max
!
                  fbxn(ivs)=fbxn(ivs)+afbxn
                endif
              endif
            endif
          endif
        enddo
!
!   re-calculate htot_th etc. with new boundary forces
!
        call reset_yspec
        if(jwgt_mc(kmvsequ,jmvloop).eq.-1) then
          jDB_sum_chi=3
          call sum_chi_u
        else
          jDB_sum_chi=4
          call sum_chi_w
        endif
        call store_chi_th
!
!   store avg. boundary contact and susceptibility
!   for "odat_th"-output
!
        do ivs=0,nvs_spec
          nac_fbxo=nac_fbx
          qbxx_fbxo(ivs)=qbxx_fbx(ivs)
          cbxx_fbxo(ivs)=q2bxx_fbx(ivs)-qbxx_fbx(ivs)**2
!
          qbxn_fbxo(ivs)=qbxn_fbx(ivs)
          cbxn_fbxo(ivs)=q2bxn_fbx(ivs)-qbxn_fbx(ivs)**2
        enddo
      endif
!
!   zero fbx-accumulators
!
      if(nac_fbx.ge.mac_fbx) then
        do ivs=0,nvs_spec
          qbxx_fbx(ivs)=0.d0
          q2bxx_fbx(ivs)=0.d0
!
          qbxn_fbx(ivs)=0.d0
          q2bxn_fbx(ivs)=0.d0
        enddo
        neq_fbx=0
        nac_fbx=0
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine sch_fts
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! set insertion-forced kinetics control parameters
!
      jsfxdi=jtmp_sx(imvsequ,jmvloop)
      jkrxdi=jtmp_kx(imvsequ,jmvloop)
!
! update MC temperature and stepwidths
!
!
      ftmp_imv=1.d0
      if(jtmp_mv(imvsequ,jmvloop).eq.0) then
        ftmp_imv=1.d0
      endif
!
      if(jtmp_mv(imvsequ,jmvloop).eq.1) then
        ftmp_imv=ftmp_mc(imvsequ,jmvloop)
      endif
!
      if(jtmp_mv(imvsequ,jmvloop).eq.10) then
        if(kmvsequ_lp.ge.1) then
          r1=kmove/(1.d0*nmove(kmvsequ,jmvloop))
          ftmp_imv=                                                     &
     &         r1*ftmp_mc(imvsequ,jmvloop)                              &
     &        +(1.d0-r1)*ftmp_mc(kmvsequ_lp,jmvloop)
        else
          ftmp_imv=ftmp_mc(imvsequ,jmvloop)
        endif
      endif
!
      if(jtmp_mv(imvsequ,jmvloop).eq.11) then
        if(kmvsequ_lp.ge.1) then
          r1=kmove/(1.d0*nmove(kmvsequ,jmvloop))
          ftmp_imv=                                                     &
     &         r1/ftmp_mc(imvsequ,jmvloop)                              &
     &        +(1.d0-r1)/ftmp_mc(kmvsequ_lp,jmvloop)
          ftmp_imv=1.d0/ftmp_imv
        else
          ftmp_imv=ftmp_mc(imvsequ,jmvloop)
        endif
      endif
!
      if(jtmp_mv(imvsequ,jmvloop).eq.12) then
        if(kmvsequ_lp.ge.1) then
          r1=kmove/(1.d0*nmove(kmvsequ,jmvloop))
          ftmp_imv=                                                     &
     &     r1*dlog(dabs(ftmp_mc(imvsequ,jmvloop)))                      &
     &    +(1.d0-r1)*dlog(dabs(ftmp_mc(kmvsequ_lp,jmvloop)))
          ftmp_imv=dexp(ftmp_imv)
        else
          ftmp_imv=ftmp_mc(imvsequ,jmvloop)
        endif
      endif
!
!
      fstp_imv=1.d0
      if(jstp_mc(imvsequ,jmvloop).eq.0) then
        fstp_imv=1.d0
      endif
!
      if(jstp_mc(imvsequ,jmvloop).eq.1) then
        fstp_imv=fstp_mc(imvsequ,jmvloop)
      endif
!
      if(jstp_mc(imvsequ,jmvloop).eq.10) then
        if(kmvsequ_lp.ge.1) then
          r1=kmove/(1.d0*nmove(kmvsequ,jmvloop))
          fstp_imv=                                                     &
     &         r1*fstp_mc(imvsequ,jmvloop)                              &
     &        +(1.d0-r1)*fstp_mc(kmvsequ_lp,jmvloop)
        else
          fstp_imv=fstp_mc(imvsequ,jmvloop)
        endif
      endif
!
      if(jstp_mc(imvsequ,jmvloop).eq.11) then
        if(kmvsequ_lp.ge.1) then
          r1=kmove/(1.d0*nmove(kmvsequ,jmvloop))
          fstp_imv=                                                     &
     &         r1/fstp_mc(imvsequ,jmvloop)                              &
     &        +(1.d0-r1)/fstp_mc(kmvsequ_lp,jmvloop)
          fstp_imv=1.d0/fstp_imv
        else
          fstp_imv=fstp_mc(imvsequ,jmvloop)
        endif
      endif
!
      if(jstp_mc(imvsequ,jmvloop).eq.12) then
        if(kmvsequ_lp.ge.1) then
          r1=kmove/(1.d0*nmove(kmvsequ,jmvloop))
          fstp_imv=                                                     &
     &         r1*dlog(dabs(fstp_mc(imvsequ,jmvloop)))                  &
     &        +(1.d0-r1)*dlog(dabs(fstp_mc(kmvsequ_lp,jmvloop)))
          fstp_imv=dexp(fstp_imv)
        else
          fstp_imv=fstp_mc(imvsequ,jmvloop)
        endif
      endif
!
!
      if(jupd_chi.lt.2) then
        if(imove.eq.1) then
          if(kmvsequ_lp.lt.1) jupd_chi=2
          if(kmvsequ_lp.ge.1) then
            if(jtmp_mc(kmvsequ,jmvloop).ne.jtmp_mc(kmvsequ_lp,jmvloop)) &
     &      jupd_chi=2
          endif
        endif
!
!c      if(jkrxdi.ge.2) then
!c        if(jupd_sfxdi.eq.1.and.jupd_abaxdi.eq.1) jupd_chi=2
!c        jupd_sfxdi=0
!c        jupd_abaxdi=0
!c      endif
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine sch_fwgt
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! store data re-weight factors for \chi^2-calculation
!
      fwgt_tot=-1.d0
!
      if(imvsequ.le.0) return
      if(kmvsequ.le.0) return
      if(jmvloop.le.0) return
      if(jwgt_mc(kmvsequ,jmvloop).eq.-1) return
!
!
!  set move-scheduled weight parameters
!
      npwgt_tot=npwgt(0,imvsequ,jmvloop)                                &
     &         +npwgt(1,imvsequ,jmvloop)
      do lpwgt=1,npwgt_tot
        if(jwgt_mv(imvsequ,jmvloop).eq.1) then
          pwgt(lpwgt)=pwgt_mc(lpwgt,imvsequ,jmvloop)
        endif
!
        if(jwgt_mv(imvsequ,jmvloop).eq.10) then
          if(kmvsequ_lp.ge.1) then
            r1=kmove/(1.d0*nmove(kmvsequ,jmvloop))
            pwgt(lpwgt)=                                                &
     &           r1*pwgt_mc(lpwgt,imvsequ,jmvloop)                      &
     &          +(1.d0-r1)*pwgt_mc(lpwgt,kmvsequ_lp,jmvloop)
          else
            pwgt(lpwgt)=pwgt_mc(lpwgt,imvsequ,jmvloop)
          endif
        endif
!
        if(jwgt_mv(imvsequ,jmvloop).eq.11) then
          if(kmvsequ_lp.ge.1) then
            r1=kmove/(1.d0*nmove(kmvsequ,jmvloop))
            pwgt(lpwgt)=                                                &
     &           r1/pwgt_mc(lpwgt,imvsequ,jmvloop)                      &
     &          +(1.d0-r1)/pwgt_mc(lpwgt,kmvsequ_lp,jmvloop)
            pwgt(lpwgt)=1.d0/pwgt(lpwgt)
          else
            pwgt(lpwgt)=pwgt_mc(lpwgt,imvsequ,jmvloop)
          endif
        endif
!
        if(jwgt_mv(imvsequ,jmvloop).eq.12) then
          if(kmvsequ_lp.ge.1) then
            r1=kmove/(1.d0*nmove(kmvsequ,jmvloop))
            pwgt(lpwgt)=                                                &
     &       r1*dlog(dabs(pwgt_mc(lpwgt,imvsequ,jmvloop)))              &
     &      +(1.d0-r1)*dlog(dabs(pwgt_mc(lpwgt,kmvsequ_lp,jmvloop)))
            pwgt(lpwgt)=dexp(pwgt(lpwgt))
          else
            pwgt(lpwgt)=pwgt_mc(lpwgt,imvsequ,jmvloop)
          endif
        endif
      enddo
!
!  store itxpt-dep. weight factors for each data point
!
      fwgt(0)=0.d0
      fwgt_tot=0.d0
!
      if(npwgt(0,imvsequ,jmvloop).gt.1) then
        ixpt_dtin=0
        do itxpt=1,ntxpt
          if(jwgt_tv(imvsequ,jmvloop).eq.0) then
            txpt_wgt=itxpt-1.d0
          endif
!
          if(jwgt_tv(imvsequ,jmvloop).eq.1) then
            txpt_wgt=(itxpt-1.d0)/(ntxpt-1.d0)
          endif
!
          if(jwgt_tv(imvsequ,jmvloop).eq.2) then
            txpt_wgt=time_xpt(itxpt)-time_xpt(1)
          endif
!
          if(jwgt_tv(imvsequ,jmvloop).eq.3) then
            txpt_wgt=(time_xpt(itxpt)-time_xpt(1))                      &
     &              /(time_xpt(ntxpt)-time_xpt(1))
          endif
!
          ntrapz=npwgt(0,imvsequ,jmvloop)/4
!
          do iexpt=1,nexpt
            do ims=1,nms_spec
              fwgt(itmx_xpt(ims,itxpt,iexpt))=0.d0
!
              if(itmx_xpt(ims,itxpt,iexpt).gt.0) then
                if(jwgt_tv(imvsequ,jmvloop).eq.4) then
                  ixpt_dtin=ixpt_dtin+1
                  txpt_wgt=ixpt_dtin-1.d0
                endif
!
                if(jwgt_tv(imvsequ,jmvloop).eq.5) then
                  ixpt_dtin=ixpt_dtin+1
                  txpt_wgt=(ixpt_dtin-1.d0)/(mdtin-1.d0)
                endif
!
!               pwgt(1)=twgt_cent=weight pulse centroid
!               pwgt(2)=twgt_leng=weight pulse half-length (HWHM)
!               pwgt(3)=twgt_rise=weight pulse rise time
!               pwgt(4)=fwgt_ampl=weight pulse amplitude at centroid
                fwgt(itmx_xpt(ims,itxpt,iexpt))=0.d0
                do itrapz=1,ntrapz
                  ioffs=4*(itrapz-1)
                  fwgt(itmx_xpt(ims,itxpt,iexpt))=                      &
     &            fwgt(itmx_xpt(ims,itxpt,iexpt))                       &
     &           +pwgt(4+ioffs)                                         &
     &           *wtshape(txpt_wgt                                      &
     &                   ,pwgt(1+ioffs)                                 &
     &                   ,pwgt(2+ioffs)                                 &
     &                   ,pwgt(3+ioffs)                                 &
     &                   ,jwgt_sh(imvsequ,jmvloop)                      &
     &                   )
                enddo
!
                fwgt_tot=fwgt_tot                                       &
     &                  +fwgt(itmx_xpt(ims,itxpt,iexpt))
              endif
            enddo
          enddo
        enddo
      else
        if(npwgt(0,imvsequ,jmvloop).eq.1) then
          do itmx=1,mdtin
            fwgt(itmx)=pwgt(1)
          enddo
          fwgt_tot=pwgt(1)*mdtin
        endif
        if(npwgt(0,imvsequ,jmvloop).le.0) then
          do itmx=1,mdtin
            fwgt(itmx)=1.d0
          enddo
          fwgt_tot=mdtin
        endif
      endif
!
!
      if(npwgt(1,imvsequ,jmvloop).gt.0) then
        fwgt_tot=0.d0
!
        lpwgt=npwgt(0,imvsequ,jmvloop)
        do ipwgt=1,npwgt(1,imvsequ,jmvloop)
          lpwgt=lpwgt+1
!
          if(iexpt_wc1(lpwgt,imvsequ,jmvloop).gt.0) then
            iexpt0=iexpt_wc0(lpwgt,imvsequ,jmvloop)
            iexpt1=iexpt_wc1(lpwgt,imvsequ,jmvloop)
          else
            iexpt0=1
            iexpt1=nexpt
          endif
!
          if(ims_wc1(lpwgt,imvsequ,jmvloop).gt.0) then
            ims0=ims_wc0(lpwgt,imvsequ,jmvloop)
            ims1=ims_wc1(lpwgt,imvsequ,jmvloop)
          else
            ims0=1
            ims1=nms_spec
          endif
!
          if(itxpt_wc1(lpwgt,imvsequ,jmvloop).gt.0) then
            itxpt0=itxpt_wc0(lpwgt,imvsequ,jmvloop)
            itxpt1=itxpt_wc1(lpwgt,imvsequ,jmvloop)
          else
            itxpt0=1
            itxpt1=ntxpt
          endif
!
          do iexpt=iexpt0,iexpt1
            do ims=ims0,ims1
              do itmx=itmx_ini(ims,iexpt),itmx_fin(ims,iexpt)
                if                                                      &
     &          (                                                       &
     &          itxpt_tmx(itmx).ge.itxpt0.and.                          &
     &          itxpt_tmx(itmx).le.itxpt1                               &
     &          )then
                  fwgt(itmx)=fwgt(itmx)*pwgt(lpwgt)
                endif
                if(ipwgt.eq.npwgt(1,imvsequ,jmvloop))                   &
     &          fwgt_tot=fwgt_tot+fwgt(itmx)
              enddo
            enddo
          enddo
        enddo
      endif
!
      fwgt_tot=fwgt_tot/mdtin
!
!
      jfwgt=1
      call chi_prex
!
      if(jupd_chi.lt.1) jupd_chi=1
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine sch_fbound
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
! update MC boundary forces and/or boundary contact limits
! and upper boundary contact force parameters
!
      qqbxx_imv=1.d0
      redbxx_imv=1.d0
      fbxx_imv=0.d0
      afbxx_max_imv=0.d0
      bxx_lo_imv=0.9d0
      bxx_hi_imv=1.0d0
!
      jbxx_qb_imv=-1
      jbxx_af_imv=-1
      jbxx_nf_imv=-1
      jbxx_mc_imv=-1
!
      if(imvsequ.le.0) goto 100
      if(jmvloop.le.0) goto 100
!
      jbxx_qb_imv=jbxx_qb(imvsequ,jmvloop)
      jbxx_af_imv=jbxx_af(imvsequ,jmvloop)
      jbxx_nf_imv=jbxx_nf(imvsequ,jmvloop)
      jbxx_mc_imv=jbxx_mc(imvsequ,jmvloop)
!
      if(jbxx_mv(imvsequ,jmvloop).eq.0) then
        qqbxx_imv=1.d0
        redbxx_imv=1.d0
        fbxx_imv=0.d0
        afbxx_max_imv=0.d0
        bxx_lo_imv=0.9d0
        bxx_hi_imv=1.0d0
      endif
!
      if(jbxx_mv(imvsequ,jmvloop).eq.1) then
        qqbxx_imv=qqbxx_mc(imvsequ,jmvloop)
        redbxx_imv=redbxx_mc(imvsequ,jmvloop)
        fbxx_imv=fbxx_mc(imvsequ,jmvloop)
        afbxx_max_imv=afbxx_max_mc(imvsequ,jmvloop)
        bxx_lo_imv=bxx_lo_mc(imvsequ,jmvloop)
        bxx_hi_imv=bxx_hi_mc(imvsequ,jmvloop)
      endif
!
      if(jbxx_mv(imvsequ,jmvloop).eq.10) then
        if(kmvsequ_lp.ge.1) then
          r1=kmove/(1.d0*nmove(kmvsequ,jmvloop))
          qqbxx_imv=                                                    &
     &         r1*qqbxx_mc(imvsequ,jmvloop)                             &
     &        +(1.d0-r1)*qqbxx_mc(kmvsequ_lp,jmvloop)
          redbxx_imv=                                                   &
     &         r1*redbxx_mc(imvsequ,jmvloop)                            &
     &        +(1.d0-r1)*redbxx_mc(kmvsequ_lp,jmvloop)
          fbxx_imv=                                                     &
     &         r1*fbxx_mc(imvsequ,jmvloop)                              &
     &        +(1.d0-r1)*fbxx_mc(kmvsequ_lp,jmvloop)
          afbxx_max_imv=                                                &
     &         r1*afbxx_max_mc(imvsequ,jmvloop)                         &
     &        +(1.d0-r1)*afbxx_max_mc(kmvsequ_lp,jmvloop)
          bxx_lo_imv=                                                   &
     &         r1*bxx_lo_mc(imvsequ,jmvloop)                            &
     &        +(1.d0-r1)*bxx_lo_mc(kmvsequ_lp,jmvloop)
          bxx_hi_imv=                                                   &
     &         r1*bxx_hi_mc(imvsequ,jmvloop)                            &
     &        +(1.d0-r1)*bxx_hi_mc(kmvsequ_lp,jmvloop)
        else
          qqbxx_imv = qqbxx_mc(imvsequ,jmvloop)
          redbxx_imv=redbxx_mc(imvsequ,jmvloop)
            fbxx_imv=  fbxx_mc(imvsequ,jmvloop)
          afbxx_max_imv=afbxx_max_mc(imvsequ,jmvloop)
          bxx_lo_imv=bxx_lo_mc(imvsequ,jmvloop)
          bxx_hi_imv=bxx_hi_mc(imvsequ,jmvloop)
        endif
      endif
!
      if(jbxx_mv(imvsequ,jmvloop).eq.11) then
        if(kmvsequ_lp.ge.1) then
          r1=kmove/(1.d0*nmove(kmvsequ,jmvloop))
          qqbxx_imv=                                                    &
     &         r1/qqbxx_mc(imvsequ,jmvloop)                             &
     &        +(1.d0-r1)/qqbxx_mc(kmvsequ_lp,jmvloop)
          qqbxx_imv=1.d0/qqbxx_imv
          redbxx_imv=                                                   &
     &         r1/redbxx_mc(imvsequ,jmvloop)                            &
     &        +(1.d0-r1)/redbxx_mc(kmvsequ_lp,jmvloop)
          redbxx_imv=1.d0/redbxx_imv
          fbxx_imv=                                                     &
     &         r1/fbxx_mc(imvsequ,jmvloop)                              &
     &        +(1.d0-r1)/fbxx_mc(kmvsequ_lp,jmvloop)
          fbxx_imv=1.d0/fbxx_imv
          afbxx_max_imv=                                                &
     &         r1/afbxx_max_mc(imvsequ,jmvloop)                         &
     &        +(1.d0-r1)/afbxx_max_mc(kmvsequ_lp,jmvloop)
          afbxx_max_imv=1.d0/afbxx_max_imv
          bxx_lo_imv=                                                   &
     &         r1/bxx_lo_mc(imvsequ,jmvloop)                            &
     &        +(1.d0-r1)/bxx_lo_mc(kmvsequ_lp,jmvloop)
          bxx_lo_imv=1.d0/bxx_lo_imv
          bxx_hi_imv=                                                   &
     &         r1/bxx_hi_mc(imvsequ,jmvloop)                            &
     &        +(1.d0-r1)/bxx_hi_mc(kmvsequ_lp,jmvloop)
          bxx_hi_imv=1.d0/bxx_hi_imv
        else
          qqbxx_imv = qqbxx_mc(imvsequ,jmvloop)
          redbxx_imv=redbxx_mc(imvsequ,jmvloop)
            fbxx_imv=  fbxx_mc(imvsequ,jmvloop)
          afbxx_max_imv=afbxx_max_mc(imvsequ,jmvloop)
          bxx_lo_imv=bxx_lo_mc(imvsequ,jmvloop)
          bxx_hi_imv=bxx_hi_mc(imvsequ,jmvloop)
        endif
      endif
!
      if(jbxx_mv(imvsequ,jmvloop).eq.12) then
        if(kmvsequ_lp.ge.1) then
          r1=kmove/(1.d0*nmove(kmvsequ,jmvloop))
          qqbxx_imv=                                                    &
     &     r1*dlog(dabs(qqbxx_mc(imvsequ,jmvloop)))                     &
     &    +(1.d0-r1)*dlog(dabs(qqbxx_mc(kmvsequ_lp,jmvloop)))
          qqbxx_imv=dexp(qqbxx_imv)
          redbxx_imv=                                                   &
     &     r1*dlog(dabs(redbxx_mc(imvsequ,jmvloop)))                    &
     &    +(1.d0-r1)*dlog(dabs(redbxx_mc(kmvsequ_lp,jmvloop)))
          redbxx_imv=dexp(redbxx_imv)
          fbxx_imv=                                                     &
     &     r1*dlog(dabs(fbxx_mc(imvsequ,jmvloop)))                      &
     &    +(1.d0-r1)*dlog(dabs(fbxx_mc(kmvsequ_lp,jmvloop)))
          fbxx_imv=dexp(fbxx_imv)
          afbxx_max_imv=                                                &
     &     r1*dlog(dabs(afbxx_max_mc(imvsequ,jmvloop)))                 &
     &    +(1.d0-r1)*dlog(dabs(afbxx_max_mc(kmvsequ_lp,jmvloop)))
          afbxx_max_imv=dexp(afbxx_max_imv)
          bxx_lo_imv=                                                   &
     &     r1*dlog(dabs(bxx_lo_mc(imvsequ,jmvloop)))                    &
     &    +(1.d0-r1)*dlog(dabs(bxx_lo_mc(kmvsequ_lp,jmvloop)))
          bxx_lo_imv=dexp(bxx_lo_imv)
          bxx_hi_imv=                                                   &
     &     r1*dlog(dabs(bxx_hi_mc(imvsequ,jmvloop)))                    &
     &    +(1.d0-r1)*dlog(dabs(bxx_hi_mc(kmvsequ_lp,jmvloop)))
          bxx_hi_imv=dexp(bxx_hi_imv)
        else
          qqbxx_imv = qqbxx_mc(imvsequ,jmvloop)
          redbxx_imv=redbxx_mc(imvsequ,jmvloop)
            fbxx_imv=  fbxx_mc(imvsequ,jmvloop)
          afbxx_max_imv=afbxx_max_mc(imvsequ,jmvloop)
          bxx_lo_imv=bxx_lo_mc(imvsequ,jmvloop)
          bxx_hi_imv=bxx_hi_mc(imvsequ,jmvloop)
        endif
      endif
!
! ext. controlled, fixed boundary force option
!
      if(jbxx_af(imvsequ,jmvloop).eq.0) goto 100
      goto 101
  100 continue
        do ivs=0,nvs_spec
          fbxx(ivs)=fbxx_imv
        enddo
  101 continue
!
! lower boundary contact force parameters
!
      qqbxn_imv=1.d0
      redbxn_imv=1.d0
      fbxn_imv=0.d0
      afbxn_max_imv=0.d0
      bxn_lo_imv=0.0d0
      bxn_hi_imv=0.1d0
!
      jbxn_qb_imv=-1
      jbxn_af_imv=-1
      jbxn_nf_imv=-1
      jbxn_mc_imv=-1
!
      if(imvsequ.le.0) goto 200
      if(jmvloop.le.0) goto 200
!
      jbxn_qb_imv=jbxn_qb(imvsequ,jmvloop)
      jbxn_af_imv=jbxn_af(imvsequ,jmvloop)
      jbxn_nf_imv=jbxn_nf(imvsequ,jmvloop)
      jbxn_mc_imv=jbxn_mc(imvsequ,jmvloop)
!
      if(jbxn_mv(imvsequ,jmvloop).eq.0) then
        qqbxn_imv=1.d0
        redbxn_imv=1.d0
        fbxn_imv=0.d0
        afbxn_max_imv=0.d0
        bxn_lo_imv=0.9d0
        bxn_hi_imv=1.0d0
      endif
!
      if(jbxn_mv(imvsequ,jmvloop).eq.1) then
        qqbxn_imv=qqbxn_mc(imvsequ,jmvloop)
        redbxn_imv=redbxn_mc(imvsequ,jmvloop)
        fbxn_imv=fbxn_mc(imvsequ,jmvloop)
        afbxn_max_imv=afbxn_max_mc(imvsequ,jmvloop)
        bxn_lo_imv=bxn_lo_mc(imvsequ,jmvloop)
        bxn_hi_imv=bxn_hi_mc(imvsequ,jmvloop)
      endif
!
      if(jbxn_mv(imvsequ,jmvloop).eq.10) then
        if(kmvsequ_lp.ge.1) then
          r1=kmove/(1.d0*nmove(kmvsequ,jmvloop))
          qqbxn_imv=                                                    &
     &         r1*qqbxn_mc(imvsequ,jmvloop)                             &
     &        +(1.d0-r1)*qqbxn_mc(kmvsequ_lp,jmvloop)
          redbxn_imv=                                                   &
     &         r1*redbxn_mc(imvsequ,jmvloop)                            &
     &        +(1.d0-r1)*redbxn_mc(kmvsequ_lp,jmvloop)
          fbxn_imv=                                                     &
     &         r1*fbxn_mc(imvsequ,jmvloop)                              &
     &        +(1.d0-r1)*fbxn_mc(kmvsequ_lp,jmvloop)
          afbxn_max_imv=                                                &
     &         r1*afbxn_max_mc(imvsequ,jmvloop)                         &
     &        +(1.d0-r1)*afbxn_max_mc(kmvsequ_lp,jmvloop)
          bxn_lo_imv=                                                   &
     &         r1*bxn_lo_mc(imvsequ,jmvloop)                            &
     &        +(1.d0-r1)*bxn_lo_mc(kmvsequ_lp,jmvloop)
          bxn_hi_imv=                                                   &
     &         r1*bxn_hi_mc(imvsequ,jmvloop)                            &
     &        +(1.d0-r1)*bxn_hi_mc(kmvsequ_lp,jmvloop)
        else
          qqbxn_imv=qqbxn_mc(imvsequ,jmvloop)
          redbxn_imv=redbxn_mc(imvsequ,jmvloop)
          fbxn_imv=fbxn_mc(imvsequ,jmvloop)
          afbxn_max_imv=afbxn_max_mc(imvsequ,jmvloop)
          bxn_lo_imv=bxn_lo_mc(imvsequ,jmvloop)
          bxn_hi_imv=bxn_hi_mc(imvsequ,jmvloop)
        endif
      endif
!
      if(jbxn_mv(imvsequ,jmvloop).eq.11) then
        if(kmvsequ_lp.ge.1) then
          r1=kmove/(1.d0*nmove(kmvsequ,jmvloop))
          qqbxn_imv=                                                    &
     &         r1/qqbxn_mc(imvsequ,jmvloop)                             &
     &        +(1.d0-r1)/qqbxn_mc(kmvsequ_lp,jmvloop)
          qqbxn_imv=1.d0/qqbxn_imv
          redbxn_imv=                                                   &
     &         r1/redbxn_mc(imvsequ,jmvloop)                            &
     &        +(1.d0-r1)/redbxn_mc(kmvsequ_lp,jmvloop)
          redbxn_imv=1.d0/redbxn_imv
          fbxn_imv=                                                     &
     &         r1/fbxn_mc(imvsequ,jmvloop)                              &
     &        +(1.d0-r1)/fbxn_mc(kmvsequ_lp,jmvloop)
          fbxn_imv=1.d0/fbxn_imv
          afbxn_max_imv=                                                &
     &         r1/afbxn_max_mc(imvsequ,jmvloop)                         &
     &        +(1.d0-r1)/afbxn_max_mc(kmvsequ_lp,jmvloop)
          afbxn_max_imv=1.d0/afbxn_max_imv
          bxn_lo_imv=                                                   &
     &         r1/bxn_lo_mc(imvsequ,jmvloop)                            &
     &        +(1.d0-r1)/bxn_lo_mc(kmvsequ_lp,jmvloop)
          bxn_lo_imv=1.d0/bxn_lo_imv
          bxn_hi_imv=                                                   &
     &         r1/bxn_hi_mc(imvsequ,jmvloop)                            &
     &        +(1.d0-r1)/bxn_hi_mc(kmvsequ_lp,jmvloop)
          bxn_hi_imv=1.d0/bxn_hi_imv
        else
          qqbxn_imv=qqbxn_mc(imvsequ,jmvloop)
          redbxn_imv=redbxn_mc(imvsequ,jmvloop)
          fbxn_imv=fbxn_mc(imvsequ,jmvloop)
          afbxn_max_imv=afbxn_max_mc(imvsequ,jmvloop)
          bxn_lo_imv=bxn_lo_mc(imvsequ,jmvloop)
          bxn_hi_imv=bxn_hi_mc(imvsequ,jmvloop)
        endif
      endif
!
      if(jbxn_mv(imvsequ,jmvloop).eq.12) then
        if(kmvsequ_lp.ge.1) then
          r1=kmove/(1.d0*nmove(kmvsequ,jmvloop))
          qqbxn_imv=                                                    &
     &     r1*dlog(dabs(qqbxn_mc(imvsequ,jmvloop)))                     &
     &    +(1.d0-r1)*dlog(dabs(qqbxn_mc(kmvsequ_lp,jmvloop)))
          qqbxn_imv=dexp(qqbxn_imv)
          redbxn_imv=                                                   &
     &     r1*dlog(dabs(redbxn_mc(imvsequ,jmvloop)))                    &
     &    +(1.d0-r1)*dlog(dabs(redbxn_mc(kmvsequ_lp,jmvloop)))
          redbxn_imv=dexp(redbxn_imv)
          fbxn_imv=                                                     &
     &     r1*dlog(dabs(fbxn_mc(imvsequ,jmvloop)))                      &
     &    +(1.d0-r1)*dlog(dabs(fbxn_mc(kmvsequ_lp,jmvloop)))
          fbxn_imv=dexp(fbxn_imv)
          afbxn_max_imv=                                                &
     &     r1*dlog(dabs(afbxn_max_mc(imvsequ,jmvloop)))                 &
     &    +(1.d0-r1)*dlog(dabs(afbxn_max_mc(kmvsequ_lp,jmvloop)))
          afbxn_max_imv=dexp(afbxn_max_imv)
          bxn_lo_imv=                                                   &
     &     r1*dlog(dabs(bxn_lo_mc(imvsequ,jmvloop)))                    &
     &    +(1.d0-r1)*dlog(dabs(bxn_lo_mc(kmvsequ_lp,jmvloop)))
          bxn_lo_imv=dexp(bxn_lo_imv)
          bxn_hi_imv=                                                   &
     &     r1*dlog(dabs(bxn_hi_mc(imvsequ,jmvloop)))                    &
     &    +(1.d0-r1)*dlog(dabs(bxn_hi_mc(kmvsequ_lp,jmvloop)))
          bxn_hi_imv=dexp(bxn_hi_imv)
        else
          qqbxn_imv=qqbxn_mc(imvsequ,jmvloop)
          redbxn_imv=redbxn_mc(imvsequ,jmvloop)
          fbxn_imv=fbxn_mc(imvsequ,jmvloop)
          afbxn_max_imv=afbxn_max_mc(imvsequ,jmvloop)
          bxn_lo_imv=bxn_lo_mc(imvsequ,jmvloop)
          bxn_hi_imv=bxn_hi_mc(imvsequ,jmvloop)
        endif
      endif
!
! ext. controlled, fixed boundary force option
!
      if(jbxn_af(imvsequ,jmvloop).eq.0) goto 200
      goto 201
  200 continue
        do ivs=0,nvs_spec
          fbxn(ivs)=fbxn_imv
        enddo
  201 continue
!
!
! species boundary location and width parameters
!
      do ivs=1,nvs_spec
        ispec=ispec_vs(ivs)
        dxspec=dabs(xspec_max(ispec)-xspec_min(ispec))
!
!      upper boundary...
        xbxx_lo=xspec_min(ispec)+dxspec*bxx_lo_imv
        xbxx_hi=xspec_min(ispec)+dxspec*bxx_hi_imv
!
        ybxx_lo(ivs)=dlog(dabs(xbxx_lo))
        ybxx_hi(ivs)=dlog(dabs(xbxx_hi))
        if(dabs(ybxx_lo(ivs)-ybxx_hi(ivs)).lt.1.d-8)                    &
     &  ybxx_lo(ivs)=ybxx_hi(ivs)-1.d-8
!
        ybxx_ct(ivs)=0.5d0*(ybxx_lo(ivs)+ybxx_hi(ivs))
        sbxx(ivs)=1.0d0/(dabs(ybxx_hi(ivs)-ybxx_lo(ivs)))
!
!      lower boundary...
        xbxn_lo=xspec_min(ispec)+dxspec*bxn_lo_imv
        xbxn_hi=xspec_min(ispec)+dxspec*bxn_hi_imv
!
        ybxn_lo(ivs)=dlog(dabs(xbxn_lo))
        ybxn_hi(ivs)=dlog(dabs(xbxn_hi))
        if(dabs(ybxn_lo(ivs)-ybxn_hi(ivs)).lt.1.d-8)                    &
     &  ybxn_hi(ivs)=ybxn_lo(ivs)+1.d-8
!
        ybxn_ct(ivs)=0.5d0*(ybxn_lo(ivs)+ybxn_hi(ivs))
        sbxn(ivs)=1.0d0/(dabs(ybxn_hi(ivs)-ybxn_lo(ivs))+1.d-30)
      enddo
!
!
      if(jupd_chi.lt.1) jupd_chi=1
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine sch_ffour
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
!
      include 'ens.def'
!
!
      ffour_imv=0.d0
      efour_imv=1.d0
      cfour_imv=1.d0
!
      do iexpt=1,nexpt
        do isegft=1,nsegft(iexpt)
          do ifil_frq=1,nfil_frq(isegft,iexpt)
            wfour_sfil(ifil_frq,isegft,iexpt)=1.d0
          enddo
        enddo
      enddo
!
      jsft_xd_imv=-1
      jsft_wf_imv=-1
      jsft_pf_imv=-1
      jsft_ln_imv=-1
      jsft_mc_imv=-1
!
      if(imvsequ.le.0) return
      if(jmvloop.le.0) return
!
!V090911:
!DEACTIVATED
!R    jsft_xd_imv=jsft_xd(imvsequ,jmvloop)
!:V090911
      jsft_wf_imv=jsft_wf(imvsequ,jmvloop)
      jsft_pf_imv=jsft_pf(imvsequ,jmvloop)
      jsft_ln_imv=jsft_ln(imvsequ,jmvloop)
      jsft_mc_imv=jsft_mc(imvsequ,jmvloop)
!
      if(jsft_mv(imvsequ,jmvloop).eq.0) then
        ffour_imv=1.d0
      endif
!
      if(jsft_mv(imvsequ,jmvloop).eq.1) then
        ffour_imv=ffour_mc(imvsequ,jmvloop)
        efour_imv=efour_mc(imvsequ,jmvloop)
        cfour_imv=cfour_mc(imvsequ,jmvloop)
      endif
!
      if(jsft_mv(imvsequ,jmvloop).eq.10) then
        if(kmvsequ_lp.ge.1) then
          r1=kmove/(1.d0*nmove(kmvsequ,jmvloop))
          ffour_imv=                                                    &
     &         r1*ffour_mc(imvsequ,jmvloop)                             &
     &        +(1.d0-r1)*ffour_mc(kmvsequ_lp,jmvloop)
          efour_imv=                                                    &
     &         r1*efour_mc(imvsequ,jmvloop)                             &
     &        +(1.d0-r1)*efour_mc(kmvsequ_lp,jmvloop)
          cfour_imv=                                                    &
     &         r1*cfour_mc(imvsequ,jmvloop)                             &
     &        +(1.d0-r1)*cfour_mc(kmvsequ_lp,jmvloop)
        else
          ffour_imv = ffour_mc(imvsequ,jmvloop)
          efour_imv = efour_mc(imvsequ,jmvloop)
          cfour_imv = cfour_mc(imvsequ,jmvloop)
        endif
      endif
!
      if(jsft_mv(imvsequ,jmvloop).eq.11) then
        if(kmvsequ_lp.ge.1) then
          r1=kmove/(1.d0*nmove(kmvsequ,jmvloop))
          ffour_imv=                                                    &
     &         r1/ffour_mc(imvsequ,jmvloop)                             &
     &        +(1.d0-r1)/ffour_mc(kmvsequ_lp,jmvloop)
          ffour_imv=1.d0/ffour_imv
          efour_imv=                                                    &
     &         r1/efour_mc(imvsequ,jmvloop)                             &
     &        +(1.d0-r1)/efour_mc(kmvsequ_lp,jmvloop)
          efour_imv=1.d0/efour_imv
          cfour_imv=                                                    &
     &         r1/cfour_mc(imvsequ,jmvloop)                             &
     &        +(1.d0-r1)/cfour_mc(kmvsequ_lp,jmvloop)
          cfour_imv=1.d0/cfour_imv
        else
          ffour_imv = ffour_mc(imvsequ,jmvloop)
          efour_imv = efour_mc(imvsequ,jmvloop)
          cfour_imv = cfour_mc(imvsequ,jmvloop)
        endif
      endif
!
      if(jsft_mv(imvsequ,jmvloop).eq.12) then
        if(kmvsequ_lp.ge.1) then
          r1=kmove/(1.d0*nmove(kmvsequ,jmvloop))
          ffour_imv=                                                    &
     &     r1*dlog(dabs(ffour_mc(imvsequ,jmvloop)))                     &
     &    +(1.d0-r1)*dlog(dabs(ffour_mc(kmvsequ_lp,jmvloop)))
          ffour_imv=dexp(ffour_imv)
          efour_imv=                                                    &
     &     r1*dlog(dabs(efour_mc(imvsequ,jmvloop)))                     &
     &    +(1.d0-r1)*dlog(dabs(efour_mc(kmvsequ_lp,jmvloop)))
          efour_imv=dexp(efour_imv)
          cfour_imv=                                                    &
     &     r1*dlog(dabs(cfour_mc(imvsequ,jmvloop)))                     &
     &    +(1.d0-r1)*dlog(dabs(cfour_mc(kmvsequ_lp,jmvloop)))
          cfour_imv=dexp(cfour_imv)
        else
          ffour_imv = ffour_mc(imvsequ,jmvloop)
          efour_imv = efour_mc(imvsequ,jmvloop)
          cfour_imv = cfour_mc(imvsequ,jmvloop)
        endif
      endif
!
!
      do iexpt=1,nexpt
        do isegft=1,nsegft(iexpt)
          nft_htime=nft_time(isegft,iexpt)/2
          wf_norm=0.d0
!
          do ifil_frq=1,nfil_frq(isegft,iexpt)
            ift_freq=ift_freq_fil(ifil_frq,isegft,iexpt)
!
            if(jsft_wf_imv.eq.0) then
              wfour_sfil(ifil_frq,isegft,iexpt)=1.d0
            endif
!
            if(jsft_wf_imv.ge.1) then
              wfour_sfil(ifil_frq,isegft,iexpt)=1.d0
              if(                                                       &
     &        ift_freq.eq.0.or.                                         &
     &        ift_freq.eq.nft_htime.or.                                 &
     &        ift_freq.eq.nft_time(isegft,iexpt)                        &
     &        )                                                         &
     &        wfour_sfil(ifil_frq,isegft,iexpt)=0.5d0
            endif
!
            wf_shape=1.d0
            if(jsft_wf_imv.eq.2) then
              wf_shape=                                                 &
     &        bfil_frq(isegft,iexpt)**2                                 &
     &        /( bfil_frq(isegft,iexpt)**2                              &
     &          +(ift_freq-cfil_frq(isegft,iexpt))**2 )
            endif
!
!V090911:
!DEACTIVATED
!R          if(jsft_wf_imv.eq.10) then
!R            wf_shape=0.d0
!R            do is_ft=1,nsft_spec
!R              if(pfour_xd_tot(is_ft,isegft,iexpt).gt.0.d0)            &
!R   &          wf_shape=wf_shape                                       &
!R   &          +pfour_xd(ift_freq,is_ft,isegft,iexpt)
!R            enddo
!R            if(wf_shape.le.0.d0) wf_shape=1.d0
!R          endif
!
!R          if(jsft_wf_imv.eq.11) then
!R            wf_shape=1.d0
!R            do is_ft=1,nsft_spec
!R              if(pfour_xd_tot(is_ft,isegft,iexpt).gt.0.d0) then
!R                wf_shape=pfour_xd(ift_freq,is_ft,isegft,iexpt)
!R                goto 410
!R              endif
!R            enddo
!R410         continue
!R            if(wf_shape.le.0.d0) wf_shape=1.d0
!R          endif
!:V090911
!
            wfour_sfil(ifil_frq,isegft,iexpt)=                          &
     &      wfour_sfil(ifil_frq,isegft,iexpt)*wf_shape
!
            wf_norm=wf_norm                                             &
     &      +wfour_sfil(ifil_frq,isegft,iexpt)
          enddo
!
          wf_norm=(1.d0*nfil_frq(isegft,iexpt))/wf_norm
          do ifil_frq=1,nfil_frq(isegft,iexpt)
            wfour_sfil(ifil_frq,isegft,iexpt)=                          &
     &      wfour_sfil(ifil_frq,isegft,iexpt)                           &
     &      *wf_norm
          enddo
        enddo
      enddo
!
!
      if(jupd_chi.lt.1) jupd_chi=1
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine sch_pst
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! initialize Theta population (if needed) and updating controls
! for PST moves
!
      include 'ens.def'
!
!
      if(imvsequ.le.0.or.jmvloop.le.0) return
!
      if(.not.                                                          &
     &   (jmty(imvsequ,jmvloop).ge.1000 .and.                           &
     &    jmty(imvsequ,jmvloop).le.2999)                                &
     &) return
!
      jtmpst_lst=jtmpst
!
      jinist=jini_st(imvsequ,jmvloop)
      jtmpst=jtmp_st(imvsequ,jmvloop)
      jxc1st=jxc1_st(imvsequ,jmvloop)
      jxc2st=jxc2_st(imvsequ,jmvloop)
      jmthyst=jmthy_st(imvsequ,jmvloop)
      jrthyst=jrthy_st(imvsequ,jmvloop)
      jxthyst=jxthy_st(imvsequ,jmvloop)
      mfoxst=mfox_st(imvsequ,jmvloop)
!c    if(jdo_st4ge.eq.1) mfoxst=0
      nparst=npar_st(imvsequ,jmvloop)
!
      althyst=althy_st(imvsequ,jmvloop)
      estpst=estp_st(imvsequ,jmvloop)
      amthyst=amthy_st(imvsequ,jmvloop)
!
      if(jdo_st4ge.eq.1) jpst_sch=1
!
      if(npop_st(imvsequ,jmvloop).ne.npopst_lst) jpst_sch=1
      if(npopst_lst.ge.1) then
        if(                                                             &
     &  dabs(beta_st(npopst_lst)-1.d0/temp_st(imvsequ,jmvloop))         &
     &  .ge.(1.d-8*beta_st(npopst_lst))                                 &
     &  .and.jtmpst.ge.10                                               &
     &  )jpst_sch=1
!
        if(jtmpst.ne.jtmpst_lst) jpst_sch=1
      endif
!
      if(jpst_sch.le.0) return
      jpst_sch=0
!
      if(jdo_st4ge.eq.0) then
        npopst=npopst_lst
        if(npopst.gt.0) call reord_st
      endif
!
      npopst=npop_st(imvsequ,jmvloop)
      if(jdo_st4ge.eq.1) then
        npopst=npopge
        if(jbsuge.eq.101) npopst=nsurvge
        if(jbsuge.eq.102) npopst=npopge-nsurvge-1
      endif
!
      do ipop=0,npopst
        iorst(ipop)=ipop
      enddo
!
!
      beta_st(npopst)=1.d0/temp_st(imvsequ,jmvloop)
      if(jtmpst.eq.0) beta_st(npopst)=beta_mc
!
!
      do ipop=0,(npopst-1)
        if(jtmpst.eq.0)                                                 &
     &  beta_st(ipop)=beta_mc
!
        if(jtmpst.eq.1)                                                 &
     &  beta_st(ipop)=beta_st(npopst)
!
        if(jtmpst.eq.10)                                                &
     &  beta_st(ipop)=1.d0/                                             &
     &                 (1.d0/beta_mc                                    &
     &                 +(                                               &
     &                  1.d0/beta_st(npopst)-1.d0/beta_mc               &
     &                  )*((1.d0*ipop)/(1.d0*npopst))                   &
     &                 )
!
        if(jtmpst.eq.11)                                                &
     &  beta_st(ipop)=beta_mc                                           &
     &                 +(                                               &
     &                  beta_st(npopst)-beta_mc                         &
     &                  )*((1.d0*ipop)/(1.d0*npopst))
!
        if(jtmpst.eq.12)                                                &
     &  beta_st(ipop)=beta_mc                                           &
     &                 *(                                               &
     &                  beta_st(npopst)/beta_mc                         &
     &                  )**((1.d0*ipop)/(1.d0*npopst))
      enddo
      ipop=-1
!
!
      if(jdo_st4ge.eq.1) return
      if(jrstart.eq.1) return
      if(jinist.eq.0) return
!
!
      if(jinist.ge.1.and.jinist.le.2) then
        ipop_upd=0
        call store_th2st
        jhoodst(ipop_upd)=0
!
        npopst_sin=npopst_lst
        if(npopst_sin.lt.0) npopst_sin=0
!
        if(npopst.le.npopst_sin) goto 990
!
        if(npopst.gt.npopst_sin) then
          if(jinist.eq.1) then
            ipop_upd=npopst_sin
            call store_st2th ! sch_pst-01
!
            do ipop=(npopst_sin+1),npopst
              ipop_upd=ipop
              call store_th2st
              jhoodst(ipop_upd)=jhoodst(npopst_sin)
            enddo
!
            ipop_upd=0
            call store_st2th ! sch_pst-02
          endif
!
          if(jinist.eq.2) then
            do ipop=(npopst_sin+1),npopst
              ipop_upd=ipop
              call store_rnd2st
!
!DRLIM190524-2244:
              if(  mlimdrv.ge.1) then ! sch_pst-01
                errtag='000121.000.006: # rate fct calls > nlim_drv, during pst initial'
                call err_term
              endif
!             May evolve a Theta with mlimdrv>=1 here.
!             Need to implement better handling for that case!! 
!:DRLIM190524-2244
!
              jhoodst(ipop_upd)=0
            enddo
          endif
        endif
      endif
!
!
      if(jinist.ge.30.and.jinist.le.31) then
        ipop_upd=0
        call store_th2st
        jhoodst(ipop_upd)=0
!
        npopst_sin=0
        if(jinist.eq.31) npopst_sin=1
        do ipop=npopst_sin,npopst
          ipop_upd=ipop
          call store_rnd2st
!
!DRLIM190524-2244:
          if(  mlimdrv.ge.1) then ! sch_pst-02
            errtag='000121.000.007: # rate fct calls > nlim_drv, during pst initial'
            call err_term
          endif
!         May evolve a Theta with mlimdrv>=1 here.
!         Need to implement better handling for that case!! 
!:DRLIM190524-2244
!
          jhoodst(ipop_upd)=0
        enddo
!
        ipop_upd=0
        call store_st2th ! sch_pst-03
      endif
!
!
  990 continue
      ipop_upd=-1
      ipop=-1
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine sch_pge
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! initialize Theta population (if needed) and updating controls
! for PGE moves
!
      include 'ens.def'
!
!
      if(imvsequ.le.0.or.jmvloop.le.0) return
!
      if(.not.                                                          &
     &   (jmty(imvsequ,jmvloop).ge.3000 .and.                           &
     &    jmty(imvsequ,jmvloop).le.4999)                                &
     &) return
!
      if(jmty(imvsequ,jmvloop).eq.3912) jdo_st4ge=1
      if(jmty(imvsequ,jmvloop).eq.3921) jdo_st4ge=0
!
!   Set PGE control params.: jinige,jnsuge,jbsuge, ...
      jinige=jini_ge(imvsequ,jmvloop)
      jnsuge=jnsu_ge(imvsequ,jmvloop)
      jbsuge=jbsu_ge(imvsequ,jmvloop)
      jrsuge=jrsu_ge(imvsequ,jmvloop)
      npopge=npop_ge(imvsequ,jmvloop)
      ansurge=ansur_ge(imvsequ,jmvloop)
      bnsurge=bnsur_ge(imvsequ,jmvloop)
      beta_ge=1.d0/temp_ge(imvsequ,jmvloop)
!
      if(jmty(imvsequ,jmvloop).eq.3901) then
        if(jnsuge.eq.1) then
          nsurvge=1.000001d0+dabs(ansurge)
        endif
        if(jnsuge.eq.2) then
          nsurvge=1.000001d0+dabs(ansurge)
          nsurvge=nsurvge+randx()*(dabs(bnsurge))
        endif
        if(nsurvge.gt.npopge) nsurvge=npopge
      endif
!
      if(npop_ge(imvsequ,jmvloop).ne.npopge_lst) jpge_sch=1
!
      if(jpge_sch.le.0) return
      jpge_sch=0
!
      do ipop=0,npopge
        iorge(ipop)=ipop
      enddo
!
      if(jrstart.eq.1) return
      if(jinige.eq.0) return
!
      if(jinige.ge.1.and.jinige.le.9) then
        ipop_upd=0
        call store_th2ge
!
        npopge_sin=npopge_lst
        if(npopge_sin.lt.0) npopge_sin=0
!
        if(npopge.le.npopge_sin) goto 990
!
        if(npopge.gt.npopge_sin) then
          if(jinige.eq.1) then
            ipop_upd=npopge_sin
            call store_ge2th
!
            do ipop=(npopge_sin+1),npopge
              ipop_upd=ipop
              call store_th2ge
            enddo
            ipop_upd=0
            call store_ge2th
          endif
!
          if(jinige.eq.2) then
            do ipop=(npopge_sin+1),npopge
              ipop_upd=ipop
              call store_rnd2ge
!
!DRLIM190524-2244:
              if(  mlimdrv.ge.1) then ! sch_pge-01
                errtag='000121.000.008: # rate fct calls > nlim_drv, during pge initial'
                call err_term
              endif
!             May evolve a Theta with mlimdrv>=1 here.
!             Need to implement better handling for that case!! 
!:DRLIM190524-2244
!
            enddo
          endif
        endif
      endif
!
!
      if(jinige.ge.30.and.jinige.le.39) then
        ipop_upd=0
        call store_th2ge
!
!DRLIM190524-2244:
              if(  mlimdrv.ge.1) then  ! sch_pge-02
                errtag='000121.000.009: # rate fct calls > nlim_drv, during pge initial'
                call err_term
              endif
!             May evolve a Theta with mlimdrv>=1 here.
!             Need to implement better handling for that case!! 
!:DRLIM190524-2244
!
!
        npopge_sin=0
        if(jinige.eq.31) npopge_sin=1
!
        do ipop=npopge_sin,npopge
          ipop_upd=ipop
          call store_rnd2ge
        enddo
!
        ipop_upd=0
        call store_ge2th
      endif
!
!
  990 continue
      ipop_upd=-1
      ipop=-1
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine get_chi
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! calculate new chisq, chi2, chi1 for proposed MC move
!
!     parallelized:
!     -------------
      call mpm_getkin ! get_chi-01
!DRLIM190524-2244:
      mlimdrv=0
      if(.not.(jtime.eq.1.or.jtime.eq.2)) then
        if(nlim_drv.gt.0) then
          do iexpt_drv=1,nexpt
            if(n_drv_xp(iexpt_drv).gt.nlim_drv) then
              mlimdrv=mlimdrv+1
            endif
          enddo
        endif
      endif
!:DRLIM190524-2244
!
      if(jmvloop.le.0.or.imvsequ.le.0) then
        jDB_sum_chi=5
        call sum_chi_u
!
        jDB_get_chi=0
        return
      endif
!
      if(jmvloop.eq.1.or.jmvloop.eq.2) then
        if(jwgt_mc(kmvsequ,jmvloop).eq.-1) then
          jDB_sum_chi=7
          call sum_chi_u
        else
          jDB_sum_chi=8
          call sum_chi_w
        endif
      endif
!
      jDB_get_chi=0
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ct_htotst
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! increment htot-counter for PST or PGE moves
!
      if(jmvloop.gt.0.and.kmvsequ.gt.0.and.imvsequ.gt.0) then
        if(                                                             &
     &  jmty(imvsequ,jmvloop).ge.1000.and.                              &
     &  jmty(imvsequ,jmvloop).le.2999                                   &
     &  )then
!
          if(                                                           &
     &    jtmp_en(imvsequ,jmvloop).eq.4.and.                            &
     &    jmty(imvsequ,jmvloop).ne.1013.and.                            &
     &    jmty(imvsequ,jmvloop).ne.1014.and.                            &
     &    jmty(imvsequ,jmvloop).ne.1901                                 &
     &    ) return
!
          mhtot_pst=mhtot_pst+1
          ihtot_pst=ihtot_pst+1
!
          if(mhtot_pst.eq.mth_tot) then
            if(mth_tot.gt.0) then
              imove_pst=(ihtot_pst-1)/mth_tot
              imove_pst=imove_pst+1
            endif
!
            call store_st2repl
!
            jclO=142
            if(jo_th.eq.41) call odat_th !  ct_htotst-01
            call ck_stop_swp
!
            mhtot_pst=0
            imove_pst=imove_pst+1
          endif
        endif
!
!
        if(                                                             &
     &  jmty(imvsequ,jmvloop).ge.3000.and.                              &
     &  jmty(imvsequ,jmvloop).le.4999                                   &
     &  )then
          mhtot_pge=mhtot_pge+1
          ihtot_pge=ihtot_pge+1
!
          if(mhtot_pge.eq.mth_tot) then
            if(mth_tot.gt.0) then
              imove_pge=(ihtot_pge-1)/mth_tot
              imove_pge=imove_pge+1
            endif
!
            call store_ge2repl
!
            jclO=143
            if(jo_th.eq.41) call odat_th !  ct_htotst-02
            call ck_stop_swp
!
            mhtot_pge=0
            imove_pge=imove_pge+1
          endif
        endif
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine get_rasf_ini
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! for randomized SFs only: to be executed at the
! start of every MC theta-move with jrasf_ctl=2:
!
! re-randomizes all  SFs; then re-calculates
!     chisq, scale factors sxp*, energies htot, hwall etc.,
! without re-solving kinetics rate eqs. from currently
! stored [x,y]spec_chi_th, zspec_ipch_th; then
! freezes all random SFs for MC theta-moves to follow...
! SFs must then again be unfrozen at end of MC theta-move
! by call to "get_rasf_fin".
!
      if(jmvloop.lt.1.or.jmvloop.gt.2) return
      if(imvsequ.lt.1.or.imvsequ.gt.nmvsequ(jmvloop)) return
      if(jrasf_ctl(imvsequ,jmvloop).ne.2) return
!
!    unfreeze SFs for randomization in
!    "chi_rasf <- chi_accu <- sum_chi_[u,w]":
      jrasf_freez=-1
!     Note: may actually not be needed, since default is "unfrozen":
!
      call reset_yspec
      if(jwgt_mc(kmvsequ,jmvloop).eq.-1) then
        jDB_sum_chi=9
        call sum_chi_u
      else
        jDB_sum_chi=10
        call sum_chi_w
      endif
!
!     store only SF-dependent quantities:
!       chisq, energies htot, hwall etc.,
!     since SF-independent quantities, incl. species concs.,
!     have not been changed by foregoing SF-randomization:
!     jsto_chiras=1 (not mandatory, just to save time)
!
      jsto_chiras=1
      call store_chi_th
      jsto_chiras=-1
!
!     freeze SFs:
      jrasf_freez=1
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine get_rasf_fin
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!     unfreeze SFs at end of MC theta-move:
      jrasf_freez=-1
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine sum_chi_w
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! calculate new chisq, chi2, chi1 for proposed MC move
! using externally controlled ("fwgt") data weight modif.factors
!
      call chi_zero
      jfwgt=1
      jDB_chi_accu=2
      call chi_accu
      call chi_htot
!
      jDB_sum_chi=0
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine sum_chi_u
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! calculate new chisq, chi2, chi1 for proposed MC move
! using unit (1.d0) data weight modif.factors
!
      call chi_zero
      jfwgt=0
      jDB_chi_accu=3
      call chi_accu
      call chi_htot
!
      jDB_sum_chi=0
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine store_chi_th
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! store new chisq, chi2, chi1 after MC move
!
      chisq_th=chisq
!
      hfour_th=hfour
      hfous_th=hfous
      hfout_th=hfout
      hbxx_th=hbxx
      hbxn_th=hbxn
      hwall_th=hwall
      htot_th=htot
!
      if(jsto_chiras.eq.1) return
!
      do kscal=1,nkscal
        chi2_ks_th(kscal)=chi2_ks(kscal)
        chi1_ks_th(kscal)=chi1_ks(kscal)
        sxplog_ks_th(kscal)=sxplog_ks(kscal)
      enddo
!
      do iscal=1,niscal
        chi2_is_th(iscal)=chi2_is(iscal)
        chi1_is_th(iscal)=chi1_is(iscal)
        sxplog_is_th(iscal)=sxplog_is(iscal)
      enddo
!
!
      do ims=1,nms_spec
        if(jmsspec_px(ispec_ms(ims)).eq.0) then
          do iexpt=1,nexpt
            do itmx=itmx_ini(ims,iexpt),itmx_fin(ims,iexpt)
              yspec_chi_th(itmx)=yspec_chi(itmx)
            enddo
          enddo
        endif
      enddo
!
      do iipch=0,nipch
        zspec_ipch_th(iipch)=zspec_ipch(iipch)
      enddo
!
      do itsxdc=1,ntsxdc_tot
        xspec_tsxdc_th(1,itsxdc)=                            &
     &  xspec_tsxdc(1,itsxdc)
!
        xspec_tsxdc_th(2,itsxdc)=                            &
     &  xspec_tsxdc(2,itsxdc)
      enddo
!
      do ivs=0,nvs_spec
        qbxx_th(ivs)=qbxx(ivs)
        fbxx_th(ivs)=fbxx(ivs)
        qbxn_th(ivs)=qbxn(ivs)
        fbxn_th(ivs)=fbxn(ivs)
      enddo
!
      do iexpt=1,nexpt
        do isegft=1,nsegft(iexpt)
          pfour_seg_th(isegft,iexpt)=                                   &
     &    pfour_seg(isegft,iexpt)
          qfour_seg_th(isegft,iexpt)=                                   &
     &    qfour_seg(isegft,iexpt)
          do is_ft=1,nsft_spec
            pfour_sfil_th(is_ft,isegft,iexpt)=                          &
     &      pfour_sfil(is_ft,isegft,iexpt)
            pfour_stot_th(is_ft,isegft,iexpt)=                          &
     &      pfour_stot(is_ft,isegft,iexpt)
          enddo
        enddo
      enddo
!
      do iexpt=1,nexpt
        do ibx_time=1,nbx_time
          do ivs=1,nvs_spec
            yspec_qbx_th(ivs,ibx_time,iexpt)=                           &
     &      yspec_qbx(ivs,ibx_time,iexpt)
          enddo
        enddo
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine store_chi_uth
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! store chisq, chi2, chi1 after chisq_calc.
! using unit (1.d0) data weight modif.factors
! (for output in "odat_th")
!
      chisq_uth=chisq
!
      do kscal=1,nkscal
        chi2_ks_uth(kscal)=chi2_ks(kscal)
        chi1_ks_uth(kscal)=chi1_ks(kscal)
        chi0_ks_u(kscal)=chi0_ks(kscal)
        sxplog_ks_uth(kscal)=sxplog_ks(kscal)
      enddo
!
      do iscal=1,niscal
        chi2_is_uth(iscal)=chi2_is(iscal)
        chi1_is_uth(iscal)=chi1_is(iscal)
        chi0_is_u(iscal)=chi0_is(iscal)
        sxplog_is_uth(iscal)=sxplog_is(iscal)
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine reset_yspec
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! reset "yspec_chi" for recalc. of "chisq" etc. using "sum_chi_w"
!
      do ims=1,nms_spec
        if(jmsspec_px(ispec_ms(ims)).eq.0) then
          do iexpt=1,nexpt
            do itmx=itmx_ini(ims,iexpt),itmx_fin(ims,iexpt)
              yspec_chi(itmx)=yspec_chi_th(itmx)
              xspec_chi(itmx)=dexp(yspec_chi_th(itmx))
            enddo
          enddo
        endif
      enddo
!
      do iipch=0,nipch
        zspec_ipch(iipch)=zspec_ipch_th(iipch)
      enddo
!
      do itsxdc=1,ntsxdc_tot
        xspec_tsxdc(1,itsxdc)=                            &
     &  xspec_tsxdc_th(1,itsxdc)
!
        xspec_tsxdc(2,itsxdc)=                            &
     &  xspec_tsxdc_th(2,itsxdc)
      enddo
!
      do iexpt=1,nexpt
        do ibx_time=1,nbx_time
          do ivs=1,nvs_spec
            yspec_qbx(ivs,ibx_time,iexpt)=                              &
     &      yspec_qbx_th(ivs,ibx_time,iexpt)
          enddo
        enddo
      enddo
!
      do iexpt=1,nexpt
        do isegft=1,nsegft(iexpt)
          pfour_seg(isegft,iexpt)=                                      &
     &    pfour_seg_th(isegft,iexpt)
          qfour_seg(isegft,iexpt)=                                      &
     &    qfour_seg_th(isegft,iexpt)
          do is_ft=1,nsft_spec
            pfour_sfil(is_ft,isegft,iexpt)=                             &
     &      pfour_sfil_th(is_ft,isegft,iexpt)
            pfour_stot(is_ft,isegft,iexpt)=                             &
     &      pfour_stot_th(is_ft,isegft,iexpt)
          enddo
        enddo
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine reset_yspec_expt
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! reset "yspec_chi" for recalc. of "chisq" etc. using "sum_chi_w"
!
      do ims=1,nms_spec
        if(jmsspec_px(ispec_ms(ims)).eq.0) then
!c        do iexpt=1,nexpt
            do itmx=itmx_ini(ims,iexpt),itmx_fin(ims,iexpt)
              yspec_chi(itmx)=yspec_chi_th(itmx)
              xspec_chi(itmx)=dexp(yspec_chi_th(itmx))
            enddo
!c        enddo
        endif
      enddo
!
!
      do ims=1,nms_spec
        ispec=ispec_ms(ims)
        if(jmsspec_px(ispec).eq.1) then
          do iipch=iipch_ini(ims,iexpt),iipch_fin(ims,iexpt)
            zspec_ipch(iipch)=zspec_ipch_th(iipch)
          enddo
        endif
      enddo
!
      do itsxdc=1,ntsxdc_tot
        xspec_tsxdc(1,itsxdc)=                            &
     &  xspec_tsxdc_th(1,itsxdc)
!
        xspec_tsxdc(2,itsxdc)=                            &
     &  xspec_tsxdc_th(2,itsxdc)
      enddo
!
!c    do iexpt=1,nexpt
        do ibx_time=1,nbx_time
          do ivs=1,nvs_spec
            yspec_qbx(ivs,ibx_time,iexpt)=                              &
     &      yspec_qbx_th(ivs,ibx_time,iexpt)
          enddo
        enddo
!c    enddo
!
!c    do iexpt=1,nexpt
        do isegft=1,nsegft(iexpt)
          pfour_seg(isegft,iexpt)=                                      &
     &    pfour_seg_th(isegft,iexpt)
          qfour_seg(isegft,iexpt)=                                      &
     &    qfour_seg_th(isegft,iexpt)
          do is_ft=1,nsft_spec
            pfour_sfil(is_ft,isegft,iexpt)=                             &
     &      pfour_sfil_th(is_ft,isegft,iexpt)
            pfour_stot(is_ft,isegft,iexpt)=                             &
     &      pfour_stot_th(is_ft,isegft,iexpt)
          enddo
        enddo
!c    enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine save_chi_th
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! save last chisq, chi2, chi1 before proposing next MC move
!
      chisq_th0=chisq_th
!
      hfour_th0=hfour_th
      hfous_th0=hfous_th
      hfout_th0=hfout_th
      hbxx_th0=hbxx_th
      hbxn_th0=hbxn_th
      hwall_th0=hwall_th
      htot_th0=htot_th
!
      do kscal=1,nkscal
        chi2_ks_th0(kscal)=chi2_ks_th(kscal)
        chi1_ks_th0(kscal)=chi1_ks_th(kscal)
        sxplog_ks_th0(kscal)=sxplog_ks_th(kscal)
      enddo
!
      do iscal=1,niscal
        chi2_is_th0(iscal)=chi2_is_th(iscal)
        chi1_is_th0(iscal)=chi1_is_th(iscal)
        sxplog_is_th0(iscal)=sxplog_is_th(iscal)
      enddo
!
      do ims=1,nms_spec
        if(jmsspec_px(ispec_ms(ims)).eq.0) then
          do iexpt=1,nexpt
            do itmx=itmx_ini(ims,iexpt),itmx_fin(ims,iexpt)
              yspec_chi_th0(itmx)=yspec_chi_th(itmx)
            enddo
          enddo
        endif
      enddo
!
      do iipch=0,nipch
        zspec_ipch_th0(iipch)=zspec_ipch_th(iipch)
      enddo
!
      do itsxdc=1,ntsxdc_tot
        xspec_tsxdc_th0(1,itsxdc)=                            &
     &  xspec_tsxdc_th(1,itsxdc)
!
        xspec_tsxdc_th0(2,itsxdc)=                            &
     &  xspec_tsxdc_th(2,itsxdc)
      enddo
!
      do ivs=0,nvs_spec
        qbxx_th0(ivs)=qbxx_th(ivs)
        fbxx_th0(ivs)=fbxx_th(ivs)
        qbxn_th0(ivs)=qbxn_th(ivs)
        fbxn_th0(ivs)=fbxn_th(ivs)
      enddo
!
      do iexpt=1,nexpt
        do isegft=1,nsegft(iexpt)
          pfour_seg_th0(isegft,iexpt)=                                  &
     &    pfour_seg_th(isegft,iexpt)
          qfour_seg_th0(isegft,iexpt)=                                  &
     &    qfour_seg_th(isegft,iexpt)
          do is_ft=1,nsft_spec
            pfour_sfil_th0(is_ft,isegft,iexpt)=                         &
     &      pfour_sfil_th(is_ft,isegft,iexpt)
            pfour_stot_th0(is_ft,isegft,iexpt)=                         &
     &      pfour_stot_th(is_ft,isegft,iexpt)
          enddo
        enddo
      enddo
!
      do iexpt=1,nexpt
        do ibx_time=1,nbx_time
          do ivs=1,nvs_spec
            yspec_qbx_th0(ivs,ibx_time,iexpt)=                          &
     &      yspec_qbx_th(ivs,ibx_time,iexpt)
          enddo
        enddo
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine reset_chi_th
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! restore last chisq, chi2, chi1 after rejected MC move
!
      chisq_th=chisq_th0
!
      hfour_th=hfour_th0
      hfous_th=hfous_th0
      hfout_th=hfout_th0
      hbxx_th=hbxx_th0
      hbxn_th=hbxn_th0
      hwall_th=hwall_th0
      htot_th=htot_th0
!
      do kscal=1,nkscal
        chi2_ks_th(kscal)=chi2_ks_th0(kscal)
        chi1_ks_th(kscal)=chi1_ks_th0(kscal)
        sxplog_ks_th(kscal)=sxplog_ks_th0(kscal)
      enddo
!
      do iscal=1,niscal
        chi2_is_th(iscal)=chi2_is_th0(iscal)
        chi1_is_th(iscal)=chi1_is_th0(iscal)
        sxplog_is_th(iscal)=sxplog_is_th0(iscal)
      enddo
!
      do ims=1,nms_spec
        if(jmsspec_px(ispec_ms(ims)).eq.0) then
          do iexpt=1,nexpt
            do itmx=itmx_ini(ims,iexpt),itmx_fin(ims,iexpt)
              yspec_chi_th(itmx)=yspec_chi_th0(itmx)
            enddo
          enddo
        endif
      enddo
!
      do iipch=0,nipch
        zspec_ipch_th(iipch)=zspec_ipch_th0(iipch)
      enddo
!
      do itsxdc=1,ntsxdc_tot
        xspec_tsxdc_th(1,itsxdc)=                            &
     &  xspec_tsxdc_th0(1,itsxdc)
!
        xspec_tsxdc_th(2,itsxdc)=                            &
     &  xspec_tsxdc_th0(2,itsxdc)
      enddo
!
      do ivs=0,nvs_spec
        qbxx_th(ivs)=qbxx_th0(ivs)
        fbxx_th(ivs)=fbxx_th0(ivs)
        qbxn_th(ivs)=qbxn_th0(ivs)
        fbxn_th(ivs)=fbxn_th0(ivs)
      enddo
!
      do iexpt=1,nexpt
        do ibx_time=1,nbx_time
          do ivs=1,nvs_spec
            yspec_qbx_th(ivs,ibx_time,iexpt)=                           &
     &      yspec_qbx_th0(ivs,ibx_time,iexpt)
          enddo
        enddo
      enddo
!
      do iexpt=1,nexpt
        do isegft=1,nsegft(iexpt)
          pfour_seg_th(isegft,iexpt)=                                   &
     &    pfour_seg_th0(isegft,iexpt)
          qfour_seg_th(isegft,iexpt)=                                   &
     &    qfour_seg_th0(isegft,iexpt)
          do is_ft=1,nsft_spec
            pfour_sfil_th(is_ft,isegft,iexpt)=                          &
     &      pfour_sfil_th0(is_ft,isegft,iexpt)
            pfour_stot_th(is_ft,isegft,iexpt)=                          &
     &      pfour_stot_th0(is_ft,isegft,iexpt)
          enddo
        enddo
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine store_sfxdi
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! re-store "sxplog_ks_th"  as "sxplog_xdi" or set
! "sxplog_xdi=0.d0", for use in xptl. data interpolation
!
      if(jsfxdi.eq.9) return
!
      if(jsfxdi.eq.0) then
        do iexpt=1,nexpt
          do is_xdi=1,nsxdi_spec(iexpt)
            ispec=ispec_xdi(is_xdi,iexpt)
            ims=ims_spec(ispec)
!
            do isegxd=1,nsegxd(is_xdi,iexpt)
              it_xdi=0
              do itxpt                                                  &
     &        =itxpt_xdii(isegxd,is_xdi,iexpt)                          &
     &        ,itxpt_xdif(isegxd,is_xdi,iexpt)
                if(jzxdi_xpt(itmx_xpt(ims,itxpt,iexpt)).ne.9.and.       &
     &          itmx_xpt(ims,itxpt,iexpt).gt.0                          &
     &          ) then
                  it_xdi=it_xdi+1
                  sxplog_xdi(it_xdi,isegxd,is_xdi,iexpt)=               &
     &            0.d0
                endif
              enddo
            enddo
          enddo
        enddo
!
        jupd_sfxdi=1
      endif
!
!
      if(jsfxdi.eq.1) then
        do iexpt=1,nexpt
          do is_xdi=1,nsxdi_spec(iexpt)
            ispec=ispec_xdi(is_xdi,iexpt)
            ims=ims_spec(ispec)
!
            do isegxd=1,nsegxd(is_xdi,iexpt)
              it_xdi=0
              do itxpt                                                  &
     &        =itxpt_xdii(isegxd,is_xdi,iexpt)                          &
     &        ,itxpt_xdif(isegxd,is_xdi,iexpt)
                if(jzxdi_xpt(itmx_xpt(ims,itxpt,iexpt)).ne.9.and.       &
     &          itmx_xpt(ims,itxpt,iexpt).gt.0                          &
     &          ) then
                  it_xdi=it_xdi+1
                  sxplog_xdi(it_xdi,isegxd,is_xdi,iexpt)=               &
     &            sxplog_ks_th(kscal_xpt(itmx_xpt(ims,itxpt,iexpt)))
                endif
              enddo
            enddo
          enddo
        enddo
!
        jupd_sfxdi=1
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine move_cs1
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! Metropolis move on species conc. schedule Theta-parameter
!
      include 'ens.def'
!
      if(nblkth(imvsequ,jmvloop).ge.1) then
        call move_cs1_blk
        return
      endif
!
      call get_rasf_ini
      call save_chi_th
!
!   select \Theta-comp. for Metropolis move
      r1=randx()
      adum0=mth_spec*r1
      ith_upd=adum0
      ith_upd=ith_upd+1
      if(ith_upd.gt.mth_spec) ith_upd=mth_spec
!
      ispec_upd=ispec_th(ith_upd)
      ipm_upd=ipmspec_th(ith_upd)
!
!   save old \Theta
      theta0=cspec(ispec_upd,ipm_upd)
!
!
!   propose new \Theta
      rstep=randx()
      dtheta=(rstep-0.5d0)*stepspec(ith_upd)*fstp_imv*fstep_st
!
!  apply stepwidth optimization factor
      if(mpr_swo.gt.0) then
        ith_swo=ith_upd
        dtheta=dtheta*fstp_swo(ith_swo)
      endif
!
!     jctspec=0: Metropolis move \Theta
      if(jctspec(ispec_upd,ipm_upd).eq.0) then
        theta1=theta0+dtheta
        ahispec=rhispec(ith_upd)
        alospec=rlospec(ith_upd)
      endif
!
!     jctspec=1: Metropolis move ln(\Theta)
      if(jctspec(ispec_upd,ipm_upd).eq.1) then
        theta1=dlog(theta0)+dtheta
        ahispec=dlog(rhispec(ith_upd))
        alospec=dlog(rlospec(ith_upd))
      endif
!
!   enforce lo- and hi-Theta boundaries
      if( theta1.gt.ahispec                                             &
     &.or.theta1.lt.alospec) then
        if(jbcspec(ispec_upd,ipm_upd).eq.0) then
          jaccp=-1 ! move_cs1-01, jbc==0
          goto 71
        endif
!
        if(jbcspec(ispec_upd,ipm_upd).eq.1) then
          call refl_th(theta1                                           &
     &                ,ahispec                                          &
     &                ,alospec                                          &
     &                ,isign_pi)
        endif
      endif
!
      if(jctspec(ispec_upd,ipm_upd).eq.1) theta1=dexp(theta1)
!
!   calculate htot for proposed new \Theta
      cspec(ispec_upd,ipm_upd)=theta1
!
      if(jtmp_en(imvsequ,jmvloop).eq.4) goto 71
!
      jckkin=1
!
      jDB_get_chi=7
      call get_chi ! move_cs1-01
!
!DRLIM190524-2244:
      if(mlimdrv.ge.1) jaccp=-1 ! move_cs1-01
!:DRLIM190524-2244
!
      call store_chi_th
!
      jckkin=0
!
   71 continue
      call accp_move ! move_cs1-01
!
      if(jaccp.eq.0) then
        call reset_chi_th
        cspec(ispec_upd,ipm_upd)=theta0
      endif
!
      call get_rasf_fin ! move_cs1-01
!
      if(jmvloop.eq.1.or.jmvloop.eq.2) then
!
!DRLIM190524-2244:
        jlimd=0
        if(mlimdrv.ge.1) jlimd=1
        ith_swo=ith_upd
        nplimd(ith_swo)=nplimd(ith_swo)+1
        nmlimd(ith_swo)=nmlimd(ith_swo)+jlimd*mlimdrv
        njlimd(ith_swo)=njlimd(ith_swo)+jlimd
!:DRLIM190524-2244
!
        ipmty=2
        nprop(ith_upd,imvsequ,jmvloop,ipmty)=                           &
     &   nprop(ith_upd,imvsequ,jmvloop,ipmty)+1
        naccp(ith_upd,imvsequ,jmvloop,ipmty)=                           &
     &    naccp(ith_upd,imvsequ,jmvloop,ipmty)+jaccp
!
        if(mpr_swo.gt.0.and.raccp_lo(imvsequ,jmvloop).le.1.d0) then
          ith_swo=ith_upd
          nprop_swo(ith_swo)=                                           &
     &    nprop_swo(ith_swo)+1
          nprop_up_swo(ith_swo)=                                        &
     &    nprop_up_swo(ith_swo)+jprop_up
          naccp_swo(ith_swo)=                                           &
     &    naccp_swo(ith_swo)+jaccp
          naccp_up_swo(ith_swo)=                                        &
     &    naccp_up_swo(ith_swo)+jaccp_up
        endif
!
        if(ipop_upd.ge.0) then
          nprop_pop(ipop_upd)=                                          &
     &    nprop_pop(ipop_upd)+1
          nprop_up_pop(ipop_upd)=                                       &
     &    nprop_up_pop(ipop_upd)+jprop_up
          naccp_pop(ipop_upd)=                                          &
     &    naccp_pop(ipop_upd)+jaccp
          naccp_up_pop(ipop_upd)=                                       &
     &    naccp_up_pop(ipop_upd)+jaccp_up
        endif
!
        if(mac_fbx.gt.0) call mc_fbxa
      endif
!
!
!
      jclO=151
      if(jo_th.eq.51) call odat_th ! move_cs1-01
!
      call accu_dos
      call ckcvg_dos
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine move_rk1
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! Metropolis move on reaction rate Theta-parameter
!
      include 'ens.def'
!
!
      if(nblkth(imvsequ,jmvloop).ge.1) then
        call move_rk1_blk
        return
      endif
!
      call get_rasf_ini
      call save_chi_th
!
!   select \Theta-comp. for Metropolis move
      r1=randx()
      adum0=mth_reac*r1
      ith_upd=adum0
      ith_upd=ith_upd+1
      if(ith_upd.gt.mth_reac) ith_upd=mth_reac
!
      ireac_upd=ireac_th(ith_upd)
      ipm_upd=ipmreac_th(ith_upd)
!
!   save old \Theta
      theta0=rreac(ireac_upd,ipm_upd)
!
!   propose new \Theta
      rstep=randx()
!RRR corrected 060801-1527:
!RRR  dtheta=(rstep-0.5d0)*stepspec(ith_upd)*fstp_imv*fstep_st
      dtheta=(rstep-0.5d0)*stepreac(ith_upd)*fstp_imv*fstep_st
!RRR
!
!  apply stepwidth optimization factor
      if(mpr_swo.gt.0) then
        ith_swo=ith_upd+mth_spec
        dtheta=dtheta*fstp_swo(ith_swo)
      endif
!
!     jctreac=0: Metropolis move Theta
      if(jctreac(ireac_upd,ipm_upd).eq.0) then
        theta1=theta0+dtheta
        ahireac=rhireac(ith_upd)
        aloreac=rloreac(ith_upd)
      endif
!
!     jctreac=1: Metropolis move ln(Theta)
      if(jctreac(ireac_upd,ipm_upd).eq.1) then
        theta1=dlog(theta0)+dtheta
        ahireac=dlog(rhireac(ith_upd))
        aloreac=dlog(rloreac(ith_upd))
      endif
!
!   enforce lo- and hi-Theta boundaries
      if( theta1.gt.ahireac                                             &
     &.or.theta1.lt.aloreac) then
        if(jbcreac(ireac_upd,ipm_upd).eq.0) then
          jaccp=-1 ! move_rk1-01, jbc==0
          goto 71
        endif
!
        if(jbcreac(ireac_upd,ipm_upd).eq.1) then
          call refl_th(theta1                                           &
     &                ,ahireac                                          &
     &                ,aloreac                                          &
     &                ,isign_pi)
        endif
      endif
!
      if(jctreac(ireac_upd,ipm_upd).eq.1) theta1=dexp(theta1)
!
!   calculate htot for proposed new \Theta
      rreac(ireac_upd,ipm_upd)=theta1
!
      if(jtmp_en(imvsequ,jmvloop).eq.4) goto 71
!
      jckkin=2
!
      jDB_get_chi=8
      call get_chi ! move_rk1-01
!
!DRLIM190524-2244:
      if(mlimdrv.ge.1) jaccp=-1 ! move_rk1-01
!:DRLIM190524-2244
!
      call store_chi_th
!
      jckkin=0
!
   71 continue
      call accp_move! move_rk1-01
!
      if(jaccp.eq.0) then
        call reset_chi_th
        rreac(ireac_upd,ipm_upd)=theta0
      endif
!
!
      call get_rasf_fin ! move_rk1-01
!
      if(jmvloop.eq.1.or.jmvloop.eq.2) then
!
!DRLIM190524-2244:
        jlimd=0
        if(mlimdrv.ge.1) jlimd=1
        ith_swo=ith_upd+mth_spec
        nplimd(ith_swo)=nplimd(ith_swo)+1
        nmlimd(ith_swo)=nmlimd(ith_swo)+jlimd*mlimdrv
        njlimd(ith_swo)=njlimd(ith_swo)+jlimd
!:DRLIM190524-2244
!
        ipmty=1
        nprop(ith_upd,imvsequ,jmvloop,ipmty)=                           &
     &    nprop(ith_upd,imvsequ,jmvloop,ipmty)+1
        naccp(ith_upd,imvsequ,jmvloop,ipmty)=                           &
     &    naccp(ith_upd,imvsequ,jmvloop,ipmty)+jaccp
!
        if(mpr_swo.gt.0.and.raccp_lo(imvsequ,jmvloop).le.1.d0) then
          ith_swo=ith_upd+mth_spec
          nprop_swo(ith_swo)=                                           &
     &    nprop_swo(ith_swo)+1
          nprop_up_swo(ith_swo)=                                        &
     &    nprop_up_swo(ith_swo)+jprop_up
          naccp_swo(ith_swo)=                                           &
     &    naccp_swo(ith_swo)+jaccp
          naccp_up_swo(ith_swo)=                                        &
     &    naccp_up_swo(ith_swo)+jaccp_up
        endif
!
        if(ipop_upd.ge.0) then
          nprop_pop(ipop_upd)=                                          &
     &    nprop_pop(ipop_upd)+1
          nprop_up_pop(ipop_upd)=                                       &
     &    nprop_up_pop(ipop_upd)+jprop_up
          naccp_pop(ipop_upd)=                                          &
     &    naccp_pop(ipop_upd)+jaccp
          naccp_up_pop(ipop_upd)=                                       &
     &    naccp_up_pop(ipop_upd)+jaccp_up
        endif
!
!
        if(mac_fbx.gt.0) call mc_fbxa
      endif
!
!
      jclO=152
      if(jo_th.eq.51) call odat_th ! move_rk1-01
!
      call accu_dos
      call ckcvg_dos
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine move_thu
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! Global Metropolis move of all species and reaction rate
! Theta-parameters along random unit vector direction in Theta-space
!
      include 'ens.def'
!
!
      if(nblkth(imvsequ,jmvloop).ge.1) then
        call move_thu_blk
        return
      endif
!
      call get_rasf_ini
      call save_chi_th
      call save_theta
!
! construct random unit vector in Theta-space
!
  100 continue
      cu_theta=0.d0
      ith_upd=0
      do ith_half=1,mth_tot
        r1=randx()
        r2=randx()
        rgauss=dsqrt(dabs(dlog(dabs(r1)+1.d-20)))
!
        ith_upd=ith_upd+1
        if(ith_upd.gt.mth_tot) goto 110
        u_theta(ith_upd)=rgauss*dcos(pi2*r2)
        cu_theta=cu_theta+u_theta(ith_upd)**2
!
        ith_upd=ith_upd+1
        if(ith_upd.gt.mth_tot) goto 110
        u_theta(ith_upd)=rgauss*dsin(pi2*r2)
        cu_theta=cu_theta+u_theta(ith_upd)**2
      enddo
  110 continue
      if(cu_theta.lt.1.d-16) goto 100
      cu_theta=1.d0/dsqrt(cu_theta)
      ith_upd=-1
      ith_half=-1
!
      do ith_upd=1,mth_tot
        if(ith_upd.le.mth_spec) then
          ispec_upd=ispec_th(ith_upd)
          ipm_upd=ipmspec_th(ith_upd)
          rhi_th=rhispec(ith_upd)
          rlo_th=rlospec(ith_upd)
          step_th=stepspec(ith_upd)
          jct_th=jctspec(ispec_upd,ipm_upd)
          jbc_th=jbcspec(ispec_upd,ipm_upd)
!
          theta0=cspec(ispec_upd,ipm_upd)
        else
          ireac_upd=ireac_th(ith_upd-mth_spec)
          ipm_upd=ipmreac_th(ith_upd-mth_spec)
          rhi_th=rhireac(ith_upd-mth_spec)
          rlo_th=rloreac(ith_upd-mth_spec)
          step_th=stepreac(ith_upd-mth_spec)
          jct_th=jctreac(ireac_upd,ipm_upd)
          jbc_th=jbcreac(ireac_upd,ipm_upd)
!
          theta0=rreac(ireac_upd,ipm_upd)
        endif
!
!      propose new \Theta
        dtheta=cu_theta*step_th                                         &
     &        *fstp_imv*u_theta(ith_upd)*fstep_st
!
!      apply stepwidth optimization factors
        if(mpr_swo.gt.0) then
          ith_swo=mth_tot+1
          dtheta=dtheta*fstp_swo(ith_upd)*fstp_swo(ith_swo)
        endif
!
!      jct_th=0: Metropolis move Theta
        if(jct_th.eq.0) then
          theta1=theta0+dtheta
          ahi_th=rhi_th
          alo_th=rlo_th
        endif
!
!      jct_th=1: Metropolis move ln(Theta)
        if(jct_th.eq.1) then
          theta1=dlog(theta0)+dtheta
          ahi_th=dlog(rhi_th)
          alo_th=dlog(rlo_th)
        endif
!
!     enforce lo- and hi-Theta boundaries
        if( theta1.gt.ahi_th                                            &
     &  .or.theta1.lt.alo_th) then
!
!     jbc_th=0: reject cross-boundary moves
          if(jbc_th.eq.0) then
            jaccp=-1 !  move_thu-01, jbc==0
            goto 71
          endif
!
!     jbc_th=1: reflect cross-boundary moves ("bounce of the wall")
          if(jbc_th.eq.1) then
            call refl_th(theta1,ahi_th,alo_th,isign_pi)
          endif
        endif
!
        if(jct_th.eq.1) theta1=dexp(theta1)
!
        if(ith_upd.le.mth_spec) then
          cspec(ispec_upd,ipm_upd)=theta1
        else
          rreac(ireac_upd,ipm_upd)=theta1
        endif
      enddo
!
!   calculate htot for proposed new \Theta
      if(jtmp_en(imvsequ,jmvloop).eq.4) goto 71
      jDB_get_chi=9
      call get_chi ! move_thu-01
!
!DRLIM190524-2244:
      if(mlimdrv.ge.1) jaccp=-1 ! move_thu-01
!:DRLIM190524-2244
!
      call store_chi_th
!
   71 continue
      call accp_move ! move_thu-01
!
      if(jaccp.eq.0) then
        call reset_chi_th
        call reset_theta
      endif
!
      call get_rasf_fin ! move_thu-01
!
      if(jmvloop.eq.1.or.jmvloop.eq.2) then
!
!DRLIM190524-2244:
        jlimd=0
        if(mlimdrv.ge.1) jlimd=1
        ith_swo=mth_tot+1
        nplimd(ith_swo)=nplimd(ith_swo)+1
        nmlimd(ith_swo)=nmlimd(ith_swo)+jlimd*mlimdrv
        njlimd(ith_swo)=njlimd(ith_swo)+jlimd
!:DRLIM190524-2244
!
        ipmty=3
        ith_upd=1
        nprop(ith_upd,imvsequ,jmvloop,ipmty)=                           &
     &    nprop(ith_upd,imvsequ,jmvloop,ipmty)+1
        naccp(ith_upd,imvsequ,jmvloop,ipmty)=                           &
     &    naccp(ith_upd,imvsequ,jmvloop,ipmty)+jaccp
!
        if(mpr_swo.gt.0.and.raccp_lo(imvsequ,jmvloop).le.1.d0) then
          ith_swo=mth_tot+1
          nprop_swo(ith_swo)=                                           &
     &    nprop_swo(ith_swo)+1
          nprop_up_swo(ith_swo)=                                        &
     &    nprop_up_swo(ith_swo)+jprop_up
          naccp_swo(ith_swo)=                                           &
     &    naccp_swo(ith_swo)+jaccp
          naccp_up_swo(ith_swo)=                                        &
     &    naccp_up_swo(ith_swo)+jaccp_up
        endif
!
        if(ipop_upd.ge.0) then
          nprop_pop(ipop_upd)=                                          &
     &    nprop_pop(ipop_upd)+1
          nprop_up_pop(ipop_upd)=                                       &
     &    nprop_up_pop(ipop_upd)+jprop_up
          naccp_pop(ipop_upd)=                                          &
     &    naccp_pop(ipop_upd)+jaccp
          naccp_up_pop(ipop_upd)=                                       &
     &    naccp_up_pop(ipop_upd)+jaccp_up
        endif
!
!
        if(mac_fbx.gt.0) call mc_fbxa
      endif
!
!
!
      jclO=153
      if(jo_th.eq.51) call odat_th ! move_thu-01
!
      call accu_dos
      call ckcvg_dos
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine move_cs1_blk
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! Metropolis move on species conc. schedule Theta-parameter
! selected from a Theta block
!
      include 'ens.def'
!
!
      call get_rasf_ini
      call save_chi_th
!
      if(mthb_spec(imvsequ,jmvloop).eq.0) return
!
!   select \Theta-comp. for Metropolis move
      r1=randx()
!
      if(kthb_spec_ini(imvsequ,jmvloop).eq.-1) then
        adum0=mth_spec*r1
        ith_upd=adum0
        ith_upd=ith_upd+1
        if(ith_upd.gt.mth_spec) ith_upd=mth_spec
      else
        adum0=mthb_spec(imvsequ,jmvloop)*r1
        mthblk1=adum0
        mthblk1=mthblk1+1
        if(mthblk1.gt.mthb_spec(imvsequ,jmvloop))                     &
     &  mthblk1=mthb_spec(imvsequ,jmvloop)
!
        mthblk0=0
        ith_upd=-1
        do kthblk=kthb_spec_ini(imvsequ,jmvloop)                      &
     &  ,         kthb_spec_fin(imvsequ,jmvloop)
          if(ithc_thblk(kthblk).le.mth_spec) then
            mthblk0=mthblk0+1
            if(mthblk0.eq.mthblk1) then
              ith_upd=ithc_thblk(kthblk)
              goto 19
            endif
          endif
        enddo
      endif
   19 continue
!
      if(ith_upd.le.0) then
        errtag='000110.003'
        call err_term
      endif
!
      ispec_upd=ispec_th(ith_upd)
      ipm_upd=ipmspec_th(ith_upd)
!
!   save old \Theta
      theta0=cspec(ispec_upd,ipm_upd)
!
!
!   propose new \Theta
      rstep=randx()
      dtheta=(rstep-0.5d0)*stepspec(ith_upd)*fstp_imv*fstep_st
!
!  apply stepwidth optimization factor
      if(mpr_swo.gt.0) then
        ith_swo=ith_upd
        dtheta=dtheta*fstp_swo(ith_swo)
      endif
!
!     jctspec=0: Metropolis move \Theta
      if(jctspec(ispec_upd,ipm_upd).eq.0) then
        theta1=theta0+dtheta
        ahispec=rhispec(ith_upd)
        alospec=rlospec(ith_upd)
      endif
!
!     jctspec=1: Metropolis move ln(\Theta)
      if(jctspec(ispec_upd,ipm_upd).eq.1) then
        theta1=dlog(theta0)+dtheta
        ahispec=dlog(rhispec(ith_upd))
        alospec=dlog(rlospec(ith_upd))
      endif
!
!   enforce lo- and hi-Theta boundaries
      if( theta1.gt.ahispec                                             &
     &.or.theta1.lt.alospec) then
        if(jbcspec(ispec_upd,ipm_upd).eq.0) then
          jaccp=-1 ! move_cs1_blk-01, jbc==0
          goto 71
        endif
!
        if(jbcspec(ispec_upd,ipm_upd).eq.1) then
          call refl_th(theta1                                           &
     &                ,ahispec                                          &
     &                ,alospec                                          &
     &                ,isign_pi)
        endif
      endif
!
      if(jctspec(ispec_upd,ipm_upd).eq.1) theta1=dexp(theta1)
!
!   calculate htot for proposed new \Theta
      cspec(ispec_upd,ipm_upd)=theta1
!
      if(jtmp_en(imvsequ,jmvloop).eq.4) goto 71
!
      jckkin=1
!
      jDB_get_chi=10
      call get_chi ! move_cs1_blk-01
!
!DRLIM190524-2244:
      if(mlimdrv.ge.1) jaccp=-1 ! move_cs1_blk-01
!:DRLIM190524-2244
!
      call store_chi_th
!
      jckkin=0
!
   71 continue
      call accp_move ! move_cs1_blk-01
!
      if(jaccp.eq.0) then
        call reset_chi_th
        cspec(ispec_upd,ipm_upd)=theta0
      endif
!
      call get_rasf_fin ! move_cs1_blk-01
!
      if(jmvloop.eq.1.or.jmvloop.eq.2) then
!
!DRLIM190524-2244:
        jlimd=0
        if(mlimdrv.ge.1) jlimd=1
        ith_swo=ith_upd
        nplimd(ith_swo)=nplimd(ith_swo)+1
        nmlimd(ith_swo)=nmlimd(ith_swo)+jlimd*mlimdrv
        njlimd(ith_swo)=njlimd(ith_swo)+jlimd
!:DRLIM190524-2244
!
        ipmty=2
        nprop(ith_upd,imvsequ,jmvloop,ipmty)=                           &
     &   nprop(ith_upd,imvsequ,jmvloop,ipmty)+1
        naccp(ith_upd,imvsequ,jmvloop,ipmty)=                           &
     &    naccp(ith_upd,imvsequ,jmvloop,ipmty)+jaccp
!
        if(mpr_swo.gt.0.and.raccp_lo(imvsequ,jmvloop).le.1.d0) then
          ith_swo=ith_upd
          nprop_swo(ith_swo)=                                           &
     &    nprop_swo(ith_swo)+1
          nprop_up_swo(ith_swo)=                                        &
     &    nprop_up_swo(ith_swo)+jprop_up
          naccp_swo(ith_swo)=                                           &
     &    naccp_swo(ith_swo)+jaccp
          naccp_up_swo(ith_swo)=                                        &
     &    naccp_up_swo(ith_swo)+jaccp_up
        endif
!
        if(ipop_upd.ge.0) then
          nprop_pop(ipop_upd)=                                          &
     &    nprop_pop(ipop_upd)+1
          nprop_up_pop(ipop_upd)=                                       &
     &    nprop_up_pop(ipop_upd)+jprop_up
          naccp_pop(ipop_upd)=                                          &
     &    naccp_pop(ipop_upd)+jaccp
          naccp_up_pop(ipop_upd)=                                       &
     &    naccp_up_pop(ipop_upd)+jaccp_up
        endif
!
!
        if(mac_fbx.gt.0) call mc_fbxa
      endif
!
!
!
      jclO=151
      if(jo_th.eq.51) call odat_th ! move_cs1_blk-01
!
      call accu_dos
      call ckcvg_dos
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine move_rk1_blk
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! Metropolis move on reaction rate Theta-parameter
! selected from a Theta block
!
      include 'ens.def'
!
!DB090908
!!    write(*,*) ' '
!!    write(*,*)                                                  &
!!   &'============================================================'
!!    write(*,*) 'move_rk1_blk:>START,mp_myid=',mp_myid
!!    write(*,*) 'jmvloop,imvsequ,jmty,imove,kmove,ith_cs,ith_rk='
!!    write(*,*)  jmvloop,imvsequ,jmty(imvsequ,jmvloop)           &
!!   &                                ,imove,kmove,ith_cs,ith_rk
!
!!    write(*,*) 'LAST RAND r1=', r1
!
!!    write(*,*) 'mthb_tot,mthb_spec,mthb_reac='                  &
!!   &,mthb_tot(imvsequ,jmvloop)                                  &
!!   &,mthb_spec(imvsequ,jmvloop)                                 &
!!   &,mthb_reac(imvsequ,jmvloop)
!!    write(*,*)                                                  &
!!   &'============================================================'
!FB090808
!
      call get_rasf_ini
      call save_chi_th
!
      if(mthb_reac(imvsequ,jmvloop).eq.0) return
!
!   select \Theta-comp. for Metropolis move
! Fixed fatal bug:
!V090908:
      r1=randx()
!:V090908
!
      if(kthb_reac_ini(imvsequ,jmvloop).eq.-1) then
        adum0=mth_reac*r1
        ith_upd=adum0
        ith_upd=ith_upd+1
        if(ith_upd.gt.mth_reac) ith_upd=mth_reac
      else
        adum0=mthb_reac(imvsequ,jmvloop)*r1
        mthblk1=adum0
        mthblk1=mthblk1+1
        if(mthblk1.gt.mthb_reac(imvsequ,jmvloop))                     &
     &  mthblk1=mthb_reac(imvsequ,jmvloop)
!
        mthblk0=0
        ith_upd=-1
        do kthblk=kthb_reac_ini(imvsequ,jmvloop)                      &
     &  ,         kthb_reac_fin(imvsequ,jmvloop)
          if(ithc_thblk(kthblk).gt.mth_spec) then
            mthblk0=mthblk0+1
            if(mthblk0.eq.mthblk1) then
              ith_upd=ithc_thblk(kthblk)-mth_spec
              goto 19
            endif
          endif
        enddo
      endif
   19 continue
!
!DB090908
!!    write(*,*)                                                  &
!!   &'============================================================'
!!    write(*,*) 'move_rk1_blk:>19 CONTINUE,,mp_myid=',mp_myid
!!    write(*,*) 'jmvloop,imvsequ,jmty,imove,kmove,ith_cs,ith_rk='
!!    write(*,*)  jmvloop,imvsequ,jmty(imvsequ,jmvloop)           &
!!   &                                ,imove,kmove,ith_cs,ith_rk
!
!!    write(*,*) 'CURRENT RAND r1=', r1
!
!!    write(*,*) 'mthb_tot,mthb_spec,mthb_reac='                  &
!!   &,mthb_tot(imvsequ,jmvloop)                                  &
!!   &,mthb_spec(imvsequ,jmvloop)                                 &
!!   &,mthb_reac(imvsequ,jmvloop)
!
!!    idum=ith_upd+mth_spec
!!    write(*,*) 'mthblk1,mthblk0,kthblk,ith_upd,ithc_upd='
!!    write(*,*)  mthblk1,mthblk0,kthblk,ith_upd,idum
!
!!    write(*,*)                                                  &
!!   &'============================================================'
!FB090808
!
      if(ith_upd.le.0) then
        errtag='000110.004'
        call err_term
      endif
!
      ireac_upd=ireac_th(ith_upd)
      ipm_upd=ipmreac_th(ith_upd)
!
!   save old \Theta
      theta0=rreac(ireac_upd,ipm_upd)
!
!   propose new \Theta
      rstep=randx()
!RRR corrected 060801-1527:
!RRR  dtheta=(rstep-0.5d0)*stepspec(ith_upd)*fstp_imv*fstep_st
      dtheta=(rstep-0.5d0)*stepreac(ith_upd)*fstp_imv*fstep_st
!RRR
!
!  apply stepwidth optimization factor
      if(mpr_swo.gt.0) then
        ith_swo=ith_upd+mth_spec
        dtheta=dtheta*fstp_swo(ith_swo)
      endif
!
!     jctreac=0: Metropolis move Theta
      if(jctreac(ireac_upd,ipm_upd).eq.0) then
        theta1=theta0+dtheta
        ahireac=rhireac(ith_upd)
        aloreac=rloreac(ith_upd)
      endif
!
!     jctreac=1: Metropolis move ln(Theta)
      if(jctreac(ireac_upd,ipm_upd).eq.1) then
        theta1=dlog(theta0)+dtheta
        ahireac=dlog(rhireac(ith_upd))
        aloreac=dlog(rloreac(ith_upd))
      endif
!
!   enforce lo- and hi-Theta boundaries
      if( theta1.gt.ahireac                                             &
     &.or.theta1.lt.aloreac) then
        if(jbcreac(ireac_upd,ipm_upd).eq.0) then
          jaccp=-1 ! move_rk1_blk-01, jbc==0
          goto 71
        endif
!
        if(jbcreac(ireac_upd,ipm_upd).eq.1) then
          call refl_th(theta1                                           &
     &                ,ahireac                                          &
     &                ,aloreac                                          &
     &                ,isign_pi)
        endif
      endif
!
      if(jctreac(ireac_upd,ipm_upd).eq.1) theta1=dexp(theta1)
!
!   calculate htot for proposed new \Theta
      rreac(ireac_upd,ipm_upd)=theta1
!
      if(jtmp_en(imvsequ,jmvloop).eq.4) goto 71
!
      jckkin=2
!
      jDB_get_chi=11
      call get_chi ! move_rk1_blk-01
!
!DRLIM190524-2244:
      if(mlimdrv.ge.1) jaccp=-1 ! move_rk1_blk-01
!:DRLIM190524-2244
!
      call store_chi_th
!
      jckkin=0
!
   71 continue
      call accp_move ! move_rk1_blk-01
!
      if(jaccp.eq.0) then
        call reset_chi_th
        rreac(ireac_upd,ipm_upd)=theta0
      endif
!
      call get_rasf_fin ! move_rk1_blk-01
!
      if(jmvloop.eq.1.or.jmvloop.eq.2) then
!
!DRLIM190524-2244:
        jlimd=0
        if(mlimdrv.ge.1) jlimd=1
        ith_swo=ith_upd+mth_spec
        nplimd(ith_swo)=nplimd(ith_swo)+1
        nmlimd(ith_swo)=nmlimd(ith_swo)+jlimd*mlimdrv
        njlimd(ith_swo)=njlimd(ith_swo)+jlimd
!:DRLIM190524-2244
!
        ipmty=1
        nprop(ith_upd,imvsequ,jmvloop,ipmty)=                           &
     &    nprop(ith_upd,imvsequ,jmvloop,ipmty)+1
        naccp(ith_upd,imvsequ,jmvloop,ipmty)=                           &
     &    naccp(ith_upd,imvsequ,jmvloop,ipmty)+jaccp
!
        if(mpr_swo.gt.0.and.raccp_lo(imvsequ,jmvloop).le.1.d0) then
          ith_swo=ith_upd+mth_spec
          nprop_swo(ith_swo)=                                           &
     &    nprop_swo(ith_swo)+1
          nprop_up_swo(ith_swo)=                                        &
     &    nprop_up_swo(ith_swo)+jprop_up
          naccp_swo(ith_swo)=                                           &
     &    naccp_swo(ith_swo)+jaccp
          naccp_up_swo(ith_swo)=                                        &
     &    naccp_up_swo(ith_swo)+jaccp_up
        endif
!
        if(ipop_upd.ge.0) then
          nprop_pop(ipop_upd)=                                          &
     &    nprop_pop(ipop_upd)+1
          nprop_up_pop(ipop_upd)=                                       &
     &    nprop_up_pop(ipop_upd)+jprop_up
          naccp_pop(ipop_upd)=                                          &
     &    naccp_pop(ipop_upd)+jaccp
          naccp_up_pop(ipop_upd)=                                       &
     &    naccp_up_pop(ipop_upd)+jaccp_up
        endif
!
!
        if(mac_fbx.gt.0) call mc_fbxa
      endif
!
!
!
      jclO=152
      if(jo_th.eq.51) call odat_th ! move_rk1_blk-01
!
      call accu_dos
      call ckcvg_dos
!
!DB090908
!!    write(*,*)                                                  &
!!   &'============================================================'
!!    write(*,*) 'move_rk1_blk:<RETURN,mp_myid=',mp_myid
!!    write(*,*) 'jmvloop,imvsequ,jmty,imove,kmove,ith_cs,ith_rk='
!!    write(*,*)  jmvloop,imvsequ,jmty(imvsequ,jmvloop)           &
!!   &                                ,imove,kmove,ith_cs,ith_rk
!
!!    write(*,*) 'FINAL RAND r1=', r1
!
!!    idum=ith_upd+mth_spec
!!    write(*,*) 'ith_upd,ithc_upd,ith_swo,nprop_swo,naccp_swo='
!!    write(*,*)                                                  &
!!   & ith_upd,idum,ith_swo                                       &
!!   &,nprop_swo(ith_swo)                                         &
!!   &,naccp_swo(ith_swo)
!
!!    write(*,*)                                                  &
!!   &'============================================================'
!!    write(*,*) ' '
!FB090808
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine move_thu_blk
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! Global Metropolis move of all species and reaction rate
! Theta-parameters along random unit vector direction in
! Theta sub-space selected from a Theta block
!
      include 'ens.def'
!
!
      call get_rasf_ini
      call save_chi_th
      call save_theta
!
      if(mthb_tot(imvsequ,jmvloop).eq.0) return
!
! construct random unit vector in Theta-space
  100 continue
      cu_theta=0.d0
      kth_upd=0
      do ith_half=1,mthb_tot(imvsequ,jmvloop)
        r1=randx()
        r2=randx()
        rgauss=dsqrt(dabs(dlog(dabs(r1)+1.d-20)))
!
        kth_upd=kth_upd+1
        if(kth_upd.gt.mthb_tot(imvsequ,jmvloop)) goto 110
        u_theta(kth_upd)=rgauss*dcos(pi2*r2)
        cu_theta=cu_theta+u_theta(kth_upd)**2
!
        kth_upd=kth_upd+1
        if(kth_upd.gt.mthb_tot(imvsequ,jmvloop)) goto 110
        u_theta(kth_upd)=rgauss*dsin(pi2*r2)
        cu_theta=cu_theta+u_theta(kth_upd)**2
      enddo
  110 continue
      if(cu_theta.lt.1.d-16) goto 100
      cu_theta=1.d0/dsqrt(cu_theta)
      kth_upd=-1
      ith_half=-1
!
! Construct globally updated theta-vector
      do kth_upd=1,mthb_tot(imvsequ,jmvloop)
        if(kthb_tot_ini(imvsequ,jmvloop).ge.1) then
          kthblk=kthb_tot_ini(imvsequ,jmvloop)+kth_upd-1
          ith_upd=ithc_thblk(kthblk)
        endif
        if(kthb_tot_ini(imvsequ,jmvloop).eq.-1) then
          ith_upd=kth_upd
        endif
!
        if(ith_upd.le.mth_spec) then
          ispec_upd=ispec_th(ith_upd)
          ipm_upd=ipmspec_th(ith_upd)
          rhi_th=rhispec(ith_upd)
          rlo_th=rlospec(ith_upd)
          step_th=stepspec(ith_upd)
          jct_th=jctspec(ispec_upd,ipm_upd)
          jbc_th=jbcspec(ispec_upd,ipm_upd)
!
          theta0=cspec(ispec_upd,ipm_upd)
        else
          ireac_upd=ireac_th(ith_upd-mth_spec)
          ipm_upd=ipmreac_th(ith_upd-mth_spec)
          rhi_th=rhireac(ith_upd-mth_spec)
          rlo_th=rloreac(ith_upd-mth_spec)
          step_th=stepreac(ith_upd-mth_spec)
          jct_th=jctreac(ireac_upd,ipm_upd)
          jbc_th=jbcreac(ireac_upd,ipm_upd)
!
          theta0=rreac(ireac_upd,ipm_upd)
        endif
!
!      propose new \Theta
        dtheta=cu_theta*step_th                                         &
     &        *fstp_imv*u_theta(kth_upd)*fstep_st
!
!      apply stepwidth optimization factors
        if(mpr_swo.gt.0) then
          ith_swo=mth_tot+1
          dtheta=dtheta*fstp_swo(ith_upd)*fstp_swo(ith_swo)
        endif
!
!      jct_th=0: Metropolis move Theta
        if(jct_th.eq.0) then
          theta1=theta0+dtheta
          ahi_th=rhi_th
          alo_th=rlo_th
        endif
!
!      jct_th=1: Metropolis move ln(Theta)
        if(jct_th.eq.1) then
          theta1=dlog(theta0)+dtheta
          ahi_th=dlog(rhi_th)
          alo_th=dlog(rlo_th)
        endif
!
!     enforce lo- and hi-Theta boundaries
        if( theta1.gt.ahi_th                                            &
     &  .or.theta1.lt.alo_th) then
!
!     jbc_th=0: reject cross-boundary moves
          if(jbc_th.eq.0) then
            jaccp=-1 ! move_thu_blk-01, jbc==0
            goto 71
          endif
!
!     jbc_th=1: reflect cross-boundary moves ("bounce of the wall")
          if(jbc_th.eq.1) then
            call refl_th(theta1,ahi_th,alo_th,isign_pi)
          endif
        endif
!
        if(jct_th.eq.1) theta1=dexp(theta1)
!
        if(ith_upd.le.mth_spec) then
          cspec(ispec_upd,ipm_upd)=theta1
        else
          rreac(ireac_upd,ipm_upd)=theta1
        endif
      enddo
!
!   calculate htot for proposed new \Theta
      if(jtmp_en(imvsequ,jmvloop).eq.4) goto 71
      jDB_get_chi=12
      call get_chi ! move_thu_blk-01
!
!DRLIM190524-2244:
      if(mlimdrv.ge.1) jaccp=-1 ! move_thu_blk-01
!:DRLIM190524-2244
!
      call store_chi_th
!
   71 continue
      call accp_move ! move_thu_blk-01
!
      if(jaccp.eq.0) then
        call reset_chi_th
        call reset_theta
      endif
!
      call get_rasf_fin ! move_thu_blk-01
!
      if(jmvloop.eq.1.or.jmvloop.eq.2) then
!
!DRLIM190524-2244:
        jlimd=0
        if(mlimdrv.ge.1) jlimd=1
        ith_swo=mth_tot+1
        nplimd(ith_swo)=nplimd(ith_swo)+1
        nmlimd(ith_swo)=nmlimd(ith_swo)+jlimd*mlimdrv
        njlimd(ith_swo)=njlimd(ith_swo)+jlimd
!:DRLIM190524-2244
!
        ipmty=3
        ith_upd=1
        nprop(ith_upd,imvsequ,jmvloop,ipmty)=                           &
     &    nprop(ith_upd,imvsequ,jmvloop,ipmty)+1
        naccp(ith_upd,imvsequ,jmvloop,ipmty)=                           &
     &    naccp(ith_upd,imvsequ,jmvloop,ipmty)+jaccp
!
        if(mpr_swo.gt.0.and.raccp_lo(imvsequ,jmvloop).le.1.d0) then
          ith_swo=mth_tot+1
          nprop_swo(ith_swo)=                                           &
     &    nprop_swo(ith_swo)+1
          nprop_up_swo(ith_swo)=                                        &
     &    nprop_up_swo(ith_swo)+jprop_up
          naccp_swo(ith_swo)=                                           &
     &    naccp_swo(ith_swo)+jaccp
          naccp_up_swo(ith_swo)=                                        &
     &    naccp_up_swo(ith_swo)+jaccp_up
        endif
!
        if(ipop_upd.ge.0) then
          nprop_pop(ipop_upd)=                                          &
     &    nprop_pop(ipop_upd)+1
          nprop_up_pop(ipop_upd)=                                       &
     &    nprop_up_pop(ipop_upd)+jprop_up
          naccp_pop(ipop_upd)=                                          &
     &    naccp_pop(ipop_upd)+jaccp
          naccp_up_pop(ipop_upd)=                                       &
     &    naccp_up_pop(ipop_upd)+jaccp_up
        endif
!
!
        if(mac_fbx.gt.0) call mc_fbxa
      endif
!
!
      jclO=153
      if(jo_th.eq.51) call odat_th ! move_thu_blk-01
!
      call accu_dos
      call ckcvg_dos
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine move_ham
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
!  Global move of all Theta-variables
!  by fictitious Hamiltonian leap-frog time evolution
!
      include 'ens.def'
!
      lhtot_ham=0
!
!
      call get_rasf_ini
      call save_chi_th
      call save_theta
!
!   initialize fict. conj. momenta and fict. masses, if needed
      call get_pi
!
!   run Hamiltonian leap-frog time evolution
      jaccp=1
      itfic=-1
      call get_force ! move_ham-01
      call get_hevl ! move_ham-01
!
!c      call test_hamevl
!
!   accept/reject the leap-frog run
!
      if(jaccp.eq.-1) then
        jaccp=0
        jaccp_up=0
        jprop_up=0
!
        jaccp_ek=0
        jaccp_ek_up=0
        jprop_ek_up=0
        goto 71
      endif
!
!   accept or reject proposed move
!   by generalized Metropolis criterion
      if(jtmp_en(imvsequ,jmvloop).eq.4) then
        jaccp=1
!
        rweight=ftmp_imv/(beta_mc*fbeta_st)
        rmet=randx()
        if(rmet.gt.rweight) jaccp=0
!
        jaccp_up=0
        jprop_up=0
        jaccp_ek_up=0
        jprop_ek_up=0
!
        if(                                                             &
     &     jmty(imvsequ,jmvloop).ge.1000.and.                           &
     &     jmty(imvsequ,jmvloop).le.2999                                &
     &  )then
          jhoodst(iorst(ipop_upd))=                                     &
     &    jhoodst(iorst(ipop_upd))+jaccp
        endif
        goto 71
      endif
      jaccp=1
      jaccp_ek=1
!
      dekin=(ekin_th-ekin_th0)
      dhtot=dekin                                                       &
     &      +(htot_th-htot_th0)*beta_mc*fbeta_st/ftmp_imv
!
      if(jtmp_en(imvsequ,jmvloop).eq.3) then
        enrg_dos=htot_th
        call get_dos
        aln_dos_th=aln_dos
!
        enrg_dos=htot_th0
        call get_dos
        aln_dos_th0=aln_dos
!
        dln_dos=aln_dos_th-aln_dos_th0
!
        dhtot=dekin+dln_dos
      endif
!
      rmet=randx()
      rmet=dlog(rmet+1.d-20)
!
      rweight=-dhtot
      if(rmet.gt.rweight) jaccp=0
!
      rweight=-dekin
      if(rmet.gt.rweight) jaccp_ek=jaccp
!
      if(htot_th.gt.htot_th0) then
        jaccp_up=jaccp
        jprop_up=1
      else
        jaccp_up=0
        jprop_up=0
      endif
!
      if(ekin_th.gt.ekin_th0) then
        jaccp_ek_up=jaccp_ek
        jprop_ek_up=1
      else
        jaccp_ek_up=0
        jprop_ek_up=0
      endif
!
   71 continue
      if(jaccp.eq.0) then
        call reset_chi_th
        call reset_theta
      endif
!
!CORR190521-1537: Moved this fct call here, from inside "if jmvloop==1,2"
      call get_rasf_fin ! move_ham-01
!:CORR190521-1537
!
!
      if(jmvloop.eq.1.or.jmvloop.eq.2) then
        if(jaccp.eq.1) then
          do ith_ham=1,mth_tot
            aforce_accpf(ith_ham,jmvloop)=                              &
     &      aforce_accpf(ith_ham,jmvloop)                               &
     &      +(force_ham(ith_ham)**2)                                    &
     &      *(0.5d0*omas_ham(ith_ham)*(dtfic_swo**2))
!
            if(jct_ham(ith_ham).eq.0) then
              adhevl_accpf(ith_ham,jmvloop)=                            &
     &        adhevl_accpf(ith_ham,jmvloop)                             &
     &        +(theta_ham(ith_ham,ntfic)-theta_ham(ith_ham,0))**2       &
     &        /(step_ham(ith_ham)*fstp_imv                              &
     &         *fstp_swo(ith_ham)*fstep_st)**2
            endif
!
            if(jct_ham(ith_ham).eq.1) then
              adhevl_accpf(ith_ham,jmvloop)=                            &
     &        adhevl_accpf(ith_ham,jmvloop)                             &
     &        +dlog(theta_ham(ith_ham,ntfic)/theta_ham(ith_ham,0))**2   &
     &        /(step_ham(ith_ham)*fstp_imv                              &
     &         *fstp_swo(ith_ham)*fstep_st)**2
            endif
          enddo
          ith_ham=-1
!
          htot_ham_accpf(jmvloop)=htot_ham_accpf(jmvloop)+htot_ham
          naccp_ham_fin(jmvloop)=naccp_ham_fin(jmvloop)+1
        endif
!
!
!CORR190521-1537: Moved this fct call to above, outside "if jmvloop==1,2"
!       call get_rasf_fin
!:CORR190521-1537
!
!
!DRLIM190524-2244:
        jlimd=0
        if(mlimdrv.ge.1) jlimd=1
        ith_swo=mth_tot+11
        nplimd(ith_swo)=nplimd(ith_swo)+1
        nmlimd(ith_swo)=nmlimd(ith_swo)+jlimd*mlimdrv
        njlimd(ith_swo)=njlimd(ith_swo)+jlimd
!:DRLIM190524-2244
!
!
        nprop_ham(imvsequ,jmvloop)=                                     &
     &    nprop_ham(imvsequ,jmvloop)+1
!
        naccp_ham(imvsequ,jmvloop)=                                     &
     &    naccp_ham(imvsequ,jmvloop)+jaccp
!
        ipmty=3
        ith_upd=2
        nprop(ith_upd,imvsequ,jmvloop,ipmty)=                           &
     &    nprop(ith_upd,imvsequ,jmvloop,ipmty)+1
        naccp(ith_upd,imvsequ,jmvloop,ipmty)=                           &
     &    naccp(ith_upd,imvsequ,jmvloop,ipmty)+jaccp
!
        if(mpr_swo.gt.0.and.raccp_lo(imvsequ,jmvloop).le.1.d0) then
          ith_swo=mth_tot+11
          nprop_swo(ith_swo)=                                           &
     &    nprop_swo(ith_swo)+1
          nprop_up_swo(ith_swo)=                                        &
     &    nprop_up_swo(ith_swo)+jprop_up
          naccp_swo(ith_swo)=                                           &
     &    naccp_swo(ith_swo)+jaccp
          naccp_up_swo(ith_swo)=                                        &
     &    naccp_up_swo(ith_swo)+jaccp_up
!
          ith_swo=mth_tot+12
          nprop_swo(ith_swo)=                                           &
     &    nprop_swo(ith_swo)+1
          nprop_up_swo(ith_swo)=                                        &
     &    nprop_up_swo(ith_swo)+jprop_ek_up
          naccp_swo(ith_swo)=                                           &
     &    naccp_swo(ith_swo)+jaccp_ek
          naccp_up_swo(ith_swo)=                                        &
     &    naccp_up_swo(ith_swo)+jaccp_ek_up
        endif
!
        if(ipop_upd.ge.0) then
          nprop_pop(ipop_upd)=                                          &
     &    nprop_pop(ipop_upd)+1
          nprop_up_pop(ipop_upd)=                                       &
     &    nprop_up_pop(ipop_upd)+jprop_up
          naccp_pop(ipop_upd)=                                          &
     &    naccp_pop(ipop_upd)+jaccp
          naccp_up_pop(ipop_upd)=                                       &
     &    naccp_up_pop(ipop_upd)+jaccp_up
        endif
!
        if(mac_fbx.gt.0) call mc_fbxa
      endif
!
!
!
      jclO=154
      if(jo_th.eq.51) call odat_th ! move_ham-01
!
      call accu_dos
      call ckcvg_dos
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine move_dcon
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!   Performs Gibbs sampler move for truncated Gaussian distribution
!   of spectral deconvolution amplitude variables.
!
      if(mdconr(imvsequ,jmvloop).eq.0) return
      if(mdconp(imvsequ,jmvloop).eq.0) return
      if(mampdu_tot(imvsequ,jmvloop).eq.0) return
!
      call get_rasf_ini
!
      jDB_get_chi=13
      call get_chi ! move_dcon-01
!DRLIM190524-2244:
!     Will likely have mlimdrv=0 here, since Theta is an already
!     accepted update from a prior MC move
!:DRLIM190524-2244
      call store_chi_th
!
!
      call save_chi_th
      call save_theta
!
! store deconv. real-species (RS) matrix elements in
! square symm. matrix format for each pseudo-species (PS),
! then diagonalize phi-matrix (if required) and move
! PS-RS amplitudes
!
! deconvolution amplitudes for _different_ pseudo-species (ldconp)
! are assumed to be independently distributed for each ldconp
! (with all other non-ampl. theta-variables held fixed);
! therefore we can perform independent Gibbs sampler sweeps on
! the sub-vector of deconv.ampls. of just one pseudo-species,
! and do so one "ldconp" at a time
!
      hpspecv0_tot=0
      hpspecv_tot=0
!
      do ldconp=ldconp_ini(imvsequ,jmvloop)            &
     &,         ldconp_fin(imvsequ,jmvloop)
        ipspec=ipspec_dconp(ldconp)
        ims=ims_spec(ipspec)
!
        if(jmsspec_ip(ipspec).eq.1) jmsip=1
        if(jmsspec_ip(ipspec).eq.0.or.jmsspec_ip(ipspec).eq.2) jmsip=2
!
! calculate full psi- and phi-matrix, including frozen-amplitude MEs
! for pseudo-species ldconp
        if(jwgt_mc(kmvsequ,jmvloop).ne.-1) jfwgt=1
        if(jwgt_mc(kmvsequ,jmvloop).eq.-1) jfwgt=0
        call get_mat_dcon
!      Note: must calculate psi-vector and psi-matrix _here_;
!      cannot be done in kin_xpt  b/c of dependence on randomized SFs
!
! store full deconv. amplitude vector, incl. frozen amplitudes,
! and amplitude limits, for pseudo-species ldconp,
! from corresponding theta-variable arrays
        call store_ampv_dcon
!
!
!!!DB090815
!!For debug only:
!!re-calculating pseudo-species xspec_chi from real-species xspec_tsxdc
!!with old amplitudes ampr_dconr before Gibbs sampler updates; then
!!compare to prior chisq_th and xspec_chi_th.
!!This re-calc. via get_xchi_dcon should *NOT* change the
!!chisq- and xspec_chivalue, i.e., we should have:
!!   chisq          = chisq_th
!!   xspec_chi(itmx)= xspec_chi_th(itmx)
!!after get_xchi_dcon,sum_chi_[u,w].
!!      call get_xchi_dcon
!!      if(jwgt_mc(kmvsequ,jmvloop).eq.-1) then
!!        jDB_sum_chi=11
!!        call sum_chi_u
!!      else
!!        jDB_sum_chi=12
!!        call sum_chi_w
!!      endif
!!!FB090815
!
! store unfrozen deconv. amplitude vector and
! store unfrozen psi-vector, phi-matrix and phi-trace,
! including unfrozen-theta amplitude MEs only,
! excluding frozen-amplitude MEs
        call store_ampu_dcon
! Note:
! psivec, phimat, ampr etc. are temps, valid only for current ldconp.
! Therefore cannot close and re-open ldconp-loop here.
!
! calculate pre-move pseudo-species chisq-/energy-contribution
! using all (unfrozen+frozen) amplitudes
        call get_hp0_dcon
!
!V090903:
!
! move unfrozen deconv. amplitudes for pseudo-species "ldconp"
! using truncated Gaussian Gibbs sampler single-line move algorithm
!   single-line moves along single-amplitude coordinate directions:
        if(jmty_ampdc(imvsequ,jmvloop).eq.8) then
!        store psibar- and phibar-vectors, amplitude ranges dampr
          call store_pbar1_dcon
!        perform sweep of single-amplitude moves:
          call mv_ampu1_dcon
        endif
!
!   single-line moves along phi-matrix e-vector directions:
        if(jmty_ampdc(imvsequ,jmvloop).eq.18) then
!        calculate e-vectors, e-vector products and store amplitude ranges
          call store_pbarev_dcon
!        perform sweep of e-vector moves:
          call mv_ampev_dcon
        endif
! other move types, jmty_ampdc|=8,18: not yet implemented
!:V090903
!
! save new, moved unfrozen ampr_ampdu into ampr_dconr, cspec, rreac
        call save_ampu_dcon
!
! calculate post-move pseudo-species chisq-contribution
! and change in chisq, using all (unfrozen+frozen) amplitudes
! for code testing purposes only
        call get_hp1_dcon
!
! update pseudo-species xspec_chi, yspec_chi from
! xspec_tsxdc(jmsip,itsxdc) and updated amplitudes ampr_dconr
        call get_xchi_dcon
      enddo !ldconp
!
      dhpspecv_tot=hpspecv_tot-hpspecv0_tot
!
! Calculate new chisq from updated amplitudes at frozen SFs
!
      if(jwgt_mc(kmvsequ,jmvloop).eq.-1) then
        jDB_sum_chi=13
        call sum_chi_u
      else
        jDB_sum_chi=14
        call sum_chi_w
      endif
      call store_chi_th
!
      dchipspec_th=chisq_th-chisq_th0
!
      call get_rasf_fin ! move_dcon-01
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine get_mat_dcon
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! Stores psi-vector and phi-matrix for deconvolution
! superposition, by calculating itxpt-iexpt-sums
!     \Phi_{p}(s,r)= \sum_e\sum_{t\in Expt_{p,e}}  X_s(e,t) X_r(e,t) / W_p(e,t)^2
!     \Psi_{p}(s)  = \sum_e\sum_{t\in Expt_{p,e}}  X_s(e,t) Z_p(e,t) / W_p(e,t)^2
! for pseudo-species p in expt no. e with exptl. conc. Z_p(e,t) and width W_p(e,t),
! p being a linear dependent of real species s,r with txpt-interpolated
! model conc. X_s(e,t) in expt no. e, with obs. time t==txpt
!
! zero psi-vector and on/above-diagonal phi-matrix elements and store
! temp look-ups for real-species model concs. at exptl. obs. times
! of the resp. pseudo-species.
!
! Notes:
! psi and phi must be evaluated inside "do ldconp"-loop b/c width
! "xspec_wid", weight factor "fwgt", and SF "sxplin" depend on "ldconp"
!
! must have set ims=imsspec(ipspec) before calling this subprg.;
! this was done in "do ldconp"-loop in "move_dcon"
!
! temp. variable ntxdc, temp. array itmx_txdc(itxdc) and
! temp. array xspec_txdcr(itxdc,idconr) are overwritten/re-stored
! for each ldconp, where
!     -ntxdc=no.of obs. times (over all iexpt) for ldconp;
!     -itmx_txdc(itxdc)=itmx(txpt,ims,iexpt)-label for ldconp,
!      given running label itxdc for fixed ims=imsspec(ipspec);
!     -xspec_txdcr(itxdc,idconr)=real-species parent conc. for ldconp
!      at (txpt,iexpt) for real-species parent idconr<-->ldconr
!
          ntxdc=0
          do ldconr2=ldconr_ini(imvsequ,jmvloop)              &
     &    ,          ldconr_fin(imvsequ,jmvloop)
            idconr2=ldconr2-ldconr_ini(imvsequ,jmvloop)+1
            irspec2=irspec_dconr(ldconr2)
            psivec_dconr(idconr2)=0.d0
!
            itxdc=0
            do iexpt=1,nexpt
              do itmx=itmx_ini(ims,iexpt),itmx_fin(ims,iexpt)
                itxdc=itxdc+1
!
                itxpt=itxpt_tmx(itmx)
                do itsxdc2=itsxdc_ini(irspec2,iexpt),itsxdc_fin(irspec2,iexpt)
                  if(itxpt.eq.itxpt_tsxdc(itsxdc2)) goto 119
                enddo
                errtag='000110.005: itxpt_tsxdc NOT FOUND'
                call err_term
  119           continue
!
                xspec_txdcr(itxdc,idconr2)=xspec_tsxdc(jmsip,itsxdc2)
                itmx_txdc(itxdc)=itmx
              enddo
            enddo
            ntxdc=itxdc
!
            do ldconr1=ldconr_ini(imvsequ,jmvloop),ldconr2
              idconr1=ldconr1-ldconr_ini(imvsequ,jmvloop)+1
              phimat_dconr(idconr1,idconr2)=0.d0
            enddo
          enddo
!
! sum up psi-vector and and above-diagonal phi-matrix elements
!
!V090927:
          beta_tot=beta_mc*fbeta_st/ftmp_imv
!:V090927
!
          do itxdc=1,ntxdc
            itmx=itmx_txdc(itxdc)
!
!          allow for weight factor:
            if(jfwgt.eq.0)                                          &
     &      wgt_lin=(1.d0/xspec_wid(itmx))**2
            if(jfwgt.eq.1)                                          &
     &      wgt_lin=(fwgt(itmx)/xspec_wid(itmx))**2
!
!V090927:
            wgt_lin=wgt_lin*beta_tot
!:V090927
!
            swx_psi=xspec_xpt(itmx)                                 &
     &      *wgt_lin                                                &
     &      *sxplin_ras(kscal_xpt(itmx))
!
            swx_phi=                                                &
     &       wgt_lin                                                &
     &      *sxplin_ras(kscal_xpt(itmx))**2
!
!
            do ldconr2=ldconr_ini(imvsequ,jmvloop)              &
     &      ,          ldconr_fin(imvsequ,jmvloop)
              idconr2=ldconr2-ldconr_ini(imvsequ,jmvloop)+1
!
              psivec_dconr(idconr2)=                          &
     &        psivec_dconr(idconr2)                           &
     &        +swx_psi*xspec_txdcr(itxdc,idconr2)
!
              do ldconr1=ldconr_ini(imvsequ,jmvloop),ldconr2
                idconr1=ldconr1-ldconr_ini(imvsequ,jmvloop)+1
                phimat_dconr(idconr1,idconr2)=                  &
     &          phimat_dconr(idconr1,idconr2)                   &
     &          +swx_phi*xspec_txdcr(itxdc,idconr1)         &
     &                  *xspec_txdcr(itxdc,idconr2)
              enddo !ldconr1
            enddo !ldconr2
          enddo !itxdc
!
! store symmetric below-diagonal phi-matrix elements
!
          do ldconr2=ldconr_ini(imvsequ,jmvloop)              &
     &    ,          ldconr_fin(imvsequ,jmvloop)
            idconr2=ldconr2-ldconr_ini(imvsequ,jmvloop)+1
!
            do ldconr1=ldconr_ini(imvsequ,jmvloop),(ldconr2-1)
              idconr1=ldconr1-ldconr_ini(imvsequ,jmvloop)+1
                phimat_dconr(idconr2,idconr1)=         &
     &          phimat_dconr(idconr1,idconr2)
            enddo !ldconr1
          enddo !ldconr2
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine store_ampv_dcon
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! store deconv. amplitudes, incl. frozen amplitudes,
! and amplitude limits, for pseudo-species ldconp
! from corresponding theta-variable arrays
!
        kampdv2=kampdv_inips(ldconp)-1
!
        do ldconr2=ldconr_ini(imvsequ,jmvloop)              &
     &  ,          ldconr_fin(imvsequ,jmvloop)
          idconr2=ldconr2-ldconr_ini(imvsequ,jmvloop)+1
          irspec2=irspec_dconr(ldconr2)
!
          kampdv2=kampdv2+1
!          Note: kampdv2=idconr2+kampdv_inips(ldconp)-1
          ispre2=ispre_ampdv(kampdv2)
          ipm2=ipm_ampdv(kampdv2)
!
          if(ispre2.le.nspec) then
            ampr_dconr(idconr2)=cspec(ispre2,ipm2)
            ith2=ith_spre(ispre2,ipm2)
            if(ith2.ge.1) then
              amprlo_dconr(idconr2)=rlospec(ith2)
              amprhi_dconr(idconr2)=rhispec(ith2)
            else
              amprlo_dconr(idconr2)=-1.d6
              amprhi_dconr(idconr2)=-1.d6
            endif
          else
            ampr_dconr(idconr2)=rreac(ispre2-nspec,ipm2)
            ith2=ith_spre(ispre2,ipm2)
            if(ith2.ge.1) then
              amprlo_dconr(idconr2)=rloreac(ith2)
              amprhi_dconr(idconr2)=rhireac(ith2)
            else
              amprlo_dconr(idconr2)=-1.d6
              amprhi_dconr(idconr2)=-1.d6
            endif
          endif
        enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine store_ampu_dcon
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! store unfrozen deconv. amplitude vector and
! store unfrozen psi-vector, phi-matrix and phi-trace,
! including unfrozen-theta amplitude MEs only,
! excluding frozen-amplitude MEs
!
        kampdv2=kampdv_inips(ldconp)-1
!
        do ldconr2=ldconr_ini(imvsequ,jmvloop)              &
     &  ,          ldconr_fin(imvsequ,jmvloop)
          idconr2=ldconr2-ldconr_ini(imvsequ,jmvloop)+1
!
          kampdv2=kampdv2+1
!
          ispre2=ispre_ampdv(kampdv2)
          ipm2=ipm_ampdv(kampdv2)
!
          if(kampdu_ampdv(kampdv2).ge.1) then
            iampdu2=kampdu_ampdv(kampdv2)-kampdu_inips(ldconp)+1
            psivec_ampdu(iampdu2)=       &
     &      psivec_dconr(idconr2)
!
            ampr_ampdu(iampdu2)=ampr_dconr(idconr2)
            amprlo_ampdu(iampdu2)=amprlo_dconr(idconr2)
            amprhi_ampdu(iampdu2)=amprhi_dconr(idconr2)
!
            kampdv1=kampdv_inips(ldconp)-1
            do ldconr1=                              &
     &      ldconr_ini(imvsequ,jmvloop),             &
     &      ldconr_fin(imvsequ,jmvloop)
              idconr1=ldconr1-ldconr_ini(imvsequ,jmvloop)+1
              kampdv1=kampdv1+1
!
              if(kampdu_ampdv(kampdv1).ge.1) then
!              store unfrozen-unfrozen quadratic ME into psimat_ampdu
                iampdu1=kampdu_ampdv(kampdv1)-kampdu_inips(ldconp)+1
                phimat_ampdu(iampdu2,iampdu1)=       &
     &          phimat_dconr(idconr2,idconr1)
              else  !if: kampdu_ampdv(kampdv1)<1:
!              add mixed (unfrozen-frozen) quadratic term to psivec_ampdu
                psivec_ampdu(iampdu2)=       &
     &          psivec_ampdu(iampdu2)-       &
     &          phimat_dconr(idconr2,idconr1)*ampr_dconr(idconr1)
              endif !kampdu_ampdv(kampdv1)>=1
            enddo !ldconr1
          endif !kampdu_ampdv(kampdv2)>=1
        enddo !ldconr2
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine get_hp0_dcon
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
! calculate pre-move pseudo-species chisq-/energy-contribution
! using all (unfrozen+frozen) amplitudes
!
        hpspecv=0.d0
!
        do ldconr2=ldconr_ini(imvsequ,jmvloop)                    &
     &  ,          ldconr_fin(imvsequ,jmvloop)
          idconr2=ldconr2-ldconr_ini(imvsequ,jmvloop)+1
!
          hpspecv=hpspecv                                         &
     &    -2.d0*psivec_dconr(idconr2)*ampr_dconr(idconr2)
!
          do ldconr1=ldconr_ini(imvsequ,jmvloop),ldconr2
            idconr1=ldconr1-ldconr_ini(imvsequ,jmvloop)+1
!
            adum0=1.d0
            if(ldconr1.lt.ldconr2) adum0=2.d0
!
            hpspecv=                                                  &
     &      hpspecv+                                                  &
     &      adum0*phimat_dconr(idconr1,idconr2)*                      &
     &      ampr_dconr(idconr1)*ampr_dconr(idconr2)
          enddo !ldconr1
        enddo !ldconr2
!
        hpspecv0_dconp(ldconp)=hpspecv
        hpspecv0_tot=hpspecv0_tot+hpspecv
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine store_pbar1_dcon
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! store psibar- and phibar-vectors and amplitude ranges dampr
! impose lower cut-offs on diagonal phi-matrix elements phibar
! pre-store standardized Gaussian conversion factors zetabar and
! their inverses
!
!        Pre-store for all iampdu:
          do iampdu=1,mampdu_ps(ldconp)
!          Pre-store psibar-values for each amplitude dir.
            psibar(iampdu)=psivec_ampdu(iampdu)
            do iampdu1=1,mampdu_ps(ldconp)
              psibar(iampdu)=psibar(iampdu)-                       &
     &        phimat_ampdu(iampdu,iampdu1)*ampr_ampdu(iampdu1)
            enddo
!
!          Pre-store amplitude ranges and bound error limits
            dampr1(iampdu)=dabs((amprhi_ampdu(iampdu)              &
     &                              -amprlo_ampdu(iampdu)))
!
            ampr_errhi_ampdu(iampdu)=amprhi_ampdu(iampdu)          &
     &      +1.d-3*dampr1(iampdu)
            ampr_errlo_ampdu(iampdu)=amprlo_ampdu(iampdu)          &
     &      -1.d-3*dampr1(iampdu)
!
!V090903:
!!!         if(                                                    &
!!!  &      (amprhi_ampdu(iampdu)                                  &
!!!  &      *amprlo_ampdu(iampdu)).gt.0                            &
!!!  &      )then
!!!           dampr2=dabs((amprhi_ampdu(iampdu)**2         &
!!!  &                                -amprlo_ampdu(iampdu)**2))
!!!         else
!!!           dampr2=dabs((amprhi_ampdu(iampdu)**2         &
!!!  &                                +amprlo_ampdu(iampdu)**2))
!!!         endif
!!!
            zeta_hi=dabs((amprhi_ampdu(iampdu)                      &
     &                  -amprlo_ampdu(iampdu)))
!          Note: zeta_hi==\sqrt(dampr2) now stores the largest possible
!          value that |zeta| could ever reach  when moving the
!          amplitude vector by a move vector
!               zeta * u
!          along unit vector u in iampdu-ampl. direction within "bound box"
!          defined by the amplitudes' lo- and hi-bounds. This maximal
!          |zeta|-value could be reached only if the starting point of
!          the move is one of the two surfaces of the box perpendicular
!          to the iampdu-direction, i.e. if the starting amplitude-value
!          equals either the lo- or to the hi-bound value.
!
!          Store and set lower phibar cut-off and store inverse of phibar
            phibar(iampdu)=dabs(phimat_ampdu(iampdu,iampdu))
            dampr2=zeta_hi**2
            dhphi=phibar(iampdu)*dampr2
            if(dhphi.lt.1.d-8) phibar(iampdu)=1.d-8/dampr2
            ophibar(iampdu)=1.d0/phibar(iampdu)
!
!          Pre-store standardized Gaussian conversion factors
!          zetabar and their inverses
            ozetabar(iampdu)=dsqrt((2.d0*phibar(iampdu)))
            zetabar(iampdu)=1.d0/ozetabar(iampdu)
!:V090903
          enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mv_ampu1_dcon
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! move unfrozen deconv. amplitudes for pseudo-species "ldconp"
! along single-amplitude coordinate directions, using truncated
! Gaussian Gibbs sampler single-line move algorithm
!
          jclev=0
          ort2=dsqrt(0.5d0)
          idcsweep_tot=ndcsweep(imvsequ,jmvloop)*mampdu_ps(ldconp)**2
!
          do idcsweep=1,idcsweep_tot
            r1=randx()
            r2=randx()
!
            adum0=mampdu_ps(ldconp)*r1+1.d0
            iampdu_upd=adum0
            if(iampdu_upd.gt.mampdu_ps(ldconp)) iampdu_upd=mampdu_ps(ldconp)
            if(iampdu_upd.lt.1) iampdu_upd=1
!
!          construct z-shift and Gaussian truncation z-limits
            zpsibar=2.d0*psibar(iampdu_upd)*zetabar(iampdu_upd)
!
            zlo=ozetabar(iampdu_upd)                             &
     &         *(amprlo_ampdu(iampdu_upd)                        &
     &            -ampr_ampdu(iampdu_upd))                       &
     &         -zpsibar
!
            zhi=ozetabar(iampdu_upd)                             &
     &         *(amprhi_ampdu(iampdu_upd)                        &
     &            -ampr_ampdu(iampdu_upd))                       &
     &         -zpsibar
!
            jpoiss=0
            if(zlo.gt.50.d0.or.zhi.lt.-50.d0) jpoiss=1
            call tgauss(zprob,zlo,zhi,jpoiss,jclev,jerrivn,jerrtg)
!
            ampr_upd=zprob*zetabar(iampdu_upd)                  &
     &              +psibar(iampdu_upd)*ophibar(iampdu_upd)     &
     &              +ampr_ampdu(iampdu_upd)
!
            if(                                           &
     &      jerrivn.ne.0.or.jerrtg.gt.0.or.               &
     &      ampr_upd.gt.ampr_errhi_ampdu(iampdu_upd).or.  &
     &      ampr_upd.lt.ampr_errlo_ampdu(iampdu_upd)      &
     &      )then
              errtag='000110.006.000'
              call err_term
            endif
!
            if(ampr_upd.ge.amprhi_ampdu(iampdu_upd))    &
     &      ampr_upd=amprhi_ampdu(iampdu_upd)-1.d-8*dampr1(iampdu_upd)
            if(ampr_upd.le.amprlo_ampdu(iampdu_upd))    &
     &      ampr_upd=amprlo_ampdu(iampdu_upd)+1.d-8*dampr1(iampdu_upd)
!
!          move deconv. amplitude variable and corresp. psibar
            dampr_upd=ampr_upd-ampr_ampdu(iampdu_upd)
            ampr_ampdu(iampdu_upd)=ampr_upd
            psibar(iampdu_upd)=psibar(iampdu_upd)-      &
     &      phimat_ampdu(iampdu_upd,iampdu_upd)*dampr_upd
          enddo !idcsweep
!
!
      return
      end
!
!V090903:
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine store_pbarev_dcon
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! calculates phi-matrix e-values, e-vectors and e-vector
! products needed for single-line moves along phi-matrix e-vector
! directions, using truncated Gaussian Gibbs sampler algorithm
!
!    Store trace of phi-matrix
      trphimat=0.d0
      do iampdu=1,mampdu_ps(ldconp)
        trphimat=trphimat+dabs(phimat_ampdu(iampdu,iampdu))
      enddo
!
!    Diagonalize phi-matrix
      jevphi=1
      call ev_rs(                                          &
     &           mdconr_y, mampdu_ps(ldconp)               &
!!                     nm,                 n
     &          ,phimat_ampdu, evphi,   jevphi, uevphi     &
!!              ,           a,     w,     matz,      z
     &          ,phifv1,   phifv2,    jerr_evphi           &
!!              ,   fv1,      fv2,          ierr
     &          )
      if(jerr_evphi.ne.0) then
        errtag='000110.006.001'
        call err_term
      endif
!!
!!    subrt. ev_rs(nm,n,a,w,matz,z,fv1,fv2,ierr)
!!
!!    integer n,nm,ierr,matz
!!    real*8 a(nm,n),w(n),z(nm,n),fv1(n),fv2(n)
!!
!!    this subrt. ev_rs calls the recommended sequence of
!!    subroutines from the eigensystem subroutine package (eispack)
!!    to find the eigenvalues and eigenvectors (if desired)
!!    of a real symmetric matrix.
!!
!!    on input
!!
!!       nm  must be set to the row dimension of the two-dimensional
!!       array parameters as declared in the calling program
!!       dimension statement.
!!
!!       n  is the order of the matrix  a.
!!
!!       a  contains the real symmetric matrix.
!!
!!       matz  is an integer variable set equal to zero if
!!       only eigenvalues are desired.  otherwise it is set to
!!       any non-zero integer for both eigenvalues and eigenvectors.
!!
!!    on output
!!
!!       w  contains the eigenvalues in ascending order.
!!
!!       z  contains the eigenvectors if matz is not zero.
!!
!!       ierr  is an integer output variable set equal to an error
!!          completion code described in the documentation for tqlrat
!!          and tql2.  the normal completion code is zero.
!!
!!       fv1  and  fv2  are temporary storage arrays.
!!
!
!    Test norm and (re-)normalize e-vectors [O(N^2)-operation]
      do ievphi=1,mampdu_ps(ldconp)
        anorm=0.d0
        do iampdu1=1,mampdu_ps(ldconp)
          anorm=anorm+uevphi(iampdu1,ievphi)**2
        enddo !iampdu1
        if(anorm.lt.1.0d-6) then
          errtag='000110.006.002'
          call err_term
        endif
        anorm=1.d0/dsqrt(anorm)
        do iampdu1=1,mampdu_ps(ldconp)
          uevphi(iampdu1,ievphi)=anorm*uevphi(iampdu1,ievphi)
        enddo !iampdu1
      enddo !ievphi
!
!    Store inverse non-zero e-vector elements
      do ievphi=1,mampdu_ps(ldconp)
        do iampdu=1,mampdu_ps(ldconp)
          ouevphi(iampdu,ievphi)=0.d0
          if(dabs(uevphi(iampdu,ievphi)).gt.1.d-22)       &
     &    ouevphi(iampdu,ievphi)=1.d0/uevphi(iampdu,ievphi)
        enddo !iampdu
      enddo !ievphi
!
!
!V090912:`
!    Calculate "effective" e-values for each normalized num. e-vector u:
!      phibar==<u|phi|u>
!
!    Calculate phimat-multiplied normalized num.e-vector u:
!      phiuev==phi|u>
!
!    Calculate psivec overlap with normalized num. e-vector u:
!      psiuev==<psi|u>
!
!
! jdcckev=0: low-test-level option
!   Skips all checks of e-vector and e-value quality;
!   assumes that all num. e-vectors and e-values have been
!   obtained from ev_rs with sufficient num. accuracy.
!   Thus, approximates phibar, phiuev via num. e-values and e-vectors
!
! jdcckev=111: high-test-level option
!   Carefully checks quality of e-vectors and e-values;
!   Also, calculates phibar, phiuev via vector and matrix multiplications
!   from num. evectors u only, as defined above, without using e-vector properties
!   and hence without assuming accuracy of num. e-values and e-vectors.
!   This same procedure would therefore also work for single-line
!   moves along any randomly chosen set of unit vectors u that
!   are not required to be (even approximate) e-vectors of phimat.
!
! Other jdcckev options: NOT YET IMPLEMENTED
!
!
!    Low-test-level option
!
      if(                                                      &
     &jdcckev(imvsequ,jmvloop).eq.  0                          &
     &)then
!
!      Set "effective" e-values = actual num.e-values evphi, i.e.
!      for each normalized e-vector u: phibar==<u|phi|u>= e_u;
!      where evphi==e_u the num.e-value of num. e-vector u
!
!      Set phimat-multiplied num.e-vector u = e-value * e-vector, i.e.
!      phimat-multiplied e-vector u: phiuev==phi|u> = e_u * |u>;
!
!      Calculate psivec overlap with e-vector u: psiuev= <psi|u>;
!
        do ievphi=1,mampdu_ps(ldconp)
          phibar(ievphi)=evphi(ievphi)
          psiuev(ievphi)=0.d0
          do iampdu1=1,mampdu_ps(ldconp)
            psiuev(ievphi)=psiuev(ievphi)                            &
     &      +psivec_ampdu(iampdu1)*uevphi(iampdu1,ievphi)
!
            phiuev(iampdu1,ievphi)=                                  &
     &      evphi(ievphi)*uevphi(iampdu1,ievphi)
          enddo !iampdu1
        enddo !ievphi
!
        goto 501
      endif !if(jdcckev==0)
!
!    High-test-level option
!
      if(                                                      &
     &jdcckev(imvsequ,jmvloop).eq.  111                        &
     &)then
!
!      Test accuracy of e-vector, calculate "effective" e-values
!      for each normalized e-vector u: phibar==<u|phi|u>;
!      phimat-multiplied e-vector u: phiuev==phi|u>;
!      and psivec overlap with e-vector u: psiuev= <psi|u>;
!      also test ascending order of e-values
!
!      By using eff. e-values and phi-multiplied e-vectors
!      in single-line updates along e-vector direction, the
!      accuracy of e-vectors, e-values does not matter: we
!      simply treat the approximate e-vector as an arbitrary
!      (non-e-vector) single-line direction and perform a
!      move along that line accordingly, using only uevphi,
!      phibar, psiuev and phiuev, without assuming uevphi
!      to be an e-vector.
        do ievphi=1,mampdu_ps(ldconp)
          phibar(ievphi)=0.d0
          psiuev(ievphi)=0.d0
          anorm=0.d0
          do iampdu1=1,mampdu_ps(ldconp)
            psiuev(ievphi)=psiuev(ievphi)                            &
     &      +psivec_ampdu(iampdu1)*uevphi(iampdu1,ievphi)
!
            phiuev(iampdu1,ievphi)=0.d0
            do iampdu2=1,mampdu_ps(ldconp)
              phiuev(iampdu1,ievphi)=phiuev(iampdu1,ievphi)          &
     &        +phimat_ampdu(iampdu1,iampdu2)*uevphi(iampdu2,ievphi)
            enddo
            phibar(ievphi)=phibar(ievphi)                            &
     &      +phiuev(iampdu1,ievphi)*uevphi(iampdu1,ievphi)
!
            anorm=anorm                                              &
     &      +(phiuev(iampdu1,ievphi)                                 &
     &      -evphi(ievphi)*uevphi(iampdu1,ievphi)                    &
     &      )**2
          enddo !iampdu1
!
          anorm=anorm/trphimat**2
          if(anorm.gt.1.0d-8) then
            errtag='000110.006.004'
            call err_term
          endif
!
          anorm=((evphi(ievphi)-phibar(ievphi))/trphimat)**2
          if(anorm.gt.1.0d-8) then
            errtag='000110.006.005'
            call err_term
          endif
!
          if(ievphi.ge.2) then
            if(evphi(ievphi).lt.evphi(ievphi-1)) then
              errtag='000110.006.006'
              call err_term
            endif
          endif
        enddo !ievphi
      endif !if(jdcckev==111)
!
!
  501 continue
!
!:V090912
!
!    Impose lower cut-off on eff. e-value phibar and
!    pre-store standardized Gaussian conversion factor
!    zetabar and its inverse
      do ievphi=1,mampdu_ps(ldconp)
!      find extremal zeta bound along chosen e-vector direction
        jzeta_bound=0
        zeta_hi=-1.d0
!
        do iampdu=1,mampdu_ps(ldconp)
          if(dabs(uevphi(iampdu,ievphi)).le.1.d-20) goto 90
!
          zeta_amphi=                                            &
     &    dabs(                                                  &
     &         ouevphi(iampdu,ievphi)                            &
     &        *(amprhi_ampdu(iampdu)-amprlo_ampdu(iampdu))       &
     &        )
!
          if(jzeta_bound.eq.0) then
            zeta_hi=zeta_amphi
            jzeta_bound=1
            goto 90
          endif
!
          if(zeta_amphi.lt.zeta_hi) zeta_hi=zeta_amphi
!
   90     continue
        enddo !iampdu
!      Note: zeta_hi now stores the largest possible value that
!      |zeta| could ever reach when moving the amplitude vector
!      by a move vector
!           zeta * u
!      along the normalized e-vector u within the "bound box"
!      defined by the amplitudes' lo- and hi-bounds. This maximal
!      |zeta|-value could be reached only if the starting point of
!      the move is one of the corners of the box.
!
!      Set lower phibar cut-off and store inverse of phibar
        dzeta2=zeta_hi**2
        dhphi=phibar(ievphi)*dzeta2
        if(dhphi.lt.1.d-8) phibar(ievphi)=1.d-8/dzeta2
        ophibar(ievphi)=1.d0/phibar(ievphi)
!
!      Pre-store standardized Gaussian conversion factors
!      zetabar and their inverses
        ozetabar(ievphi)=dsqrt((2.d0*phibar(ievphi)))
        zetabar(ievphi)=1.d0/ozetabar(ievphi)
      enddo !ievphi
!
!
!    Pre-store amplitude ranges and bound error limits
      do iampdu=1,mampdu_ps(ldconp)
        dampr1(iampdu)=dabs((amprhi_ampdu(iampdu)          &
     &                          -amprlo_ampdu(iampdu)))
!
        ampr_errhi_ampdu(iampdu)=amprhi_ampdu(iampdu)      &
     &  +1.d-3*dampr1(iampdu)
        ampr_errlo_ampdu(iampdu)=amprlo_ampdu(iampdu)      &
     &  -1.d-3*dampr1(iampdu)
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mv_ampev_dcon
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! perfoms sweep of truncated Gaussian Gibbs sampler moves along
! arbitrary unit-vector directions u stored in columns of uevphi,
! which may be, but  do not *have* to be, (approx.) e-vectors of
! the phi-matrix. Moves are strictly confined to lie within the
! "bound box" defined by the amplitudes' lo- and hi-bounds.
!
! Required psi-vector-, phi-matrix- and bound-related inputs:
!  uevphi(iampdu,ievphi):
!    unit column vectors |u(ievphi)>
!  ouevphi(iampdu,ievphi):
!    inverses of no-zero uevphi elements.
!  amprlo_ampdu(iampdu), ampr_ampdu(iampdu):
!    amplitude lo-, hi-bounds
!  psiuev(ievphi):
!    projection of psi-vector onto u: <u|Psi>
!  phiuev(iampdu,ievphi):
!    matrix of phi-multiplied u-vectors: Phi|u>
!  phibar(ievphi):
!    u-diag. phi-matrix element <u|Phi|u>, w/ box-defined pos. low cut-off
!  ophibar(ievphi):
!    1 / <u|Phi|u>
!  zetabar(ievphi):
!    1 / sqrt(2*<u|Phi|u>)
!  ozetabar(ievphi):
!        sqrt(2*<u|Phi|u>)
!
!
        jclev=0
        ort2=dsqrt(0.5d0)
        idcsweep_tot=ndcsweep(imvsequ,jmvloop)*mampdu_ps(ldconp)**2
!
        ievphi_upd=0
        do idcsweep=1,idcsweep_tot
!
!        move along lowest-e-value direction first:
!        cycle through e-vectors in order of ascending e-value
          ievphi_upd=ievphi_upd+1
          if(ievphi_upd.gt.mampdu_ps(ldconp)) ievphi_upd=1
!
!        find lo- and hi-zeta bounds along chosen e-vector direction
          jzeta_bound=0
          zeta_lo=+1.d0
          zeta_hi=-1.d0
          do iampdu=1,mampdu_ps(ldconp)
            if(dabs(uevphi(iampdu,ievphi_upd)).le.1.d-20) goto 90
!
            if(uevphi(iampdu,ievphi_upd).gt.0.d0) then
              zeta_amplo=ouevphi(iampdu,ievphi_upd)                       &
     &                   *(amprlo_ampdu(iampdu)-ampr_ampdu(iampdu))
              zeta_amphi=ouevphi(iampdu,ievphi_upd)                       &
     &                   *(amprhi_ampdu(iampdu)-ampr_ampdu(iampdu))
            endif
!
            if(uevphi(iampdu,ievphi_upd).lt.0.d0) then
              zeta_amplo=ouevphi(iampdu,ievphi_upd)                       &
     &                   *(amprhi_ampdu(iampdu)-ampr_ampdu(iampdu))
              zeta_amphi=ouevphi(iampdu,ievphi_upd)                       &
     &                   *(amprlo_ampdu(iampdu)-ampr_ampdu(iampdu))
            endif
!
            if(jzeta_bound.eq.0) then
              zeta_lo=zeta_amplo
              zeta_hi=zeta_amphi
              jzeta_bound=1
              goto 90
            endif
!
            if(zeta_amplo.gt.zeta_lo)                          &
     &      zeta_lo=zeta_amplo
!
            if(zeta_amphi.lt.zeta_hi)                          &
     &      zeta_hi=zeta_amphi
!
   90       continue
          enddo !iampdu
!
          if(zeta_hi.le.zeta_lo) then
            errtag='000110.006.007'
            call err_term
          endif
!
!        calculate psibarev
          psibarev=psiuev(ievphi_upd)
          do iampdu=1,mampdu_ps(ldconp)
            psibarev=psibarev                                  &
     &      -phiuev(iampdu,ievphi_upd)*ampr_ampdu(iampdu)
          enddo
!
!        construct z-shift and Gaussian truncation z-limits;
!        then draw random z from truncated Gaussian
          zpsibar=2.d0*psibarev*zetabar(ievphi_upd)
!
          zlo=ozetabar(ievphi_upd)*zeta_lo                     &
     &       -zpsibar
!
          zhi=ozetabar(ievphi_upd)*zeta_hi                     &
     &       -zpsibar
!
          jpoiss=0
          if(zlo.gt.50.d0.or.zhi.lt.-50.d0) jpoiss=1
          call tgauss(zprob,zlo,zhi,jpoiss,jclev,jerrivn,jerrtg)
!
          if(                                                  &
     &    jerrivn.ne.0.or.jerrtg.gt.0                          &
     &    )then
            errtag='000110.006.008'
            call err_term
          endif
!
!        construct random zeta, update amplitudes ampr_upd
          zeta_upd=zprob*zetabar(ievphi_upd)                 &
     &            +psibarev*ophibar(ievphi_upd)
!
          do iampdu=1,mampdu_ps(ldconp)
            ampr_upd=ampr_ampdu(iampdu)                        &
     &              +zeta_upd*uevphi(iampdu,ievphi_upd)
!
            if(                                           &
     &      ampr_upd.gt.ampr_errhi_ampdu(iampdu).or.  &
     &      ampr_upd.lt.ampr_errlo_ampdu(iampdu)      &
     &      )then
              errtag='000110.006.009'
              call err_term
            endif
!
!          enforce deconv amplitude lo- and hi-limits
            if(ampr_upd.ge.amprhi_ampdu(iampdu))    &
     &      ampr_upd=amprhi_ampdu(iampdu)-1.d-8*dampr1(iampdu)
            if(ampr_upd.le.amprlo_ampdu(iampdu))    &
     &      ampr_upd=amprlo_ampdu(iampdu)+1.d-8*dampr1(iampdu)
!
!          move deconv. amplitude variable
            ampr_ampdu(iampdu)=ampr_upd
          enddo !iampdu
        enddo !idcsweep
!
!
      return
      end
!
!:V090903
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine save_ampu_dcon
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! save new, moved unfrozen ampr_ampdu into ampr_dconr, cspec, rreac
!
        kampdv2=kampdv_inips(ldconp)-1
!
        do ldconr2=                              &
     &  ldconr_ini(imvsequ,jmvloop),             &
     &  ldconr_fin(imvsequ,jmvloop)
          idconr2=ldconr2-ldconr_ini(imvsequ,jmvloop)+1
          kampdv2=kampdv2+1
!
          if(kampdu_ampdv(kampdv2).ge.1) then
            iampdu2=kampdu_ampdv(kampdv2)-kampdu_inips(ldconp)+1
            ampr_dconr(idconr2)=ampr_ampdu(iampdu2)
!
            ispre2=ispre_ampdv(kampdv2)
            ipm2=ipm_ampdv(kampdv2)
            if(ispre2.le.nspec) then
              cspec(ispre2,ipm2)=ampr_dconr(idconr2)
            else
              rreac(ispre2-nspec,ipm2)=ampr_dconr(idconr2)
            endif
          endif !kampdu_ampdv(kampdv2)>=1
        enddo !ldconr2
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine get_hp1_dcon
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! calculate post-move pseudo-species chisq-contribution
! and change in chisq, using all (unfrozen+frozen) amplitudes
! for code testing purposes only
!
        hpspecv_dconp(ldconp)=0.d0
        hpspecv=0.d0
!
        do ldconr2=ldconr_ini(imvsequ,jmvloop)                    &
     &  ,          ldconr_fin(imvsequ,jmvloop)
          idconr2=ldconr2-ldconr_ini(imvsequ,jmvloop)+1
!
          hpspecv=hpspecv                                         &
     &    -2.d0*psivec_dconr(idconr2)*ampr_dconr(idconr2)
!
          do ldconr1=ldconr_ini(imvsequ,jmvloop),ldconr2
            idconr1=ldconr1-ldconr_ini(imvsequ,jmvloop)+1
!
            adum0=1.d0
            if(ldconr1.lt.ldconr2) adum0=2.d0
!
            hpspecv=                                   &
     &      hpspecv+                                   &
     &      adum0*phimat_dconr(idconr1,idconr2)*                      &
     &      ampr_dconr(idconr1)*ampr_dconr(idconr2)
          enddo !ldconr1
        enddo !ldconr2
!
        hpspecv_dconp(ldconp)=hpspecv
        hpspecv_tot=hpspecv_tot+hpspecv
!
        dhpspecv_dconp(ldconp)=                                       &
     &  hpspecv_dconp(ldconp)-hpspecv0_dconp(ldconp)
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine get_xchi_dcon
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
! update xspec_chi, yspec_chi from xspec_tsxdc(jmsip,itsxdc)
! and from updated amplitudes ampr_dconr
! Note:
! before calling this subprg. w/ alt. summation option,
! for pseudo-species ldconp w/ species ID ipspec=ipspec_dcon(ldconp):
! --must have set ims=imsspec(ipspec);
!   this was done inside "do ldconp"-loop in "move_dcon";
! --temp. variable ntxdc, temp. array itmx_txdc(itxdc) and
!   temp. array xspec_txdcr(itxdc,idconr)
!   must have been stored for ldconp:
!     -ntxdc=no.of obs. times (over all iexpt) for ldconp;
!     -itmx_txdc(itxdc)=itmx(txpt,ims,iexpt)-label for ldconp,
!      given running label itxdc for fixed ims=imsspec(ipspec);
!     -xspec_txdcr(itxdc,idconr)=real-species parent conc. for ldconp
!      at (txpt,iexpt) for real-species parent idconr<-->ldconr
!   this was done inside "do ldconp"-loop in "get_mat_dcon"
!
      if(jdcpspec_sum(imvsequ,jmvloop).eq.1) then
        do iexpt=1,nexpt
          do itmx=itmx_ini(ims,iexpt),itmx_fin(ims,iexpt)
            xspec_chi(itmx)=0.d0
            itxpt=itxpt_tmx(itmx)
!
            do ldconr=                                           &
     &      ldconr_ini(imvsequ,jmvloop),                         &
     &      ldconr_fin(imvsequ,jmvloop)
              ispec=irspec_dconr(ldconr)
              idconr=ldconr-ldconr_ini(imvsequ,jmvloop)+1
!
              do itsxdc=itsxdc_ini(ispec,iexpt),itsxdc_fin(ispec,iexpt)
                if(itxpt_tsxdc(itsxdc).eq.itxpt) goto 79
              enddo !itsxdc
   79         continue
              xspec_chi(itmx)=xspec_chi(itmx)                &
     &        +ampr_dconr(idconr)*xspec_tsxdc(jmsip,itsxdc)
            enddo !ldconr
!
            yspec_chi(itmx)=dlog(dabs(xspec_chi(itmx)))
          enddo !itmx
        enddo !iexpt
      endif
!
! Faster alternative, using temp-stored real-species xspec_chi
! (xspec_txdcr is temp-stored in get_mat_dcon for one ldconp at a time).
!
      if(jdcpspec_sum(imvsequ,jmvloop).eq.2) then
        do itxdc=1,ntxdc
          itmx=itmx_txdc(itxdc)
          xspec_chi(itmx)=0.d0
!
          do ldconr=                                           &
     &    ldconr_ini(imvsequ,jmvloop),                         &
     &    ldconr_fin(imvsequ,jmvloop)
            idconr=ldconr-ldconr_ini(imvsequ,jmvloop)+1
!
            xspec_chi(itmx)=xspec_chi(itmx)                &
     &      +ampr_dconr(idconr)                            &
     &      *xspec_txdcr(itxdc,idconr)
          enddo !ldconr
!
          yspec_chi(itmx)=dlog(dabs(xspec_chi(itmx)))
        enddo !itxdc
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine move_amb
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!   declare "amoeba"-local I/O variables and arrays
!     NOTE: all following local variable/array decl's.
!     (w/ names ending in "..._amlr") MUST NOT appear
!     in "ens.def" var./arr. decl's. or common blocks
!
      integer mp_amlr, np_amlr, ndim_amlr, iter_amlr                    &
     &      , NMAX_amlr, ITMAX_amlr                                     &
     &      , jct_amlr                                                  &
     &      , ivec_amlr, ivec0_amlr                                     &
     &      , ith_amlr                                                  &
     &      , ispec_amlr                                                &
     &      , ireac_amlr                                                &
     &      , ipm_amlr                                                  &
     &      , isign_pi_amlr
!
      real*8  ptheta_amlr(1:(mth_tot_x+1),mth_tot_x)                    &
     &      , ptheta0_amlr(1:mth_tot_x)                                 &
     &      , y_amlr(1:(mth_tot_x+1))                                   &
     &      , z_amlr(1:(mth_tot_x+1))                                   &
     &      , ftol_amlr                                                 &
     &      , step_amlr                                                 &
     &      , rhi_amlr                                                  &
     &      , rlo_amlr                                                  &
     &      , p0_amlr                                                   &
     &      , y0_amlr
!
      external htot_amlr
!
      call get_rasf_ini
!
      jtrepl=1
      jo_amb=1
      jamb_ini=jamb_repl*jamb_rsi
!
      do ivec_amlr=1,(mth_tot+1)
        do ith_amlr=1,mth_tot
          if(ith_amlr.le.mth_spec) then
            ispec_amlr=ispec_th(ith_amlr)
            ipm_amlr=ipmspec_th(ith_amlr)
!
            step_amlr=stepspec(ith_amlr)*fstp_imv                       &
     &               *fstp_swo(ith_amlr)
!
            rhi_amlr=rhispec(ith_amlr)
            rlo_amlr=rlospec(ith_amlr)
            jct_amlr=jctspec(ispec_amlr,ipm_amlr)
!
            if(jamb_ini.le.0) then
              ptheta_amlr(ivec_amlr,ith_amlr)                           &
     &         =cspec(ispec_amlr,ipm_amlr)
            else
              ptheta_amlr(ivec_amlr,ith_amlr)                           &
     &         =theta_repl(ith_amlr,ivec_amlr-1,jtrepl)
            endif
          endif
!
          if(ith_amlr.gt.mth_spec) then
            ireac_amlr=ireac_th(ith_amlr-mth_spec)
            ipm_amlr=ipmreac_th(ith_amlr-mth_spec)
!
            step_amlr=stepreac(ith_amlr-mth_spec)*fstp_imv              &
     &               *fstp_swo(ith_amlr-mth_spec)
!
            rhi_amlr=rhireac(ith_amlr-mth_spec)
            rlo_amlr=rloreac(ith_amlr-mth_spec)
            jct_amlr=jctreac(ireac_amlr,ipm_amlr)
!
            if(jamb_ini.le.0) then
              ptheta_amlr(ivec_amlr,ith_amlr)                           &
     &         =rreac(ireac_amlr,ipm_amlr)
            else
              ptheta_amlr(ivec_amlr,ith_amlr)                           &
     &         =theta_repl(ith_amlr,ivec_amlr-1,jtrepl)
            endif
          endif
!
!
          if(jct_amlr.eq.1) then
            rhi_amlr=dlog(rhi_amlr)
            rlo_amlr=dlog(rlo_amlr)
            ptheta_amlr(ivec_amlr,ith_amlr)                             &
     &      =dlog(ptheta_amlr(ivec_amlr,ith_amlr))
          endif
!
          if(jamb_ini.le.0) then
            if(ith_amlr.eq.(ivec_amlr-1)) then
              p0_amlr=ptheta_amlr(ivec_amlr,ith_amlr)
   20         continue
              ptheta_amlr(ivec_amlr,ith_amlr)                           &
     &        =p0_amlr+step_amlr
              call refl_th(ptheta_amlr(ivec_amlr,ith_amlr)              &
     &                    ,rhi_amlr                                     &
     &                    ,rlo_amlr                                     &
     &                    ,isign_pi_amlr)
!
              if(                                                       &
     &        dabs(p0_amlr-ptheta_amlr(ivec_amlr,ith_amlr)).lt.         &
     &        (1.d-3*step_amlr)                                         &
     &        ) then
                step_amlr=step_amlr*0.5d0
                goto 20
              endif
            endif
!
            ptheta0_amlr(ith_amlr)                                      &
     &      =ptheta_amlr(ivec_amlr,ith_amlr)
          endif
        enddo
!
        ihtot_amb=-1
        mhtot_amb=-2
!
        if(jamb_ini.le.0) then
          call htot_amlr(y_amlr(ivec_amlr),z_amlr(ivec_amlr)            &
     &                  ,ptheta0_amlr)                       ! move_amb-01
        else
          y_amlr(ivec_amlr)=htot_repl(ivec_amlr-1,jtrepl)
          z_amlr(ivec_amlr)=chisq_repl(ivec_amlr-1,jtrepl)
        endif
!
        ihtot_amb=-1
        mhtot_amb=-2
      enddo
!
      jamb_repl=0
      jamb_rsi=0
!
!
!   zero htot_amlr-function call counter
      ihtot_amb=ihtot_amb_ini
!
      mhtot_amb=0
      if(mth_tot.gt.0) then
        imove_amb=(ihtot_amb-1)/mth_tot
        imove_amb=imove_amb+1
        mhtot_amb=ihtot_amb-mth_tot*(imove_amb-1)
        if(mhtot_amb.eq.mth_tot) mhtot_amb=0
        imove_amb=-1
      endif
!
      mp_amlr=mth_tot_x+1
      np_amlr=mth_tot_x
      NMAX_amlr=mth_tot_x
      ndim_amlr=mth_tot
      ITMAX_amlr=mit_amb*mth_tot-ihtot_amb
      ftol_amlr=tol_amb
!
      call store_pth2repl(y_amlr,z_amlr,ptheta_amlr)
!
      call amoeba(ptheta_amlr,y_amlr,z_amlr,mp_amlr,np_amlr,ndim_amlr   &
     &           ,ftol_amlr,htot_amlr                                   &
     &           ,iter_amlr,NMAX_amlr,ITMAX_amlr)
!
      call store_pth2repl(y_amlr,z_amlr,ptheta_amlr)
!
      ihtot_amb_ini=0
!
      y0_amlr=y_amlr(1)
      ivec0_amlr=1
      do ivec_amlr=1,(mth_tot+1)
        if(y_amlr(ivec_amlr).lt.y0_amlr) then
          y0_amlr=y_amlr(ivec_amlr)
          ivec0_amlr=ivec_amlr
        endif
      enddo
!
      ivec_amlr=ivec0_amlr
      do ith_amlr=1,mth_tot
        if(ith_amlr.le.mth_spec) then
          ispec_amlr=ispec_th(ith_amlr)
          ipm_amlr=ipmspec_th(ith_amlr)
!
          rhi_amlr=rhispec(ith_amlr)
          rlo_amlr=rlospec(ith_amlr)
          jct_amlr=jctspec(ispec_amlr,ipm_amlr)
        endif
!
        if(ith_amlr.gt.mth_spec) then
          ireac_amlr=ireac_th(ith_amlr-mth_spec)
          ipm_amlr=ipmreac_th(ith_amlr-mth_spec)
!
          rhi_amlr=rhireac(ith_amlr-mth_spec)
          rlo_amlr=rloreac(ith_amlr-mth_spec)
          jct_amlr=jctreac(ireac_amlr,ipm_amlr)
        endif
!
        if(jct_amlr.eq.1) then
          rhi_amlr=dlog(rhi_amlr)
          rlo_amlr=dlog(rlo_amlr)
        endif
!
        call refl_th(ptheta_amlr(ivec_amlr,ith_amlr)                    &
     &              ,rhi_amlr                                           &
     &              ,rlo_amlr                                           &
     &              ,isign_pi_amlr)
!
!
        if(ptheta_amlr(ivec_amlr,ith_amlr).gt.rhi_amlr)                 &
     &  ptheta_amlr(ivec_amlr,ith_amlr)=rhi_amlr
        if(ptheta_amlr(ivec_amlr,ith_amlr).lt.rlo_amlr)                 &
     &  ptheta_amlr(ivec_amlr,ith_amlr)=rlo_amlr
!
        if(jct_amlr.eq.1) then
          ptheta_amlr(ivec_amlr,ith_amlr)                               &
     &    =dexp(ptheta_amlr(ivec_amlr,ith_amlr))
        endif
!
        if(ith_amlr.le.mth_spec) then
          cspec(ispec_amlr,ipm_amlr)                                    &
     &     =ptheta_amlr(ivec_amlr,ith_amlr)
        else
          rreac(ireac_amlr,ipm_amlr)                                    &
     &    =ptheta_amlr(ivec_amlr,ith_amlr)
        endif
      enddo
!
!
      jDB_get_chi=14
      call get_chi ! move_amb-01
!
!DRLIM190524-2244:
      if(  mlimdrv.ge.1) then ! move_amb-01
        errtag='000121.001: # rate fct calls > nlim_drv, during amoeba'
        call err_term
      endif
!     May evolve a Theta with mlimdrv>=1 here.
!     Need to implement better handling for that case!! 
!:DRLIM190524-2244
!
      call store_chi_th
!
      ith_cs=-1
      if(mth_tot.gt.0) then
        imove_amb=(ihtot_amb-1)/mth_tot
        imove_amb=imove_amb+1
        ith_cs=ihtot_amb-mth_tot*(imove_amb-1)
      endif
!Db
      jclC=21
!Fb
      call ck_chimin
      ith_cs=-1
      imove_amb=-1
!
!
      if(jmvloop.eq.1.or.jmvloop.eq.2) then
        if(mac_fbx.gt.0) call mc_fbxa
      endif
!
      jo_amb=0
!
      call get_rasf_fin ! move_amb-01
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine move_xst
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!   parallel simulated tempering (PST) move B: exchange
!   whole Theta's between neighboring temps T_{i}, T_{i+k}
!
!     call get_rasf_ini
      if(jmvloop.eq.1.or.jmvloop.eq.2) then
        if(imvsequ.ge.1.and.imvsequ.le.nmvsequ(jmvloop)) then
          if(jrasf_ctl(imvsequ,jmvloop).eq.2) then
            errtag='000110.007: Randomzd SF NOT YET IMPLEMENTED in popul.moves'
            call err_term
          endif
        endif
      endif
!
      jo_pst=1
!
      jprop_xst_up=0
      jprop_xst=0
      jaccp_xst_up=0
      jaccp_xst=0
!
      fstp_swo_xst=1.d0
      if(mpr_swo.gt.0) then
        ith_swo=mth_tot+21
        fstp_swo_xst=fstp_swo(ith_swo)
      endif
!
      do ipop_xst=0,npopst
!     ...select Theta pair for exchange
        ixst=ipop_xst
        call fxch12_st
!
!
        dhtot_xst=                                                      &
     &    htot_st(iorst(ipop_y(1)))*beta_st(ipop_y(2))                  &
     &   +htot_st(iorst(ipop_y(2)))*beta_st(ipop_y(1))                  &
     &   -htot_st(iorst(ipop_y(1)))*beta_st(ipop_y(1))                  &
     &   -htot_st(iorst(ipop_y(2)))*beta_st(ipop_y(2))
!
!
        if(dhtot_xst.gt.0.d0) jprop_xst_up=jprop_xst_up+1
        jprop_xst=jprop_xst+1
!
        if(dhtot_xst.le.0.d0) goto 180
!
        if(dhtot_xst.gt.16.d0) goto 190
!
        rweight=dexp(-dhtot_xst)
        if(randx().gt.rweight) goto 190
!
! ... move accepted
  180   continue
        idum=iorst(ipop_y(1))
        iorst(ipop_y(1))=iorst(ipop_y(2))
        iorst(ipop_y(2))=idum
!
        if(dhtot_xst.gt.0.d0) jaccp_xst_up=jaccp_xst_up+1
        jaccp_xst=jaccp_xst+1
!
! ... move rejected
  190   continue
      enddo
!
      ipop_xst=-1
      ipop_y(1)=-1
      ipop_y(2)=-1
!
!
      if(jmvloop.eq.1.or.jmvloop.eq.2) then
        ipmty=3
        ith_upd=3
        nprop(ith_upd,imvsequ,jmvloop,ipmty)=                           &
     &    nprop(ith_upd,imvsequ,jmvloop,ipmty)+jprop_xst
        naccp(ith_upd,imvsequ,jmvloop,ipmty)=                           &
     &    naccp(ith_upd,imvsequ,jmvloop,ipmty)+jaccp_xst
!
        if(mpr_swo.gt.0.and.raccp_lo(imvsequ,jmvloop).le.1.d0) then
          ith_swo=mth_tot+21
!
          nprop_swo(ith_swo)=                                           &
     &    nprop_swo(ith_swo)+jprop_xst
          nprop_up_swo(ith_swo)=                                        &
     &    nprop_up_swo(ith_swo)+jprop_xst_up
          naccp_swo(ith_swo)=                                           &
     &    naccp_swo(ith_swo)+jaccp_xst
          naccp_up_swo(ith_swo)=                                        &
     &    naccp_up_swo(ith_swo)+jaccp_xst_up
        endif
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine move_yst
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!   parallel simulated tempering (PST) move C: exchange
!   Theta components between temps T_{i}, T_{i+k}
!
!
!     call get_rasf_ini
      if(jmvloop.eq.1.or.jmvloop.eq.2) then
        if(imvsequ.ge.1.and.imvsequ.le.nmvsequ(jmvloop)) then
          if(jrasf_ctl(imvsequ,jmvloop).eq.2) then
            errtag='000110.008: Randomzd SF NOT YET IMPLEMENTED in popul.moves'
            call err_term
          endif
        endif
      endif
!
      jo_pst=1
!
      jprop=0
      jprop_up=0
      jaccp_up=0
      jaccp=0
!
!
      do ipop_yst=0,npopst
!
!     ... keep this inside ipop_yst-loop
!         b/c of "move_xst"-calls below
        fstp_swo_xst=1.d0
        fstp_swo_yst=1.d0
        if(mpr_swo.gt.0) then
          ith_swo=mth_tot+31
          fstp_swo_xst=fstp_swo(ith_swo)
!
          ith_swo=mth_tot+32
          fstp_swo_yst=fstp_swo(ith_swo)
        endif
!
!     ...select Theta pair for exchange
        ixst=ipop_yst
        call fxch12_st
!
!     ...select number of Theta components for exchange
        if(jmthyst.eq.1) mthyst=dabs(amthyst)+1.001d0
!
        if(jmthyst.eq.2) then
          mthyst=randx()*(dabs(amthyst)+1.d0)
          mthyst=mthyst+1
        endif
!
        if(jmthyst.eq.11)                                               &
     &  mthyst=dabs(amthyst*fstp_swo_yst)+1.001d0
!
        if(jmthyst.eq.12) then
          mthyst=randx()*(dabs(amthyst*fstp_swo_yst)+1.d0)
          mthyst=mthyst+1
        endif
!
!     ...select range of Theta components for exchange
        if(jrthyst.eq.0) mth_xch=mth_tot
        if(jrthyst.eq.1) mth_xch=mth_spec
        if(jrthyst.eq.2) mth_xch=mth_reac
!
        if(mthyst.gt.mth_xch) mthyst=mth_xch
!
!     ...select Theta components for exchange
        do kthyst=1,mthyst
   10     continue
          ith=randx()*mth_xch
          ith=ith+1
          if(ith.gt.mth_xch) ith=mth_xch
          if(jrthyst.eq.2) ith=ith+mth_spec
!
          if(kthyst.gt.1) then
            do kthyst0=1,(kthyst-1)
              if(ith.eq.ith_xch(kthyst0)) goto 10
            enddo
          endif
!
          ith_xch(kthyst)=ith
        enddo
!
! jxthyst=1:
!   asymm. inject Theta-compnts. from one pair member into the other
!   only receiving Theta-changes, source Theta unchanged
! jxthyst=2:
!   symm. exchange Theta-compnts. between two pair members
!   each Theta is both source and receiver, both Theta change
!
        ihupd_skip=-1
        if(jxthyst.eq.1) then
          ihupd_skip=1
          if(randx().gt.0.5d0)                                           &
     &    ihupd_skip=2
        endif
!
!
        if(jtmp_en(imvsequ,jmvloop).eq.4) then
          jprop=jprop+1
!
!
          fbeta_st=0.d0
          idum1=0
          do ihupd=1,2
            if(ihupd.ne.ihupd_skip) then
              ipop_upd=ipop_y(ihupd)
              ipop_xch=ipop_y(3-ihupd)
              fbeta_st=fbeta_st+1.d0/beta_st(ipop_upd)
              idum1=idum1+1
            endif
          enddo
          fbeta_st=fbeta_st/(1.d0*idum1)
!
!c        fbeta_st=(1.d0/fbeta_st)/beta_mc
!c        rweight=ftmp_imv/(fbeta_st*beta_mc)
          rweight=ftmp_imv*fbeta_st
!
          rmet=randx()
!
          if(rmet.le.rweight) then
            jaccp=jaccp+1
            goto 184
          else
            goto 194
          endif
        endif
!
        dhtot=0.d0
!DRLIM190524-2244:
        mlimdrv_tot=0
!:DRLIM190524-2244
        do ihupd=1,2
          if(ihupd.eq.ihupd_skip) goto 90
!
          ipop_upd=ipop_y(ihupd)
          ipop_xch=ipop_y(3-ihupd)
!
          call store_st2th ! move_yst-01
!
          do kthyst=1,mthyst
            ith=ith_xch(kthyst)
            if(ith.le.mth_spec) then
              ispec=ispec_th(ith)
              ipm=ipmspec_th(ith)
              cspec(ispec,ipm)=theta_st(ith,iorst(ipop_xch))
            endif
            if(ith.gt.mth_spec) then
              ireac=ireac_th(ith-mth_spec)
              ipm=ipmreac_th(ith-mth_spec)
              rreac(ireac,ipm)=theta_st(ith,iorst(ipop_xch))
            endif
          enddo
!
          jDB_get_chi=15
          call get_chi ! move_yst-01
!
!DRLIM190524-2244:
          mlimdrv_tot=mlimdrv_tot+mlimdrv
!:DRLIM190524-2244
!
          call store_chi_th
!Db
      jclC=3
!Fb
          call ck_chimin
!
          htot_y(ihupd)=htot_th
          chisq_y(ihupd)=chisq_th
!
          dhtot=dhtot                                                   &
     &       +(htot_th-htot_st(iorst(ipop_upd)))                        &
     &       *beta_st(ipop_upd)
!
   90     continue
        enddo
!
!
        if(dhtot.gt.0.d0) jprop_up=jprop_up+1
        jprop=jprop+1
!
!DRLIM190524-2244:
        if(mlimdrv_tot.eq.0.and.dhtot.le.0.d0) goto 180 ! move_yst: accept
!
        if(mlimdrv_tot.ge.1) goto 190 ! move_yst: reject
!:DRLIM190524-2244
!
        if(dhtot.gt.16.d0) goto 190
!
        rweight=dexp(-dhtot)
        if(randx().gt.rweight) goto 190
!
! ... move accepted
  180   continue
        if(dhtot.gt.0.d0) jaccp_up=jaccp_up+1
        jaccp=jaccp+1
!
  184   continue
        do ihupd=1,2
          if(ihupd.eq.ihupd_skip) goto 188
!
          ipop_upd=ipop_y(ihupd)
          ipop_xch=ipop_y(3-ihupd)
!
          if(jtmp_en(imvsequ,jmvloop).eq.4) then
            jhoodst(iorst(ipop_upd))=                                   &
     &      jhoodst(iorst(ipop_upd))+1
            goto 188
          endif
!
          htot_st(iorst(ipop_upd))=htot_y(ihupd)
          chisq_st(iorst(ipop_upd))=chisq_y(ihupd)
!
  188     continue
        enddo
!
!     ...Note: this Theta-component exchange will work OK
!        for both jxthyst=1 and jxthyst=2 !
!        For jxthyst=1, previous ihupd-loop exits w/ "right"
!        ipop_upd ipop_xch values; whereas,
!        for jxthyst=2, ipop_upd and ipop_xch are
!        interchangeable in following loop
!
        do kthyst=1,mthyst
          ith=ith_xch(kthyst)
          theta1=                                                       &
     &    theta_st(ith,iorst(ipop_upd))
!
          theta_st(ith,iorst(ipop_upd))=                                &
     &    theta_st(ith,iorst(ipop_xch))
!
          if(jxthyst.eq.2)                                              &
     &    theta_st(ith,iorst(ipop_xch))=                                &
     &    theta1
        enddo
        if(jtmp_en(imvsequ,jmvloop).eq.4) goto 194
!
! ... move rejected
!
  190   continue
!
        do ihupd=1,2
          if(ihupd.eq.ihupd_skip) goto 192
!
          ipop_upd=ipop_y(ihupd)
          ipop_xch=ipop_y(3-ihupd)
!
          call store_st2th  ! move_yst-02
          call ct_htotst
!
  192     continue
        enddo
!
        do ifoxst=1,mfoxst
          call move_xst
        enddo
!
  194   continue
      enddo
!
!
      ipop_yst=-1
      mthyst=-1
!
      ipop_upd=-1
      ipop_xch=-1
      fbeta_st=1.d0
!
!
      if(jmvloop.eq.1.or.jmvloop.eq.2) then
        ipmty=3
        ith_upd=4
        nprop(ith_upd,imvsequ,jmvloop,ipmty)=                           &
     &    nprop(ith_upd,imvsequ,jmvloop,ipmty)+jprop
        naccp(ith_upd,imvsequ,jmvloop,ipmty)=                           &
     &    naccp(ith_upd,imvsequ,jmvloop,ipmty)+jaccp
!
        if(mpr_swo.gt.0.and.raccp_lo(imvsequ,jmvloop).le.1.d0) then
          do ith_swo=(mth_tot+31),(mth_tot+32)
            nprop_swo(ith_swo)=                                         &
     &      nprop_swo(ith_swo)+jprop
            nprop_up_swo(ith_swo)=                                      &
     &      nprop_up_swo(ith_swo)+jprop_up
            naccp_swo(ith_swo)=                                         &
     &      naccp_swo(ith_swo)+jaccp
            naccp_up_swo(ith_swo)=                                      &
     &      naccp_up_swo(ith_swo)+jaccp_up
          enddo
        endif
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine move_hst
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!   (re-)evaluate energy "htot" for each PST Theta, sequentially,
!   and measure Metropolis accept. ratios at specified temp_st;
!   to be executed after performing
!        "PGE mutation moves"
!   with energy-independent, externally specified acceptance ratios
!   using
!        jtmp_en=4
!
!
!     call get_rasf_ini
      if(jmvloop.eq.1.or.jmvloop.eq.2) then
        if(imvsequ.ge.1.and.imvsequ.le.nmvsequ(jmvloop)) then
          if(jrasf_ctl(imvsequ,jmvloop).eq.2) then
            errtag='000110.009: Randomzd SF NOT YET IMPLEMENTED in popul.moves'
            call err_term
          endif
        endif
      endif
!
      jo_pst=1
!
      jprop=1
      jaccp=1
!
      htot_th0=htot_th
!
      jDB_get_chi=16
      call get_chi ! move_hst-01
!
      call store_chi_th
!
      dhtot=htot_th-htot_th0
!
      rweight=dhtot*beta_mc*fbeta_st/ftmp_imv
!
!DRLIM190524-2244:
      if(mlimdrv.ge.1.or.rweight.gt.16.d0) then ! move_hst-01
        jaccp=0
        goto 190
      endif
!:DRLIM190524-2244
!
      if(dhtot.gt.0) then
        rweight=dexp(-rweight)
        rmet=randx()
        if(rmet.gt.rweight) jaccp=0
      endif
!
  190 continue
      jprop_up=0
      jaccp_up=0
!
      if(dhtot.gt.0) then
        jprop_up=1
        if(jaccp.eq.1) jaccp_up=1
      endif
!
!
      if(jmvloop.eq.1.or.jmvloop.eq.2) then
        ipmty=3
        ith_upd=5
        nprop(ith_upd,imvsequ,jmvloop,ipmty)=                           &
     &    nprop(ith_upd,imvsequ,jmvloop,ipmty)+jprop
        naccp(ith_upd,imvsequ,jmvloop,ipmty)=                           &
     &    naccp(ith_upd,imvsequ,jmvloop,ipmty)+jaccp
!
        if(mpr_swo.gt.0.and.raccp_lo(imvsequ,jmvloop).le.1.d0) then
          do ith_swo=(mth_tot+41),(mth_tot+42)
            nprop_swo(ith_swo)=                                         &
     &      nprop_swo(ith_swo)+jprop
            nprop_up_swo(ith_swo)=                                      &
     &      nprop_up_swo(ith_swo)+jprop_up
            naccp_swo(ith_swo)=                                         &
     &      naccp_swo(ith_swo)+jaccp
            naccp_up_swo(ith_swo)=                                      &
     &      naccp_up_swo(ith_swo)+jaccp_up
          enddo
        endif
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine move_pst
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
!   parallel simulated tempering (PST) moves
!
!     call get_rasf_ini
      if(jmvloop.eq.1.or.jmvloop.eq.2) then
        if(imvsequ.ge.1.and.imvsequ.le.nmvsequ(jmvloop)) then
          if(jrasf_ctl(imvsequ,jmvloop).eq.2) then
            errtag='000110.010: Randomzd SF NOT YET IMPLEMENTED in popul.moves'
            call err_term
          endif
        endif
      endif
!
      jo_pst=1
!
!
      inc_pst0=0
      inc_pst1=1
      if(jxthyst.eq.1) inc_yst=   npopst+1
      if(jxthyst.eq.2) inc_yst=2*(npopst+1)
      inc_ham=(mth_tot+1)*(ntfic+1)
      inc_amb=mth_tot*mit_amb
!
      mhtot_pst=0
!
!
      if(jtmp_en(imvsequ,jmvloop).eq.4) ihtot_pst_ini=0
      if(jmty(imvsequ,jmvloop).eq.1901) ihtot_pst_ini=0
!
!
      ihtot_pst=ihtot_pst_ini
!
      lhtot_ham=0
      lhtot_pst=0
!
      mthyst=-1
!
!   parallel simulated tempering (PST) moves "A": MetMC at
!   randomly chosen single temp. T_{i}
!
      if(                                                               &
     &jmty(imvsequ,jmvloop).ge.1000.and.                                &
     &jmty(imvsequ,jmvloop).le.1999                                     &
     &)then
        do ipop_pst=0,npopst
          if(jxc1st.eq.1) ipop_upd=npopst-ipop_pst
          if(jxc1st.eq.2) ipop_upd=ipop_pst
          if(jxc1st.eq.3) then
            ipop_upd=(npopst+1.d0)*randx()
            if(ipop_upd.gt.npopst) ipop_upd=npopst
            if(ipop_upd.lt.0) ipop_upd=0
          endif
          if(jmty(imvsequ,jmvloop).eq.1901) ipop_upd=ipop_pst
!
          fbeta_st=beta_st(ipop_upd)/beta_mc
!
          fstep_st=dabs(fbeta_st)**(-estpst)
          if(jtmp_en(imvsequ,jmvloop).eq.4) then
            ith_swo=mth_tot+41
            fstep_st=fstp_swo(ith_swo)
          endif
!
!   move 1 randomly selected species concentration variable
!
          if(jmty(imvsequ,jmvloop).eq.1001) then
            if(gomv(lhtot_pst,ihtot_pst_ini,inc_pst1)) then
              call store_st2th ! move_pst-01
              call move_cs1
              call store_th2st
!Db
      jclC=1001
!Fb
              call ck_chimin
              call ct_htotst
              do ifoxst=1,mfoxst
                call move_xst
              enddo
            endif
            goto 810
          endif
!
!   move "mth_spec" randomly selected species concentration
!   variables
!
          if(jmty(imvsequ,jmvloop).eq.1002) then
            do ith_cs=1,mth_spec
              if(gomv(lhtot_pst,ihtot_pst_ini,inc_pst1)) then
                call store_st2th ! move_pst-02
                call move_cs1
                call store_th2st
!Db
      jclC=1002
!Fb
                call ck_chimin
                call ct_htotst
                do ifoxst=1,mfoxst
                  call move_xst
                enddo
              endif
            enddo
            ith_cs=-1
            goto 810
          endif
!
!   move 1 randomly selected reaction rate variable
!
          if(jmty(imvsequ,jmvloop).eq.1003) then
            if(gomv(lhtot_pst,ihtot_pst_ini,inc_pst1)) then
              call store_st2th ! move_pst-03
              call move_rk1
              call store_th2st
!Db
      jclC=1003
!Fb
              call ck_chimin
              call ct_htotst
              do ifoxst=1,mfoxst
                call move_xst
              enddo
            endif
            goto 810
          endif
!
!   move "mth_reac" randomly selected reaction rate variables
!
          if(jmty(imvsequ,jmvloop).eq.1004) then
            do ith_rk=1,mth_reac
              if(gomv(lhtot_pst,ihtot_pst_ini,inc_pst1)) then
                call store_st2th ! move_pst-04
                call move_rk1
                call store_th2st
!Db
      jclC=1004
!Fb
                call ck_chimin
                call ct_htotst
                do ifoxst=1,mfoxst
                  call move_xst
                enddo
              endif
            enddo
            ith_rk=-1
            goto 810
          endif
!
!   move "mth_reac" randomly selected reaction rate and then
!   "mth_spec randomly selected" species concentration variables
!
          if(jmty(imvsequ,jmvloop).eq.1005) then
            do ith_rk=1,mth_reac
              if(gomv(lhtot_pst,ihtot_pst_ini,inc_pst1)) then
                call store_st2th ! move_pst-05
                call move_rk1
                call store_th2st
!Db
      jclC=1005
!Fb
                call ck_chimin
                call ct_htotst
                do ifoxst=1,mfoxst
                  call move_xst
                enddo
              endif
            enddo
            ith_rk=-1
!
            do ith_cs=1,mth_spec
              if(gomv(lhtot_pst,ihtot_pst_ini,inc_pst1)) then
                call store_st2th ! move_pst-06
                call move_cs1
                call store_th2st
!Db
      jclC=1015
!Fb
                call ck_chimin
                call ct_htotst
                do ifoxst=1,mfoxst
                  call move_xst
                enddo
              endif
            enddo
            ith_cs=-1
            goto 810
          endif
!
!   move "mth_spec" randomly selected species concentration variables
!   and then "mth_reac" randomly selected reaction rate variables
!
          if(jmty(imvsequ,jmvloop).eq.1006) then
            do ith_cs=1,mth_spec
              if(gomv(lhtot_pst,ihtot_pst_ini,inc_pst1)) then
                call store_st2th ! move_pst-07
                call move_cs1
                call store_th2st
!Db
      jclC=1006
!Fb
                call ck_chimin
                call ct_htotst
                do ifoxst=1,mfoxst
                  call move_xst
                enddo
              endif
            enddo
            ith_cs=-1
!
            do ith_rk=1,mth_reac
              if(gomv(lhtot_pst,ihtot_pst_ini,inc_pst1)) then
                call store_st2th  ! move_pst-08
                call move_rk1
                call store_th2st
!Db
      jclC=1016
!Fb
                call ck_chimin
                call ct_htotst
                do ifoxst=1,mfoxst
                  call move_xst
                enddo
              endif
            enddo
            ith_rk=-1
            goto 810
          endif
!
!   move 1 randomly selected species concentration
!   or reaction rate variable
!
          if(jmty(imvsequ,jmvloop).eq.1007) then
            if(gomv(lhtot_pst,ihtot_pst_ini,inc_pst1)) then
              r1=randx()
              r1=r1*mth_tot
              call store_st2th ! move_pst-09
              if(r1.lt.mth_spec) then
                call move_cs1
              else
                call move_rk1
              endif
              call store_th2st
!Db
      jclC=1007
!Fb
              call ck_chimin
              call ct_htotst
              do ifoxst=1,mfoxst
                call move_xst
              enddo
            endif
            goto 810
          endif
!
!   move "mth_tot" randomly selected species concentration
!   or reaction rate variables
!
          if(jmty(imvsequ,jmvloop).eq.1008) then
            do ith_cs=1,mth_tot
              if(gomv(lhtot_pst,ihtot_pst_ini,inc_pst1)) then
                r1=randx()
                r1=r1*mth_tot
                call store_st2th ! move_pst-10
                if(r1.lt.mth_spec) then
                  call move_cs1
                else
                  call move_rk1
                endif
                call store_th2st
!Db
      jclC=1008
!Fb
                call ck_chimin
                call ct_htotst
                do ifoxst=1,mfoxst
                  call move_xst
                enddo
              endif
            enddo
            ith_cs=-1
            goto 810
          endif
!
! DISABLED !! NOT USEFUL FOR POPULATION ?!?
!   move all "mth_tot" species concentration
!   and reaction rate variables by "Amoeba"
!   algorithm for "chisq"-minimization
!
!c        if(jmty(imvsequ,jmvloop).eq.1010) then
!c          if(gomv(lhtot_pst,ihtot_pst_ini,inc_amb)) then
!c            call store_st2th ! move_pst-11
!c            call move_amb
!c            call store_th2st
!c            call ck_chimin
!c            do ifoxst=1,mfoxst
!c              call move_xst
!c            enddo
!c          endif
!c          goto 810
!c        endif
!
!   move Theta globally along 1 randomly selected
!   unit vector direction in Theta-space
!
          if(jmty(imvsequ,jmvloop).eq.1011) then
            if(gomv(lhtot_pst,ihtot_pst_ini,inc_pst1)) then
              call store_st2th  ! move_pst-12
              call move_thu
              call store_th2st
!Db
      jclC=1011
!Fb
              call ck_chimin
              call ct_htotst
              do ifoxst=1,mfoxst
                call move_xst
              enddo
            endif
            goto 810
          endif
!
!   move Theta globally along "mth_tot" randomly selected
!   unit vector directions in Theta-space
!
          if(jmty(imvsequ,jmvloop).eq.1012) then
            do ith_rk=1,mth_tot
              if(gomv(lhtot_pst,ihtot_pst_ini,inc_pst1)) then
                call store_st2th ! move_pst-13
                call move_thu
                call store_th2st
!Db
      jclC=1012
!Fb
                call ck_chimin
                call ct_htotst
                do ifoxst=1,mfoxst
                  call move_xst
                enddo
              endif
            enddo
            ith_rk=-1
            goto 810
          endif
!
!   move all "mth_tot" species concentration
!   and reaction rate variables simultaneously
!   by fictitious Hamiltonian time evolution
!
          if(jmty(imvsequ,jmvloop).eq.1013) then
            if(gomv(lhtot_pst,ihtot_pst_ini,inc_ham)) then
              call store_st2th ! move_pst-14
              call move_ham
              call store_th2st
!Db
      jclC=1013
!Fb
              call ck_chimin
              do ict_ham=1,lhtot_ham
                call ct_htotst
              enddo
              do ifoxst=1,mfoxst
                call move_xst
              enddo
              ict_ham=-1
              lhtot_ham=0
            endif
            goto 810
          endif
!
!   move all "mth_tot" species concentration
!   and reaction rate variables simultaneously
!   by fictitious Hamiltonian time evolution,
!   executed "mth_tot" times
!
          if(jmty(imvsequ,jmvloop).eq.1014) then
            do ith_rk=1,mth_tot
              if(gomv(lhtot_pst,ihtot_pst_ini,inc_ham)) then
                call store_st2th ! move_pst-15
                call move_ham
                call store_th2st
!Db
      jclC=1014
!Fb
                call ck_chimin
                do ict_ham=1,lhtot_ham
                  call ct_htotst
                enddo
                do ifoxst=1,mfoxst
                  call move_xst
                enddo
                ict_ham=-1
                lhtot_ham=0
              endif
            enddo
            ith_rk=-1
            goto 810
          endif
!
!   (re-)evaluate energy "htot" for each Theta, sequentially;
!   to be executed after performing
!        "PGE mutation moves"
!   with energy-independent, externally specified acceptance ratios
!   using
!        jtmp_en=4
!
          if(jmty(imvsequ,jmvloop).eq.1901) then
            if(gomv(lhtot_pst,ihtot_pst_ini,inc_pst1)) then
              ipop_upd=ipop_pst
              if(jhoodst(iorst(ipop_upd)).gt.0) then
                call store_st2th ! move_pst-16
                call move_hst
                call store_th2st
                jhoodst(iorst(ipop_upd))=0
!Db
      jclC=1901
!Fb
                call ck_chimin
                call ct_htotst
!
                do ifoxst=1,mfoxst
                  call move_xst
                enddo
              endif
            endif
            goto 810
          endif
!
!
  810     continue
          ipop_upd=-1
          ipop_xch=-1
          fbeta_st=1.d0
          fstep_st=1.d0
        enddo
!
        ipop_pst=-1
        goto 820
      endif
!
!
!   parallel simulated tempering (PST) moves "B":
!   MetMC exchanges between randomly chosen T_{i} and T_{i+k}
!
      if(jmty(imvsequ,jmvloop).eq.2001) then
        if(gomv(lhtot_pst,ihtot_pst_ini,inc_pst0))                      &
     &  call move_xst
        goto 820
      endif
!
!
      if(jmty(imvsequ,jmvloop).eq.2002) then
        do ith_cs=0,npopst
          if(gomv(lhtot_pst,ihtot_pst_ini,inc_pst0))                    &
     &    call move_xst
        enddo
        ith_cs=-1
        goto 820
      endif
!
      if(jmty(imvsequ,jmvloop).eq.2011) then
        if(gomv(lhtot_pst,ihtot_pst_ini,inc_yst))                       &
     &  call move_yst
        goto 820
      endif
!
      if(jmty(imvsequ,jmvloop).eq.2012) then
        do ith_rk=1,mth_tot
          if(gomv(lhtot_pst,ihtot_pst_ini,inc_yst))                     &
     &    call move_yst
        enddo
        ith_rk=-1
        goto 820
      endif
!
      if(jmty(imvsequ,jmvloop).eq.2021) then
        if(gomv(lhtot_pst,ihtot_pst_ini,inc_yst))                       &
     &  call move_yst
        do ith_cs=0,npopst
          if(gomv(lhtot_pst,ihtot_pst_ini,inc_pst0))                    &
     &    call move_xst
        enddo
        ith_cs=-1
        goto 820
      endif
!
      if(jmty(imvsequ,jmvloop).eq.2022) then
        do ith_rk=1,mth_tot
          if(gomv(lhtot_pst,ihtot_pst_ini,inc_yst))                     &
     &    call move_yst
          do ith_cs=0,npopst
            if(gomv(lhtot_pst,ihtot_pst_ini,inc_pst0))                  &
     &      call move_xst
          enddo
          ith_cs=-1
        enddo
        ith_rk=-1
        goto 820
      endif
!
!
  820 continue
!
!
      call fin_st
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine move_pge
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!     popoulation genetic evolution (PGE) moves
!
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! A) How the fittest survive:
!----------------------------
!      jmty=3901, nmovr=1: move_fsu
!
!
! B) How the survivors replicate:
!--------------------------------
!      jmty=3902, nmovr=1: move_rsu
!
!
! C) How the off-spring mutate:
!------------------------------
!   Copy theta_ge (or sub-population) to theta_st;
!   then apply standard (or modified) PST moves to
!   mutate theta_st; then copy theta_st back to theta_ge,
!   as follows:
!
!   Swap Theta-population from "ge" to "st" for PST-moves:
!     jmty=3912, nmovr=1: move_ge2st
!
!   Then do PST moves by scheduling move_pst sequence with
!     jmty=1001, ...,2999;
!   attached (pmvtype<0) to last jmty=3912 move.
!   To mutate with energy-independent, externally specified
!   acceptance ratios, set the ensemble option
!     jtmp_en=4  <--> jtmp_mc=4nn w/ nn=jtmp_mv)
!   This will use the value of
!     temp_st*ftmp_imv
!   as the pre-determined acceptance ratio.
!   Then terminate PST sequence with
!     jmty=1901, nmovr=1
!
!   Swap Theta-population from "st" to "ge" after PST-moves:
!     jmty=3921, nmovr=1: move_st2ge
!
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
!     call get_rasf_ini
      if(jmvloop.eq.1.or.jmvloop.eq.2) then
        if(imvsequ.ge.1.and.imvsequ.le.nmvsequ(jmvloop)) then
          if(jrasf_ctl(imvsequ,jmvloop).eq.2) then
            errtag='000110.011: Randomzd SF NOT YET IMPLEMENTED in popul.moves'
            call err_term
          endif
        endif
      endif
!
      jo_pge=1
!
      mhtot_pge=0
!
      ihtot_pge=ihtot_pge_ini
!
!
      if(                                                               &
     &jmty(imvsequ,jmvloop).ge.3000.and.                                &
     &jmty(imvsequ,jmvloop).le.4999                                     &
     &)then
!
!   select sub-population of survivors
!
        if(jmty(imvsequ,jmvloop).eq.3901) then
          call move_fsu
          goto 810
        endif
!
!   replicate survivors to generate off-spring
!   replacing non-survivors
!
        if(jmty(imvsequ,jmvloop).eq.3902) then
          call move_rsu
          goto 810
        endif
!
!   swap (selected and multiplied) GE population in theta_ge
!   into ST arrays theta_st while saving prior theta_st
!
        if(jmty(imvsequ,jmvloop).eq.3912) then
          call move_ge2st
          goto 810
        endif
!
!   swap (mutated/transformed) GE population from theta_st
!   back into ST arrays theta_ge while restoring prior theta_st
!
        if(jmty(imvsequ,jmvloop).eq.3921) then
          call move_st2ge
          goto 810
        endif
!
!
  810   continue
      endif
!
!
      call fin_ge
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine move_fsu
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! selects the fittest to survive
!
! sort population in order of ascending energy htot_ge
!
!
!     call get_rasf_ini
      if(jmvloop.eq.1.or.jmvloop.eq.2) then
        if(imvsequ.ge.1.and.imvsequ.le.nmvsequ(jmvloop)) then
          if(jrasf_ctl(imvsequ,jmvloop).eq.2) then
            errtag='000110.012: Randomzd SF NOT YET IMPLEMENTED in popul.moves'
            call err_term
          endif
        endif
      endif
!
      call htord_ge
!
! select sub-population for "life or death" e.g.
! using Boltzmann acceptance factors w/ a finite
! "survival temperature" 1/beta_ge
!
!   ... set everyone's intial survival flags to "death"
      do ipop_fsu=0,npopge
        jsurv(ipop_fsu)=0
        isurv_pop(ipop_fsu)=-1
      enddo
!
!   ... find lowest-enery not yet surviving individual
      do isurv=0,nsurvge
        do ipop_fsu=0,npopge
          if(jsurv(ipop_fsu).eq.0) then
            htotge_min=htot_ge(iorge(ipop_fsu))
            goto 19
          endif
        enddo
   19   continue
!
!     ...construct probabilities for next survivor
        pfsusum(-1)=0.d0
        do ipop_fsu=0,npopge
          pfsusum(ipop_fsu)=pfsusum(ipop_fsu-1)
!
          if(jsurv(ipop_fsu).eq.0) then
            dhtot=beta_ge*(htot_ge(iorge(ipop_fsu))-htotge_min)
            if(dhtot.lt.16.d0)                                          &
     &      pfsusum(ipop_fsu)=pfsusum(ipop_fsu-1)+dexp(-dhtot)
          endif
        enddo
!
!     ... select next survivor
        ipop_surv(isurv)=-1
!
   20   continue
        r1=randx()*pfsusum(npopge)
        do ipop_fsu=0,npopge
          if(jsurv(ipop_fsu).eq.0) then
            if(r1.le.pfsusum(ipop_fsu)) then
              jsurv(ipop_fsu)=jsurv(ipop_fsu)+1
              isurv_pop(ipop_fsu)=isurv
              ipop_surv(isurv)=ipop_fsu
              goto 29
            endif
          endif
        enddo
   29   continue
        if(ipop_surv(isurv).eq.-1) goto 20
      enddo
!
!  Check jsurv(...), isurv_pop(...), ipop_surv(....)
      nsurvck1=-1
      nsurvck2=-1
!
      ipop_fsux=-1
      do ipop_fsu=0,npopge
        nsurvck1=nsurvck1+jsurv(ipop_fsu)
        if(isurv_pop(ipop_fsu).ge.0) nsurvck2=nsurvck2+1
        if(jsurv(ipop_fsu).gt.1) ipop_fsux=ipop_fsu
      enddo
!
      isurvx=-1
      do ipop_fsu1=0,npopge
        if(isurv_pop(ipop_fsu1).ge.0) then
          do ipop_fsu2=(ipop_fsu1+1),npopge
            if(isurv_pop(ipop_fsu1).eq.isurv_pop(ipop_fsu2)) then
              isurvx=isurv_pop(ipop_fsu1)
              goto 39
            endif
          enddo
        endif
      enddo
      ipop_fsu1=-1
      ipop_fsu2=-1
   39 continue
!
!
      if(                                                               &
     &nsurvck1.ne.nsurvge.or.                                           &
     &nsurvck2.ne.nsurvge.or.                                           &
     &ipop_fsux.ge.0.or.                                                &
     &ipop_fsu1.ge.0.or.                                                &
     &ipop_fsu2.ge.0.or.                                                &
     &isurvx.ge.0                                                       &
     &)then
            errtag='000111.000'
            call err_term
      endif
!
!
!
! sort survivor population and non-survivor population into
! contig. blocks, maintaining order of ascending energy htot_ge
! w/in each block
!
! jbsuge=1, 101:
!   sort survivors into 1st block, non-survivors into 2nd block;
!   surv:     ipop= 0         --> nsurvge,
!   non-surv: ipop= nsurvge+1 --> npopge
! jbsuge=2, 102:
!   sort survivors into 2nd block, non-survivors into 1st block;
!   non-surv: ipop= 0              --> npopge-nsurvge-1
!   surv:     ipop= npopge-nsurvge --> npopge
!
      if(jbsuge.ge.1) then
!     ... sort survivors
        do ipop_fsu1=0,npopge
          if(jsurv(ipop_fsu1).eq.1) then
            if(jbsuge.eq.1.or.jbsuge.eq.101)                            &
     &      ipop_blo=0
            if(jbsuge.eq.2.or.jbsuge.eq.102)                            &
     &      ipop_blo=npopge-nsurvge
!
            do ipop_fsu2=0,npopge
              if(                                                       &
     &        jsurv(ipop_fsu2).eq.1.and.                                &
     &        ipop_fsu2.lt.ipop_fsu1                                    &
     &        )                                                         &
     &        ipop_blo=ipop_blo+1
            enddo
!
            iorge9(ipop_blo)=iorge(ipop_fsu1)
            jsurv9(ipop_blo)=jsurv(ipop_fsu1)
            isurv9_pop(ipop_blo)=isurv_pop(ipop_fsu1)
!
            if(isurv9_pop(ipop_blo).ge.0)                               &
     &      ipop9_surv(isurv9_pop(ipop_blo))=ipop_blo
          endif
        enddo
!
!     ... sort non-survivors
        do ipop_fsu1=0,npopge
          if(jsurv(ipop_fsu1).eq.0) then
            if(jbsuge.eq.1.or.jbsuge.eq.101)                            &
     &      ipop_blo=nsurvge+1
            if(jbsuge.eq.2.or.jbsuge.eq.102)                            &
     &      ipop_blo=0
!
            do ipop_fsu2=0,npopge
              if(                                                       &
     &        jsurv(ipop_fsu2).eq.0.and.                                &
     &        ipop_fsu2.lt.ipop_fsu1                                    &
     &        )                                                         &
     &        ipop_blo=ipop_blo+1
            enddo
!
            iorge9(ipop_blo)=iorge(ipop_fsu1)
            jsurv9(ipop_blo)=jsurv(ipop_fsu1)
            isurv9_pop(ipop_blo)=isurv_pop(ipop_fsu1)
!
            if(isurv9_pop(ipop_blo).ge.0)                               &
     &      ipop9_surv(isurv9_pop(ipop_blo))=ipop_blo
          endif
        enddo
!
        do ipop_fsu=0,npopge
          iorge(ipop_fsu)=iorge9(ipop_fsu)
          jsurv(ipop_fsu)=jsurv9(ipop_fsu)
          isurv_pop(ipop_fsu)=isurv9_pop(ipop_fsu)
        enddo
!
        do isurv=0,nsurvge
          ipop_surv(isurv)=ipop9_surv(isurv)
        enddo
!
        do ipop_fsu=0,npopge
          ipop_orge(iorge(ipop_fsu))=ipop
        enddo
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine move_rsu
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
! replication of the survivors
!
! replicate randomly selected survivor (ancestor)
! to generate off-spring to replace non-survivor,
! subject to following conditions on allowed no.
! of off-spring per ancestor:
!
! ...jrsuge=1: "random allocation of allowed no. of off-spring";
!     ancestor selected for replication independently of previous
!     selections and w/ equal probability from full pool of
!     survivors, w/out limits on max. or min. number
!     of offspring allowed for each ancestral survivor.
!
! ...jrsuge=2: "equitable allocation of allowed no. of off-spring";
!     ancestor selected for replication only from restricted pool
!     of those survivors having lowest number of off-spring
!     so far, i.e. subject to constraint that each ancestor's
!     number of off-spring cannot exceed that of any other
!     ancestor by more than 1.
!
!
!     call get_rasf_ini
      if(jmvloop.eq.1.or.jmvloop.eq.2) then
        if(imvsequ.ge.1.and.imvsequ.le.nmvsequ(jmvloop)) then
          if(jrasf_ctl(imvsequ,jmvloop).eq.2) then
            errtag='000111.001: Randomzd SF NOT YET IMPLEMENTED in popul.moves'
            call err_term
          endif
        endif
      endif
!
      do ipop_rsu=0,npopge
        if(jsurv(ipop_rsu).eq.0) then
   10     continue
          r1=randx()*(nsurvge+1.d0)
          isurv=r1
          if(isurv.gt.nsurvge) isurv=nsurvge
          ipop_ancs=ipop_surv(isurv)
!
          if(jrsuge.eq.1) goto 20
          if(jrsuge.eq.2) then
            do ipop_ancs0=0,npopge
              if(                                                       &
     &        jsurv(ipop_ancs0).gt.0.and.                               &
     &        jsurv(ipop_ancs0).lt.jsurv(ipop_ancs))                    &
     &        goto 10
            enddo
          endif
!
   20     continue
          jsurv(ipop_ancs)=jsurv(ipop_ancs)+1
          isurv_pop(ipop_rsu)=isurv
!
          htot_ge(iorge(ipop_rsu))=htot_ge(iorge(ipop_ancs))
          chisq_ge(iorge(ipop_rsu))=chisq_ge(iorge(ipop_ancs))
!
          do ith=1,mth_tot
            theta_ge(ith,iorge(ipop_rsu))=                              &
     &      theta_ge(ith,iorge(ipop_ancs))
          enddo
        endif
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine move_ge2st
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! save original PST population to theta_st0
! copy PGE population theta_ge to PST theta_st,
! to do mutations on theta_st
!
!
!     call get_rasf_ini
      if(jmvloop.eq.1.or.jmvloop.eq.2) then
        if(imvsequ.ge.1.and.imvsequ.le.nmvsequ(jmvloop)) then
          if(jrasf_ctl(imvsequ,jmvloop).eq.2) then
            errtag='000111.002: Randomzd SF NOT YET IMPLEMENTED in popul.moves'
            call err_term
          endif
        endif
      endif
!
      do ipop_swp=0,npopst_x
        htot_st0(ipop_swp)=htot_st(ipop_swp)
        chisq_st0(ipop_swp)=chisq_st(ipop_swp)
        do ith=1,mth_tot
          theta_st0(ith,ipop_swp)=theta_st(ith,ipop_swp)
        enddo
      enddo
!
      do ipop_swp=0,npopge
        jhoodst(ipop_swp)=0
!
        htot_st(ipop_swp)=htot_ge(iorge(ipop_swp))
        chisq_st(ipop_swp)=chisq_ge(iorge(ipop_swp))
        do ith=1,mth_tot
          theta_st(ith,ipop_swp)=theta_ge(ith,iorge(ipop_swp))
        enddo
      enddo
!
!
!c    do ipop_swp=0,npopst_x
!c      htot_ge(ipop_swp)=htot_st0(ipop_swp)
!c      chisq_ge(ipop_swp)=chisq_st0(ipop_swp)
!c      do ith=1,mth_tot
!c        theta_ge(ith,ipop_swp)=theta_st0(ith,ipop_swp)
!c      enddo
!c    enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine move_st2ge
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! copy PST population theta_st to PGE theta_ge,
! after mutations on theta_st
! restore original PST population from theta_st0
!
!
!     call get_rasf_ini
      if(jmvloop.eq.1.or.jmvloop.eq.2) then
        if(imvsequ.ge.1.and.imvsequ.le.nmvsequ(jmvloop)) then
          if(jrasf_ctl(imvsequ,jmvloop).eq.2) then
            errtag='000111.003: Randomzd SF NOT YET IMPLEMENTED in popul.moves'
            call err_term
          endif
        endif
      endif
!
!c    do ipop_swp=0,npopst_x
!c      htot_st0(ipop_swp)=htot_ge(ipop_swp)
!c      chisq_st0(ipop_swp)=chisq_ge(ipop_swp)
!c      do ith=1,mth_tot
!c        theta_st0(ith,ipop_swp)=theta_ge(ith,ipop_swp)
!c      enddo
!c    enddo
!
!
      do ipop_swp=0,npopge
        htot_ge(iorge(ipop_swp))=htot_st(ipop_swp)
        chisq_ge(iorge(ipop_swp))=chisq_st(ipop_swp)
        do ith=1,mth_tot
          theta_ge(ith,iorge(ipop_swp))=theta_st(ith,ipop_swp)
        enddo
      enddo
!
!
      do ipop_swp=0,npopst_x
        htot_st(ipop_swp)=htot_st0(ipop_swp)
        chisq_st(ipop_swp)=chisq_st0(ipop_swp)
        do ith=1,mth_tot
          theta_st(ith,ipop_swp)=theta_st0(ith,ipop_swp)
        enddo
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine fxch12_st
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! generate pair from Theta-population for pair exchange moves
! "move_xst" and "move_yst"
!
!     ...select 1st member of Theta pair for exchange
        if(jxc1st.eq.1) ipop_y(1)=npopst-ixst
        if(jxc1st.eq.2) ipop_y(1)=ixst
        if(jxc1st.eq.3) then
          ipop_y(1)=(npopst+1.d0)*randx()
          if(ipop_y(1).gt.npopst) ipop_y(1)=npopst
          if(ipop_y(1).lt.0) ipop_y(1)=0
        endif
!
!     ...select 2nd member of Theta pair for exchange
        ireyst=0
    5   continue
!
        if(jxc2st.eq.0) then
          ipop_y(2)=ipop_y(1)+1
          goto 30
        endif
!
        if(jxc2st.eq.1) then
          ireyst=ireyst+1
          kxst=dabs(althyst)+1.00001d0
          if(ireyst.gt.2) kxst=kxst+ireyst-2
          adum1=randx()
          if(adum1.lt.0.5d0) kxst=-kxst
          ipop_y(2)=ipop_y(1)+kxst
          goto 30
        endif
!
        if(jxc2st.eq.2) then
          kxst=randx()*(dabs(althyst)+1.d0)
          kxst=kxst+1
          adum1=randx()
          if(adum1.lt.0.5d0) kxst=-kxst
          ipop_y(2)=ipop_y(1)+kxst
          goto 30
        endif
!
        if(jxc2st.eq.3) then
   20     continue
          ipop_y(2)=(npopst+1.d0)*randx()
          if(ipop_y(2).gt.npopst) ipop_y(2)=npopst
          if(ipop_y(2).lt.0) ipop_y(2)=0
          if(ipop_y(2).eq.ipop_y(1)) goto 20
          goto 35
        endif
!
        if(jxc2st.eq.12) then
          kxst=randx()*(dabs(althyst*fstp_swo_xst)+1.d0)
          kxst=kxst+1
          adum1=randx()
          if(adum1.lt.0.5d0) kxst=-kxst
          ipop_y(2)=ipop_y(1)+kxst
          goto 30
        endif
!
!     ...reflect 2nd Theta pair member into [0,npopst]-interval
!        if needed:
   30   continue
        if(ipop_y(2).lt.0) then
          ipop_y(2)=-ipop_y(2)
          goto 30
        endif
        if(ipop_y(2).gt.npopst) then
          ipop_y(2)=2*npopst-ipop_y(2)
          goto 30
        endif
        if(ipop_y(2).eq.ipop_y(1)) goto 5
!
   35   continue
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine accp_move
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
!   accept or reject proposed move
!   acc. to ensemble probability Q(\Theta):
!
      rmet=randx()
!
      if(jaccp.eq.-1) then
        jaccp=0
        jaccp_up=0
        jprop_up=0
        return
      endif
!
!   0 =< jtmp_mc < 100
!   Q(\Theta)= const * exp(-\chi^2(\Theta)/T_{MC})
!
      if(jtmp_en(imvsequ,jmvloop).eq.0) then
        jaccp=1
!
        if(htot_cut.gt.0.d0.and.htot_th.gt.htot_cut) then
          jaccp=0
          goto 190
        endif
!
        dhtot=htot_th-htot_th0
        if(dhtot.le.0.d0) goto 190
!
        rweight=dhtot*beta_mc*fbeta_st/ftmp_imv
        if(rweight.gt.16.d0) then
          jaccp=0
          goto 190
        endif
!
        if(dhtot.gt.0) then
          rweight=dexp(-rweight)
!V091029:
!!        rmet=randx()
!:V091029
          if(rmet.gt.rweight) jaccp=0
        endif
        goto 190
      endif
!
! 100 =< jtmp_mc < 200
!   Q(\Theta)= const /(1+\chi^2(\Theta)/(M_{xpt,in}T_{MC}))
!
      if(jtmp_en(imvsequ,jmvloop).eq.1) then
        jaccp=1
!
        if(htot_cut.gt.0.d0.and.htot_th.gt.htot_cut) then
          jaccp=0
          goto 190
        endif
!
        dhtot=htot_th-htot_th0
        if(dhtot.le.0.d0) goto 190
!
        rweight=                                                        &
     &   (1.d0+htot_th0*beta_mc*fbeta_st/(ftmp_imv*mdtin))              &
     &  /(1.d0+htot_th *beta_mc*fbeta_st/(ftmp_imv*mdtin))
!
        if(rweight.lt.1.d0) then
!V091029:
!!        rmet=randx()
!:V091029
          if(rmet.gt.rweight) jaccp=0
        endif
        goto 190
      endif
!
!
! 200 =< jtmp_mc < 300
!   Q(\Theta)= const /(1+dlog(1+\chi^2(\Theta)/(M_{xpt,in}T_{MC})))
!
      if(jtmp_en(imvsequ,jmvloop).eq.2) then
        jaccp=1
!
        if(htot_cut.gt.0.d0.and.htot_th.gt.htot_cut) then
          jaccp=0
          goto 190
        endif
!
        dhtot=htot_th-htot_th0
        if(dhtot.le.0.d0) goto 190
!
        rweight=                                                        &
     &   (1.d0+dlog(1.d0+htot_th0*beta_mc*fbeta_st/(ftmp_imv*mdtin)))   &
     &  /(1.d0+dlog(1.d0+htot_th *beta_mc*fbeta_st/(ftmp_imv*mdtin)))
!
        if(rweight.lt.1.d0) then
!V091029:
!!        rmet=randx()
!:V091029
          if(rmet.gt.rweight) jaccp=0
        endif
        goto 190
      endif
!
!
! 300 =< jtmp_mc < 400
!   WL algorithm: Q(\Theta)= const /g_dos(E(\Theta))
!
      if(jtmp_en(imvsequ,jmvloop).eq.3) then
        jaccp=1
        if(htot_cut.gt.0.d0.and.htot_th.gt.htot_cut) then
          jaccp=0
          goto 190
        endif
!
        enrg_dos=htot_th
        call get_dos
        aln_dos_th=aln_dos
!
        enrg_dos=htot_th0
        call get_dos
        aln_dos_th0=aln_dos
!
        dln_dos=aln_dos_th-aln_dos_th0
!
        if(dln_dos.le.0.d0) goto 190
!
        rweight=dln_dos
        if(rweight.gt.16.d0) then
          jaccp=0
          goto 190
        endif
!
        if(dln_dos.gt.0) then
          rweight=dexp(-dln_dos)
!V091029:
!!        rmet=randx()
!:V091029
          if(rmet.gt.rweight) jaccp=0
        endif
        goto 190
      endif
!
!
!   400 =< jtmp_mc < 500
!   energy-independent, ext. controlled acceptance ratio,
!   to be used mainly for PGE moves
!
      if(jtmp_en(imvsequ,jmvloop).eq.4) then
        jaccp=1
!
        rweight=ftmp_imv/(beta_mc*fbeta_st)
!
!V091029:
!!      rmet=randx()
!:V091029
        if(rmet.gt.rweight) jaccp=0
!
        jaccp_up=0
        jprop_up=0
!
        if(                                                             &
     &     jmty(imvsequ,jmvloop).ge.1000.and.                           &
     &     jmty(imvsequ,jmvloop).le.2999                                &
     &  )then
          jhoodst(iorst(ipop_upd))=                                     &
     &    jhoodst(iorst(ipop_upd))+jaccp
        endif
!
        goto 195
      endif
!
!
  190 continue
      if(htot_th.gt.htot_th0) then
        jprop_up=1
        jaccp_up=jaccp
      else
        jprop_up=0
        jaccp_up=0
      endif
!
!
  195 continue
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine get_dos
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!  calculates log of density of states and resident energy intervall
!  for given input energy "enrg_dos"; for use in WL algorithm
!
      if(enrg_ie(neintv).le.enrg_dos) then
        ienrg_dos=neintv+1
        aln_dos=aln_dos_ie(ienrg_dos)
        goto 90
      endif
!
      if(enrg_ie(0).gt.enrg_dos) then
        ienrg_dos=0
        aln_dos=aln_dos_ie(ienrg_dos)
        goto 90
      endif
!
      do ieintv=1,neintv
        if(enrg_ie(ieintv-1).le.enrg_dos .and.                          &
     &     enrg_ie(ieintv).gt.enrg_dos)                                 &
     &  then
          ienrg_dos=ieintv
          aln_dos=aln_dos_ie(ienrg_dos)
          goto 90
        endif
      enddo
!
   90 continue
      if(jnm_dos.eq.2) aln_dos=aln_dos-aln_wintv_ie(ienrg_dos)
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine accu_dos
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!  increments log of density of states and histogram for input
!  energy "enrg_dos"; for use in WL algorithm
!
      nacc_dos=nacc_dos+1
!
      enrg_dos=htot_th
      call get_dos
      aln_dos_ie(ienrg_dos)=aln_dos_ie(ienrg_dos)+alnf_dos
      hist_ie(ienrg_dos)=hist_ie(ienrg_dos)+1.d0
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine zero_dos
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
!  zero WL DOS and visitation flags
!
      do ieintv=0,neintv+1
        aln_dos_ie(ieintv)=0.d0
        jei_vis(ieintv)=0
      enddo
      nacc_dos=0
      it_dos=1
      mck_dos=0
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine zero_his
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!  zero WL histogram
!
      do ieintv=0,neintv+1
        hist_ie(ieintv)=0.d0
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine zero_wlit
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!  zero iteration counters, convergence flags
!
      jcv_his=0
      jcv_dos=0
      mo_dos=0
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ckcvg_dos
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! check histogram flatness, including only energies inside
! predetermined energy intervall (i.e. excl. ieintv=0, neintv+1),
! check convergence of flatness,
! if conv., update alnf_dos and zero histogram
! output aln_dos_ie and hist_ie
!
      jcv_his=0
!
      mo_dos=mo_dos+1
      if(mo_dos.ge.no_dos) mo_dos=0
!
      mck_dos=mck_dos+1
      if(mck_dos.ge.nck_dos) mck_dos=0
!
      if(mck_dos.gt.0.and.mo_dos.gt.0)                                  &
     & goto 190
!
      a1_his=0.d0
      a2_his=0.d0
      a1ln_his=0.d0
      a2ln_his=0.d0
!
      hist_eps=1.d0
      if(jnm_dos.eq.2) hist_eps=hist_eps/wintv_min
!
      hist_min=1000.d0*nck_dos
      if(jnm_dos.eq.2) hist_min=hist_min/wintv_min
      hist_max=0.d0
!
      do ieintv=1,neintv
        hist0=hist_ie(ieintv)
        if(jnm_dos.eq.2) hist0=hist0/wintv_ie(ieintv)
!
        if(hist0.lt.hist_min) hist_min=hist0
        if(hist0.gt.hist_max) hist_max=hist0
!
        a1ln_his=a1ln_his+dlog((hist0/hist_eps)+1.d0)
        a2ln_his=a2ln_his+dlog((hist0/hist_eps)+1.d0)**2
!
        a1_his=a1_his+hist0
        a2_his=a2_his+hist0**2
      enddo
!
      nei_vis=0
      do ieintv=0,neintv+1
        jei_vis(ieintv)=0
        if(aln_dos_ie(ieintv).gt.0.d0) then
          jei_vis(ieintv)=1
        endif
        nei_vis=nei_vis+jei_vis(ieintv)
      enddo
!
      htot_ei_min=enrg_ie(0)
      iei_min=-1
      do ieintv=0,neintv
        if(jei_vis(ieintv+1).eq.1) then
          htot_ei_min=enrg_ie(ieintv)
          iei_min=ieintv
          goto 10
        endif
      enddo
   10 continue
!
!
      htot_ei_max=enrg_ie(neintv)
      iei_max=neintv+1
      do ieintv=0,neintv
        if(jei_vis(neintv-ieintv).eq.1) then
          htot_ei_max=enrg_ie(neintv-ieintv)
          iei_max=neintv-ieintv
          goto 20
        endif
      enddo
   20 continue
!
!
      do ieintv=0,neintv+1
        hist_ie_o(ieintv)=hist_ie(ieintv)
        aln_dos_ie_o(ieintv)=aln_dos_ie(ieintv)
      enddo
!
      alnf_dos_o=alnf_dos
      it_dos_o=it_dos
!
      a1_his=a1_his/(1.d0*neintv)
      a2_his=a2_his/(1.d0*neintv)
      d_his=dsqrt(dabs(a2_his-a1_his**2))/(a1_his+1.d-10)
!
      a1ln_his=a1ln_his/(1.d0*neintv)
      a2ln_his=a2ln_his/(1.d0*neintv)
      dln_his=dsqrt(dabs(a2ln_his-a1ln_his**2))/(dabs(a1ln_his)+1.d-10)
!
      wpm_his=(hist_max-hist_min)/(a1_his+1.d-10)
      wpmln_his=(dlog((hist_max/hist_eps)+1.d0)                         &
     &          -dlog((hist_min/hist_eps)+1.d0))/(a1ln_his+1.d-10)
!
      wam_his=(a1_his-hist_min)/(a1_his+1.d-10)
      wamln_his=(a1ln_his                                               &
     &          -dlog((hist_min/hist_eps)+1.d0))/(a1ln_his+1.d-10)
!
!
      if(mck_dos.eq.0) then
        if(jck_his.eq.0) jcv_his=1
!
        if(jck_his.eq.1.and.d_his.lt.ck_his) jcv_his=1
        if(jck_his.eq.2.and.dln_his.lt.ck_his) jcv_his=1
!
        if(jck_his.eq.11.and.wpm_his.lt.ck_his) jcv_his=1
        if(jck_his.eq.12.and.wpmln_his.lt.ck_his) jcv_his=1
!
        if(jck_his.eq.21.and.wam_his.lt.ck_his) jcv_his=1
        if(jck_his.eq.22.and.wamln_his.lt.ck_his) jcv_his=1
!
        if(jcv_his.eq.1) then
          it_dos=it_dos+1
          alnf_dos=alnf_dos/pf_dos
!
          if(it_dos.gt.nit_dos) jcv_dos=-1
          if(alnf_dos.lt.alnf_dos1) jcv_dos=1
!
          do ieintv=0,neintv+1
            hist_ie(ieintv)=0.d0
          enddo
        endif
      endif
!
  190 continue
      if(jtmp_en(imvsequ,jmvloop).ne.3) then
        jcv_dos=0
      endif
!
      if(jcv_dos.ne.0.or.jcv_his.eq.1                                   &
     &.or.mck_dos.eq.0.or.mo_dos.eq.0)                                  &
     &call odat_dos
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine get_pi
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
! (re-)set optimal fict. time stepwidth
      if(jdtfic.eq.1) dtfic_swo=dtfic
!
      if(mpr_swo.gt.0.and.jdtfic.eq.2) then
        dtfic_swo=dtfic*fstp_swo(mth_tot+11)*fstep_st
      endif
      dtfic_swoh=0.5d0*dtfic_swo
!
!
!   set fict. inverse masses and max. fict. forces
      do ith_ham=1,mth_tot
        if(jmsfic.eq.0) omas_ham(ith_ham)=1.d0
!
        if(jmsfic.eq.1.or.jmsfic.eq.2) then
          omas_ham(ith_ham)=0.5d0*gamma_ms                              &
     &    *((0.25d0*step_ham(ith_ham)*fstp_imv/dtfic)**2)
!
          if(mpr_swo.gt.0.and.jmsfic.eq.2) then
            omas_ham(ith_ham)=omas_ham(ith_ham)                         &
     &      *((fstp_swo(ith_ham)*fstep_st)**2)
          endif
        endif
!
        if( jfxfic.eq.1  .or.jfxfic.eq.2  .or.jfxfic.eq.3               &
     &  .or.jfxfic.eq.101.or.jfxfic.eq.102.or.jfxfic.eq.103) then
          force_th=                                                     &
     &    gamma_fx/(dsqrt(0.5d0*omas_ham(ith_ham)))
        endif
!
        if(mpr_swo.le.0.or.jfxfic.eq.1.or.jfxfic.eq.101) then
          force_max(ith_ham)=force_th/dtfic_swo
        endif
!
        if(mpr_swo.gt.0.and.(jfxfic.eq.2.or.jfxfic.eq.102)) then
          force_max(ith_ham)=(force_th/dtfic)                           &
     &                      *fstp_swo(mth_tot+12)*fstep_st
        endif
!
        if(mpr_swo.gt.0.and.(jfxfic.eq.3.or.jfxfic.eq.103)) then
          force_max(ith_ham)=(force_th/dtfic_swo)                       &
     &                      *fstp_swo(mth_tot+12)*fstep_st
        endif
!
!      Note: Step width optimization (SWO) controls:
!      (A) mpr_swo>0:
!      ==============
!      For jfxfic=2 or 102, "force_max" is modified  only by the factor
!           fstp_swo(mth_tot+12)
!      regardless of "jdtfic"
!
!      If jdtfic=2:
!      "dtfic_swo" is modified by "fstp_swo(mth_tot+11)"; hence:
!        For jfxfic=1 or 101, "force_max" is modified by the factor
!           1/fstp_swo(mth_tot+11)
!        For jfxfic=3 or 103, "force_max" is modified by the ratio
!           fstp_swo(mth_tot+12)/fstp_swo(mth_tot+11)
!
!      If jdtfic=1:
!      "dtfic_swo" is not modified by "fstp_swo(mth_tot+11)"; hence:
!        For jfxfic=1 or 101, "force_max" is un-modified, =modified by
!           1
!        For jfxfic=3 or 103, "force_max" is modified by the factor
!           fstp_swo(mth_tot+12)
!
!      (B) mpr_swo=<0:
!      ==============
!      All results same as for jfxfic=1 and jdtfic=1, no SWO modifiers
!
      enddo
      ith_ham=-1
!
!   initialize conjugate momenta with Gaussian
!   random numbers of (1/e)-width=sqrt(2*mass)
!
      ith_ham=0
      do ith_half=1,mth_tot
        r1=randx()
        r2=randx()
        rgauss=dsqrt(2.d0*dabs(dlog(dabs(r1)+1.d-20)))
!
        ith_ham=ith_ham+1
        if(ith_ham.gt.mth_tot) goto 110
        pi_ham(ith_ham,0)=rgauss*dcos(pi2*r2)                           &
     &                   /dsqrt(omas_ham(ith_ham))
!
        ith_ham=ith_ham+1
        if(ith_ham.gt.mth_tot) goto 110
        pi_ham(ith_ham,0)=rgauss*dsin(pi2*r2)                           &
     &                   /dsqrt(omas_ham(ith_ham))
      enddo
  110 continue
      ith_ham=-1
!
!
!   calculate initial kinetic energy
      ekin_th0=0.d0
      do ith_ham=1,mth_tot
        ekin_th0=ekin_th0                                               &
     &  +omas_ham(ith_ham)*pi_ham(ith_ham,0)**2
      enddo
      ith_ham=-1
!
      ekin_th0=ekin_th0*0.5d0
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine test_hamevl
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! test Ham. time evol. by backwards propagation
! w/ reversed momenta
!
      do ith_ham=1,mth_tot
        theta_ini(ith_ham)=theta_ham(ith_ham,0)
        theta_fin(ith_ham)=theta_ham(ith_ham,ntfic)
!
        pi_ini(ith_ham)=pi_ham(ith_ham,0)
        pi_fin(ith_ham)=pi_ham(ith_ham,ntfic+1)
      enddo
      ith_ham=-1
!
!
      do ith_ham=1,mth_tot
        theta_ham(ith_ham,0)=theta_fin(ith_ham)
        pi_ham(ith_ham,0)=-pi_fin(ith_ham)
      enddo
      ith_ham=-1
!
      itfic=0
      call pass_thham
      call get_force ! test_hamevl-01
      call get_hevl ! test_hamevl-01
!
!
      err_pi=0.d0
      err_th=0.d0
      devl_th=0.d0
      do ith_ham=1,mth_tot
        err_pi=err_pi                                                   &
     &        +(pi_ham(ith_ham,ntfic+1)+pi_ini(ith_ham))**2
        err_th=err_th                                                   &
     &        +((theta_ham(ith_ham,ntfic)-theta_ini(ith_ham))           &
     &         /(theta_fin(ith_ham)+theta_ini(ith_ham))                 &
     &         )**2
        devl_th=devl_th                                                 &
     &        +4.d0*((theta_fin(ith_ham)-theta_ini(ith_ham))            &
     &              /(theta_fin(ith_ham)+theta_ini(ith_ham))            &
     &              )**2
      enddo
      ith_ham=-1
!
!
      err_pi=dsqrt(err_pi)
      err_th=dsqrt(err_th)
      devl_th=dsqrt(devl_th)
!
      do ith_ham=1,mth_tot
        theta_ham(ith_ham,ntfic)=theta_fin(ith_ham)
        pi_ham(ith_ham,ntfic+1)=pi_fin(ith_ham)
!
        theta_ham(ith_ham,0)=theta_ini(ith_ham)
        pi_ham(ith_ham,0)=pi_ini(ith_ham)
      enddo
      ith_ham=-1
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine get_hevl
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!   Hamiltonian leap frog time evolution of
!   "theta_ham" and "pi_ham" to propose new \Theta
!
      if(jmvloop.eq.1.or.jmvloop.eq.2) then
        do ith_ham=1,mth_tot
          aforce_propi(ith_ham,jmvloop)=                                &
     &    aforce_propi(ith_ham,jmvloop)                                 &
     &    +(force_ham(ith_ham)**2)                                      &
     &    *(0.5d0*omas_ham(ith_ham)*(dtfic_swo**2))
        enddo
        ith_ham=-1
        htot_ham_propi(jmvloop)=htot_ham_propi(jmvloop)+htot_ham
        nprop_ham_ini(jmvloop)=nprop_ham_ini(jmvloop)+1
      endif
!
!   ...initial half-step on "pi_ham":
!
!      Note: Must call "get_force" to calculate forces for the
!      initial Theta-configuration  b e f o r e  calling "get_hevl"
!
      do ith_ham=1,mth_tot
        pi_ham(ith_ham,1)=                                              &
     &  pi_ham(ith_ham,0)+dtfic_swoh*force_ham(ith_ham)
      enddo
      ith_ham=-1
!
!   ... full steps on "theta_ham" and "pi_ham",
!   followed by final half-step on "pi_ham"
!
      do itfic=1,ntfic
!
!     evolve Hamiltonian coordinates "theta_ham"
        do ith_ham=1,mth_tot
          if(jct_ham(ith_ham).eq.0) then
            theta_ham(ith_ham,itfic)=                                   &
     &      theta_ham(ith_ham,itfic-1)                                  &
     &      +dtfic_swo*pi_ham(ith_ham,itfic)*omas_ham(ith_ham)
          endif
          if(jct_ham(ith_ham).eq.1) then
            theta_ham(ith_ham,itfic)=                                   &
     &      dlog(theta_ham(ith_ham,itfic-1))+                           &
     &      dtfic_swo*pi_ham(ith_ham,itfic)*omas_ham(ith_ham)
          endif
        enddo
        ith_ham=-1
!
!     enforce lo- and hi-Theta boundaries
        do ith_ham=1,mth_tot
!        if trajectory runs out of bounds ...
          if(theta_ham(ith_ham,itfic).gt.ahi_ham(ith_ham)               &
     &    .or.theta_ham(ith_ham,itfic).lt.alo_ham(ith_ham))             &
     &    then
!          ...either reject the trajectory:
            if(jbcfic.eq.0) then
              jaccp=-1 ! get_hevl-01, jbc==0
              goto 99
            endif
!          ...or "bounce off the wall" (multiple bounces allowed):
            if(jbcfic.eq.1) then
              call refl_th(                                             &
     &                     theta_ham(ith_ham,itfic)                     &
     &                    ,ahi_ham(ith_ham)                             &
     &                    ,alo_ham(ith_ham)                             &
     &                    ,isign_pi)
!           ... and reverse conj. momentum, if needed:
              pi_ham(ith_ham,itfic)=isign_pi                            &
     &                             *pi_ham(ith_ham,itfic)
            endif
          endif
!
          if(jct_ham(ith_ham).eq.1)                                     &
     &    theta_ham(ith_ham,itfic)=                                     &
     &    dexp(theta_ham(ith_ham,itfic))
        enddo
        ith_ham=-1
!
!     calculate forces
        call pass_thham
        call get_force ! get_hevl-01
!
!     evolve Hamiltonian conjugate momenta "pi_ham"
        if(itfic.lt.ntfic) then
          do ith_ham=1,mth_tot
            pi_ham(ith_ham,itfic+1)=                                    &
     &      pi_ham(ith_ham,itfic)+dtfic_swo*force_ham(ith_ham)
          enddo
          ith_ham=-1
        else
          do ith_ham=1,mth_tot
            pi_ham(ith_ham,itfic+1)=                                    &
     &      pi_ham(ith_ham,itfic)+dtfic_swoh*force_ham(ith_ham)
          enddo
          ith_ham=-1
!
          if(jmvloop.eq.1.or.jmvloop.eq.2) then
            do ith_ham=1,mth_tot
              aforce_propf(ith_ham,jmvloop)=                            &
     &        aforce_propf(ith_ham,jmvloop)                             &
     &        +(force_ham(ith_ham)**2)                                  &
     &        *(0.5d0*omas_ham(ith_ham)*(dtfic_swo**2))
!
              if(jct_ham(ith_ham).eq.0) then
                adhevl_propf(ith_ham,jmvloop)=                          &
     &          adhevl_propf(ith_ham,jmvloop)                           &
     &          +(theta_ham(ith_ham,ntfic)-theta_ham(ith_ham,0))**2     &
     &          /(step_ham(ith_ham)*fstp_imv                            &
     &           *fstp_swo(ith_ham)*fstep_st)**2
              endif
!
              if(jct_ham(ith_ham).eq.1) then
                adhevl_propf(ith_ham,jmvloop)=                          &
     &          adhevl_propf(ith_ham,jmvloop)                           &
     &          +dlog(theta_ham(ith_ham,ntfic)/theta_ham(ith_ham,0))**2 &
     &          /(step_ham(ith_ham)*fstp_imv                            &
     &           *fstp_swo(ith_ham)*fstep_st)**2
              endif
            enddo
            ith_ham=-1
!
            htot_ham_propf(jmvloop)=htot_ham_propf(jmvloop)+htot_ham
            nprop_ham_fin(jmvloop)=nprop_ham_fin(jmvloop)+1
          endif
        endif
      enddo
!
!   calculate final kinetic energy
      ekin_th=0.d0
      do ith_ham=1,mth_tot
        ekin_th=ekin_th                                                 &
     &  +omas_ham(ith_ham)*pi_ham(ith_ham,ntfic+1)**2
      enddo
      ith_ham=-1
!
      ekin_th=ekin_th*0.5d0
!
   99 continue
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine get_force
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
      if(itfic.eq.-1) then
        htot_ham=htot_th0
      endif
!
      if(itfic.ge.0) then
        jDB_get_chi=17
        call get_chi ! get_force-01
!
!DRLIM190524-2244:
        if(mlimdrv.ge.1) jaccp=-1
!X      if(  mlimdrv.ge.1) then ! get_force-01
!X        errtag='000121.002: # rate fct calls > nlim_drv, during fict. Hamiltonian'
!X        call err_term
!X      endif
!X      May evolve a Theta with mlimdrv>=1 here.
!X      Need to implement better handling for that case!! 
!:DRLIM190524-2244
!
        call store_chi_th
!Db
      jclC=31
!Fb
        call ck_chimin
        lhtot_ham=lhtot_ham+1
!
        htot_ham=htot_th
      endif
!
      do ith_ham=1,mth_tot
        if(ith_ham.le.mth_spec) then
          ith_upd=ith_ham
          ispec_upd=ispec_th(ith_upd)
          ipm_upd=ipmspec_th(ith_upd)
!
          theta0=cspec(ispec_upd,ipm_upd)
!
          fderiv_th=2.d0
          if(dderiv_th.le.-1.d0)                                        &
     &    fderiv_th=-0.99999999d0*fderiv_th/dderiv_th
   10     continue
          fderiv_th=0.5d0*fderiv_th
          theta1=theta0*(1.d0+dderiv_th*fderiv_th)
          if(theta1.ge.rhispec(ith_upd).or.                             &
     &       theta1.le.rlospec(ith_upd))                                &
     &    theta1=theta0/(1.d0+dderiv_th*fderiv_th)
          if(theta1.ge.rhispec(ith_upd).or.                             &
     &       theta1.le.rlospec(ith_upd)) goto 10
!
          cspec(ispec_upd,ipm_upd)=theta1
          jDB_get_chi=18
          call get_chi ! get_force-02
!
!DRLIM190524-2244:
          if(mlimdrv.ge.1) jaccp=-1
!X        if(  mlimdrv.ge.1) then! get_force-02
!X          errtag='000121.003: # rate fct calls > nlim_drv, during fict. Hamiltonian'
!X          call err_term
!X        endif
!X        May evolve a Theta with mlimdrv>=1 here.
!X        Need to implement better handling for that case!! 
!:DRLIM190524-2244
!
          lhtot_ham=lhtot_ham+1
          cspec(ispec_upd,ipm_upd)=theta0
        endif
!
        if(ith_ham.gt.mth_spec) then
          ith_upd=ith_ham-mth_spec
          ireac_upd=ireac_th(ith_upd)
          ipm_upd=ipmreac_th(ith_upd)
!
          theta0=rreac(ireac_upd,ipm_upd)
!
          fderiv_th=2.d0
          if(dderiv_th.le.-1.d0)                                        &
     &    fderiv_th=-0.99999999d0*fderiv_th/dderiv_th
   20     continue
          fderiv_th=0.5d0*fderiv_th
          theta1=theta0*(1.d0+dderiv_th*fderiv_th)
          if(theta1.ge.rhireac(ith_upd).or.                             &
     &       theta1.le.rloreac(ith_upd))                                &
     &    theta1=theta0/(1.d0+dderiv_th*fderiv_th)
          if(theta1.ge.rhireac(ith_upd).or.                             &
     &       theta1.le.rloreac(ith_upd)) goto 20
!
          rreac(ireac_upd,ipm_upd)=theta1
          jDB_get_chi=19
          call get_chi ! get_force-03
!
!DRLIM190524-2244:
          if(mlimdrv.ge.1) jaccp=-1
!X        if(  mlimdrv.ge.1) then ! get_force-03
!X          errtag='000121.004: # rate fct calls > nlim_drv, during fict. Hamiltonian'
!X          call err_term
!X        endif
!X        May evolve a Theta with mlimdrv>=1 here.
!X        Need to implement better handling for that case!! 
!:DRLIM190524-2244
!
          lhtot_ham=lhtot_ham+1
          rreac(ireac_upd,ipm_upd)=theta0
        endif
!
        force_ham(ith_ham)=-(beta_mc*fbeta_st/ftmp_imv)                 &
     &                     *(htot-htot_ham)/(theta1-theta0)
        if(jct_ham(ith_ham).eq.1)                                       &
     &  force_ham(ith_ham)=force_ham(ith_ham)                           &
     &                    *(theta1+theta0)*0.5d0
!
        if(jfxfic.eq.1.or.jfxfic.eq.2.or.jfxfic.eq.3) then
          force_th=force_ham(ith_ham)
          if(force_th.gt.force_max(ith_ham))                            &
     &    force_ham(ith_ham)=force_max(ith_ham)
!
          if(force_th.lt.(-force_max(ith_ham)))                         &
     &    force_ham(ith_ham)=-force_max(ith_ham)
        endif
!
        if(jfxfic.eq.101.or.jfxfic.eq.102.or.jfxfic.eq.103) then
          force_th=force_ham(ith_ham)
          force_ham(ith_ham)=force_th*force_max(ith_ham)                &
     &    /dsqrt(force_th**2+force_max(ith_ham)**2)
        endif
      enddo
      ith_ham=-1
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine save_theta
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
      ith_ham=0
      do ith=1,mth_spec
        ispec=ispec_th(ith)
        ipm=ipmspec_th(ith)
!
        ith_ham=ith_ham+1
        theta_ham(ith_ham,0)=cspec(ispec,ipm)
      enddo
!
      do ith=1,mth_reac
        ireac=ireac_th(ith)
        ipm=ipmreac_th(ith)
!
        ith_ham=ith_ham+1
        theta_ham(ith_ham,0)=rreac(ireac,ipm)
      enddo
      ith_ham=-1
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine pass_thham
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
      ith_ham=0
      do ith=1,mth_spec
        ispec=ispec_th(ith)
        ipm=ipmspec_th(ith)
!
        ith_ham=ith_ham+1
        cspec(ispec,ipm)=theta_ham(ith_ham,itfic)
      enddo
!
      do ith=1,mth_reac
        ireac=ireac_th(ith)
        ipm=ipmreac_th(ith)
!
        ith_ham=ith_ham+1
        rreac(ireac,ipm)=theta_ham(ith_ham,itfic)
      enddo
      ith_ham=-1
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine reset_theta
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
      ith_ham=0
      do ith=1,mth_spec
        ispec=ispec_th(ith)
        ipm=ipmspec_th(ith)
!
        ith_ham=ith_ham+1
        cspec(ispec,ipm)=theta_ham(ith_ham,0)
      enddo
!
      do ith=1,mth_reac
        ireac=ireac_th(ith)
        ipm=ipmreac_th(ith)
!
        ith_ham=ith_ham+1
        rreac(ireac,ipm)=theta_ham(ith_ham,0)
      enddo
      ith_ham=-1
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mc_ini_r
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! initialize random number generator for MC simulation
!
      call srandx(imc_ran,iseed2,jrand)
!
! zero output counter for DOS output file "ens.o04":
!
      iout_dos=0
!
! initial temperature, stepwidth and data weight modif. factors
!
      ftmp_imv=-1.d0
      fstp_imv=-1.d0
!
      fwgt_tot=-1.d0
      fwgt(0)=-1.d0
      do itxpt=1,ntxpt
        do iexpt=1,nexpt
          do ims=1,nms_spec
            fwgt(itmx_xpt(ims,itxpt,iexpt))=-1.d0
          enddo
        enddo
      enddo
!
! initial restart flag "jrstart" and open "ens.o02"
! for read-in of previous Theta's, if restart
!
      if(imc_smp.eq.2) then
        close(32)
        jmc_inir=240
!
        iun=35
        inquire(file='ens.o05',exist=fexist)
        if(fexist) then
          open(iun,file='ens.o05',status='old')
        else
!BLADE:
!         open(iun,file='ens.o05',status='new')
          open(iun,file='ens.o05')
!:BLADE
        endif
        rewind(iun)
      endif
!
      jrstart=0
!
      if(                                                               &
     &  (jmc_inir.ge.240.and.jmc_inir.lt.250).or.                       &
     &  (jmc_inir.ge.340.and.jmc_inir.le.399)                           &
     &)then
        if(jmc_inir.ge.240.and.jmc_inir.lt.250) then
          open(32,file='ens.o02',status='old')
          rewind(32)
        endif
!
        if(jmc_inir.ge.340.and.jmc_inir.le.399) then
          open(24,file='ens.i12',status='old')
          rewind(24)
        endif
!
        jrstart=1
        jcl_rstart=0
!
        call idat_tr_i
!
        jmvloop_rst=-1
        imc_rep_rst=-1
        imc_eql_rst=-1
        imc_acc_rst=-1
        imc_upd_rst=-1
        kmvsequ_rst=-1
        imvsequ_rst=-1
        imove_rst=-1
!
        kmove_rst=-1
!
      endif
!
! initial output files "ens.o02", "ens.o11", "ens.o12"
!
      if(jrstart.eq.0.or.                                               &
     &  (jmc_inir.ge.340.and.jmc_inir.le.399)                           &
     &)then
        call mc_ini_o02
        call mc_ini_o11
        call mc_ini_o12
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mc_ini_o02
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! open file "ens.o02" for complete MC sample Theta^s, s=1,...Nmc_acc
!
      inquire(file='ens.o02',exist=fexist)
      if(fexist) then
        open(32,file='ens.o02',status='old')
      else
!BLADE:
!       open(32,file='ens.o02',status='new')
        open(32,file='ens.o02')
!:BLADE
      endif
!
!
      if(nset.gt.1) then
        iun=32
        call efile(iun)
      else
        rewind(32)
      endif
!
! zero output counter for "ens.o02":
      iout_th=0
      write(32,3000) iout_th
 3000 format(/'iout_th'/i8)
!
!
!DRLIM190524-2244: jo_th_lmdrv==1 -> Enable lim-drv output by ith
!CHG190516-1747: Enable ODE solver stats output for all iout_th blocks,
!              w/ jo_th_mchi==1.
      write(32,*) '   '
      write(32,3002)                                                    &
     &                jo_ar    , jo_xspec                               &
     &              , jo_sxt   , jo_cfi    , jo_xdi , jo_xko            &
     &              , jo_th    , jo_th_opt1, jo_th_opt2                 &
     &              , jo_th_mvs                                         &
     &              , jo_th_xo , jo_th_wg , jo_th_cu, jo_th_sw          &
     &              , jo_th_bxx, jo_th_bxn, jo_th_ft, jo_th_hto         &
     &              , jo_th_ark, jo_th_mine, jo_th_dprec, jo_th_mchi    &
     &              , jo_th_lmdrv
 3002 format(/                       &
     &       '   jo_ar        jo_xspec'                                 &
     &      /i8,i16                                                     &
     &      /'      jo_... sxt cfi xdi xko'                             &
     &      /12x,4i4                                                    &
     &      /'   jo_th      jo_th_opt1      jo_th_opt2'                 &
     &      /i8, 2i16                                                   &
     &      /'   jo_th_... mvs  xo  wg  cu  sw bxx bxn  ft hto'         &
     &      /12x,9i4                                                    &
     &      /'   jo_th_... ark mne dpr mch ldr'                         &
     &      /12x,5i4                                                    &
     &      )
!:CHG190516-1747
!:DRLIM190524-2244
!
!
      write(32,*) '   '
      write(32,3010) nmc_rep,nmc_eql,nmc_acc,nmc_upd                    &
     &              ,mth_tot,mth_spec,mth_reac,mdokin                   &
     &              ,muf_tot,muf_spec,muf_reac                          &
     &              ,muv_tot,muv_spec,muv_reac                          &
     &              ,mdtin,mdtin_raw,mdtin_odp,ndtin,nipch              &
!!   &              ,mdpen_tot,mdpen_spec,mdpen_reac                    &
!!   &              ,ndpen_tot,ndpen_spec,ndpen_reac                    &
     &              ,nms_spec,nsft_spec,nvs_spec,nfs_spec               &
     &              ,ntime,no_time,ntxpt,nexpt,nspec,nreac
 3010 format(                       &
     &       '   nmc_rep   nmc_eql   nmc_acc   nmc_upd'                 &
     &      /4i10                                                       &
     &      /'   mth_tot  mth_spec  mth_reac    mdokin'                 &
     &      /4i10                                                       &
     &      /'   muf_tot  muf_spec  muf_reac'                           &
     &      /3i10                                                       &
     &      /'   muv_tot  muv_spec  muv_reac'                           &
     &      /3i10                                                       &
     &      /'     mdtin mdtin_raw mdtin_odp     ndtin     nipch'       &
     &      /5i10                                                       &
     &      /'  nms_spec nsft_spec  nvs_spec  nfs_spec'                 &
     &      /4i10                                                       &
     &      /'     ntime   no_time     ntxpt     nexpt'                 &
     &      ,'     nspec     nreac'                                     &
     &      /6i10                                                       &
     &      )
!
      write(32,3012)                                                         &
     &      mdpen_tot,mdpen_spec,mdpen_reac                                  &
     &     ,ndpen_tot,ndpen_spec,ndpen_reac                                  &
     &     ,lblkth_tot, kthblk_tot, kpmblk_tot, lrasf_tot                    &
     &     ,ldconr_tot ,ldconp_tot, ldconfz_tot, kampdv_tot, kampdu_tot      &
     &     ,ntsxdc_tot, ntxdc, mtsxdc_max
 3012 format(                                                                &
     &       ' mdpen_tot mdpen_spec mdpen_reac'                              &
     &      /3i10                                                            &
     &      /' ndpen_tot ndpen_spec ndpen_reac'                              &
     &      /3i10                                                            &
     &      /' lblkth_.. kthblk_..  kpmblk..  lrasf_..              .._tot'  &
     &      /4i10                                                            &
     &      /' ldconr_.. ldconp_.. ldconfz_.. kampdv_.. kampdu_..   .._tot'  &
     &      /5i10                                                            &
     &      /'ntsxdc_tot     ntxdc mtsxdc_max'                               &
     &      /3i10                                                            &
     &      )
!
      if(kthblk_tot.ge.1.or.kpmblk_tot.ge.1) then
        write(32,*) '  '
        do jmvloop=1,2
          do imvsequ=1,nmvsequ(jmvloop)
            write(32,*) '  '
            write(32,*)                                                    &
     &      '  theta move and parameter variable (ipm,ispre) block'
            write(32,3020)                                                 &
     &        jmvloop                                                      &
     &      , imvsequ                                                      &
     &      , jmty(imvsequ,jmvloop)                                        &
!
     &      , mthb_spec(imvsequ,jmvloop)                                   &
     &      , kthb_spec_ini(imvsequ,jmvloop)                               &
     &      , kthb_spec_fin(imvsequ,jmvloop)                               &
!
     &      , mthb_reac(imvsequ,jmvloop)                                   &
     &      , kthb_reac_ini(imvsequ,jmvloop)                               &
     &      , kthb_reac_fin(imvsequ,jmvloop)                               &
!
     &      , mthb_tot(imvsequ,jmvloop)                                    &
     &      , kthb_tot_ini(imvsequ,jmvloop)                                &
     &      , kthb_tot_fin(imvsequ,jmvloop)                                &
!
     &      , mpmb_tot(imvsequ,jmvloop)                                    &
     &      , kpmb_ini(imvsequ,jmvloop)                                    &
     &      , kpmb_fin(imvsequ,jmvloop)                                    &
!
     &      , lblkth_ini(imvsequ,jmvloop)                                  &
     &      , lblkth_fin(imvsequ,jmvloop)                                  &
!
     &      , lrasf_ini(imvsequ,jmvloop)                                   &
     &      , lrasf_fin(imvsequ,jmvloop)
!
 3020       format(                                                        &
     &       ' jmvloop imvsequ    jmty'                                    &
     &      ,'  mthb_S kthb_SI kthb_SF  mthb_R kthb_RI kthb_RF'            &
     &      /9i8                                                           &
     &      /'                        '                                    &
     &      ,'  mthb_T kthb_TI kthb_TF'                                    &
     &      ,'  mpmb_T  kpmb_I  kpmb_F'                                    &
     &      /24x,6i8                                                       &
     &      /32x,' lblkt_I lblkt_F lrasf_I lrasf_F'                        &
     &      /32x,4i8                                                       &
     &      )
!
!
            write(32,*) '  '
            write(32,3022)
 3022       format(                                                        &
     &       '  species move block'                                        &
     &      /'  kthblk    ithc     ith     ipm   ispec   ireac   ispre'    &
     &      /'/namespec'                                                   &
     &      )
            do kthblk=kthb_spec_ini(imvsequ,jmvloop)          &
     &               ,kthb_spec_fin(imvsequ,jmvloop)
              ith=ithc_thblk(kthblk)
              if(ith.le.mth_spec) then
                ispec=ispec_th(ith)
                ipm=ipmspec_th(ith)
                ireac=-1
                aline=namespec(ispec)
                ispre=ispec
              else
                ith=ith-mth_spec
                ireac=ireac_th(ith)
                ipm=ipmreac_th(ith)
                ispec=-1
                aline=namereac(ireac)
                ispre=ireac+nspec
              endif
              write(32,3024) kthblk                           &
     &                     , ithc_thblk(kthblk)               &
     &                     , ith                              &
     &                     , ipm                              &
     &                     , ispec                            &
     &                     , ireac                            &
     &                     , ispre                            &
     &                     , aline
 3024         format(7i8/a80)
            enddo
!
!
            write(32,*) '  '
            write(32,3026)
 3026       format(                                                        &
     &       '  reaction move block'                                       &
     &      /'  kthblk    ithc     ith     ipm   ispec   ireac   ispre'    &
     &      /'/namereac'                                                   &
     &      )
            do kthblk=kthb_reac_ini(imvsequ,jmvloop)          &
     &               ,kthb_reac_fin(imvsequ,jmvloop)
              ith=ithc_thblk(kthblk)
              if(ith.le.mth_spec) then
                ispec=ispec_th(ith)
                ipm=ipmspec_th(ith)
                ireac=-1
                aline=namespec(ispec)
                ispre=ispec
              else
                ith=ith-mth_spec
                ireac=ireac_th(ith)
                ipm=ipmreac_th(ith)
                ispec=-1
                aline=namereac(ireac)
                ispre=ireac+nspec
              endif
              write(32,3028) kthblk                           &
     &                     , ithc_thblk(kthblk)               &
     &                     , ith                              &
     &                     , ipm                              &
     &                     , ispec                            &
     &                     , ireac                            &
     &                     , ispre                            &
     &                     , aline
 3028         format(7i8/a80)
            enddo
!
!
            write(32,*) '  '
            write(32,3030)
 3030       format(                                                        &
     &       '  global move block'                                         &
     &      /'  kthblk    ithc     ith     ipm   ispec   ireac   ispre'    &
     &      /'/namespre'                                                   &
     &      )
            do kthblk=kthb_tot_ini(imvsequ,jmvloop)          &
     &               ,kthb_tot_fin(imvsequ,jmvloop)
              ith=ithc_thblk(kthblk)
              if(ith.le.mth_spec) then
                ispec=ispec_th(ith)
                ipm=ipmspec_th(ith)
                ireac=-1
                aline=namespec(ispec)
                ispre=ispec
              else
                ith=ith-mth_spec
                ireac=ireac_th(ith)
                ipm=ipmreac_th(ith)
                ispec=-1
                aline=namereac(ireac)
                ispre=ireac+nspec
              endif
              write(32,3032) kthblk                           &
     &                     , ithc_thblk(kthblk)               &
     &                     , ith                              &
     &                     , ipm                              &
     &                     , ispec                            &
     &                     , ireac                            &
     &                     , ispre                            &
     &                     , aline
 3032         format(7i8/a80)
            enddo
!
!
            write(32,*) '  '
            write(32,3034)
 3034       format(                                                        &
     &       '  parameter variable (ipm,ispre) block'                      &
     &      /'  kpmblk    ithc     ith     ipm   ispec   ireac   ispre'    &
     &      /'/namespre'                                                   &
     &      )
            do kpmblk=kpmb_ini(imvsequ,jmvloop)          &
     &               ,kpmb_fin(imvsequ,jmvloop)
              ispre=ispre_pmblk(kpmblk)
              ipm=ipm_pmblk(kpmblk)
!
              ith=ith_spre(ispre,ipm)
              ithc=ith
              if(ispre.gt.nspec.and.ith.ge.1) ithc=ith+nspec
!
              if(ispre.le.nspec) then
                ispec=ispre
                ireac=-1
                aline=namespec(ispec)
              else
                ireac=ispre-nspec
                ispec=-1
                aline=namereac(ireac)
              endif
              write(32,3036) kpmblk                           &
     &                     , ithc                             &
     &                     , ith                              &
     &                     , ipm                              &
     &                     , ispec                            &
     &                     , ireac                            &
     &                     , ispre                            &
     &                     , aline
 3036         format(7i8/a80)
            enddo
          enddo
        enddo
        jmvloop=-1
        imvsequ=-1
        ith=-1
        ithc=-1
        ispec=-1
        ireac=-1
        ispre=-1
      endif
!
      write(32,*) '   '
      write(32,*) '   '
!
      write(32,3150)
 3150 format('ispec_dpen and ipm_dpen vs. idpen:'                       &
     &      /'   ispec   ipm   ispec   ipm   ispec   ipm'               &
     &      ,'   ispec   ipm   ispec   ipm')
!
      write(32,3152) (ispec_dpen(idpen)                                 &
     &               ,  ipm_dpen(idpen)                                 &
     &               ,idpen=1,ndpen_spec)
 3152 format(2x,2i6,2x,2i6,2x,2i6,2x,2i6,2x,2i6)
!
!
      write(32,*) '   '
!
      write(32,3154)
 3154 format('ireac_dpen and ipm_dpen vs. idpen:'                       &
     &      /'   ireac   ipm   ireac   ipm   ireac   ipm'               &
     &      ,'   ireac   ipm   ireac   ipm')
!
      write(32,3156) (ireac_dpen(idpen+ndpen_spec)                      &
     &               ,  ipm_dpen(idpen+ndpen_spec)                      &
     &               ,idpen=1,ndpen_reac)
 3156 format(2x,2i6,2x,2i6,2x,2i6,2x,2i6,2x,2i6)
!
!
      write(32,*) ' '
      write(32,*) ' '
      write(32,*) ' dependent parameters in input list order'
      write(32,*) ' '
!
      ispre0=-1
      do idpen=1,ndpen_tot
        ispre=ispre_dpen(idpen)
        ispec=ispec_dpen(idpen)
        ireac=ireac_dpen(idpen)
!c      call tr_spre(ispec,ireac,ispre,nspec)
        ipm=ipm_dpen(idpen)
!
        if(ispre.ne.ispre0) then
          ispre0=ispre
          write(32,3162) namespre(ispre)
 3162     format('  namespre'                                           &
     &        /a80                                                      &
     &        /' idpen     jprio ispre ispec ireac   ipm mparn'         &
     &      ,            '  msib jdrdp j/namefunc'                      &
     &          )
        endif
!!!     write(32,3164) idpen,jprio_dpen(idpen),ispre,ispec,ireac,ipm
!!!3164 format(1x,6i6)
        write(32,3164) idpen,jprio_dpen(idpen),ispre,ispec,ireac,ipm    &
     &                ,mparn_dpen(idpen)                                &
     &                ,msib_dpen(idpen)                                 &
     &                ,jdrdp_dpen(idpen)                                &
     &                ,jfunc_dpen(idpen)                                &
     &                ,namefunc_dpen(idpen)
 3164   format(i6,i10,8i6                                               &
     &           /a80)
      enddo
!
!
      write(32,*) ' '
      write(32,*) ' '
      write(32,*) ' dependent parameter parents in priority order'
      write(32,*) ' '
      write(32,3170) ndpen_tot,ndpen_spec,ndpen_reac
 3170 format(' ndpen_tot .._spec .._reac'             &
     &      /3i8)
!
      do ipriodp=1,ndpen_tot
        idpen=idpen_prio(ipriodp)
        ispre=ispre_dpen(idpen)
        ispec=ispec_dpen(idpen)
        ireac=ireac_dpen(idpen)
!c      call tr_spre(ispec,ireac,ispre,nspec)
        ipm=ipm_dpen(idpen)
!
        write(32,3172)                                                  &
     &                 namespre(ispre)                                  &
     &                ,idpen,jprio_dpen(idpen)                          &
     &                ,ispre,ispec,ireac,ipm                            &
     &                ,mparn_dpen(idpen)                                &
     &                ,msib_dpen(idpen)                                 &
     &                ,jdrdp_dpen(idpen)                                &
     &                ,jfunc_dpen(idpen)                                &
     &                ,namefunc_dpen(idpen)
 3172   format(                                                         &
     &      /'   namespre_dpen'                                         &
     &      /a80                                                        &
!!!  &      /'  idpen jprio ispre ispec ireac   ipm mparn'              &
     &      /' idpen     jprio ispre ispec ireac   ipm mparn'           &
     &      ,          '  msib jdrdp j/namefunc'                        &
     &      /i6,i10,8i6                                                 &
     &      /a80                                                        &
     &      /'   name_parn|pm_parn /'                                   &
     &      /'   iparn ispre_parn ispec_parn ireac_parn   ipm_parn'     &
     &      ,'         ti_parn'                                         &
     &      )
!
        do iparn=1,mparn_dpen(idpen)
          ispec0=-2
          ireac0=-2
          ispre0=ispre_parn(iparn,idpen)
          ipm0=ipm_parn(iparn,idpen)
          if(ispre0.gt.0) then
            call tr_spre(ispec0,ireac0,ispre0,nspec)
            write(32,3176)                                              &
     &                 namespre(ispre0)                                 &
     &                ,iparn,ispre0,ispec0,ireac0,ipm0                  &
     &                ,ti_parn(iparn,idpen)
 3176       format(a80/i8,4i11,d16.8)
          else
            write(32,3178)                                              &
     &                 pmparn(iparn,idpen)                              &
     &                ,iparn,ispre0,ispec0,ireac0,ipm0                  &
     &                ,ti_parn(iparn,idpen)
 3178       format(d16.8/i8,4i11,d16.8)
          endif
        enddo
!
        if(msib_dpen(idpen).gt.0.d0) then
          do isib=1,msib_dpen(idpen)
!           write(32,3180)
!3180         format(                                                       &
!    &               '  isib idpen ispec'                                   &
!    &              /'      namespec_dpen'                                  &
!    &              /' jfunc'                                               &
!    &              /'      namefunc_dpen'                                  &
!    &              /'ispreP itimeP'                                        &
!    &              /'      namespre_parn'                                  &
!    &              )
!
!           if(isib.gt.1) write(32,*) ' '
            write(32,3182)                                                  &
     &                     namespec(ispec_sib(isib,idpen))                  &
     &                    ,isib                                             &
     &                    ,idpen_sib(isib,idpen)                            &
     &                    ,ispec_sib(isib,idpen)                            &
     &                    ,namefunc_dpen(idpen_sib(isib,idpen))             &
     &                    ,jfunc_sib(isib,idpen)                            &
     &                    ,namespre(ispreP_sib(isib,idpen))                 &
     &                    ,ispreP_sib(isib,idpen)                           &
     &                    ,itimeP_sib(isib,idpen)
!
 3182       format(                                                         &
     &            /'       namespec_sib/  isib idpen ispec'                 &
     &            /a80                                                      &
     &            /20x,3i6                                                  &
     &            /'           namefunc/ jfunc'                             &
     &            /a80                                                      &
     &            /20x,i6                                                   &
     &            /'          namespreP/ispreP itimeP'                      &
     &            /a80                                                      &
     &            /20x,2i6                                                  &
     &            )
          enddo
        endif
      enddo
!
!
      write(32,*) '   '
      write(32,*) '   '
!
      write(32,3220)
 3220 format('ispec_th and ipmspec_th vs. ith:'     &
     &      /'   ispec   ipm   ispec   ipm   ispec   ipm'               &
     &      ,'   ispec   ipm   ispec   ipm')
!
      write(32,3222) (ispec_th(ith),ipmspec_th(ith),ith=1,mth_spec)
 3222 format(2x,2i6,2x,2i6,2x,2i6,2x,2i6,2x,2i6)
!
!
      write(32,*) '   '
!
      write(32,3230)
 3230 format('ireac_th and ipmreac_th vs. ith:'     &
     &      /'   ireac   ipm   ireac   ipm   ireac   ipm'               &
     &      ,'   ireac   ipm   ireac   ipm')
!
      write(32,3232) (ireac_th(ith),ipmreac_th(ith),ith=1,mth_reac)
 3232 format(2x,2i6,2x,2i6,2x,2i6,2x,2i6,2x,2i6)
!
!
!
      write(32,*) ' '
      write(32,*) ' species Theta parameters'
      ispec0=-1
      do ith=1,mth_spec
        ispec=ispec_th(ith)
        ipm=ipmspec_th(ith)
!
        if(ispec.ne.ispec0) then
          ispec0=ispec
          write(32,3242) namespec(ispec)
 3242     format('  namespec'             &
     &          /a80                                                    &
     &          /'   ith ispec   ipm'                                   &
     &          )
        endif
        write(32,3244) ith,ispec,ipm
 3244   format(3i6)
      enddo
!
      write(32,*) ' '
      write(32,*) ' reaction Theta parameters'
      ireac0=-1
      do ith=1,mth_reac
        ireac=ireac_th(ith)
        ipm=ipmreac_th(ith)
!
        if(ireac.ne.ireac0) then
          ireac0=ireac
          write(32,3252) namereac(ireac)
 3252     format('  namereac'             &
     &          /a80                                                    &
     &          /'   ith ireac   ipm'                                   &
     &          )
        endif
        write(32,3254) ith,ireac,ipm
 3254   format(3i6)
      enddo
!
!
      if(jxpt.ge.100.and.jxpt.lt.200) then
        write(32,*) '   '
!
        write(32,3342)
 3342   format(             &
     &  'true Theta configuration:')
!
        write(32,3344)
 3344   format(             &
     &  '     chisq_tru      chi2_tru      chi1_tru    sxplog_tru')
!
        write(32,3345)                                                  &
     &    chisq_tru ,chi2_tru ,chi1_tru ,sxplog_tru
 3345   format(4d14.6)
!
        write(32,3352)
 3352   format(' cspec_th')
!
        write(32,3353)                                                  &
     &  (pmspec(ispec_th(ith),ipmspec_th(ith),5)                        &
     &  ,ith=1,mth_spec)
 3353   format(5d14.6)
!
        write(32,3362)
 3362   format(' rreac_th')
!
        write(32,3363)                                                  &
     &  (pmreac(ireac_th(ith),ipmreac_th(ith),5)                        &
     &  ,ith=1,mth_reac)
 3363   format(5d14.6)
!
!
        if(jo_th_hto.ge.1) then
          write(32,3372)                                                &
     &    htot_tru, hwall_tru, hfour_tru
 3372     format(             &
     &    '      htot_tru     hwall_tru     hfour_tru'                  &
     &    /3d14.6)
!
          write(32,3373)                                                &
     &    hbxx_tru, hbxn_tru, hfous_tru, hfout_tru
 3373     format(             &
     &    '      hbxx_tru      hbxn_tru     hfous_tru     hfout_tru'    &
     &    /4d14.6)
        endif
!
        if(jo_th_bxx.ge.1) then
          write(32,3382)
 3382     format(             &
     &    '      qbxx_tru ')
!
          write(32,3383)                                                &
     &    (qbxx_tru(ivs), ivs=0,nvs_spec)
 3383     format(5d14.6)
        endif
!
!
        if(jo_th_bxn.ge.1) then
          write(32,3392)
 3392     format(             &
     &    '      qbxn_tru ')
!
          write(32,3393)                                                &
     &    (qbxn_tru(ivs), ivs=0,nvs_spec)
 3393     format(5d14.6)
        endif
!
        if(jo_th_ft.ge.1) then
          do iexpt=1,nexpt
            do isegft=1,nsegft(iexpt)
              write(32,3410)                                            &
     &        iexpt,isegft                                              &
     &        ,pfour_seg_tru(isegft,iexpt)                              &
     &        ,qfour_seg_tru(isegft,iexpt)
 3410         format(             &
     &        '  iexpt isegft pfour_seg_tru qfour_seg_tru'              &
     &        /2i7,2d14.6)
!
              write(32,3412)
 3412         format(' pfour_sfil_tru ')
              write(32,3414)                                            &
     &        (pfour_sfil_tru(is_ft,isegft,iexpt)                       &
     &        ,is_ft=1,nsft_spec)
 3414         format(5d14.6)
!
              write(32,3416)
 3416         format(' pfour_stot_tru ')
              write(32,3418)                                            &
     &        (pfour_stot_tru(is_ft,isegft,iexpt)                       &
     &        ,is_ft=1,nsft_spec)
 3418         format(5d14.6)
            enddo
          enddo
        endif
      endif
!
!c      close(32)
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mc_ini_o11
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! open file "ens.o11" for complete kinetics solution "xspec"
!
      if(jo_xko.eq.1.or.jo_xko.eq.2) then
        inquire(file='ens.o11',exist=fexist)
        if(fexist) then
          open(41,file='ens.o11',status='old')
        else
!BLADE:
!          open(41,file='ens.o11',status='new')
           open(41,file='ens.o11')
!:BLADE
        endif
!
        if(nset.ge.2) then
          iun=41
          call efile(iun)
        else
          rewind(41)
        endif
!
!
        write(41,*) '   '
        write(41,4102)                                                  &
     &  nmc_rep,nmc_eql,nmc_acc,nmc_upd
 4102   format(             &
     &  ' nmc_rep nmc_eql nmc_acc nmc_upd'                              &
     &  /6i8                                                            &
     &        )
!
        write(41,*) '   '
        write(41,4104) nspec,nms_spec,nexpt,ntxpt,ntime,ntskip
 4104   format(             &
     &         '   nspec nms_spec  nexpt   ntxpt   ntime  ntskip'       &
     &        /6i8                                                      &
     &        )
!
!
        write(41,4110)
 4110   format(             &
     &         1x                                                       &
     &        ,' exptl. observed species at exptl. time points'         &
     &        )
!
        do iexpt=1,nexpt
          do ims=1,nms_spec
            ispec=ispec_ms(ims)
            write(41,4120) iexpt, ims, ispec,namespec(ispec)
 4120       format(/'   iexpt     ims   ispec'             &
     &             /3i8                                                 &
     &             /' namespec:'                                        &
     &             /a80                                                 &
     &             /'    itxpt      time_xpt     xspec_xpt')
!
            do itxpt=1,ntxpt
              write(41,4130) itxpt,time_xpt(itxpt)                      &
     &                      ,xspec_xpt(itmx_xpt(ims,itxpt,iexpt))
 4130         format(i8,2d14.6)
            enddo
          enddo
        enddo
!
        close(41)
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mc_ini_o12
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! open file "ens.o12" for complete kinetics solution "xspec"
! in "gnuplot" format
!
      if(jo_xko.eq.2) then
        inquire(file='ens.o12',exist=fexist)
        if(fexist) then
          open(42,file='ens.o12',status='old')
        else
!BLADE:
!         open(42,file='ens.o12',status='new')
          open(42,file='ens.o12')
!:BLADE
        endif
!
        if(nset.ge.2) then
          iun=42
          call efile(iun)
        else
          rewind(42)
        endif
!
        write(42,*) '#   '
        close(42)
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mc_zero_r
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! zero repeat accumulators
!
      ar_chisq_n=0.d0
      dr_chisq_n=0.d0
!
      do kscal=1,nkscal
        ar_chi1_ks(kscal)=0.d0
        dr_chi1_ks(kscal)=0.d0
!
        ar_chi2_ks(kscal)=0.d0
        dr_chi2_ks(kscal)=0.d0
!
        ar_sxplog_ks(kscal)=0.d0
        dr_sxplog_ks(kscal)=0.d0
      enddo
!
      do iscal=1,niscal
        ar_chi1_is(iscal)=0.d0
        dr_chi1_is(iscal)=0.d0
!
        ar_chi2_is(iscal)=0.d0
        dr_chi2_is(iscal)=0.d0
!
        ar_sxplog_is(iscal)=0.d0
        dr_sxplog_is(iscal)=0.d0
      enddo
!
!
!V090911:
!Fixed lcrdp-Bug:
!!!   do idpen=1,mdpen_tot
      do lcrdp=1,mdpen_tot
        idpen0=idpen_crdp(lcrdp)
        if(ispec_dpen(idpen0).gt.0) npow_dpen=npow_spec
        if(ireac_dpen(idpen0).gt.0) npow_dpen=npow_reac
!!!     if(ispec_dpen(idpen).gt.0) npow_dpen=npow_spec
!!!     if(ireac_dpen(idpen).gt.0) npow_dpen=npow_reac
!
        do ipow=1,npow_dpen
!!!       ar_crdpen(idpen,ipow)=0.d0
!!!       dr_crdpen(idpen,ipow)=0.d0
          ar_crdpen(lcrdp,ipow)=0.d0
          dr_crdpen(lcrdp,ipow)=0.d0
!:V090911
        enddo
      enddo
!
!
!
      do ipow=1,npow_spec
        do ith=1,mth_spec
          ar_cspec(ith,ipow)=0.d0
          dr_cspec(ith,ipow)=0.d0
        enddo
      enddo
!
      do ipow=1,npow_reac
        do ith=1,mth_reac
          ar_rreac(ith,ipow)=0.d0
          dr_rreac(ith,ipow)=0.d0
        enddo
      enddo
!
!
!
      ar_htot=0.d0
      dr_htot=0.d0
!
      ar_hwall=0.d0
      dr_hwall=0.d0
!
      ar_hbxx=0.d0
      dr_hbxx=0.d0
!
      ar_hbxn=0.d0
      dr_hbxn=0.d0
!
      ar_hfour=0.d0
      dr_hfour=0.d0
!
      ar_hfous=0.d0
      dr_hfous=0.d0
!
      ar_hfout=0.d0
      dr_hfout=0.d0
!
      do ivs=0,nvs_spec
        ar_qbxx(ivs)=0.d0
        dr_qbxx(ivs)=0.d0
!
        ar_fbxx(ivs)=0.d0
        dr_fbxx(ivs)=0.d0
!
        ar_qbxn(ivs)=0.d0
        dr_qbxn(ivs)=0.d0
!
        ar_fbxn(ivs)=0.d0
        dr_fbxn(ivs)=0.d0
      enddo
!
!
      do iexpt=1,nexpt
        do isegft=1,nsegft(iexpt)
          ar_pfour_seg(isegft,iexpt)=0.d0
          dr_pfour_seg(isegft,iexpt)=0.d0
!
          ar_qfour_seg(isegft,iexpt)=0.d0
          dr_qfour_seg(isegft,iexpt)=0.d0
!
          do is_ft=1,nsft_spec
            ar_pfour_sfil(is_ft,isegft,iexpt)=0.d0
            dr_pfour_sfil(is_ft,isegft,iexpt)=0.d0
!
            ar_pfour_stot(is_ft,isegft,iexpt)=0.d0
            dr_pfour_stot(is_ft,isegft,iexpt)=0.d0
          enddo
        enddo
      enddo
!
!
      if(jo_ar.eq.10) then
        do iexpt=1,nexpt
!c        do ivs=1,nvs_spec_o(iexpt)
          do ispec=1,nspec_o(iexpt)
            do ipow=1,npow_spec
              do io_time=1,no_time
                ar_xspec(io_time,ispec,iexpt,ipow)=0.d0
                dr_xspec(io_time,ispec,iexpt,ipow)=0.d0
!
                ar_yspec(io_time,ispec,iexpt,ipow)=0.d0
                dr_yspec(io_time,ispec,iexpt,ipow)=0.d0
              enddo
            enddo
          enddo
        enddo
      endif
!
! zero proposal and acceptance counters
!
      do ipmty=1,3
        do jmvloop=1,2
          do imvsequ=1,nmvsequ(jmvloop)
            do ith=1,mth_ty(ipmty)
              nprop(ith,imvsequ,jmvloop,ipmty)=0
              naccp(ith,imvsequ,jmvloop,ipmty)=0
            enddo
          enddo
        enddo
      enddo
!
      do jmvloop=1,2
        do imvsequ=1,nmvsequ(jmvloop)
          nprop_ham(imvsequ,jmvloop)=0
          naccp_ham(imvsequ,jmvloop)=0
        enddo
      enddo
!
! zero out-of-bound species counters
!
      do jmvloop=1,2
        nkin_run(jmvloop)=0
      enddo
!
      do ispec=1,nspec
        do jmvloop=1,2
          a_lspec_max(ispec,jmvloop)=0.d0
          a_lspec_min(ispec,jmvloop)=0.d0
          r_lspec_max(ispec,jmvloop)=0.d0
          r_lspec_min(ispec,jmvloop)=0.d0
        enddo
      enddo
!
      do ireac=1,nreac
        do jmvloop=1,2
          a_lvfor(ireac,jmvloop)=0.d0
          a_lvbak(ireac,jmvloop)=0.d0
          a_lvreac(ireac,jmvloop)=0.d0
          r_lvfor(ireac,jmvloop)=0.d0
          r_lvbak(ireac,jmvloop)=0.d0
          r_lvreac(ireac,jmvloop)=0.d0
        enddo
      enddo
!
! zero Hamiltonian rms forces
!
        if(jmvloop.eq.1.or.jmvloop.eq.2) then
          do ith_ham=1,mth_tot
            aforce_propi(ith_ham,jmvloop)=0.d0
            aforce_propf(ith_ham,jmvloop)=0.d0
            aforce_accpf(ith_ham,jmvloop)=0.d0
!
            adhevl_propf(ith_ham,jmvloop)=0.d0
            adhevl_accpf(ith_ham,jmvloop)=0.d0
          enddo
          ith_ham=-1
!
          htot_ham_propi(jmvloop)=0.d0
          htot_ham_propf(jmvloop)=0.d0
          htot_ham_accpf(jmvloop)=0.d0
!
          nprop_ham_ini(jmvloop)=0
          nprop_ham_fin(jmvloop)=0
          naccp_ham_fin(jmvloop)=0
        endif
!
! zero adaptive Runge-Kutta (ARK) and ABD step+failure counters
!
      call zero_arkabd ! mc_zero_r-01
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mc_accu_r
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
      if(imc_smp.eq.1.and..not.(jmc_inir.ge.340.and.jmc_inir.le.399))   &
     &return
!
      if(jmc_inir.eq.361) return
!
! accumulates averages and variances from MC repetitions
!
      if(nmc_acc.gt.0) then
        anorm_acc=1.d0/(1.d0*nmc_acc)
      else
        anorm_acc=1.d0
      endif
!
!V090927:
      am_chisq_th(imc_rep)=am_chisq_n*anorm_acc
      arenorm_rep(imc_rep)=1.d0
      amwgt_rep(imc_rep)=1.d0
      if(                                                  &
     &am_chisq_th(imc_rep).lt.am_chisq_lo(2).or.           &
     &am_chisq_th(imc_rep).gt.am_chisq_hi(2)               &
     &) amwgt_rep(imc_rep)=0.d0
!
      if(imc_rep.eq.1) then
        imc_rep_min=imc_rep
        if(am_chisq_th(imc_rep).ge.am_chisq_lo(2)) then
          am_chisq_min(imc_rep)=am_chisq_th(imc_rep)
        else
          am_chisq_min(imc_rep)=am_chisq_hi(imc_rep)
        endif
      endif
!
      if(imc_rep.ge.2) then
        am_chisq_min(imc_rep)=am_chisq_min(imc_rep-1)
        if(                                                          &
     &  am_chisq_th(imc_rep).lt.am_chisq_min(imc_rep).and.           &
     &  am_chisq_th(imc_rep).ge.am_chisq_lo(2)                       &
     &  )then
          imc_rep_min=imc_rep
          am_chisq_min(imc_rep)=am_chisq_th(imc_rep)
        endif
      endif
!
      if(amwgt_rep(imc_rep).lt.1.d-30) return
!    Note: am_chis_th(imc_rep) is guaranteed to be in
!    [am_chisq_lo,am_chisq_hi] below this point
!
! jrpwgt(2)=0:
!   equal weight amwgt=1.0 for all repeats
!
! jrpwgt(2)=1:
!   equal weight amwgt=1.0 for all repeats with am_chisq_th
!   in the window [am_chisq_lo,am_chisq_hi]; zero weight out-of-window
!
! jrpwgt(2)=2:
!   Boltzmann weight for all repeats with am_chisq_th in the
!   window [am_chisq_lo,am_chisq_hi], with amwgt=1.0 for
!   imc_rep with minimal am_chisq_th; zero weight out-of-window
!
      if(jrpwgt(2).eq.1) then
        arenorm_rep(imc_rep)=1.d0
        amwgt_rep(imc_rep)=1.d0
!
!      Not really needed:
        if(                                                  &
     &  am_chisq_th(imc_rep).lt.am_chisq_lo(2).or.           &
     &  am_chisq_th(imc_rep).gt.am_chisq_hi(2)               &
     &  ) amwgt_rep(imc_rep)=0.d0
      endif
!
      if(jrpwgt(2).eq.2) then
        arenorm_rep(imc_rep)=1.d0
        amwgt_rep(imc_rep)=beta_repav(2)                                  &
     &                    *(am_chisq_th(imc_rep)-am_chisq_min(imc_rep))
        amwgt_rep(imc_rep)=dexp(-dabs(amwgt_rep(imc_rep)))
!
!      Not really needed:
        if(                                                  &
     &  am_chisq_th(imc_rep).lt.am_chisq_lo(2).or.           &
     &  am_chisq_th(imc_rep).gt.am_chisq_hi(2)               &
     &  ) amwgt_rep(imc_rep)=0.d0
!
        if(imc_rep.ge.2.and.amwgt_rep(imc_rep).ge.1.d-30) then
          if(am_chisq_min(imc_rep).lt.am_chisq_min(imc_rep-1)) then
            arenorm_rep(imc_rep)=beta_repav(2)                                  &
     &                          *(am_chisq_min(imc_rep-1)-am_chisq_min(imc_rep))
            arenorm_rep(imc_rep)=dexp(-arenorm_rep(imc_rep))
            do imc_rep0=1,(imc_rep-1)
              amwgt_rep(imc_rep0)=amwgt_rep(imc_rep0)*arenorm_rep(imc_rep)
            enddo
          endif
        endif
      endif
!
!
      if(                                                    &
     &amwgt_rep(imc_rep).lt.1.d-30.and.                      &
     &dabs(arenorm_rep(imc_rep)-1.d0).lt.1.d-10              &
     &) return
!
     arenorm=arenorm_rep(imc_rep)
     amwgt=amwgt_rep(imc_rep)
!:V090927
!
      am_chisq_n=am_chisq_n*anorm_acc/(1.d0*mdtin)
      ar_chisq_n=arenorm*ar_chisq_n+amwgt*am_chisq_n
      dr_chisq_n=arenorm*dr_chisq_n+amwgt*am_chisq_n**2
!
      do kscal=1,nkscal
        am_chi1_ks(kscal)  =                                            &
     &    am_chi1_ks(kscal)*anorm_acc
        ar_chi1_ks(kscal)  =                                            &
     &    arenorm*ar_chi1_ks(kscal)+amwgt*am_chi1_ks(kscal)
        dr_chi1_ks(kscal)  =                                            &
     &    arenorm*dr_chi1_ks(kscal)+amwgt*am_chi1_ks(kscal)**2
!
        am_chi2_ks(kscal)  =                                            &
     &    am_chi2_ks(kscal)*anorm_acc
        ar_chi2_ks(kscal)  =                                            &
     &    arenorm*ar_chi2_ks(kscal)+amwgt*am_chi2_ks(kscal)
        dr_chi2_ks(kscal)  =                                            &
     &    arenorm*dr_chi2_ks(kscal)+amwgt*am_chi2_ks(kscal)**2
!
        am_sxplog_ks(kscal)  =                                          &
     &    am_sxplog_ks(kscal)*anorm_acc
        ar_sxplog_ks(kscal)  =                                          &
     &    arenorm*ar_sxplog_ks(kscal)+amwgt*am_sxplog_ks(kscal)
        dr_sxplog_ks(kscal)  =                                          &
     &    arenorm*dr_sxplog_ks(kscal)+amwgt*am_sxplog_ks(kscal)**2
      enddo
!
      do iscal=1,niscal
        am_chi1_is(iscal)  =                                            &
     &    am_chi1_is(iscal)*anorm_acc
        ar_chi1_is(iscal)  =                                            &
     &    arenorm*ar_chi1_is(iscal)+amwgt*am_chi1_is(iscal)
        dr_chi1_is(iscal)  =                                            &
     &    arenorm*dr_chi1_is(iscal)+amwgt*am_chi1_is(iscal)**2
!
        am_chi2_is(iscal)  =                                            &
     &    am_chi2_is(iscal)*anorm_acc
        ar_chi2_is(iscal)  =                                            &
     &    arenorm*ar_chi2_is(iscal)+amwgt*am_chi2_is(iscal)
        dr_chi2_is(iscal)  =                                            &
     &    arenorm*dr_chi2_is(iscal)+amwgt*am_chi2_is(iscal)**2
!
        am_sxplog_is(iscal)  =                                          &
     &    am_sxplog_is(iscal)*anorm_acc
        ar_sxplog_is(iscal)  =                                          &
     &    arenorm*ar_sxplog_is(iscal)+amwgt*am_sxplog_is(iscal)
        dr_sxplog_is(iscal)  =                                          &
     &    arenorm*dr_sxplog_is(iscal)+amwgt*am_sxplog_is(iscal)**2
      enddo
!
!
!
!V090911:
!Fixed lcrdp-Bug:
!!!   do idpen=1,mdpen_tot
      do lcrdp=1,mdpen_tot
        idpen0=idpen_crdp(lcrdp)
        if(ispec_dpen(idpen0).gt.0) npow_dpen=npow_spec
        if(ireac_dpen(idpen0).gt.0) npow_dpen=npow_reac
!!!     if(ispec_dpen(idpen).gt.0) npow_dpen=npow_spec
!!!     if(ireac_dpen(idpen).gt.0) npow_dpen=npow_reac
!
        do ipow=1,npow_dpen
!!!       am_crdpen(idpen,ipow)=am_crdpen(idpen,ipow)*anorm_acc
!!!       ar_crdpen(idpen,ipow)=arenorm*ar_crdpen(idpen,ipow)                   &
!!!  &                         +amwgt*am_crdpen(idpen,ipow)
!!!       dr_crdpen(idpen,ipow)=arenorm*dr_crdpen(idpen,ipow)                   &
!!!  &                         +amwgt*am_crdpen(idpen,ipow)**2
!
          am_crdpen(lcrdp,ipow)=am_crdpen(lcrdp,ipow)*anorm_acc
          ar_crdpen(lcrdp,ipow)=arenorm*ar_crdpen(lcrdp,ipow)                   &
     &                         +amwgt*am_crdpen(lcrdp,ipow)
          dr_crdpen(lcrdp,ipow)=arenorm*dr_crdpen(lcrdp,ipow)                   &
     &                         +amwgt*am_crdpen(lcrdp,ipow)**2
!:V090911
        enddo
      enddo
!
!
!
!
      do ipow=1,npow_spec
        do ith=1,mth_spec
          am_cspec(ith,ipow)=am_cspec(ith,ipow)*anorm_acc
!
          ar_cspec(ith,ipow)=arenorm*ar_cspec(ith,ipow)+amwgt*am_cspec(ith,ipow)
          dr_cspec(ith,ipow)=arenorm*dr_cspec(ith,ipow)+amwgt*am_cspec(ith,ipow)**2
        enddo
      enddo
!
!
      do ipow=1,npow_reac
        do ith=1,mth_reac
          am_rreac(ith,ipow)=am_rreac(ith,ipow)*anorm_acc
!
          ar_rreac(ith,ipow)=arenorm*ar_rreac(ith,ipow)+amwgt*am_rreac(ith,ipow)
          dr_rreac(ith,ipow)=arenorm*dr_rreac(ith,ipow)+amwgt*am_rreac(ith,ipow)**2
        enddo
      enddo
!
!
      am_htot=am_htot*anorm_acc
      ar_htot=arenorm*ar_htot+amwgt*am_htot
      dr_htot=arenorm*dr_htot+amwgt*am_htot**2
!
      am_hwall=am_hwall*anorm_acc
      ar_hwall=arenorm*ar_hwall+amwgt*am_hwall
      dr_hwall=arenorm*dr_hwall+amwgt*am_hwall**2
!
      am_hbxx=am_hbxx*anorm_acc
      ar_hbxx=arenorm*ar_hbxx+amwgt*am_hbxx
      dr_hbxx=arenorm*dr_hbxx+amwgt*am_hbxx**2
!
      am_hbxn=am_hbxn*anorm_acc
      ar_hbxn=arenorm*ar_hbxn+amwgt*am_hbxn
      dr_hbxn=arenorm*dr_hbxn+amwgt*am_hbxn**2
!
      am_hfour=am_hfour*anorm_acc
      ar_hfour=arenorm*ar_hfour+amwgt*am_hfour
      dr_hfour=arenorm*dr_hfour+amwgt*am_hfour**2
!
      am_hfous=am_hfous*anorm_acc
      ar_hfous=arenorm*ar_hfous+amwgt*am_hfous
      dr_hfous=arenorm*dr_hfous+amwgt*am_hfous**2
!
      am_hfout=am_hfout*anorm_acc
      ar_hfout=arenorm*ar_hfout+amwgt*am_hfout
      dr_hfout=arenorm*dr_hfout+amwgt*am_hfout**2
!
!
      do ivs=0,nvs_spec
        am_qbxx(ivs)=am_qbxx(ivs)*anorm_acc
        ar_qbxx(ivs)=arenorm*ar_qbxx(ivs)+amwgt*am_qbxx(ivs)
        dr_qbxx(ivs)=arenorm*dr_qbxx(ivs)+amwgt*am_qbxx(ivs)**2
!
        am_fbxx(ivs)=am_fbxx(ivs)*anorm_acc
        ar_fbxx(ivs)=arenorm*ar_fbxx(ivs)+amwgt*am_fbxx(ivs)
        dr_fbxx(ivs)=arenorm*dr_fbxx(ivs)+amwgt*am_fbxx(ivs)**2
!
        am_qbxn(ivs)=am_qbxn(ivs)*anorm_acc
        ar_qbxn(ivs)=arenorm*ar_qbxn(ivs)+amwgt*am_qbxn(ivs)
        dr_qbxn(ivs)=arenorm*dr_qbxn(ivs)+amwgt*am_qbxn(ivs)**2
!
        am_fbxn(ivs)=am_fbxn(ivs)*anorm_acc
        ar_fbxn(ivs)=arenorm*ar_fbxn(ivs)+amwgt*am_fbxn(ivs)
        dr_fbxn(ivs)=arenorm*dr_fbxn(ivs)+amwgt*am_fbxn(ivs)**2
      enddo
!
!
      do iexpt=1,nexpt
        do isegft=1,nsegft(iexpt)
          am_pfour_seg(isegft,iexpt)=                                   &
     &    am_pfour_seg(isegft,iexpt)*anorm_acc
!
          ar_pfour_seg(isegft,iexpt)=                                   &
     &    arenorm*ar_pfour_seg(isegft,iexpt)                                    &
     &    +amwgt*am_pfour_seg(isegft,iexpt)
!
          dr_pfour_seg(isegft,iexpt)=                                   &
     &    arenorm*dr_pfour_seg(isegft,iexpt)                                    &
     &    +amwgt*am_pfour_seg(isegft,iexpt)**2
!
          am_qfour_seg(isegft,iexpt)=                                   &
     &    am_qfour_seg(isegft,iexpt)*anorm_acc
!
          ar_qfour_seg(isegft,iexpt)=                                   &
     &    arenorm*ar_qfour_seg(isegft,iexpt)                                    &
     &    +amwgt*am_qfour_seg(isegft,iexpt)
!
          dr_qfour_seg(isegft,iexpt)=                                   &
     &    arenorm*dr_qfour_seg(isegft,iexpt)                                    &
     &    +amwgt*am_qfour_seg(isegft,iexpt)**2
!
          do is_ft=1,nsft_spec
            am_pfour_sfil(is_ft,isegft,iexpt)=                          &
     &      am_pfour_sfil(is_ft,isegft,iexpt)*anorm_acc
!
            ar_pfour_sfil(is_ft,isegft,iexpt)=                          &
     &      arenorm*ar_pfour_sfil(is_ft,isegft,iexpt)                           &
     &      +amwgt*am_pfour_sfil(is_ft,isegft,iexpt)
!
            dr_pfour_sfil(is_ft,isegft,iexpt)=                          &
     &      arenorm*dr_pfour_sfil(is_ft,isegft,iexpt)                           &
     &      +amwgt*am_pfour_sfil(is_ft,isegft,iexpt)**2
!
            am_pfour_stot(is_ft,isegft,iexpt)=                          &
     &      am_pfour_stot(is_ft,isegft,iexpt)*anorm_acc
!
            ar_pfour_stot(is_ft,isegft,iexpt)=                          &
     &      arenorm*ar_pfour_stot(is_ft,isegft,iexpt)                           &
     &      +amwgt*am_pfour_stot(is_ft,isegft,iexpt)
!
            dr_pfour_stot(is_ft,isegft,iexpt)=                          &
     &      arenorm*dr_pfour_stot(is_ft,isegft,iexpt)                           &
     &      +amwgt*am_pfour_stot(is_ft,isegft,iexpt)**2
          enddo
        enddo
      enddo
!
!
      if(jo_ar.eq.10) then
        do iexpt=1,nexpt
          do ispec=1,nspec_o(iexpt)
            do ipow=1,npow_spec
              do io_time=1,no_time
                am_xspec(io_time,ispec,iexpt,ipow)=                     &
     &            am_xspec(io_time,ispec,iexpt,ipow)*anorm_acc
!
                ar_xspec(io_time,ispec,iexpt,ipow)=                     &
     &            arenorm*ar_xspec(io_time,ispec,iexpt,ipow)                    &
     &           +amwgt*am_xspec(io_time,ispec,iexpt,ipow)
                dr_xspec(io_time,ispec,iexpt,ipow)=                     &
     &            arenorm*dr_xspec(io_time,ispec,iexpt,ipow)                    &
     &           +amwgt*am_xspec(io_time,ispec,iexpt,ipow)**2
!
                am_yspec(io_time,ispec,iexpt,ipow)=                     &
     &            am_yspec(io_time,ispec,iexpt,ipow)*anorm_acc
!
                ar_yspec(io_time,ispec,iexpt,ipow)=                     &
     &            arenorm*ar_yspec(io_time,ispec,iexpt,ipow)                    &
     &           +amwgt*am_yspec(io_time,ispec,iexpt,ipow)
                dr_yspec(io_time,ispec,iexpt,ipow)=                     &
     &            arenorm*dr_yspec(io_time,ispec,iexpt,ipow)                    &
     &           +amwgt*am_yspec(io_time,ispec,iexpt,ipow)**2
              enddo
            enddo
          enddo
        enddo
      endif
!:V090927
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mc_fin_r
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! close MC sample and kinetic solver output files
! "ens.o02", "ens.o11" and "ens.o12"
!
      iun=32
      close(iun)
!
      iun=35
      close(iun)
!
      iun=41
      close(iun)
!
      iun=42
      close(iun)
!
! normalize repeat accumulators and
! calculate standard deviations
!
!V090927:
      arwgt=1.d0*nmc_rep
      if(jrpwgt(2).eq.1.or.jrpwgt(2).eq.2) then
        arwgt=0.d0
        do imc_rep=1,nmc_rep
          arwgt=arwgt+amwgt_rep(imc_rep)
        enddo
      endif
!
      if(arwgt.gt.0.d0) then
        anorm_r=1.d0/arwgt
      else
        anorm_r=1.d0
      endif
!:V090927
!
!
      ar_chisq_n=ar_chisq_n*anorm_r
      dr_chisq_n=dr_chisq_n*anorm_r
      dr_chisq_n=dsqrt(dabs(dr_chisq_n                                  &
     &                     -ar_chisq_n**2)*anorm_r)
!
      ar_chisq=ar_chisq_n*mdtin
      dr_chisq=dr_chisq_n*mdtin
!
      do kscal=1,nkscal
        ar_chi1_ks(kscal)  =                                            &
     &    ar_chi1_ks(kscal)*anorm_r
        dr_chi1_ks(kscal)  =                                            &
     &    dr_chi1_ks(kscal)*anorm_r
        dr_chi1_ks(kscal)  =                                            &
     &    dsqrt(dabs(dr_chi1_ks(kscal)                                  &
     &              -ar_chi1_ks(kscal)**2)*anorm_r)
!
        ar_chi2_ks(kscal)  =                                            &
     &    ar_chi2_ks(kscal)*anorm_r
        dr_chi2_ks(kscal)  =                                            &
     &    dr_chi2_ks(kscal)*anorm_r
        dr_chi2_ks(kscal)  =                                            &
     &    dsqrt(dabs(dr_chi2_ks(kscal)                                  &
     &              -ar_chi2_ks(kscal)**2)*anorm_r)
!
        ar_sxplog_ks(kscal)  =                                          &
     &    ar_sxplog_ks(kscal)*anorm_r
        dr_sxplog_ks(kscal)  =                                          &
     &    dr_sxplog_ks(kscal)*anorm_r
        dr_sxplog_ks(kscal)  =                                          &
     &    dsqrt(dabs(dr_sxplog_ks(kscal)                                &
     &              -ar_sxplog_ks(kscal)**2)*anorm_r)
      enddo
!
      do iscal=1,niscal
        ar_chi1_is(iscal)  =                                            &
     &    ar_chi1_is(iscal)*anorm_r
        dr_chi1_is(iscal)  =                                            &
     &    dr_chi1_is(iscal)*anorm_r
        dr_chi1_is(iscal)  =                                            &
     &    dsqrt(dabs(dr_chi1_is(iscal)                                  &
     &              -ar_chi1_is(iscal)**2)*anorm_r)
!
        ar_chi2_is(iscal)  =                                            &
     &    ar_chi2_is(iscal)*anorm_r
        dr_chi2_is(iscal)  =                                            &
     &    dr_chi2_is(iscal)*anorm_r
        dr_chi2_is(iscal)  =                                            &
     &    dsqrt(dabs(dr_chi2_is(iscal)                                  &
     &              -ar_chi2_is(iscal)**2)*anorm_r)
!
        ar_sxplog_is(iscal)  =                                          &
     &    ar_sxplog_is(iscal)*anorm_r
        dr_sxplog_is(iscal)  =                                          &
     &    dr_sxplog_is(iscal)*anorm_r
        dr_sxplog_is(iscal)  =                                          &
     &    dsqrt(dabs(dr_sxplog_is(iscal)                                &
     &              -ar_sxplog_is(iscal)**2)*anorm_r)
      enddo
!
!
!
!V090911:
!Fixed lcrdp-Bug:
!!!   do idpen=1,mdpen_tot
      do lcrdp=1,mdpen_tot
        idpen0=idpen_crdp(lcrdp)
        if(ispec_dpen(idpen0).gt.0) npow_dpen=npow_spec
        if(ireac_dpen(idpen0).gt.0) npow_dpen=npow_reac
!!!     if(ispec_dpen(idpen).gt.0) npow_dpen=npow_spec
!!!     if(ireac_dpen(idpen).gt.0) npow_dpen=npow_reac
!
        do ipow=1,npow_dpen
!!!       ar_crdpen(idpen,ipow)=ar_crdpen(idpen,ipow)*anorm_r
!!!       dr_crdpen(idpen,ipow)=dr_crdpen(idpen,ipow)*anorm_r
!
          ar_crdpen(lcrdp,ipow)=ar_crdpen(lcrdp,ipow)*anorm_r
          dr_crdpen(lcrdp,ipow)=dr_crdpen(lcrdp,ipow)*anorm_r
!:V090911
        enddo
      enddo
!
!V090911:
!Fixed lcrdp-Bug:
!!!   do idpen=1,mdpen_tot
      do lcrdp=1,mdpen_tot
        idpen0=idpen_crdp(lcrdp)
        if(ispec_dpen(idpen0).gt.0) npow_dpen=npow_spec
        if(ireac_dpen(idpen0).gt.0) npow_dpen=npow_reac
!!!     if(ispec_dpen(idpen).gt.0) npow_dpen=npow_spec
!!!     if(ireac_dpen(idpen).gt.0) npow_dpen=npow_reac
!
        do ipow=1,npow_dpen
!!!       dr_crdpen(idpen,ipow)=                                        &
!!!  &    dsqrt(                                                        &
!!!  &    dabs(                                                         &
!!!  &         dr_crdpen(idpen,ipow)                                    &
!!!  &        -ar_crdpen(idpen,ipow)**2                                 &
!!!  &        )                                                         &
!!!  &        *anorm_r)
!
          dr_crdpen(lcrdp,ipow)=                                        &
     &    dsqrt(                                                        &
     &    dabs(                                                         &
     &         dr_crdpen(lcrdp,ipow)                                    &
     &        -ar_crdpen(lcrdp,ipow)**2                                 &
     &        )                                                         &
     &        *anorm_r)
!:V090911
        enddo
      enddo
!
!
      do ipow=1,npow_spec
        do ith=1,mth_spec
          ar_cspec(ith,ipow)=ar_cspec(ith,ipow)*anorm_r
          dr_cspec(ith,ipow)=dr_cspec(ith,ipow)*anorm_r
        enddo
      enddo
!
      do ipow=1,npow_spec
        do ith=1,mth_spec
          dr_cspec(ith,ipow)=                                           &
     &    dsqrt(                                                        &
     &    dabs(                                                         &
     &         dr_cspec(ith,ipow)                                       &
     &        -ar_cspec(ith,ipow)**2                                    &
     &        )                                                         &
     &        *anorm_r)
        enddo
      enddo
!
!
      do ipow=1,npow_reac
        do ith=1,mth_reac
          ar_rreac(ith,ipow)=ar_rreac(ith,ipow)*anorm_r
          dr_rreac(ith,ipow)=dr_rreac(ith,ipow)*anorm_r
        enddo
      enddo
!
      do ipow=1,npow_reac
        do ith=1,mth_reac
          dr_rreac(ith,ipow)=                                           &
     &    dsqrt(                                                        &
     &    dabs(                                                         &
     &         dr_rreac(ith,ipow)                                       &
     &        -ar_rreac(ith,ipow)**2                                    &
     &        )                                                         &
     &        *anorm_r)
        enddo
      enddo
!
!
!
!
      ar_htot=ar_htot*anorm_r
      dr_htot=dr_htot*anorm_r
      dr_htot=dsqrt(dabs(dr_htot                                        &
     &                  -ar_htot**2)*anorm_r)
!
      ar_hwall=ar_hwall*anorm_r
      dr_hwall=dr_hwall*anorm_r
      dr_hwall=dsqrt(dabs(dr_hwall                                      &
     &                      -ar_hwall**2)*anorm_r)
!
      ar_hbxx=ar_hbxx*anorm_r
      dr_hbxx=dr_hbxx*anorm_r
      dr_hbxx=dsqrt(dabs(dr_hbxx                                        &
     &                  -ar_hbxx**2)*anorm_r)
!
      ar_hbxn=ar_hbxn*anorm_r
      dr_hbxn=dr_hbxn*anorm_r
      dr_hbxn=dsqrt(dabs(dr_hbxn                                        &
     &                  -ar_hbxn**2)*anorm_r)
!
      ar_hfour=ar_hfour*anorm_r
      dr_hfour=dr_hfour*anorm_r
      dr_hfour=dsqrt(dabs(dr_hfour                                      &
     &                      -ar_hfour**2)*anorm_r)
!
      ar_hfous=ar_hfous*anorm_r
      dr_hfous=dr_hfous*anorm_r
      dr_hfous=dsqrt(dabs(dr_hfous                                      &
     &                      -ar_hfous**2)*anorm_r)
!
      ar_hfout=ar_hfout*anorm_r
      dr_hfout=dr_hfout*anorm_r
      dr_hfout=dsqrt(dabs(dr_hfout                                      &
     &                      -ar_hfout**2)*anorm_r)
!
!
      do ivs=0,nvs_spec
        ar_qbxx(ivs)=ar_qbxx(ivs)*anorm_r
        dr_qbxx(ivs)=dr_qbxx(ivs)*anorm_r
        dr_qbxx(ivs)=dsqrt(dabs(dr_qbxx(ivs)                            &
     &                         -ar_qbxx(ivs)**2)*anorm_r)
!
        ar_fbxx(ivs)=ar_fbxx(ivs)*anorm_r
        dr_fbxx(ivs)=dr_fbxx(ivs)*anorm_r
        dr_fbxx(ivs)=dsqrt(dabs(dr_fbxx(ivs)                            &
     &                         -ar_fbxx(ivs)**2)*anorm_r)
!
        ar_qbxn(ivs)=ar_qbxn(ivs)*anorm_r
        dr_qbxn(ivs)=dr_qbxn(ivs)*anorm_r
        dr_qbxn(ivs)=dsqrt(dabs(dr_qbxn(ivs)                            &
     &                         -ar_qbxn(ivs)**2)*anorm_r)
!
        ar_fbxn(ivs)=ar_fbxn(ivs)*anorm_r
        dr_fbxn(ivs)=dr_fbxn(ivs)*anorm_r
        dr_fbxn(ivs)=dsqrt(dabs(dr_fbxn(ivs)                            &
     &                         -ar_fbxn(ivs)**2)*anorm_r)
      enddo
!
!
      do iexpt=1,nexpt
        do isegft=1,nsegft(iexpt)
          ar_pfour_seg(isegft,iexpt)=                                   &
     &    ar_pfour_seg(isegft,iexpt)*anorm_r
!
          dr_pfour_seg(isegft,iexpt)=                                   &
     &    dr_pfour_seg(isegft,iexpt)*anorm_r
!
          dr_pfour_seg(isegft,iexpt)=                                   &
     &    dsqrt(dabs(dr_pfour_seg(isegft,iexpt)                         &
     &              -ar_pfour_seg(isegft,iexpt)**2))
!
          ar_qfour_seg(isegft,iexpt)=                                   &
     &    ar_qfour_seg(isegft,iexpt)*anorm_r
!
          dr_qfour_seg(isegft,iexpt)=                                   &
     &    dr_qfour_seg(isegft,iexpt)*anorm_r
!
          dr_qfour_seg(isegft,iexpt)=                                   &
     &    dsqrt(dabs(dr_qfour_seg(isegft,iexpt)                         &
     &              -ar_qfour_seg(isegft,iexpt)**2))
!
          do is_ft=1,nsft_spec
            ar_pfour_sfil(is_ft,isegft,iexpt)=                          &
     &      ar_pfour_sfil(is_ft,isegft,iexpt)*anorm_r
!
            dr_pfour_sfil(is_ft,isegft,iexpt)=                          &
     &      dr_pfour_sfil(is_ft,isegft,iexpt)*anorm_r
!
            dr_pfour_sfil(is_ft,isegft,iexpt)=                          &
     &      dsqrt(dabs(dr_pfour_sfil(is_ft,isegft,iexpt)                &
     &                -ar_pfour_sfil(is_ft,isegft,iexpt)**2))
!
            ar_pfour_stot(is_ft,isegft,iexpt)=                          &
     &      ar_pfour_stot(is_ft,isegft,iexpt)*anorm_r
!
            dr_pfour_stot(is_ft,isegft,iexpt)=                          &
     &      dr_pfour_stot(is_ft,isegft,iexpt)*anorm_r
!
            dr_pfour_stot(is_ft,isegft,iexpt)=                          &
     &      dsqrt(dabs(dr_pfour_stot(is_ft,isegft,iexpt)                &
     &                -ar_pfour_stot(is_ft,isegft,iexpt)**2))
          enddo
        enddo
      enddo
!
!
      if(jo_ar.eq.10) then
        do iexpt=1,nexpt
!c        do ivs=1,nvs_spec_o(iexpt)
          do ispec=1,nspec_o(iexpt)
            do ipow=1,npow_spec
              do io_time=1,no_time
                ar_xspec(io_time,ispec,iexpt,ipow)=                     &
     &            ar_xspec(io_time,ispec,iexpt,ipow)*anorm_r
                dr_xspec(io_time,ispec,iexpt,ipow)=                     &
     &            dr_xspec(io_time,ispec,iexpt,ipow)*anorm_r
!
                ar_yspec(io_time,ispec,iexpt,ipow)=                     &
     &            ar_yspec(io_time,ispec,iexpt,ipow)*anorm_r
                dr_yspec(io_time,ispec,iexpt,ipow)=                     &
     &            dr_yspec(io_time,ispec,iexpt,ipow)*anorm_r
              enddo
            enddo
          enddo
        enddo
!
        do iexpt=1,nexpt
!c        do ivs=1,nvs_spec_o(iexpt)
          do ispec=1,nspec_o(iexpt)
            do ipow=1,npow_spec
              do io_time=1,no_time
                dr_xspec(io_time,ispec,iexpt,ipow)=                     &
     &          dsqrt(                                                  &
     &          dabs(                                                   &
     &               dr_xspec(io_time,ispec,iexpt,ipow)                 &
     &              -ar_xspec(io_time,ispec,iexpt,ipow)**2              &
     &              )                                                   &
     &              *anorm_r)
!
                dr_yspec(io_time,ispec,iexpt,ipow)=                     &
     &          dsqrt(                                                  &
     &          dabs(                                                   &
     &               dr_yspec(io_time,ispec,iexpt,ipow)                 &
     &              -ar_yspec(io_time,ispec,iexpt,ipow)**2              &
     &              )                                                   &
     &              *anorm_r)
              enddo
            enddo
          enddo
        enddo
      endif
!
!
! calculate acceptance ratios
!
! ... by move sequence step:
!
      do ipmty=1,3
        do jmvloop=1,2
          do imvsequ=1,nmvsequ(jmvloop)
            nprop_tot=0
            naccp_tot=0
!
            do ith=1,mth_ty(ipmty)
              if(nprop(ith,imvsequ,jmvloop,ipmty).gt.0) then
                raccp(ith,imvsequ,jmvloop,ipmty)=                       &
     &          naccp(ith,imvsequ,jmvloop,ipmty)                        &
     &          /(1.d0*nprop(ith,imvsequ,jmvloop,ipmty))
              else
                raccp(ith,imvsequ,jmvloop,ipmty)=-1.d0
              endif
!
              nprop_tot=nprop_tot+nprop(ith,imvsequ,jmvloop,ipmty)
              naccp_tot=naccp_tot+naccp(ith,imvsequ,jmvloop,ipmty)
            enddo
!
            ith=0
            nprop(ith,imvsequ,jmvloop,ipmty)=nprop_tot
            naccp(ith,imvsequ,jmvloop,ipmty)=naccp_tot
!
            if(nprop_tot.gt.0) then
              raccp(ith,imvsequ,jmvloop,ipmty)=                         &
     &        naccp_tot/(1.d0*nprop_tot)
            else
              raccp(ith,imvsequ,jmvloop,ipmty)=-1.d0
            endif
          enddo
        enddo
      enddo
!
! ... by move type:
!
      do ipmty=1,3
        do jmvloop=1,2
          do ljmty=1,njmty(jmvloop)
            do ith=1,mth_ty(ipmty)
              nprop_ty(ith,ljmty,jmvloop,ipmty)=0
              naccp_ty(ith,ljmty,jmvloop,ipmty)=0
            enddo
          enddo
        enddo
      enddo
!
      do ipmty=1,3
        do jmvloop=1,2
          do imvsequ=1,nmvsequ(jmvloop)
            do ith=1,mth_ty(ipmty)
              nprop_ty(ith,ljmty_mvs(imvsequ,jmvloop),jmvloop,ipmty)=   &
     &        nprop_ty(ith,ljmty_mvs(imvsequ,jmvloop),jmvloop,ipmty)    &
     &        +nprop(ith,imvsequ,jmvloop,ipmty)
!
              naccp_ty(ith,ljmty_mvs(imvsequ,jmvloop),jmvloop,ipmty)=   &
     &        naccp_ty(ith,ljmty_mvs(imvsequ,jmvloop),jmvloop,ipmty)    &
     &        +naccp(ith,imvsequ,jmvloop,ipmty)
            enddo
          enddo
        enddo
      enddo
!
      do ipmty=1,3
        do jmvloop=1,2
          do ljmty=1,njmty(jmvloop)
            nprop_tot=0
            naccp_tot=0
            do ith=1,mth_ty(ipmty)
              if(nprop_ty(ith,ljmty,jmvloop,ipmty).gt.0) then
                raccp_ty(ith,ljmty,jmvloop,ipmty)=                      &
     &          naccp_ty(ith,ljmty,jmvloop,ipmty)                       &
     &          /(1.d0*                                                 &
     &          nprop_ty(ith,ljmty,jmvloop,ipmty)                       &
     &          )
              else
                raccp_ty(ith,ljmty,jmvloop,ipmty)=-1.d0
              endif
!
              nprop_tot=nprop_tot                                       &
     &                 +nprop_ty(ith,ljmty,jmvloop,ipmty)
              naccp_tot=naccp_tot                                       &
     &                 +naccp_ty(ith,ljmty,jmvloop,ipmty)
            enddo
!
            ith=0
            nprop_ty(ith,ljmty,jmvloop,ipmty)=nprop_tot
            naccp_ty(ith,ljmty,jmvloop,ipmty)=naccp_tot
!
            if(nprop_tot.gt.0) then
              raccp_ty(ith,ljmty,jmvloop,ipmty)=                        &
     &        naccp_tot/(1.d0*nprop_tot)
            else
              raccp_ty(ith,ljmty,jmvloop,ipmty)=-1.d0
            endif
          enddo
        enddo
      enddo
!
! ... by Theta parameter
!
!
      do ith=1,mth_reac
        do jmvloop=1,2
          nprop_reac(ith,jmvloop)=0
          naccp_reac(ith,jmvloop)=0
        enddo
      enddo
!
      do ith=1,mth_spec
        do jmvloop=1,2
          nprop_spec(ith,jmvloop)=0
          naccp_spec(ith,jmvloop)=0
        enddo
      enddo
!
      do ipmty=1,2
        do jmvloop=1,2
          do imvsequ=1,nmvsequ(jmvloop)
            do ith=1,mth_ty(ipmty)
              if(ipmty.eq.1) then
                nprop_reac(ith,jmvloop)=                                &
     &          nprop_reac(ith,jmvloop)                                 &
     &          +nprop(ith,imvsequ,jmvloop,1)
!
                naccp_reac(ith,jmvloop)=                                &
     &          naccp_reac(ith,jmvloop)                                 &
     &          +naccp(ith,imvsequ,jmvloop,1)
              endif
!
              if(ipmty.eq.2) then
                nprop_spec(ith,jmvloop)=                                &
     &          nprop_spec(ith,jmvloop)                                 &
     &          +nprop(ith,imvsequ,jmvloop,2)
!
                naccp_spec(ith,jmvloop)=                                &
     &          naccp_spec(ith,jmvloop)                                 &
     &          +naccp(ith,imvsequ,jmvloop,2)
              endif
            enddo
          enddo
        enddo
      enddo
!
      do jmvloop=1,2
        do ith=1,mth_reac
          if(nprop_reac(ith,jmvloop).gt.0) then
            raccp_reac(ith,jmvloop)=                                    &
     &      naccp_reac(ith,jmvloop)                                     &
     &      /(1.d0*nprop_reac(ith,jmvloop))
          else
            raccp_reac(ith,jmvloop)=-1.d0
          endif
        enddo
      enddo
!
      do jmvloop=1,2
        do ith=1,mth_spec
          if(nprop_spec(ith,jmvloop).gt.0) then
            raccp_spec(ith,jmvloop)=                                    &
     &      naccp_spec(ith,jmvloop)                                     &
     &      /(1.d0*nprop_spec(ith,jmvloop))
          else
            raccp_spec(ith,jmvloop)=-1.d0
          endif
        enddo
      enddo
!
! ... for Hamiltonian moves
!
      do jmvloop=1,2
        do imvsequ=1,nmvsequ(jmvloop)
          if(nprop_ham(imvsequ,jmvloop).gt.0) then
            raccp_ham(imvsequ,jmvloop)=                                 &
     &      naccp_ham(imvsequ,jmvloop)                                  &
     &      /(1.d0*nprop_ham(imvsequ,jmvloop))
          else
            raccp_ham(imvsequ,jmvloop)=-1.d0
          endif
        enddo
      enddo
!
!
!
      do jmvloop=1,2
        do ispec=1,nspec
          if(nkin_run(jmvloop).gt.0) then
            a_lspec_max(ispec,jmvloop)=                                 &
     &      a_lspec_max(ispec,jmvloop)/nkin_run(jmvloop)
            a_lspec_min(ispec,jmvloop)=                                 &
     &      a_lspec_min(ispec,jmvloop)/nkin_run(jmvloop)
!
            r_lspec_max(ispec,jmvloop)=                                 &
     &      r_lspec_max(ispec,jmvloop)/nkin_run(jmvloop)
            r_lspec_min(ispec,jmvloop)=                                 &
     &      r_lspec_min(ispec,jmvloop)/nkin_run(jmvloop)
          else
            a_lspec_max(ispec,jmvloop)=-1.d0
            a_lspec_min(ispec,jmvloop)=-1.d0
!
            r_lspec_max(ispec,jmvloop)=-1.d0
            r_lspec_min(ispec,jmvloop)=-1.d0
          endif
        enddo
        do ireac=1,nreac
          if(nkin_run(jmvloop).gt.0) then
            a_lvfor(ireac,jmvloop)=                                     &
     &      a_lvfor(ireac,jmvloop)/nkin_run(jmvloop)
            a_lvbak(ireac,jmvloop)=                                     &
     &      a_lvbak(ireac,jmvloop)/nkin_run(jmvloop)
            a_lvreac(ireac,jmvloop)=                                    &
     &      a_lvreac(ireac,jmvloop)/nkin_run(jmvloop)
!
            r_lvfor(ireac,jmvloop)=                                     &
     &      r_lvfor(ireac,jmvloop)/nkin_run(jmvloop)
            r_lvbak(ireac,jmvloop)=                                     &
     &      r_lvbak(ireac,jmvloop)/nkin_run(jmvloop)
            r_lvreac(ireac,jmvloop)=                                    &
     &      r_lvreac(ireac,jmvloop)/nkin_run(jmvloop)
          else
            a_lvfor(ireac,jmvloop)=-1.d0
            a_lvbak(ireac,jmvloop)=-1.d0
            a_lvreac(ireac,jmvloop)=-1.d0
!
            r_lvfor(ireac,jmvloop)=-1.d0
            r_lvbak(ireac,jmvloop)=-1.d0
            r_lvreac(ireac,jmvloop)=-1.d0
          endif
        enddo
      enddo
!
!
      do jmvloop=1,2
        do ith_ham=1,mth_tot
          if(nprop_ham_ini(jmvloop).gt.0) then
            aforce_propi(ith_ham,jmvloop)=                              &
     &      dsqrt(                                                      &
     &      aforce_propi(ith_ham,jmvloop)/nprop_ham_ini(jmvloop))
          else
            aforce_propi(ith_ham,jmvloop)=-1.d0
          endif
!
          if(nprop_ham_fin(jmvloop).gt.0) then
            aforce_propf(ith_ham,jmvloop)=                              &
     &      dsqrt(                                                      &
     &      aforce_propf(ith_ham,jmvloop)/nprop_ham_fin(jmvloop))
!
            adhevl_propf(ith_ham,jmvloop)=                              &
     &      dsqrt(                                                      &
     &      adhevl_propf(ith_ham,jmvloop)/nprop_ham_fin(jmvloop))
          else
            aforce_propf(ith_ham,jmvloop)=-1.d0
            adhevl_propf(ith_ham,jmvloop)=-1.d0
          endif
!
          if(naccp_ham_fin(jmvloop).gt.0) then
            aforce_accpf(ith_ham,jmvloop)=                              &
     &      dsqrt(                                                      &
     &      aforce_accpf(ith_ham,jmvloop)/naccp_ham_fin(jmvloop))
!
            adhevl_accpf(ith_ham,jmvloop)=                              &
     &      dsqrt(                                                      &
     &      adhevl_accpf(ith_ham,jmvloop)/naccp_ham_fin(jmvloop))
          else
            aforce_accpf(ith_ham,jmvloop)=-1.d0
            adhevl_accpf(ith_ham,jmvloop)=-1.d0
          endif
        enddo
        ith_ham=-1
      enddo
!
!
      do jmvloop=1,2
        if(nprop_ham_ini(jmvloop).gt.0) then
          htot_ham_propi(jmvloop)=                                      &
     &    htot_ham_propi(jmvloop)/nprop_ham_ini(jmvloop)
        else
          htot_ham_propi(jmvloop)=-1.d0
        endif
!
        if(nprop_ham_fin(jmvloop).gt.0) then
          htot_ham_propf(jmvloop)=                                      &
     &    htot_ham_propf(jmvloop)/nprop_ham_fin(jmvloop)
        else
          htot_ham_propf(jmvloop)=-1.d0
        endif
!
        if(naccp_ham_fin(jmvloop).gt.0) then
          htot_ham_accpf(jmvloop)=                                      &
     &    htot_ham_accpf(jmvloop)/naccp_ham_fin(jmvloop)
        else
          htot_ham_accpf(jmvloop)=-1.d0
        endif
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mc_ini_m
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!   initialize fixed control parameters
      ivpm_uf=1
      call setpm_uf
!
!
!   initialize Theta-parameters ...
!
      if(jmc_inir.eq. 10) then
!       ...at lo-Theta MC limit (ivpm=1)
        jinipm_th=1
        ivpm_th=1
      endif
!
!
      if(jmc_inir.eq. 20) then
!       ...at hi-Theta MC limit (ivpm=2)
        jinipm_th=1
        ivpm_th=2
      endif
!
!
      if(jmc_inir.eq. 30) then
!       ...randomly between lo- and hi-Theta MC limits
        jinipm_th=3
      endif
!
!
      if(jmc_inir.eq. 40) then
!       ...with initial-Theta from input (ivpm=4)
        jinipm_th=1
        ivpm_th=4
      endif
!
!
      if(jmc_inir.eq. 50) then
!       ...with true-Theta from input (ivpm=5)
        jinipm_th=1
        ivpm_th=5
      endif
!
      if(                                                               &
     &  (jmc_inir.ge.140.and.jmc_inir.lt.150).or.                       &
     &  (jmc_inir.ge.340.and.jmc_inir.le.399)                           &
     &)then
!         140=<jmc_inir<150:
!         ...with last Theta from previous run,
!       OR
!         340=<jmc_inir=<399:
!         ...with first Theta from previous run, being re-accumulated
!       and Theta stored in "ens.o02"-format in input file "ens.i12"
        jinipm_th=0
        call idat_inipm
      endif
!
!
      if(jmc_inir.ge.240.and.jmc_inir.lt.250.and.jrstart.eq.1) then
!       250>jmc_inir>=240:
!       MC restart with Theta-sequence in "ens.o02";
!       no initialization needed yet; must first find last Theta-block
!       in "ens.o02":
        return
      endif
!
      call setpm_th
!
      jDB_get_chi=20
      call get_chi ! mc_ini_m-01
!
!DRLIM190524-2244:
!     Will likely have mlimdrv=0 here, since Theta is an already
!     accepted read-in from a previous run;
!     or an accepted update from a prior MC move
!:DRLIM190524-2244
!
      call store_chi_th
!
!Db
      jclC=-10
!Fb
      call ck_chimin
!
!
      if(htot_cut.gt.0.d0.and.htot_th.gt.htot_cut) then
            errtag='000112'
            call err_term
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mc_ini_swopt
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
      if(jmc_inir.eq.361) return
!
! (re-)initialize stepwidth modifiers and accp. counters
! for optimizing MC max. stepwidths to get preset acceptance ratios
!
      do ith_swo=1,mth_swo
        nprop_swo(ith_swo)=0
        nprop_up_swo(ith_swo)=0
        naccp_swo(ith_swo)=0
        naccp_up_swo(ith_swo)=0
        raccp_swo(ith_swo)=-1.d0
        jstp_swo(ith_swo)=0
        astp_swo(ith_swo)=0.5d0
!
        if(                                                             &
     &  .not.                                                           &
     &  (    (jmc_inir.eq.141.or.jmc_inir.eq.143.or.                    &
     &        jmc_inir.eq.341)                                          &
     &       .and.imc_rep.eq.1)                                         &
     &  )                                                               &
     &  fstp_swo(ith_swo)=1.0d0
!
!
        jout_swo(ith_swo)=0
        if(ith_swo.le.mth_spec)                                         &
     &  jout_swo(ith_swo)=1
        if(ith_swo.le.mth_tot.and.ith_swo.gt.mth_spec)                  &
     &  jout_swo(ith_swo)=2
      enddo
      jout_swo(mth_tot+ 1)=101
      jout_swo(mth_tot+11)=111
      jout_swo(mth_tot+12)=112
!
      jout_swo(mth_tot+21)=121
      jout_swo(mth_tot+22)=122
      jout_swo(mth_tot+23)=123
      jout_swo(mth_tot+24)=124
      jout_swo(mth_tot+25)=125
!
      jout_swo(mth_tot+31)=131
      jout_swo(mth_tot+32)=132
      jout_swo(mth_tot+33)=133
      jout_swo(mth_tot+34)=134
      jout_swo(mth_tot+35)=135
!
      jout_swo(mth_tot+41)=141
      jout_swo(mth_tot+42)=142
      jout_swo(mth_tot+43)=143
      jout_swo(mth_tot+44)=144
      jout_swo(mth_tot+45)=145
!
!
!DRLIM190524-2244: jo_th_lmdrv==1 -> Enable lim-drv output by ith
      mth_limd=mth_swo
      do ith_limd=1,mth_limd
        jout_limd(ith_limd)=jout_swo(ith_limd)
      enddo
!:DRLIM190524-2244
!
!
      do ipop=0,npopst_x
        nprop_pop(ipop)=0
        nprop_up_pop(ipop)=0
        naccp_pop(ipop)=0
        naccp_up_pop(ipop)=0
        raccp_pop(ipop)=-1.d0
        jstp_pop(ipop)=0
        astp_pop(ipop)=0.5d0
!
        if(                                                             &
     &  .not.                                                           &
     &  (    (jmc_inir.eq.141.or.jmc_inir.eq.143.or.                    &
     &        jmc_inir.eq.341)                                          &
     &       .and.imc_rep.eq.1)                                         &
     &  )                                                               &
     &  fstp_pop(ipop)=1.0d0
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mc_ini_fbxa
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! initialize accumulators for boundary contact force adjuster
!
      neq_fbx=0
      nac_fbx=0
      nac_fbxo=-1
      do ivs=0,nvs_spec
        qbxx_fbx(ivs)=0.d0
        q2bxx_fbx(ivs)=0.d0
        fbxx(ivs)=0.d0
        qbxx_fbxo(ivs)=-1.d0
        cbxx_fbxo(ivs)=-1.d0
!
        qbxn_fbx(ivs)=0.d0
        q2bxn_fbx(ivs)=0.d0
        fbxn(ivs)=0.d0
        qbxn_fbxo(ivs)=-1.d0
        cbxn_fbxo(ivs)=-1.d0
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mc_zero_m
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
! zero MC accumulators
!
      am_chisq_n=0.d0
!
      do kscal=1,nkscal
        am_chi1_ks(kscal)=0.d0
        am_chi2_ks(kscal)=0.d0
        am_sxplog_ks(kscal)=0.d0
      enddo
!
      do iscal=1,niscal
        am_chi1_is(iscal)=0.d0
        am_chi2_is(iscal)=0.d0
        am_sxplog_is(iscal)=0.d0
      enddo
!
!V090911:
!Fixed lcrdp-Bug:
!!!   do idpen=1,mdpen_tot
      do lcrdp=1,mdpen_tot
        idpen0=idpen_crdp(lcrdp)
        if(ispec_dpen(idpen0).gt.0) npow_dpen=npow_spec
        if(ireac_dpen(idpen0).gt.0) npow_dpen=npow_reac
!!!     if(ispec_dpen(idpen).gt.0) npow_dpen=npow_spec
!!!     if(ireac_dpen(idpen).gt.0) npow_dpen=npow_reac
!
        do ipow=1,npow_dpen
!!!       am_crdpen(idpen,ipow)=0.d0
!
          am_crdpen(lcrdp,ipow)=0.d0
!:V090911
        enddo
      enddo
!
!
      do ipow=1,npow_spec
        do ith=1,mth_spec
          am_cspec(ith,ipow)=0.d0
        enddo
      enddo
!
      do ipow=1,npow_reac
        do ith=1,mth_reac
          am_rreac(ith,ipow)=0.d0
        enddo
      enddo
!
!
      am_htot=0.d0
      am_hwall=0.d0
      am_hbxx=0.d0
      am_hbxn=0.d0
      am_hfour=0.d0
      am_hfous=0.d0
      am_hfout=0.d0
!
      do ivs=0,nvs_spec
        am_qbxx(ivs)=0.d0
        am_fbxx(ivs)=0.d0
        am_qbxn(ivs)=0.d0
        am_fbxn(ivs)=0.d0
      enddo
!
!
      do iexpt=1,nexpt
        do isegft=1,nsegft(iexpt)
          am_pfour_seg(isegft,iexpt)=0.d0
          am_qfour_seg(isegft,iexpt)=0.d0
          do is_ft=1,nsft_spec
            am_pfour_sfil(is_ft,isegft,iexpt)=0.d0
            am_pfour_stot(is_ft,isegft,iexpt)=0.d0
          enddo
        enddo
      enddo
!
!
      if(jo_ar.eq.10) then
        do iexpt=1,nexpt
          do ispec=1,nspec_o(iexpt)
            do ipow=1,npow_spec
              do io_time=1,no_time
                am_xspec(io_time,ispec,iexpt,ipow)=0.d0
                am_yspec(io_time,ispec,iexpt,ipow)=0.d0
              enddo
            enddo
          enddo
        enddo
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mc_accu_m
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
      if(jmc_inir.eq.361) then
        if(jo_th.eq.41) call odat_th ! mc_accu_m-01
        return
      endif
!
      if(imc_smp.eq.1.and..not.(jmc_inir.ge.340.and.jmc_inir.le.399))   &
     & return
!
! accumulate MC scores
!
      if(jrstart.eq.1) then
        jmvloop=2
        kmvsequ=nmvsequ(jmvloop)
        imvsequ=kmvsequ
        kmvsequ_lp=kmvsequ
!
        kmove=nmove(kmvsequ,jmvloop)
!
!
        call sch_fts
        call sch_fwgt
        call sch_fbound
        call sch_ffour
        jmp_kin0=jmp_kin
        jmp_kin=1
        jDB_get_chi=21
        call get_chi ! mc_accu_m-01
!
!DRLIM190524-2244:
!       Will likely have mlimdrv=0 here, since Theta is an already
!       accepted update from a prior MC move
!:DRLIM190524-2244
!
        jmp_kin=jmp_kin0
!
        call store_chi_th
!
        if(jmc_inir.ge.340.and.jmc_inir.le.399) then
!Db
      jclC=-11
!Fb
          call ck_chimin
!
          jclO=-144
          if(jo_th.eq.41) call odat_th ! mc_accu_m-02
          call ck_stop_swp
        endif
!
        kmvsequ=-1
        imvsequ=-1
        kmvsequ_lp=-1
        imove=-1
      endif
!
!
! Write out record of score accum. into "ens.o05"
      call odat_acc
!
      am_chisq_n=am_chisq_n+chisq_th
!
      do kscal=1,nkscal
        am_chi1_ks(kscal)  =                                            &
     &    am_chi1_ks(kscal)+chi1_ks_th(kscal)
        am_chi2_ks(kscal)  =                                            &
     &    am_chi2_ks(kscal)+chi2_ks_th(kscal)
        am_sxplog_ks(kscal)  =                                          &
     &    am_sxplog_ks(kscal)+sxplog_ks_th(kscal)
      enddo
!
      do iscal=1,niscal
        am_chi1_is(iscal)  =                                            &
     &    am_chi1_is(iscal)+chi1_is_th(iscal)
        am_chi2_is(iscal)  =                                            &
     &    am_chi2_is(iscal)+chi2_is_th(iscal)
        am_sxplog_is(iscal)  =                                          &
     &    am_sxplog_is(iscal)+sxplog_is_th(iscal)
      enddo
!
!
      do iexpt=1,nexpt
        ivpm_uv=iexpt
        call setpm_uv
        call get_pdpen
      enddo
!
!V090911:
!Fixed lcrdp-Bug:
!!!   do idpen=1,mdpen_tot
      do lcrdp=1,mdpen_tot
        idpen0=idpen_crdp(lcrdp)
        if(ispec_dpen(idpen0).gt.0) npow_dpen=npow_spec
        if(ireac_dpen(idpen0).gt.0) npow_dpen=npow_reac
!!!     if(ispec_dpen(idpen).gt.0) npow_dpen=npow_spec
!!!     if(ireac_dpen(idpen).gt.0) npow_dpen=npow_reac
!
        do ipow=1,npow_dpen
!!!       am_crdpen(idpen,ipow)=am_crdpen(idpen,ipow)                   &
!!!  &                         +crdpen(idpen)**ipow
!
          am_crdpen(lcrdp,ipow)=am_crdpen(lcrdp,ipow)                   &
     &                         +crdpen(lcrdp)**ipow
!:V090911
        enddo
      enddo
!
!
      do ith=1,mth_spec
        ispec=ispec_th(ith)
        ipm=ipmspec_th(ith)
!
        do ipow=1,npow_spec
          am_cspec(ith,ipow)=am_cspec(ith,ipow)                         &
     &                      +cspec(ispec,ipm)**ipow
        enddo
      enddo
!
      do ith=1,mth_reac
        ireac=ireac_th(ith)
        ipm=ipmreac_th(ith)
        rreac0=rreac(ireac,ipm)
!
        do ipow=1,npow_reac
          am_rreac(ith,ipow)=am_rreac(ith,ipow)+rreac0**ipow
        enddo
      enddo
!
!
      am_htot=am_htot+htot_th
      am_hwall=am_hwall+hwall_th
      am_hbxx=am_hbxx+hbxx_th
      am_hbxn=am_hbxn+hbxn_th
      am_hfour=am_hfour+hfour_th
      am_hfous=am_hfous+hfous_th
      am_hfout=am_hfout+hfout_th
!
      do ivs=0,nvs_spec
        am_qbxx(ivs)=am_qbxx(ivs)+qbxx_th(ivs)
        am_fbxx(ivs)=am_fbxx(ivs)+fbxx_th(ivs)
        am_qbxn(ivs)=am_qbxn(ivs)+qbxn_th(ivs)
        am_fbxn(ivs)=am_fbxn(ivs)+fbxn_th(ivs)
      enddo
!
      do iexpt=1,nexpt
        do isegft=1,nsegft(iexpt)
          am_pfour_seg(isegft,iexpt)=                                   &
     &    am_pfour_seg(isegft,iexpt)                                    &
     &    +pfour_seg_th(isegft,iexpt)
!
          am_qfour_seg(isegft,iexpt)=                                   &
     &    am_qfour_seg(isegft,iexpt)                                    &
     &    +qfour_seg_th(isegft,iexpt)
          do is_ft=1,nsft_spec
            am_pfour_sfil(is_ft,isegft,iexpt)=                          &
     &      am_pfour_sfil(is_ft,isegft,iexpt)                           &
     &      +pfour_sfil_th(is_ft,isegft,iexpt)
!
            am_pfour_stot(is_ft,isegft,iexpt)=                          &
     &      am_pfour_stot(is_ft,isegft,iexpt)                           &
     &      +pfour_stot_th(is_ft,isegft,iexpt)
          enddo
        enddo
      enddo
!
!
      if(jo_ar.eq.10) then
!       parallelized:
!       -------------
        jmp_kin0=jmp_kin
        jmp_kin=2
        call mpm_getkin ! mc_accu_m-01
        jmp_kin=jmp_kin0
!
!c      call store_sfxdi
!c      call get_xdi
        do iexpt=1,nexpt
!!        ivpm_uv=iexpt
!!        call setpm_uv
!!        call kin_ini
!!        call kin_run
!!        call kin_xspec_o
!
          do ispec=1,nspec_o(iexpt)
            do io_time=1,no_time
              do ipow=1,npow_spec
                am_xspec(io_time,ispec,iexpt,ipow)=                     &
     &            am_xspec(io_time,ispec,iexpt,ipow)                    &
     &           +xspec_o(ispec,io_time,iexpt)**ipow
!
                am_yspec(io_time,ispec,iexpt,ipow)=                     &
     &            am_yspec(io_time,ispec,iexpt,ipow)                    &
     &           +yspec_o(ispec,io_time,iexpt)**ipow
              enddo
            enddo
          enddo
        enddo
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine odat_th
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! writes out MC movable "Theta" values of
! "cspec", "rkfor", "rkbak", "rkfor2", "rkbak2"
!
      if(jrstart.eq.1.and.                                              &
     &  (jmc_inir.ge.240.and.jmc_inir.lt.250) ) goto 999
!
      jchi_min=0
      if(chisq_th.lt.chisq_th_min0) then
        jchi_min=1
      endif
!
      if(                                                               &
     & imove.eq.1.and.                                                  &
     & jo_th.eq.41.and.                                                 &
     & (jmvloop.eq.1.or.jmvloop.eq.2).and.                              &
     & kmvsequ.ge.1.and.                                                &
     & jo_th_mvs.eq.1.and.                                              &
     & jo_mvsequ.eq.1                                                   &
     &)then
!
! Skipping this output section:
        goto 19
!
        write(32,2010) kmvsequ,jmvloop,nmove(kmvsequ,jmvloop)
 2010   format(/             &
     &  /' Move Sequence No.'                                           &
     &  /' kmvsequ jmvloop   nmove(kmvsequ,jmvloop)'                    &
     &  /3i8                                                            &
     &  )
        imvsequ_i=kmvsequ_lp+1
        if(imvsequ_i.lt.1) imvsequ_i=1
        imvsequ_f=kmvsequ
!
        write(32,2016)
 2016   format(             &
     &  ' imvsequ     jmty_mc  jnorep    jmty   nmove')
!
        write(32,2017)                                                  &
     &  (imvsequ_o,  jmty_mc(imvsequ_o,jmvloop)                         &
     &            ,   jnorep(imvsequ_o,jmvloop)                         &
     &            ,     jmty(imvsequ_o,jmvloop)                         &
     &            ,    nmove(imvsequ_o,jmvloop)                         &
     &            , imvsequ_o=imvsequ_i,imvsequ_f)
 2017   format(i8,i12,3i8)
!
        write(32,2020)
 2020   format(             &
     &  ' imvsequ     jtmp_mc',                                         &
     &  ' jtmp_sx jtmp_kx jtmp_en jtmp_mv     jstp_mc')
!
        write(32,2021)                                                  &
     &  (imvsequ_o,  jtmp_mc(imvsequ_o,jmvloop)                         &
     &            ,  jtmp_sx(imvsequ_o,jmvloop)                         &
     &            ,  jtmp_kx(imvsequ_o,jmvloop)                         &
     &            ,  jtmp_en(imvsequ_o,jmvloop)                         &
     &            ,  jtmp_mv(imvsequ_o,jmvloop)                         &
     &            ,  jstp_mc(imvsequ_o,jmvloop)                         &
     &            , imvsequ_o=imvsequ_i,imvsequ_f)
 2021   format(i8,i12,4i8,i12)
!
!
        write(32,2022)
 2022   format(             &
     &  ' imvsequ      pmvtype     raccp_lo     raccp_hi'               &
     & ,        '      ftmp_mc      fstp_mc')
!
        write(32,2023)                                                  &
     &  (imvsequ_o,  pmvtype(imvsequ_o,jmvloop)                         &
     &            , raccp_lo(imvsequ_o,jmvloop)                         &
     &            , raccp_hi(imvsequ_o,jmvloop)                         &
     &            ,  ftmp_mc(imvsequ_o,jmvloop)                         &
     &            ,  fstp_mc(imvsequ_o,jmvloop)                         &
     &            , imvsequ_o=imvsequ_i,imvsequ_f)
 2023   format(i8,5d13.5)
!
        write(32,2024)
 2024   format(             &
     &  ' imvsequ'                                                      &
     & ,' jwgt_mc jwgt_wc jwgt_sh jwgt_tv jwgt_mv    npwgt(0-1,.)')
!
        write(32,2025)                                                  &
     &  (imvsequ_o,  jwgt_mc(imvsequ_o,jmvloop)                         &
     &            ,  jwgt_wc(imvsequ_o,jmvloop)                         &
     &            ,  jwgt_sh(imvsequ_o,jmvloop)                         &
     &            ,  jwgt_tv(imvsequ_o,jmvloop)                         &
     &            ,  jwgt_mv(imvsequ_o,jmvloop)                         &
     &            ,  npwgt(0,imvsequ_o,jmvloop)                         &
     &            ,  npwgt(1,imvsequ_o,jmvloop)                         &
     &            , imvsequ_o=imvsequ_i,imvsequ_f)
 2025   format(i4,i12,6i8)
!
        if(npwgt(0,kmvsequ,jmvloop).gt.0) then
          write(32,2026)
 2026     format(             &
     &    ' imvsequ/   pwgt_mc(1)    pwgt_mc(2)    pwgt_mc(3)'          &
     &   ,        '    pwgt_mc(4)')
!
          do imvsequ_o=imvsequ_i,imvsequ_f
            write(32,2027) imvsequ_o
 2027       format(i8)
!
            write(32,2028)                                              &
     &      (pwgt_mc(lpwgt,imvsequ_o,jmvloop)                           &
     &      ,lpwgt=1,npwgt(0,kmvsequ,jmvloop))
 2028       format(8x,4d14.6)
          enddo
        endif
!
!
        if(npwgt(1,kmvsequ,jmvloop).gt.0) then
          write(32,2126)
 2126     format(             &
     &    ' imvsequ'/                                                   &
     &    ' lpwgt iexpt_wc0  _wc1 ims_wc0    _wc1'                      &
     &    ,     ' itxpt_wc0  _wc1'                                      &
     &    ,     '         fwgt_wc')
!
          do imvsequ_o=imvsequ_i,imvsequ_f
            write(32,2127) imvsequ_o
 2127       format(i8)
!
            write(32,2128)                                              &
     &      (lpwgt                                                      &
     &      ,iexpt_wc0(lpwgt,imvsequ_o,jmvloop)                         &
     &      ,iexpt_wc1(lpwgt,imvsequ_o,jmvloop)                         &
     &      ,itxpt_wc0(lpwgt,imvsequ_o,jmvloop)                         &
     &      ,itxpt_wc1(lpwgt,imvsequ_o,jmvloop)                         &
     &      , ims_wc0(lpwgt,imvsequ_o,jmvloop)                          &
     &      , ims_wc1(lpwgt,imvsequ_o,jmvloop)                          &
     &      ,pwgt_mc(lpwgt,imvsequ_o,jmvloop)                           &
     &      ,lpwgt=(npwgt(0,kmvsequ,jmvloop)+1)                         &
     &      ,(npwgt(0,kmvsequ,jmvloop)+npwgt(1,kmvsequ,jmvloop))        &
     &      )
 2128       format(i6,6i8,d16.8)
          enddo
        endif
!
!
        write(32,2130)
 2130   format(             &
     &  ' imvsequ    '                                                  &
     & ,' jbxx_mc jbxx_qb jbxx_af jbxx_nf jbxx_mv')
!
        write(32,2131)                                                  &
     &  (imvsequ_o,  jbxx_mc(imvsequ_o,jmvloop)                         &
     &            ,  jbxx_qb(imvsequ_o,jmvloop)                         &
     &            ,  jbxx_af(imvsequ_o,jmvloop)                         &
     &            ,  jbxx_nf(imvsequ_o,jmvloop)                         &
     &            ,  jbxx_mv(imvsequ_o,jmvloop)                         &
     &            , imvsequ_o=imvsequ_i,imvsequ_f)
 2131   format(i8,i12,4i8)
!
!
        write(32,2132)
 2132   format(             &
     &  ' imvsequ      fbxx_mc    bxx_lo_mc    bxx_hi_mc')
!
        write(32,2133)                                                  &
     &  (imvsequ_o,   fbxx_mc(imvsequ_o,jmvloop)                        &
     &            , bxx_lo_mc(imvsequ_o,jmvloop)                        &
     &            , bxx_lo_mc(imvsequ_o,jmvloop)                        &
     &            , imvsequ_o=imvsequ_i,imvsequ_f)
 2133   format(i8,3d13.5)
!
!
        write(32,2134)
 2134   format(             &
     &  ' imvsequ     qqbxx_mc    redbxx_mc afbxx_max_mc')
!
        write(32,2135)                                                  &
     &  (imvsequ_o,     qqbxx_mc(imvsequ_o,jmvloop)                     &
     &            ,    redbxx_mc(imvsequ_o,jmvloop)                     &
     &            , afbxx_max_mc(imvsequ_o,jmvloop)                     &
     &            , imvsequ_o=imvsequ_i,imvsequ_f)
 2135   format(i8,3d13.5)
!
        write(32,2140)
 2140   format(             &
     &  ' imvsequ    '                                                  &
     & ,' jbxn_mc jbxn_qb jbxn_af jbxn_nf jbxn_mv')
!
        write(32,2141)                                                  &
     &  (imvsequ_o,  jbxn_mc(imvsequ_o,jmvloop)                         &
     &            ,  jbxn_qb(imvsequ_o,jmvloop)                         &
     &            ,  jbxn_af(imvsequ_o,jmvloop)                         &
     &            ,  jbxn_nf(imvsequ_o,jmvloop)                         &
     &            ,  jbxn_mv(imvsequ_o,jmvloop)                         &
     &            , imvsequ_o=imvsequ_i,imvsequ_f)
 2141   format(i8,i12,4i8)
!
!
        write(32,2142)
 2142   format(             &
     &  ' imvsequ      fbxn_mc    bxn_lo_mc    bxn_hi_mc')
!
        write(32,2143)                                                  &
     &  (imvsequ_o,   fbxn_mc(imvsequ_o,jmvloop)                        &
     &            , bxn_lo_mc(imvsequ_o,jmvloop)                        &
     &            , bxn_lo_mc(imvsequ_o,jmvloop)                        &
     &            , imvsequ_o=imvsequ_i,imvsequ_f)
 2143   format(i8,3d13.5)
!
!
        write(32,2144)
 2144   format(             &
     &  ' imvsequ     qqbxn_mc    redbxn_mc afbxn_max_mc')
!
        write(32,2145)                                                  &
     &  (imvsequ_o,     qqbxn_mc(imvsequ_o,jmvloop)                     &
     &            ,    redbxn_mc(imvsequ_o,jmvloop)                     &
     &            , afbxn_max_mc(imvsequ_o,jmvloop)                     &
     &            , imvsequ_o=imvsequ_i,imvsequ_f)
 2145   format(i8,3d13.5)
!
!
        write(32,2150)
 2150   format(             &
     &  ' imvsequ    '                                                  &
     & ,' jsft_mc jsft_xd jsft_wf jsft_pf jsft_ln jsft_mv')
!V090911:
!DEACTIVATED
        jsft_xd_imv=0
!:V090911
        write(32,2151)                                                  &
     &  (imvsequ_o,  jsft_mc(imvsequ_o,jmvloop)                         &
!V090911:
!DEACTIVATED
!R   &            ,  jsft_xd(imvsequ_o,jmvloop)                         &
     &            ,  jsft_xd_imv                                        &
!:V090911
     &            ,  jsft_wf(imvsequ_o,jmvloop)                         &
     &            ,  jsft_pf(imvsequ_o,jmvloop)                         &
     &            ,  jsft_ln(imvsequ_o,jmvloop)                         &
     &            ,  jsft_mv(imvsequ_o,jmvloop)                         &
     &            , imvsequ_o=imvsequ_i,imvsequ_f)
 2151   format(i8,i12,5i8)
!
!
        write(32,2152)
 2152   format(             &
     &  ' imvsequ     ffour_mc     efour_mc     cfour_mc')
!
        write(32,2153)                                                  &
     &  (imvsequ_o,  ffour_mc(imvsequ_o,jmvloop)                        &
     &            ,  efour_mc(imvsequ_o,jmvloop)                        &
     &            ,  cfour_mc(imvsequ_o,jmvloop)                        &
     &            , imvsequ_o=imvsequ_i,imvsequ_f)
 2153   format(i8,3d13.5)
!
   19   continue
        jo_mvsequ=0
      endif
!
!
      if(                                                              &
     &jo_th.eq.41.and.                                                 &
     &(jmvloop.eq.1.or.jmvloop.eq.2).and.                              &
     &jchi_min.eq.0.and.                                               &
     &kmvsequ.ge.1) then
        if(imove.eq.nmove(kmvsequ,jmvloop)) jo_mvsequ=1
      endif
!
      iout_th=iout_th+1
      if(jchi_min.eq.0) call odat_tr_f ! odat_th-01
!
!Db
      if(jchi_min.eq.0) then
        write(32,3001) iout_th, jclC, jclO
 3001   format(/'iout_th     jclC    jclO  |  End Of Sweep'/3i8)
      else
        write(32,3002) iout_th, jclC, jclO
 3002   format(/'iout_th     jclC    jclO'/3i8)
      endif
!Fb
!
!
      if(imvsequ.gt.0.and.jmvloop.gt.0) then
        if(jmty(imvsequ,jmvloop).eq.10) then
          if(jo_amb.eq.1) then
            write(32,3003) ihtot_amb,imove_amb,mth_tot
 3003       format(             &
     &      ' ihtot_amb imove_amb   mth_tot'/3i10)
          else
            write(32,3004) ihtot_amb,imove_amb,mth_tot
 3004       format(             &
     &      ' nhtot_amb nmove_amb   mth_tot'/3i10)
          endif
        endif
!
        if(                                                             &
     &    jmty(imvsequ,jmvloop).ge.1000.and.                            &
     &    jmty(imvsequ,jmvloop).le.2999                                 &
     &  )then
          if(jo_pst.eq.1) then
            write(32,3015)                                              &
     &       ihtot_pst,imove_pst,mth_tot,npopst
!c   :      ,jmty(imvsequ,jmvloop),imvsequ
 3015       format(             &
     &      ' ihtot_pst imove_pst   mth_tot    npopst'                  &
!c   :     ,'  jmty_pst   imvsequ'
     &      /4i10)
            write(32,3017)                                              &
     &      ipop_upd,ipop_xch,ipop_pst                                  &
     &      ,ith_rk,ith_cs,ipop_yst,mthyst
 3017       format(             &
     &       '  ipop_upd  ipop_xch  ipop_pst'                           &
     &      ,'    ith_rk    ith_cs  ipop_yst    mthyst'                 &
     &      /7i10)
          else
            write(32,3018) ihtot_pst,imove_pst,mth_tot,npopst
 3018       format(             &
     &      ' nhtot_pst nmove_pst   mth_tot    npopst'                  &
     &      /4i10)
          endif
        endif
!
        if(                                                             &
     &    jmty(imvsequ,jmvloop).ge.3000.and.                            &
     &    jmty(imvsequ,jmvloop).le.4999                                 &
     &  )then
          if(jo_pge.eq.1) then
            write(32,3025)                                              &
     &       ihtot_pge,imove_pge,mth_tot,npopge
!c   :      ,jmty(imvsequ,jmvloop),imvsequ
 3025       format(             &
     &       ' ihtot_pge imove_pge   mth_tot    npopge'                 &
!c   :      ,'  jmty_pge   imvsequ'
     &       /4i10)
            write(32,3027)                                              &
     &      ipop_upd,ipop_xch                                           &
     &      ,ith_rk,ith_cs
 3027       format(             &
     &       '  ipop_upd  ipop_xch'                                     &
     &      ,'    ith_rk    ith_cs'                                     &
     &      /6i10)
          else
            write(32,3028) ihtot_pge,imove_pge,mth_tot,npopge
 3028       format(             &
     &      ' nhtot_pge nmove_pge   mth_tot    npopge'/4i10)
          endif
        endif
      endif
!
      do iexpt=1,nexpt
        ivpm_uv=iexpt
        call setpm_uv
        call get_pdpen
      enddo
!
      do ith=1,mth_spec
        ispec=ispec_th(ith)
        ipm=ipmspec_th(ith)
        cspec_th(ith)=cspec(ispec,ipm)
      enddo
!
      do ith=1,mth_reac
        ireac=ireac_th(ith)
        ipm=ipmreac_th(ith)
        rreac_th(ith)=rreac(ireac,ipm)
      enddo
!
      do ispec=1,nspec
        cspec_fin(ispec)=xspec(ispec,ntime)
      enddo
!
      if(                                                               &
     &  (jmvloop.eq.1.or.jmvloop.eq.2).and.                             &
     &  jo_th.le.41                                                     &
     &) then
        write(32,3055)                                                  &
     &   jmvloop,imc_rep,imc_eql,imc_acc,imc_upd                        &
     &  ,imvsequ,jmty(imvsequ,jmvloop),imove,kmove                      &
     &  ,kmvsequ,jkmove,imc_smp
!
 3055   format(                                                         &
     &  /' jmvloop imc_rep imc_eql'                                     &
     &  ,' imc_acc imc_upd imvsequ    jmty   imove   kmove'             &
     &  /9i8                                                            &
     &  /' kmvsequ  jkmove imc_smp'                                     &
     &  /3i8)
!
        goto 20
      endif
!
!
      if(                                                               &
     &  (jmvloop.eq.1.or.jmvloop.eq.2).and.                             &
     &  jo_th.eq.51                                                     &
     &) then
        write(32,3056)                                                  &
     &   jmvloop,imc_rep,imc_eql,imc_acc,imc_upd                        &
     &  ,imvsequ,jmty(imvsequ,jmvloop),imove                            &
     &  ,kmvsequ, kmove, jkmove,imc_smp                                         &
     &  ,ith_rk,ith_cs
 3056   format(             &
     &  /' jmvloop imc_rep imc_eql'                                     &
     &  ,' imc_acc imc_upd imvsequ    jmty  imove'                      &
     &  /8i8                                                            &
     &  /' kmvsequ   kmove  jkmove imc_smp'                             &
     &  /4i8                                                            &
     &  /'  ith_rk  ith_cs'                                             &
     &  /2i8)
        goto 20
      endif
!
!
      if(jmvloop.eq.0) then
        write(32,3059) jmvloop
 3059   format(             &
     &         /'start configuration'                                   &
     &         /' jmvloop'                                              &
     &         /i8)
        goto 20
      endif
!
!
   20 continue
!
!CHG190526-1704:
      if(jchi_min.eq.1) then
        write(32,3111) ith_cs,ith_rk,ith_upd
 3111   format(/             &
     &  'Min ChiSq_Th:     ith_cs  ith_rk ith_upd'                      &
     &  /16x,3i8)
      endif
!:CHG190526-1704
!
      write(32,3112)                                                    &
     &  chisq_th                                                        &
     & ,chisq_th_min0                                                   &
     & ,chisq_th_max                                                    &
     & ,ftmp_imv                                                        &
     & ,fstp_imv
 3112 format(             &
     &  '        chisq_th'                                              &
     &, '    chisq_th_min'                                              &
     &, '    chisq_th_max'                                              &
     &, '      ftmp_imv'                                                &
     &, '      fstp_imv'                                                &
!c   :/ 5d14.6)
     &/ 3d16.8,2d14.6)
!
      write(32,3120)
 3120 format(             &
     &                        ' kscal mscal'                            &
     &       ,                '         chi0_ks'                        &
     &       ,                '      chi1_ks_th'                        &
     &       ,                '      chi2_ks_th'                        &
     &       ,                '    sxplog_ks_th'                        &
     &      )
!
      do kscal=1,nkscal
        write(32,3121)                                                  &
     &   kscal,mscal_ks(kscal)                                          &
     &  ,chi0_ks(kscal)                                                 &
     &  ,chi1_ks_th(kscal)                                              &
     &  ,chi2_ks_th(kscal)                                              &
     &  ,sxplog_ks_th(kscal)
!!3121   format(2i7,4d14.6)
 3121   format(i4,i8,4d16.8)
      enddo
!
!     write(32,3122)
!3122 format(             &
!    &                        ' iscal lscal'                            &
!    &       ,                '         chi0_is'                        &
!    &       ,                '      chi1_is_th'                        &
!    &       ,                '      chi2_is_th'                        &
!    &       ,                '    sxplog_is_th'                        &
!    &      )
!
!     do iscal=1,niscal
!       write(32,3123)                                                  &
!    &   iscal,lscal_is(iscal)                                          &
!    &  ,chi0_is(iscal)                                                 &
!    &  ,chi1_is_th(iscal)                                              &
!    &  ,chi2_is_th(iscal)                                              &
!    &  ,sxplog_is_th(iscal)
!!3123   format(2i7,4d14.6)
!3123   format(i4,i8,4d16.8)
!     enddo
!
!
      if(jmvloop.ge.1.and.jmvloop.le.2) then
        if(imvsequ.ge.1.and.imvsequ.le.nmvsequ(jmvloop)) then
          if(jrasf_ctl(imvsequ,jmvloop).ge.1) then
            write(32,3124)
 3124       format(                                                           &
     &                              ' kscal mscal'                            &
     &             ,                ' c1sxplog_ras_th'                        &
     &             ,                ' c2sxplog_ras_th'                        &
     &             ,                '   sxplog_ras_th'                        &
     &             ,                ' jm_ch'                                  &
     &            )
!
            do kscal=1,nkscal
              write(32,3125)                                                  &
     &         kscal,mscal_ks(kscal)                                          &
     &        ,c1sxplog_ras_th(kscal)                                         &
     &        ,c2sxplog_ras_th(kscal)                                         &
     &        ,sxplog_ras_th(kscal)                                           &
     &        ,jmsspec_ch_ks(kscal)
 3125         format(i4,i8,3d16.8,i4)
            enddo
!
!
            write(32,3126)
 3126       format(                                                           &
     &                              ' kscal mscal'                            &
     &             ,                ' c1sxplin_ras_th'                        &
     &             ,                ' c2sxplin_ras_th'                        &
     &             ,                '   sxplin_ras_th'                        &
     &             ,                ' jm_ch'                                  &
     &            )
!
            do kscal=1,nkscal
              write(32,3127)                                                  &
     &         kscal,mscal_ks(kscal)                                          &
     &        ,c1sxplin_ras_th(kscal)                                         &
     &        ,c2sxplin_ras_th(kscal)                                         &
     &        ,sxplin_ras_th(kscal)                                           &
     &        ,jmsspec_ch_ks(kscal)
 3127         format(i4,i8,3d16.8,i4)
            enddo
          endif
        endif
      endif
!
      if(jo_th_hto.ge.1) then
        if(imvsequ.ge.1.and.jmvloop.ge.1) then
          if(jmty(imvsequ,jmvloop).eq.20) then
            write(32,3130)
 3130       format(/                                         &
     &       '     hpspecv_tot    hpspecv0_tot'              &
     &      ,'    dhpspecv_tot    dchipspec_th'              &
     &      )
            write(32,3131)                                   &
     &        hpspecv_tot                                    &
     &      , hpspecv0_tot                                   &
     &      , dhpspecv_tot                                   &
     &      , dchipspec_th
 3131       format(4d16.8)
!
            write(32,3132)
 3132       format(                                          &
     &       '  ldconp  ipspec     ims'                      &
     &      ,'   hpspecv_dconp  hpspecv0_dconp'              &
     &      ,'  dhpspecv_dconp'                              &
     &      )
!
            do ldconp=ldconp_ini(imvsequ,jmvloop)            &
     &      ,         ldconp_fin(imvsequ,jmvloop)
              ipspec=ipspec_dconp(ldconp)
              ims=ims_spec(ipspec)
!
              write(32,3133)                                 &
     &          ldconp, ipspec, ims                          &
     &        , hpspecv_dconp(ldconp)                        &
     &        , hpspecv0_dconp(ldconp)                       &
     &        , dhpspecv_dconp(ldconp)
 3133         format(3i8, 3d16.8)
            enddo
          endif
        endif
!
        write(32,3134)
 3134   format(/             &
     &  '         htot_th     htot_th_min     htot_th_max'              &
     &  )
!
        write(32,3135)                                                  &
     &                           htot_th                                &
     &                         , htot_th_min                            &
     &                         , htot_th_max
 3135   format(3d16.8)
!
!
        if(jo_th_hto.ge.2) then
          write(32,3137)
 3137     format(             &
     &    '        hwall_th    hwall_th_min    hwall_th_max'            &
     &    )
!
          write(32,3138)                                                &
     &                             hwall_th                             &
     &                           , hwall_th_min                         &
     &                           , hwall_th_max
 3138     format(3d16.8)
        endif
!
!
        if(jo_th_hto.ge.3) then
          write(32,3141)
 3141     format(             &
     &    '         hbxx_th     hbxx_th_min     hbxx_th_max'            &
     &    )
!
          write(32,3142)                                                &
     &                             hbxx_th                              &
     &                           , hbxx_th_min                          &
     &                           , hbxx_th_max
 3142     format(3d16.8)
        endif
!
!
        if(jo_th_hto.ge.4) then
          write(32,3147)
 3147     format(             &
     &    '         hbxn_th     hbxn_th_min     hbxn_th_max'            &
     &    )
!
          write(32,3148)                                                &
     &                             hbxn_th                              &
     &                           , hbxn_th_min                          &
     &                           , hbxn_th_max
 3148     format(3d16.8)
        endif
!
!
        if(jo_th_hto.ge.2) then
          write(32,3151)
 3151     format(             &
     &    '        hfour_th    hfour_th_min    hfour_th_max'            &
     &    )
!
          write(32,3152)                                                &
     &                             hfour_th                             &
     &                           , hfour_th_min                         &
     &                           , hfour_th_max
 3152     format(3d16.8)
        endif
!
!
        if(jo_th_hto.ge.3) then
          write(32,3155)
 3155     format(             &
     &    '        hfous_th    hfous_th_min    hfous_th_max'            &
     &    )
!
          write(32,3156)                                                &
     &                             hfous_th                             &
     &                           , hfous_th_min                         &
     &                           , hfous_th_max
 3156     format(3d16.8)
        endif
!
!
        if(jo_th_hto.ge.4) then
          write(32,3157)
 3157     format(             &
     &    '        hfout_th    hfout_th_min    hfout_th_max'            &
     &    )
!
          write(32,3158)                                                &
     &                             hfout_th                             &
     &                           , hfout_th_min                         &
     &                           , hfout_th_max
 3158     format(3d16.8)
        endif
      endif
!
!
      if(jo_th_cu.eq.1.or.jo_th_wg.ge.1) then
        call reset_yspec
!
!!NEEDED:
!?????
        jrasf_freez=0
        if(                                                        &
     &  jmvloop.ge.1.and.jmvloop.le.2                              &
     &  )then
          if(                                                      &
     &    imvsequ.ge.1.and.imvsequ.le.nmvsequ(jmvloop)             &
     &    )then
            if(jrasf_ctl(imvsequ,jmvloop).eq.2) jrasf_freez=1
          endif
        endif
        jDB_sum_chi=15
        call sum_chi_u
        jrasf_freez=0
!?????
!!:NEEDED ????
!
        call chi_acct
        call store_chi_uth
      endif
!
      if(jo_th_cu.eq.1) then
!Db
      jclC=9010
!Fb
        call ck_chimin_u
!
        write(32,*) '  '
        if(chisq_uth.lt.chisq_uth_min0) then
          write(32,3211)
 3211     format('Min ChiSq_uTh:')
        endif
!
        write(32,3212)                                                  &
     &    chisq_uth                                                     &
     &   ,chisq_uth_min0                                                &
     &   ,chisq_uth_max
 3212   format(             &
     &    '       chisq_uth'                                            &
     &  , '   chisq_uth_min'                                            &
     &  , '   chisq_uth_max'                                            &
     &  /  3d16.8)
!
        if(chisq_uth.lt.chisq_uth_min0)                                 &
     &  chisq_uth_min0=chisq_uth
!
        write(32,3220)
 3220   format(             &
     &                      ' kscal mscal'                              &
     &     ,                '       chi0_ks_u'                          &
     &     ,                '     chi1_ks_uth'                          &
     &     ,                '     chi2_ks_uth'                          &
     &     ,                '   sxplog_ks_uth'                          &
     &        )
!
        do kscal=1,nkscal
          write(32,3221)                                                &
     &     kscal,mscal_ks(kscal)                                        &
     &    ,chi0_ks_u(kscal)                                             &
     &    ,chi1_ks_uth(kscal)                                           &
     &    ,chi2_ks_uth(kscal)                                           &
     &    ,sxplog_ks_uth(kscal)
 3221     format(i4,i8,4d16.8)
        enddo
!
        write(32,3222)
 3222   format(             &
     &                      ' iscal lscal'                              &
     &     ,                '       chi0_is_u'                          &
     &     ,                '     chi1_is_uth'                          &
     &     ,                '     chi2_is_uth'                          &
     &     ,                '   sxplog_is_uth'                          &
     &        )
!
        do iscal=1,niscal
          write(32,3223)                                                &
     &     iscal,lscal_is(iscal)                                        &
     &    ,chi0_is_u(iscal)                                             &
     &    ,chi1_is_uth(iscal)                                           &
     &    ,chi2_is_uth(iscal)                                           &
     &    ,sxplog_is_uth(iscal)
 3223     format(i4,i8,4d16.8)
        enddo
      endif
!
!
      if(jo_th_bxx.ge.1) then
        write(32,3251)
 3251   format(/             &
     &  '     qqbxx_imv    redbxx_imv    bxx_lo_imv    bxx_hi_imv'      &
     &  )
!
        write(32,3252)                                                  &
     &                           qqbxx_imv                              &
     &                         , redbxx_imv                             &
     &                         , bxx_lo_imv                             &
     &                         , bxx_hi_imv
 3252   format(4d14.6)
!
        write(32,3261)
 3261   format(             &
     &  '       qbxx_th  '                                              &
     &  )
!
        write(32,3262)                                                  &
     &                          (qbxx_th(ivs),ivs=0,nvs_spec)
 3262   format(5d14.6)
!
!
        write(32,3263)
 3263   format(             &
     &  '       fbxx_th  '                                              &
     &  )
!
        write(32,3264)                                                  &
     &                          (fbxx_th(ivs),ivs=0,nvs_spec)
 3264   format(5d14.6)
!
!
      if(jo_th_bxx.eq.2) then
        write(32,3265) nac_fbxo
 3265   format(             &
     &   '      nac_fbxo '                                              &
     &  /i14                                                            &
     &  /'     qbxx_fbxo  '                                             &
     &  )
!
        write(32,3266)                                                  &
     &                          (qbxx_fbxo(ivs),ivs=0,nvs_spec)
 3266   format(5d14.6)
!
!
        write(32,3267)
 3267   format(             &
     &  '     cbxx_fbxo  '                                              &
     &  )
!
        write(32,3268)                                                  &
     &                          (cbxx_fbxo(ivs),ivs=0,nvs_spec)
 3268   format(5d14.6)
      endif
      endif
!
!
      if(jo_th_bxn.ge.1) then
        write(32,3275)
 3275   format(/             &
     &  '     qqbxn_imv    redbxn_imv    bxn_lo_imv    bxn_hi_imv'      &
     &  )
!
        write(32,3276)                                                  &
     &                           qqbxn_imv                              &
     &                         , redbxn_imv                             &
     &                         , bxn_lo_imv                             &
     &                         , bxn_hi_imv
 3276   format(4d14.6)
!
        write(32,3281)
 3281   format(             &
     &  '       qbxn_th  '                                              &
     &  )
!
        write(32,3282)                                                  &
     &                          (qbxn_th(ivs),ivs=0,nvs_spec)
 3282   format(5d14.6)
!
!
        write(32,3283)
 3283   format(             &
     &  '       fbxn_th  '                                              &
     &  )
!
        write(32,3284)                                                  &
     &                          (fbxn_th(ivs),ivs=0,nvs_spec)
 3284   format(5d14.6)
!
!
      if(jo_th_bxn.eq.2) then
        write(32,3285) nac_fbxo
 3285   format(             &
     &   '      nac_fbxo  '                                             &
     &  /i14                                                            &
     &  /'     qbxn_fbxo  '                                             &
     &  )
!
        write(32,3286)                                                  &
     &                          (qbxn_fbxo(ivs),ivs=0,nvs_spec)
 3286   format(5d14.6)
!
!
        write(32,3287)
 3287   format(             &
     &  '     cbxn_fbxo  '                                              &
     &  )
!
        write(32,3288)                                                  &
     &                          (cbxn_fbxo(ivs),ivs=0,nvs_spec)
 3288   format(5d14.6)
      endif
      endif
!
      if(jo_th_ft.ge.1) then
          write(32,*) '   '
          if(imvsequ.ge.1.and.jmvloop.ge.1) then
!V090911:
!DEACTIVATED
            jsft_xd_imv=0
!:V090911
            write(32,3290)                                              &
     &       jsft_mc(imvsequ,jmvloop)                                   &
!V090911:
!DEACTIVATED
!R   &      ,jsft_xd(imvsequ,jmvloop)                                   &
     &      ,jsft_xd_imv                                                &
!:V090911
     &      ,jsft_wf(imvsequ,jmvloop)                                   &
     &      ,jsft_pf(imvsequ,jmvloop)                                   &
     &      ,jsft_ln(imvsequ,jmvloop)                                   &
     &      ,jsft_mv(imvsequ,jmvloop)
 3290       format(             &
     &      '   jsft_mc jsft_xd jsft_wf'                                &
     &      , ' jsft_pf jsft_ln jsft_mv'                                &
     &      /i10,5i8)
          endif
          do iexpt=1,nexpt
            do isegft=1,nsegft(iexpt)
              write(32,3291)                                            &
     &        iexpt,isegft                                              &
     &        ,pfour_seg_th(isegft,iexpt)                               &
     &        ,qfour_seg_th(isegft,iexpt)                               &
     &        ,ffour_imv,efour_imv
 3291         format(             &
     &        '  iexpt isegft  pfour_seg_th  qfour_seg_th'              &
     &                     ,'     ffour_imv     efour_imv'              &
     &        /2i7,4d14.6)
!
              write(32,3292)
 3292         format(' pfour_sfil_th ')
              write(32,3294)                                            &
     &        (pfour_sfil_th(is_ft,isegft,iexpt)                        &
     &        ,is_ft=1,nsft_spec)
 3294         format(5d14.6)
!
              write(32,3296)
 3296         format(' pfour_stot_th ')
              write(32,3298)                                            &
     &        (pfour_stot_th(is_ft,isegft,iexpt)                        &
     &        ,is_ft=1,nsft_spec)
 3298         format(5d14.6)
            enddo
          enddo
      endif
!
!CHG190516-1747: Enable ODE solver stats output for all iout_th blocks,
!              w/ jo_th_mchi==1.
      if(jo_th_ark.ge.1.and.(jchi_min.eq.0.or.jo_th_mchi.eq.1).and.     &
     & (                                                                &
     &  jtime.ge.10.and.jtime.le.299                                    &
     & )                                                                &
     &) then
!:CHG190516-1747
        call sum_arkabd ! odat_th-01
!
!
!DRLIM190524-2244:
        write(32,3302)                                                            &
     &      rjlimd_tot, rmlimd_tot, njlimd_tot, nmlimd_tot, nplimd_tot
 
 3302   format(/                                                                  &
     &   '    rjlimd_tot    rmlimd_tot    njlimd_tot    nmlimd_tot    nplimd_tot' &
     &  /2d14.6,3i14                                                              &
     &  )
!:DRLIM190524-2244
!
!
        write(32,3304)                                                  &
     &         ark_ksol,    ark_ksolxp                                  &
     &   ,        ntime,      nstp_ark,      nlim_drv                   &
     &   ,  ark_kstp_av,   ark_kdrv_av,   ark_kslo_av                   &
     &   ,  ark_kbad_av,   ark_koks_av                                  &
     &   ,  ark_khlo_av(1),ark_lhlo_av(1),ark_lerx_av(1)                &
     &   ,  ark_khlo_av(2),ark_lhlo_av(2),ark_lerx_av(2)                &
     &   ,  ark_ksto_av                                                 &
!
     &   ,  abd_kfai_av                                                 &
     &   ,  abd_krdo_av                                                 &
     &   ,  abd_krin_av                                                 &
     &   ,  abd_kjac_av                                                 &
     &   ,  (abd_kist_av(idum),idum=1,7)
!
 3304   format(/                                                        &
     &   '      ark_ksol    ark_ksolxp'                                 &
     &  ,'         ntime      nstp_ark      nlim_drv'                   &
     &  /2d14.6,3i14                                                    &
     &  /'   ark_kstp_av   ark_kdrv_av   ark_kslo_av'                   &
     &  ,'   ark_kbad_av   ark_koks_av'                                 &
     &  /5d14.6                                                         &
     &  /'  ark_khlo_av1  ark_lhlo_av1  ark_lerx_av1'                   &
     &  /3d14.6                                                         &
     &  /'  ark_khlo_av2  ark_lhlo_av2  ark_lerx_av2'                   &
     &  ,'   ark_ksto_av'                                               &
     &  /4d14.6                                                         &
!
     &  /'   abd_kfai_av   abd_krdo_av   abd_krin_av   abd_kjac_av'     &
     &  /4d14.6                                                         &
     &  /'  abd_kist_av1  abd_kist_av2  abd_kist_av3'                   &
     &  ,'  abd_kist_av4  abd_kist_av5'                                 &
     &  /5d14.6                                                         &
     &  /'  abd_kist_av6  abd_kist_av7'                                 &
     &  /2d14.6                                                         &
     &  )
!
!DRLIM190524-2244: jo_th_lmdrv==1 -> Enable lim-drv output by ith
        if(jo_th_lmdrv.eq.1) then
          write(32,3306)                                          &
     &         mth_limd                                           &
     &       , rjlimd_tot, rmlimd_tot                             &
     &       , njlimd_tot, nmlimd_tot, nplimd_tot
 3306     format(/                                                &
     &     ' mth_limd       tot:        rjlimd        rmlimd'     &
     &    ,' njlimd nmlimd nplimd'                                &
     &    /i5,'               ',2d14.6,3i7                        &
     &    )
!
          write(32,3307)
 3307     format(                                                 &
     &     'ith_limd'                                             &
     &    /'     ith_cs_limd'                                     &
     &    /'          ith_rk_limd'                                &
     &    /'               jout_limd'                             &
     &    /'                            rjlimd        rmlimd'     &
     &    ,' njlimd nmlimd nplimd'                                &
     &    )
!
          do ith_limd=1,mth_limd
            ith_cs_limd=-1
            ith_rk_limd=-1
            if(jout_limd(ith_limd).gt.0) then
              if(ith_limd.le.mth_spec) then
                ith_cs_limd=ith_limd
              else
                if(ith_limd.le.mth_tot) ith_rk_limd=ith_limd-mth_spec
              endif
  !
              write(32,3308)                                        &
     &           ith_limd, ith_cs_limd, ith_rk_limd, jout_limd(ith_limd)  &
     &         , rjlimd(ith_limd), rmlimd(ith_limd)                       &
     &         , njlimd(ith_limd), nmlimd(ith_limd), nplimd(ith_limd)
 3308         format(                                               &
     &         4i5,2d14.6,3i7                                       &
     &        )
            endif
          enddo
        endif
!:DRLIM190524-2244
!
      endif
!
!CHG190516-1747: Enable ODE solver stats output for all iout_th blocks,
!              w/ jo_th_mchi==1.
      if(jo_th_ark.ge.2.and.(jchi_min.eq.0.or.jo_th_mchi.eq.1).and.     &
     & (                                                                &
     &  jtime.ge.10.and.jtime.le.299                                    &
     & )                                                                &
     &) then
!:CHG190516-1747
        write(32,3310)
 3310   format(' ark_kstp_it(itime)  ')
        write(32,3311)                                                  &
     &  (ark_kstp_it(itime),itime=1,ntime)
 3311   format(5d14.6)
!
        write(32,3312)
 3312   format(' ark_kdrv_it(itime)  ')
        write(32,3313)                                                  &
     &  (ark_kdrv_it(itime),itime=1,ntime)
 3313   format(5d14.6)
!
        write(32,3314)
 3314   format(' ark_kslo_it(itime)  ')
        write(32,3315)                                                  &
     &  (ark_kslo_it(itime),itime=1,ntime)
 3315   format(5d14.6)
!
        write(32,3316)
 3316   format(' ark_kbad_it(itime)  ')
        write(32,3317)                                                  &
     &  (ark_kbad_it(itime),itime=1,ntime)
 3317   format(5d14.6)
!
        write(32,3318)
 3318   format(' ark_koks_it(itime)  ')
        write(32,3319)                                                  &
     &  (ark_koks_it(itime),itime=1,ntime)
 3319   format(5d14.6)
!
        write(32,3320)
 3320   format(' ark_khlo_it(itime,1)  ')
        write(32,3321)                                                  &
     &  (ark_khlo_it(itime,1),itime=1,ntime)
 3321   format(5d14.6)
!
        write(32,3322)
 3322   format(' ark_lhlo_it(itime,1)  ')
        write(32,3323)                                                  &
     &  (ark_lhlo_it(itime,1),itime=1,ntime)
 3323   format(5d14.6)
!
        write(32,3324)
 3324   format(' ark_lerx_it(itime,1)  ')
        write(32,3325)                                                  &
     &  (ark_lerx_it(itime,1),itime=1,ntime)
 3325   format(5d14.6)
!
        write(32,3326)
 3326   format(' ark_khlo_it(itime,2)  ')
        write(32,3327)                                                  &
     &  (ark_khlo_it(itime,2),itime=1,ntime)
 3327   format(5d14.6)
!
        write(32,3328)
 3328   format(' ark_lhlo_it(itime,2)  ')
        write(32,3329)                                                  &
     &  (ark_lhlo_it(itime,2),itime=1,ntime)
 3329   format(5d14.6)
!
        write(32,3330)
 3330   format(' ark_lerx_it(itime,2)  ')
        write(32,3331)                                                  &
     &  (ark_lerx_it(itime,2),itime=1,ntime)
 3331   format(5d14.6)
!
        if(jsto_ark.eq.1) then
          write(32,3332)
 3332     format(' ark_ksto_it(itime)  ')
          write(32,3333)                                                &
     &    (ark_ksto_it(itime),itime=1,ntime)
 3333     format(5d14.6)
        endif
!
!
        write(32,3340)
 3340   format(' abd_kfai_it(itime)  ')
        write(32,3341)                                                  &
     &  (abd_kfai_it(itime),itime=1,ntime)
 3341   format(5d14.6)
!
        write(32,3342)
 3342   format(' abd_krdo_it(itime)  ')
        write(32,3343)                                                  &
     &  (abd_krdo_it(itime),itime=1,ntime)
 3343   format(5d14.6)
!
        write(32,3344)
 3344   format(' abd_krin_it(itime)  ')
        write(32,3345)                                                  &
     &  (abd_krin_it(itime),itime=1,ntime)
 3345   format(5d14.6)
!
        write(32,3346)
 3346   format(' abd_kjac_it(itime)  ')
        write(32,3347)                                                  &
     &  (abd_kjac_it(itime),itime=1,ntime)
 3347   format(5d14.6)
!
        write(32,3350)
 3350   format(' abd_kist_it(itime,1)  ')
        write(32,3351)                                                  &
     &  (abd_kist_it(itime,1),itime=1,ntime)
 3351   format(5d14.6)
!
        write(32,3352)
 3352   format(' abd_kist_it(itime,2)  ')
        write(32,3353)                                                  &
     &  (abd_kist_it(itime,2),itime=1,ntime)
 3353   format(5d14.6)
!
        write(32,3354)
 3354   format(' abd_kist_it(itime,3)  ')
        write(32,3355)                                                  &
     &  (abd_kist_it(itime,3),itime=1,ntime)
 3355   format(5d14.6)
!
        write(32,3356)
 3356   format(' abd_kist_it(itime,4)  ')
        write(32,3357)                                                  &
     &  (abd_kist_it(itime,4),itime=1,ntime)
 3357   format(5d14.6)
!
        write(32,3358)
 3358   format(' abd_kist_it(itime,5)  ')
        write(32,3359)                                                  &
     &  (abd_kist_it(itime,5),itime=1,ntime)
 3359   format(5d14.6)
!
        write(32,3360)
 3360   format(' abd_kist_it(itime,6)  ')
        write(32,3361)                                                  &
     &  (abd_kist_it(itime,6),itime=1,ntime)
 3361   format(5d14.6)
!
        write(32,3362)
 3362   format(' abd_kist_it(itime,7)  ')
        write(32,3363)                                                  &
     &  (abd_kist_it(itime,7),itime=1,ntime)
 3363   format(5d14.6)
      endif
!
!COMNT190524-2244, Note: Do not include ".or.jo_th_mchi==1" here.
! Want to zero counters in "zero_arkabd" _only_ at end of sweep. 
      if(jo_th_ark.ge.1.and.jchi_min.eq.0.and.                          &
     & (                                                                &
     &  jtime.ge.10.and.jtime.le.299                                    &
     & )                                                                &
     &) then
        call zero_arkabd ! odat_th-01
      endif
!
!V090911:
!DEACTIVATED:
      goto 9901
      if(jo_xdi.ge.1.and.jo_abaxdi.eq.1.and.                            &
     &(.not.(chisq_th.lt.chisq_th_min0) )     ) then
!
        jo_abaxdi=0
!
        write(32, 3404)
 3404   format(/' chisq_xdi / abaxdi / pfour_xd  ')
!
        do iexpt=1,nexpt
          do is_xdi=1,nsxdi_spec(iexpt)
            ispec=ispec_xdi(is_xdi,iexpt)
            do isegxd=1,nsegxd(is_xdi,iexpt)
              write(32,3412)                                            &
     &             namespec(ispec)                                      &
     &           , chisq_xdi(isegxd,is_xdi,iexpt),jkrxdi,jsfxdi         &
!
     &           , iexpt, is_xdi, ispec, isegxd                         &
     &           , nbaxdi(0,isegxd,is_xdi,iexpt)                        &
     &           , nbaxdi(1,isegxd,is_xdi,iexpt)                        &
     &           , ntxdi(isegxd,is_xdi,iexpt)                           &
     &           , jbaxdi(isegxd,is_xdi,iexpt)                          &
!
     &           , itxpt_xdii(isegxd,is_xdi,iexpt)                      &
     &           , itxpt_xdif(isegxd,is_xdi,iexpt)                      &
     &           , itime_xdii(isegxd,is_xdi,iexpt)                      &
     &           , itime_xdif(isegxd,is_xdi,iexpt)                      &
     &           , time_xdii(isegxd,is_xdi,iexpt)                       &
     &           , otime_xdifi(isegxd,is_xdi,iexpt)                     &
!
     &           , nsegxd(is_xdi,iexpt)                                 &
     &           , nsxdi_spec(iexpt)
 3412         format(a80             &
     &        /'    chisq_xdi jkrxdi jsfxdi'                            &
     &        /d14.6,2i8                                                &
     &        /'   iexpt  is_xdi   ispec  isegxd'                       &
     &        ,'    nbas   nbas1    ndat    jbas'                       &
     &        /8i8                                                      &
     &        /' itxpt_i itxpt_f itime_i itime_f'                       &
     &        ,'      time_xdii    otime_xdifi'                         &
     &        /4i8,2d14.6                                               &
     &        /'  nsegxd nsxdi_spec'                                    &
     &        /2i8                                                      &
     &        /' abaxdi    ')
              write(32,3414)                                            &
     &            (abaxdi(ibas,isegxd,is_xdi,iexpt)                     &
     &            ,ibas=1,nbaxdi(0,isegxd,is_xdi,iexpt))
 3414         format(5d14.6)
            enddo
          enddo
!
          do is_ft=1,nsft_spec
            ispec=ispec_sft(is_ft)
            do isegft=1,nsegft(iexpt)
              nft_htime=nft_time(isegft,iexpt)/2
!
              write(32,3422)                                            &
     &          namespec(ispec)                                         &
     &          ,iexpt, isegft, is_ft, ispec                            &
     &          ,pfour_xd_tot(is_ft,isegft,iexpt)                       &
     &          ,nft_time(isegft,iexpt)                                 &
     &          ,nft_htime
 3422         format(a80             &
     &        /'   iexpt  isegft   is_ft   ispec    pfour_xd_tot'       &
     &        ,' nft_time nft_htime '                                   &
     &        /4i8,d16.8,2i8                                            &
     &        /' pfour_xd ')
              if(pfour_xd_tot(is_ft,isegft,iexpt).gt.0.d0) then
                write(32,3424)                                          &
     &            (pfour_xd(ift_freq,is_ft,isegft,iexpt)                &
     &            ,ift_freq=0,nft_htime)
 3424           format(5d14.6)
              endif
            enddo
          enddo
        enddo
      endif
 9901 continue
!:V090911
!:DEACTIVATED
!
!
      if(jo_cfi.eq.1) then
        write(32,3500)
 3500   format(/' cspec_fin')
!
        write(32,3502)                                                  &
     &            (cspec_fin(ispec),ispec=1,nspec)
 3502   format(5d14.6)
      endif
!
      if(jo_th_mine.eq.1) then
        write(32,3510)
 3510   format(/' mine parameters ')
!
        do iexpt=1,nexpt
          ivpm_uv=iexpt
          call setpm_uv
          call get_pdpen
!
          imine=0
          do ispec=1,nspec
            if(jfix(ispec).ge.0) then
              do ipm=1,(npmspec(ispec)-npxspec(ispec))
                if(                                                     &
     &          jctspec(ispec,ipm).eq.0.or.                             &
     &          jctspec(ispec,ipm).eq.1.or.                             &
     &          jctspec(ispec,ipm).eq.10                                &
     &          )then
                  imine=imine+1
                  cspec_mine(imine)=cspec(ispec,ipm)
                endif
              enddo
            endif
          enddo
          nmine_spec=imine
!
          imine=0
          do ireac=1,nreac
            do ipm=1,(npmreac(ireac)-npxreac(ireac))
              if(                                                       &
     &        jctreac(ireac,ipm).eq.0.or.                               &
     &        jctreac(ireac,ipm).eq.1.or.                               &
     &        jctreac(ireac,ipm).eq.10                                  &
     &        )then
                imine=imine+1
                rreac_mine(imine)=rreac(ireac,ipm)
              endif
            enddo
          enddo
          nmine_reac=imine
!
!
          write(32,3512) iexpt,nmine_spec,nmine_reac
 3512     format(             &
     &    /' iexpt  nmine_spec  nmine_reac'                             &
     &    /i6,2i12                                                      &
     &    /' cspec_mine '                                               &
     &    )
!
!V090925:
          if(jo_th_dprec.eq.0) then
            write(32,3514)                                                &
     &                (cspec_mine(imine),imine=1,nmine_spec)
 3514       format(5d14.6)
          endif
          if(jo_th_dprec.eq.1) then
            write(32,3515)                                                &
     &                (cspec_mine(imine),imine=1,nmine_spec)
 3515       format(3d26.18)
          endif
!
          write(32,3516)
 3516     format(             &
     &    /' rreac_mine '                                               &
     &    )
!
          if(jo_th_dprec.eq.0) then
            write(32,3518)                                                &
     &                (rreac_mine(imine),imine=1,nmine_reac)
 3518       format(5d14.6)
          endif
          if(jo_th_dprec.eq.1) then
            write(32,3519)                                                &
     &                (rreac_mine(imine),imine=1,nmine_reac)
 3519       format(3d26.18)
          endif
!:V090925
        enddo
      endif
!
      write(32,3530)
 3530 format(/' crdpen_spec')
!
      write(32,3532)                                                    &
     &              (crdpen(lcrdp),lcrdp=1,mdpen_spec)
 3532 format(5d14.6)
!
!
      write(32,3534)
 3534 format(/' crdpen_reac')
!
      write(32,3536)                                                    &
     &              (crdpen(lcrdp+mdpen_spec),lcrdp=1,mdpen_reac)
 3536 format(5d16.8)
!
!
!
      write(32,3552)
 3552 format(/' cspec_th    ')
!
!V090925:
      if(jo_th_dprec.eq.0) then
        write(32,3555)                                                    &
     &                (cspec_th(ith),ith=1,mth_spec)
 3555   format(5d16.8)
      endif
      if(jo_th_dprec.eq.1) then
        write(32,3556)                                                    &
     &                (cspec_th(ith),ith=1,mth_spec)
 3556   format(3d26.18)
      endif
!
      write(32,3562)
 3562 format(' rreac_th     ')
!
      if(jo_th_dprec.eq.0) then
        write(32,3565)                                                    &
     &                (rreac_th(ith),ith=1,mth_reac)
 3565   format(5d16.8)
      endif
      if(jo_th_dprec.eq.1) then
        write(32,3566)                                                    &
     &                (rreac_th(ith),ith=1,mth_reac)
 3566   format(3d26.18)
      endif
!:V090925
!
!
      if(jo_th_sw.eq.1) then
        write(32,3572)
 3572   format(/' raccp_swo')
        write(32,3575)                                                  &
     &          (raccp_swo(ith),ith=1,mth_spec)
 3575   format(5d14.6)
!
        write(32,*) ' '
        write(32,3575)                                                  &
     &          (raccp_swo(ith),ith=(1+mth_spec),mth_tot)
!
        write(32,*) ' '
        do io_swo=0,mo_swo
          idum1=mth_tot+1+inc_swo*io_swo
          idum2=idum1+inc_swo-1
          if(idum2.gt.mth_swo) idum2=mth_swo
!
          ith=0
          do ith_swo=idum1,idum2
            if(jout_swo(ith_swo).gt.0) then
              ith=ith+1
              out_swo(ith)=raccp_swo(ith_swo)
            endif
          enddo
          if(ith.gt.0) then
            write(32,3575)                                              &
     &              (out_swo(ith_swo),ith_swo=1,ith)
            write(32,*) ' '
          endif
        enddo
!
!
        write(32,3582)
 3582   format(' fstp_swo')
            write(32,3585)                                              &
     &                (fstp_swo(ith),ith=1,mth_spec)
!
        write(32,*) ' '
            write(32,3585)                                              &
     &                (fstp_swo(ith),ith=(1+mth_spec),mth_tot)
 3585   format(5d14.6)
!
        write(32,*) ' '
        do io_swo=0,mo_swo
          idum1=mth_tot+1+inc_swo*io_swo
          idum2=idum1+inc_swo-1
          if(idum2.gt.mth_swo) idum2=mth_swo
!
          ith=0
          do ith_swo=idum1,idum2
            if(jout_swo(ith_swo).gt.0) then
              ith=ith+1
              out_swo(ith)=fstp_swo(ith_swo)
            endif
          enddo
          if(ith.gt.0) then
            write(32,3585)                                              &
     &              (out_swo(ith_swo),ith_swo=1,ith)
            write(32,*) ' '
          endif
        enddo
      endif
!
!
      if(jo_th_wg.ge.1) then
        if(imvsequ.gt.0.and.jmvloop.gt.0) then
!c        r1=chisq_th
!c        if(fwgt_tot.gt.0.d0.and.mdtin.gt.0)
!c   :    r1=chisq_th/(fwgt_tot*mdtin)
!
!c        r2=chisq_uth
!c        if(mdtin.gt.0) r2=chisq_uth/mdtin
!
          write(32,3602)                                                &
!c   :                   fwgt_tot,mdtin,r1,r2
     &                   jwgt_mv(imvsequ,jmvloop)                       &
     &                  ,jwgt_tv(imvsequ,jmvloop)                       &
     &                  ,jwgt_sh(imvsequ,jmvloop)                       &
     &                  ,jwgt_wc(imvsequ,jmvloop)                       &
     &                  ,npwgt(0,imvsequ,jmvloop)                       &
     &                  ,npwgt(1,imvsequ,jmvloop)
 3602     format(/             &
!c   :     '          fwgt_tot   mdtin'
!c   :    ,' Chisq_th/fwgt_tot/mdtin'
!c   :    ,' Chisq_uth/mdtin'
!c   :    /f18.8,i8,2d18.8
!c   :    /
     &     ' jwgt_mv jwgt_tv jwgt_sh jwgt_wc npwgt(0-1,.)'              &
     &    /6i8                                                          &
     &    )
!
          if(npwgt(0,imvsequ,jmvloop).gt.1) then
            if(jwgt_sh(imvsequ,jmvloop).eq.0) then
              write(32,3604)
 3604         format(             &
     &         '         twgt_cent         twgt_leng'                   &
     &        ,'         twgt_rise         fwgt_ampl'                   &
     &        )
              write(32,3606) (pwgt(lpwgt)                               &
     &                       ,lpwgt=1,npwgt(0,imvsequ,jmvloop))
 3606         format(             &
     &         4f18.8                                                   &
     &        )
            endif
          endif
!
          if(npwgt(0,imvsequ,jmvloop).eq.1) then
            write(32,3608) pwgt(1)
 3608       format(             &
     &      '       fwgt_ampl'                                          &
     &      /d16.8                                                      &
     &      )
          endif
!
          if(npwgt(1,imvsequ,jmvloop).gt.1) then
            write(32,3610)
 3610       format(             &
     &       ' lpwgt iexpt_wc0  _wc1 ims_wc0    _wc1'                   &
     &      ,      ' itxpt_wc0  _wc1'                                   &
     &      ,      '         fwgt_wc')
!
            write(32,3612)                                              &
     &      (lpwgt                                                      &
     &      ,iexpt_wc0(lpwgt,imvsequ,jmvloop)                           &
     &      ,iexpt_wc1(lpwgt,imvsequ,jmvloop)                           &
     &      ,itxpt_wc0(lpwgt,imvsequ,jmvloop)                           &
     &      ,itxpt_wc1(lpwgt,imvsequ,jmvloop)                           &
     &      , ims_wc0(lpwgt,imvsequ,jmvloop)                            &
     &      , ims_wc1(lpwgt,imvsequ,jmvloop)                            &
     &      ,pwgt_mc(lpwgt,imvsequ,jmvloop)                             &
     &      ,lpwgt=(npwgt(0,imvsequ,jmvloop)+1)                         &
     &      ,(npwgt(0,imvsequ,jmvloop)+npwgt(1,imvsequ,jmvloop))        &
     &      )
 3612       format(i6,6i8,d16.8)
          endif
!c      else
!c        write(32,3620) fwgt_tot
!3620     format(
!c   :     '   fwgt_tot'
!c   :    /f18.8
!c   :    )
        endif
!
        write(32,3710) chisq_th,chisq_uth
 3710   format(/             &
     &  '                Chisq_th         Chisq_uth'                    &
     &  /6x,2d18.10)
!
        if(jo_th_wg.eq.2.or.jo_th_wg.eq.3) then
          write(32,3711)
 3711     format(/                                                      &
     &    /  ' iexpt'                                                   &
     &    ,  '           fwgt_xp        chisq_xp mdtin_xp'              &
     &    )
!
          adum1=0.d0
          adum2=0.d0
          idum=0
          do iexpt=1,nexpt
            write(32,3712)                                              &
     &       iexpt                                                      &
     &      ,fwgt_xp(iexpt)                                             &
     &      ,chisq_xp(iexpt)                                            &
     &      ,mdtin_xp(iexpt)
 3712       format(i6,f18.8,d16.8,i6)
!
            adum1=adum1+fwgt_xp(iexpt)
            adum2=adum2+chisq_xp(iexpt)
            idum=idum+mdtin_xp(iexpt)
          enddo
          write(32,3714) adum1,adum2,idum
 3714     format(             &
     &     '*Totals*'                                                   &
     &    /6x,f18.8,d16.8,i6)
!
!
          write(32,3720)
 3720     format(/             &
     &    ' namespec/'                                                  &
     &    /'   ims'                                                     &
     &    ,'           fwgt_ms        chisq_ms mdtin_ms'                &
     &    )
!
          adum1=0.d0
          adum2=0.d0
          idum=0
          do ims=1,nms_spec
            write(32,3722)                                              &
     &       namespec(ispec_ms(ims))                                    &
     &      ,ims                                                        &
     &      ,fwgt_ms(ims)                                               &
     &      ,chisq_ms(ims)                                              &
     &      ,mdtin_ms(ims)
 3722       format(     &
     &      a80                                                         &
     &      /i6,f18.8,d16.8,i6)
!
            adum1=adum1+fwgt_ms(ims)
            adum2=adum2+chisq_ms(ims)
            idum=idum+mdtin_ms(ims)
          enddo
          write(32,3724) adum1,adum2,idum
 3724     format(     &
     &     '*Totals*'                                                   &
     &    /6x,f18.8,d16.8,i6)
!
!
          write(32,3730)
 3730     format(/     &
     &    ' iexpt   ims'                                                &
     &    ,'         fwgt_msxp      chisq_msxp mdtin_msxp'              &
     &    )
!
          adum1=0.d0
          adum2=0.d0
          adum3=0.d0
          idum=0
          do iexpt=1,nexpt
            bdum1=0.d0
            bdum2=0.d0
            kdum=0
            do ims=1,nms_spec
              write(32,3732)                                            &
     &         iexpt,ims                                                &
     &        ,fwgt_msxp(ims,iexpt)                                     &
     &        ,chisq_msxp(ims,iexpt)                                    &
     &        ,mdtin_msxp(ims,iexpt)
 3732         format(2i6,f18.8,d16.8,i6)
!
              bdum1=bdum1+fwgt_msxp(ims,iexpt)
              bdum2=bdum2+chisq_msxp(ims,iexpt)
              kdum=kdum+mdtin_msxp(ims,iexpt)
!
              if(mdtin_msxp(ims,iexpt).gt.0) then
                adum3=adum3                                             &
     &               +(fwgt_msxp(ims,iexpt)                             &
     &                /mdtin_msxp(ims,iexpt))**2                        &
     &               *chisq_msxp(ims,iexpt)
              endif
            enddo
            write(32,3734) bdum1,bdum2,kdum
 3734       format(     &
     &       ' *Subtotals*'                                             &
     &      ,f18.8,d16.8,i6)
!
            adum1=adum1+bdum1
            adum2=adum2+bdum2
            idum=idum+kdum
          enddo
          write(32,3736) adum1,adum2,idum,adum3
 3736     format(     &
     &     '*Totals*'                                                   &
     &    /12x,f18.8,d16.8,i6                                           &
     &    /30x,d16.8)
!
          write(32,3740) chisq_uth,chisq_th
 3740     format(     &
     &    /'                              Chisq_uTh:'                   &
     &    /30x,d18.10                                                   &
     &    /'                               Chisq_Th:'                   &
     &    /30x,d18.10)
        endif
!
!
        if(jo_th_wg.eq.1.or.jo_th_wg.eq.3) then
          write(32,3810)
 3810     format(/     &
     &     ' iexpt   ims itxpt          time_xpt'                       &
     &    ,  '           fwgt_tx        chisq_tx mdtin_tx'              &
     &    )
!
          do itxpt=1,ntxpt
            do iexpt=1,nexpt
              do ims=1,nms_spec
                if(itmx_xpt(ims,itxpt,iexpt).gt.0) then
                  write(32,3812)                                        &
     &             iexpt,ims,itxpt                                      &
     &            ,time_xpt(itxpt)                                      &
     &            ,fwgt_tx(itxpt)                                       &
     &            ,chisq_tx(itxpt)                                      &
     &            ,mdtin_tx(itxpt)
 3812             format(3i6,2f18.8,d16.8,i6)
                  goto 910
                endif
              enddo
            enddo
  910       continue
          enddo
        endif
      endif
!
!c      close(32)
!
      if(jo_th_xo.eq.1) call odat_th_x ! odat_th-01
      if(jchi_min.eq.0) call odat_tr_f ! odat_th-02
!
  999 continue
!
      jclO=-11111
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine odat_acc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! Records MC accumulation into "ens.o05":
! writes out MC movable "Theta" values of
! "cspec", "rkfor", "rkbak", "rkfor2", "rkbak2"
! and resulting "chisq_th" during MC accumulation
!
      iun=35
!
      write(iun,3001) iout_th
 3001 format(/'iout_th '/i8/'  Accumulation Record')
!
!
      if(                                                               &
     &  (jmvloop.eq.1.or.jmvloop.eq.2).and.                             &
     &  jo_th.le.41                                                     &
     &) then
        write(iun,3055)                                                 &
     &   jmvloop,imc_rep,imc_eql,imc_acc,imc_upd                        &
     &  ,imvsequ                                                        &
!XXX :  ,jmty(imvsequ,jmvloop)
     &  ,imove,kmove                                                    &
     &  ,kmvsequ,jkmove
!
 3055   format(     &
     &  /' jmvloop imc_rep imc_eql'                                     &
!XXX :  ,' imc_acc imc_upd imvsequ    jmty   imove   kmove'
     &  ,' imc_acc imc_upd imvsequ   imove   kmove'                     &
!XXX :  /9i8
     &  /8i8                                                            &
     &  /' kmvsequ  jkmove'                                             &
     &  /2i8)
!
      endif
!
!
      write(iun,3112)                                                   &
     &  chisq_th                                                        &
     & ,chisq_th_min0                                                   &
     & ,chisq_th_max                                                    &
     & ,ftmp_imv                                                        &
     & ,fstp_imv
 3112 format(     &
     &  '        chisq_th'                                              &
     &, '    chisq_th_min'                                              &
     &, '    chisq_th_max'                                              &
     &, '      ftmp_imv'                                                &
     &, '      fstp_imv'                                                &
     &/ 3d16.8,2d14.6)
!
      write(iun,3120)
 3120 format(     &
     &                        ' kscal mscal'                            &
     &       ,                '         chi0_ks'                        &
     &       ,                '      chi1_ks_th'                        &
     &       ,                '      chi2_ks_th'                        &
     &       ,                '    sxplog_ks_th'                        &
     &      )
!
      do kscal=1,nkscal
        write(iun,3121)                                                 &
     &   kscal,mscal_ks(kscal)                                          &
     &  ,chi0_ks(kscal)                                                 &
     &  ,chi1_ks_th(kscal)                                              &
     &  ,chi2_ks_th(kscal)                                              &
     &  ,sxplog_ks_th(kscal)
!3121   format(2i7,4d14.6)
 3121   format(i4,i8,4d16.8)
      enddo
!
      write(iun,3122)
 3122 format(     &
     &                        ' iscal lscal'                            &
     &       ,                '         chi0_is'                        &
     &       ,                '      chi1_is_th'                        &
     &       ,                '      chi2_is_th'                        &
     &       ,                '    sxplog_is_th'                        &
     &      )
!
      do iscal=1,niscal
        write(iun,3123)                                                 &
     &   iscal,lscal_is(iscal)                                          &
     &  ,chi0_is(iscal)                                                 &
     &  ,chi1_is_th(iscal)                                              &
     &  ,chi2_is_th(iscal)                                              &
     &  ,sxplog_is_th(iscal)
!3123   format(2i7,4d14.6)
 3123   format(i4,i8,4d16.8)
      enddo
!
!
!CHG190516-1747: Enable ODE solver stats output for all iout_th blocks,
!              w/ jo_th_mchi==1.
      if(jo_th_ark.ge.1.and.(jchi_min.eq.0.or.jo_th_mchi.eq.1).and.     &
     & (                                                                &
     &  jtime.ge.10.and.jtime.le.299                                    &
     & )                                                                &
     &) then
!:CHG190516-1747
        call sum_arkabd ! odat_acc-01
!
!
!DRLIM190524-2244:
        write(iun,3302)                                                           &
     &      rjlimd_tot, rmlimd_tot, njlimd_tot, nmlimd_tot, nplimd_tot
!
 3302   format(/                                                                  &
     &   '    rjlimd_tot    rmlimd_tot    njlimd_tot    nmlimd_tot    nplimd_tot' &
     &  /2d14.6,3i14                                                              &
     &  )
!:DRLIM190524-2244
!
!
        write(iun,3304)                                                 &
     &         ark_ksol,    ark_ksolxp                                  &
     &   ,        ntime,      nstp_ark,      nlim_drv                   &
     &   ,  ark_kstp_av,   ark_kdrv_av,   ark_kslo_av                   &
     &   ,  ark_kbad_av,   ark_koks_av                                  &
     &   ,  ark_khlo_av(1),ark_lhlo_av(1),ark_lerx_av(1)                &
     &   ,  ark_khlo_av(2),ark_lhlo_av(2),ark_lerx_av(2)                &
     &   ,  ark_ksto_av                                                 &
!
     &   ,  abd_kfai_av                                                 &
     &   ,  abd_krdo_av                                                 &
     &   ,  abd_krin_av                                                 &
     &   ,  abd_kjac_av                                                 &
     &   ,  (abd_kist_av(idum),idum=1,7)
!
 3304   format(/                                                        &
     &   '      ark_ksol    ark_ksolxp'                                 &
     &  ,'         ntime      nstp_ark      nlim_drv'                   &
     &  /2d14.6,3i14                                                    &
     &  /'   ark_kstp_av   ark_kdrv_av   ark_kslo_av'                   &
     &  ,'   ark_kbad_av   ark_koks_av'                                 &
     &  /5d14.6                                                         &
     &  /'  ark_khlo_av1  ark_lhlo_av1  ark_lerx_av1'                   &
     &  /3d14.6                                                         &
     &  /'  ark_khlo_av2  ark_lhlo_av2  ark_lerx_av2'                   &
     &  ,'   ark_ksto_av'                                               &
     &  /4d14.6                                                         &
!
     &  /'   abd_kfai_av   abd_krdo_av   abd_krin_av   abd_kjac_av'     &
     &  /4d14.6                                                         &
     &  /'  abd_kist_av1  abd_kist_av2  abd_kist_av3'                   &
     &  ,'  abd_kist_av4  abd_kist_av5'                                 &
     &  /5d14.6                                                         &
     &  /'  abd_kist_av6  abd_kist_av7'                                 &
     &  /2d14.6                                                         &
     &  )
      endif
!
!DRLIM190524-2244: jo_th_lmdrv==1 -> Enable lim-drv output by ith
        if(jo_th_lmdrv.eq.1) then
          write(iun,3306)                                         &
     &         mth_limd                                           &
     &       , rjlimd_tot, rmlimd_tot                             &
     &       , njlimd_tot, nmlimd_tot, nplimd_tot
 3306     format(/                                                &
     &     ' mth_limd       tot:        rjlimd        rmlimd'     &
     &    ,' njlimd nmlimd nplimd'                                &
     &    /i5,'               ',2d14.6,3i7                        &
     &    )
          write(iun,3307)
 3307     format(                                                 &
     &     'ith_limd'                                             &
     &    /'     ith_cs_limd'                                     &
     &    /'          ith_rk_limd'                                &
     &    /'               jout_limd'                             &
     &    /'                            rjlimd        rmlimd'     &
     &    ,' njlimd nmlimd nplimd'                                &
     &    )
!
          do ith_limd=1,mth_limd
            ith_cs_limd=-1
            ith_rk_limd=-1
            if(jout_limd(ith_limd).gt.0) then
              if(ith_limd.le.mth_spec) then
                ith_cs_limd=ith_limd
              else
                if(ith_limd.le.mth_tot) ith_rk_limd=ith_limd-mth_spec
              endif
  !
              write(iun,3308)                                       &
     &           ith_limd, ith_cs_limd, ith_rk_limd, jout_limd(ith_limd)  &
     &         , rjlimd(ith_limd), rmlimd(ith_limd)                       &
     &         , njlimd(ith_limd), nmlimd(ith_limd), nplimd(ith_limd)
 3308         format(                                               &
     &         4i5,2d14.6,3i7                                       &
     &        )
            endif
          enddo
        endif
!:DRLIM190524-2244
!
!CHG190524-2244: Enable ODE solver stats output for all iout_th blocks,
!              w/ jo_th_mchi==1. Note: this was forgotten in CHG190516-1747
      if(jo_th_ark.ge.2.and.(jchi_min.eq.0.or.jo_th_mchi.eq.1).and.     &
     & (                                                                &
     &  jtime.ge.10.and.jtime.le.299                                    &
     & )                                                                &
     &) then
!:CHG190524-2244
        write(iun,3310)
 3310   format(' ark_kstp_it(itime)  ')
        write(iun,3311)                                                 &
     &  (ark_kstp_it(itime),itime=1,ntime)
 3311   format(5d14.6)
!
        write(iun,3312)
 3312   format(' ark_kdrv_it(itime)  ')
        write(iun,3313)                                                 &
     &  (ark_kdrv_it(itime),itime=1,ntime)
 3313   format(5d14.6)
!
        write(iun,3314)
 3314   format(' ark_kslo_it(itime)  ')
        write(iun,3315)                                                 &
     &  (ark_kslo_it(itime),itime=1,ntime)
 3315   format(5d14.6)
!
        write(iun,3316)
 3316   format(' ark_kbad_it(itime)  ')
        write(iun,3317)                                                 &
     &  (ark_kbad_it(itime),itime=1,ntime)
 3317   format(5d14.6)
!
        write(iun,3318)
 3318   format(' ark_koks_it(itime)  ')
        write(iun,3319)                                                 &
     &  (ark_koks_it(itime),itime=1,ntime)
 3319   format(5d14.6)
!
        write(iun,3320)
 3320   format(' ark_khlo_it(itime,1)  ')
        write(iun,3321)                                                 &
     &  (ark_khlo_it(itime,1),itime=1,ntime)
 3321   format(5d14.6)
!
        write(iun,3322)
 3322   format(' ark_lhlo_it(itime,1)  ')
        write(iun,3323)                                                 &
     &  (ark_lhlo_it(itime,1),itime=1,ntime)
 3323   format(5d14.6)
!
        write(iun,3324)
 3324   format(' ark_lerx_it(itime,1)  ')
        write(iun,3325)                                                 &
     &  (ark_lerx_it(itime,1),itime=1,ntime)
 3325   format(5d14.6)
!
        write(iun,3326)
 3326   format(' ark_khlo_it(itime,2)  ')
        write(iun,3327)                                                 &
     &  (ark_khlo_it(itime,2),itime=1,ntime)
 3327   format(5d14.6)
!
        write(iun,3328)
 3328   format(' ark_lhlo_it(itime,2)  ')
        write(iun,3329)                                                 &
     &  (ark_lhlo_it(itime,2),itime=1,ntime)
 3329   format(5d14.6)
!
        write(iun,3330)
 3330   format(' ark_lerx_it(itime,2)  ')
        write(iun,3331)                                                 &
     &  (ark_lerx_it(itime,2),itime=1,ntime)
 3331   format(5d14.6)
!
        if(jsto_ark.eq.1) then
          write(iun,3332)
 3332     format(' ark_ksto_it(itime)  ')
          write(iun,3333)                                               &
     &    (ark_ksto_it(itime),itime=1,ntime)
 3333     format(5d14.6)
        endif
!
!
        write(iun,3340)
 3340   format(' abd_kfai_it(itime)  ')
        write(iun,3341)                                                 &
     &  (abd_kfai_it(itime),itime=1,ntime)
 3341   format(5d14.6)
!
        write(iun,3342)
 3342   format(' abd_krdo_it(itime)  ')
        write(iun,3343)                                                 &
     &  (abd_krdo_it(itime),itime=1,ntime)
 3343   format(5d14.6)
!
        write(iun,3344)
 3344   format(' abd_krin_it(itime)  ')
        write(iun,3345)                                                 &
     &  (abd_krin_it(itime),itime=1,ntime)
 3345   format(5d14.6)
!
        write(iun,3346)
 3346   format(' abd_kjac_it(itime)  ')
        write(iun,3347)                                                 &
     &  (abd_kjac_it(itime),itime=1,ntime)
 3347   format(5d14.6)
!
        write(iun,3350)
 3350   format(' abd_kist_it(itime,1)  ')
        write(iun,3351)                                                 &
     &  (abd_kist_it(itime,1),itime=1,ntime)
 3351   format(5d14.6)
!
        write(iun,3352)
 3352   format(' abd_kist_it(itime,2)  ')
        write(iun,3353)                                                 &
     &  (abd_kist_it(itime,2),itime=1,ntime)
 3353   format(5d14.6)
!
        write(iun,3354)
 3354   format(' abd_kist_it(itime,3)  ')
        write(iun,3355)                                                 &
     &  (abd_kist_it(itime,3),itime=1,ntime)
 3355   format(5d14.6)
!
        write(iun,3356)
 3356   format(' abd_kist_it(itime,4)  ')
        write(iun,3357)                                                 &
     &  (abd_kist_it(itime,4),itime=1,ntime)
 3357   format(5d14.6)
!
        write(iun,3358)
 3358   format(' abd_kist_it(itime,5)  ')
        write(iun,3359)                                                 &
     &  (abd_kist_it(itime,5),itime=1,ntime)
 3359   format(5d14.6)
!
        write(iun,3360)
 3360   format(' abd_kist_it(itime,6)  ')
        write(iun,3361)                                                 &
     &  (abd_kist_it(itime,6),itime=1,ntime)
 3361   format(5d14.6)
!
        write(iun,3362)
 3362   format(' abd_kist_it(itime,7)  ')
        write(iun,3363)                                                 &
     &  (abd_kist_it(itime,7),itime=1,ntime)
 3363   format(5d14.6)
      endif
!
!COMNT190524-2244, Note: Do not include ".or.jo_th_mchi==1" here.
! Want to zero counters in "zero_arkabd" _only_ at end fo sweep. 
      if(jo_th_ark.ge.1.and.jchi_min.eq.0.and.                          &
     & (                                                                &
     &  jtime.ge.10.and.jtime.le.299                                    &
     & )                                                                &
     &) then
        call zero_arkabd ! odat_acc-01
      endif
!
!
      if(jo_cfi.eq.1) then
        write(iun,3500)
 3500   format(/' cspec_fin')
!
        write(iun,3502)                                                 &
     &            (cspec_fin(ispec),ispec=1,nspec)
 3502   format(5d14.6)
      endif
!
!
      if(jo_th_mine.eq.1) then
        write(32,3510)
 3510   format(/' mine parameters ')
!
        do iexpt=1,nexpt
          ivpm_uv=iexpt
          call setpm_uv
          call get_pdpen
!
          imine=0
          do ispec=1,nspec
            if(jfix(ispec).ge.0) then
              do ipm=1,(npmspec(ispec)-npxspec(ispec))
                if(                                                     &
     &          jctspec(ispec,ipm).eq.0.or.                             &
     &          jctspec(ispec,ipm).eq.1.or.                             &
     &          jctspec(ispec,ipm).eq.10                                &
     &          )then
                  imine=imine+1
                  cspec_mine(imine)=cspec(ispec,ipm)
                endif
              enddo
            endif
          enddo
          nmine_spec=imine
!
          imine=0
          do ireac=1,nreac
            do ipm=1,(npmreac(ireac)-npxreac(ireac))
              if(                                                       &
     &        jctreac(ireac,ipm).eq.0.or.                               &
     &        jctreac(ireac,ipm).eq.1.or.                               &
     &        jctreac(ireac,ipm).eq.10                                  &
     &        )then
                imine=imine+1
                rreac_mine(imine)=rreac(ireac,ipm)
              endif
            enddo
          enddo
          nmine_reac=imine
!
!
          write(32,3512) iexpt,nmine_spec,nmine_reac
 3512     format(     &
     &    /' iexpt  nmine_spec  nmine_reac'                             &
     &    /i6,2i12                                                      &
     &    /' cspec_mine '                                               &
     &    )
!
          write(32,3514)                                                &
     &              (cspec_mine(imine),imine=1,nmine_spec)
 3514     format(5d14.6)
!
          write(32,3516)
 3516     format(     &
     &    /' rreac_mine '                                               &
     &    )
!
          write(32,3518)                                                &
     &              (rreac_mine(imine),imine=1,nmine_reac)
 3518     format(5d14.6)
        enddo
      endif
!
!
      write(iun,3530)
 3530 format(/' crdpen_spec')
!
      write(iun,3532)                                                   &
     &              (crdpen(lcrdp),lcrdp=1,mdpen_spec)
 3532 format(5d14.6)
!
!
      write(iun,3534)
 3534 format(/' crdpen_reac')
!
      write(iun,3536)                                                   &
     &              (crdpen(lcrdp+mdpen_spec),lcrdp=1,mdpen_reac)
 3536 format(5d16.8)
!
!
!
      write(iun,3552)
 3552 format(/' cspec_th    ')
!
      write(iun,3555)                                                   &
     &              (cspec_th(ith),ith=1,mth_spec)
 3555 format(5d16.8)
!
!
      write(iun,3562)
 3562 format(' rreac_th     ')
!
      write(iun,3565)                                                   &
     &              (rreac_th(ith),ith=1,mth_reac)
 3565 format(5d16.8)
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine odat_th_x
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
!
      inquire(file='ens.o03',exist=fexist)
      if(fexist) then
        open(33,file='ens.o03',status='old')
        iun=33
        call efile(iun)
      else
!BLADE:
!       open(33,file='ens.o03',status='new')
        open(33,file='ens.o03')
!:BLADE
        rewind(33)
      endif
!
!
      write(33,3300) iout_th, no_time
 3300 format(/          &
     &       /'iout_th'                                                 &
     &       /i8                                                        &
     &       /' no_time'                                                &
     &       /i8                                                        &
     &      )
!
!
!c    call store_sfxdi
!c    call get_xdi
!
!     parallelized:
!     -------------
      jmp_kin0=jmp_kin
      jmp_kin=3
      call mpm_getkin ! odat_th_x-01
      jmp_kin=jmp_kin0
!
      do iexpt=1,nexpt
!!      ivpm_uv=iexpt
!!      call setpm_uv
!!      call kin_ini
!!      call kin_run
!!      call kin_xspec_o
!
        write(33,3310) iexpt
 3310   format(                                                         &
     &         /'  iexpt'                                               &
     &         /i8                                                      &
     &        )
!
        write(33,3321)
 3321   format(/' lspec_min vs. ivs')
        write(33,3322)                                                  &
     &              (lspec_min(ispec_vs(ivs))                           &
     &              ,ivs=1,nvs_spec)
 3322   format(10i6)
!
        write(33,3323)
 3323   format(/' lspec_max vs. ivs')
        write(33,3324)                                                  &
     &              (lspec_max(ispec_vs(ivs))                           &
     &              ,ivs=1,nvs_spec)
 3324   format(10i6)
!
        if(jrlim.eq.1) then
          write(33,3331)
 3331     format(/' lvfor vs. ireac')
          write(33,3332)                                                &
     &                (lvfor(ireac)                                     &
     &                ,ireac=1,nreac)
 3332     format(10i6)
!
          write(33,3333)
 3333     format(/' lvbak vs. ireac')
          write(33,3334)                                                &
     &                (lvbak(ireac)                                     &
     &                ,ireac=1,nreac)
 3334     format(10i6)
        endif
!
        if(jrlim.eq.2) then
          write(33,3335)
 3335     format(/' lvreac vs. ireac')
          write(33,3336)                                                &
     &                (lvreac(ireac)                                    &
     &                ,ireac=1,nreac)
 3336     format(10i6)
        endif
!
!
!c      do ivs=1,nvs_spec
        do ispec=1,nspec
          write(33,3346) iexpt                                          &
     &                  ,ispec                                          &
     &                  ,namespec(ispec)
 3346     format(/'   iexpt   ispec'     &
     &           /2i8                                                   &
     &           /'namespec:'                                           &
     &           /a80                                                   &
     &           /' xspec_o vs. io_time:'                               &
     &          )
!
          write(33,3348)                                                &
     &    (xspec_o(ispec,io_time,iexpt),io_time=1,no_time)
 3348     format(5d14.6)
        enddo
      enddo
!
      close(33)
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine odat_dos
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
!
      inquire(file='ens.o04',exist=fexist)
      if(fexist) then
        open(34,file='ens.o04',status='old')
        iun=34
        call efile(iun)
      else
!BLADE:
!       open(34,file='ens.o04',status='new')
        open(34,file='ens.o04')
!:BLADE
        rewind(34)
      endif
!
!
      iout_dos=iout_dos+1
      write(34,3400) iout_dos
 3400 format(/'iout_dos'/i8)
!
      if(iout_dos.eq.1) then
        write(34,3402)
 3402   format(/' eintv_ie,  ieintv=0,neintv:')
!
        write(34,3404) (enrg_ie(ieintv),ieintv=0,neintv)
 3404   format(5d14.6)
!
        write(34,*) ' '
        write(34,3408) iout_dos
 3408   format(/'iout_dos'/i8)
      endif
!
!
        write(34,3410)                                                  &
     &   jmvloop,imc_rep,imc_eql,imc_acc,imc_upd                        &
     &  ,imvsequ,jmty(imvsequ,jmvloop),imove                            &
     &  ,ith_rk,ith_cs,it_dos,mck_dos,nacc_dos                          &
     &  ,jcv_his,jcv_dos,neintv,nei_vis
 3410   format(     &
     &  /' jmvloop imc_rep imc_eql'                                     &
     &  ,' imc_acc imc_upd imvsequ    jmty   imove'                     &
     &  /8i8                                                            &
     &  /'   ith_rk  ith_cs it_dos mck_dos nacc_dos'                    &
     &  ,' jcv_his jcv_dos neintv nei_vis'                              &
     &  /9i8)
!
!
      write(34,3412)                                                    &
     &  htot_th_min, htot_th_max, htot_th, alnf_dos_o                   &
     &, htot_ei_min, htot_ei_max, iei_min, iei_max                      &
     &, a1_his, a2_his, d_his, wpm_his, wam_his                         &
     &, a1ln_his, a2ln_his, dln_his, wpmln_his, wamln_his
 3412 format(     &
     & /'     htot_th_min     htot_th_max         htot_th'              &
     & ,'      alnf_dos_o'                                              &
     & /4d16.8                                                          &
     & /'     htot_ei_min     htot_ei_max iei_min iei_max'              &
     & /2d16.8, 2i8                                                     &
     & /'        a1_his        a2_his         d_his'                    &
     &, '       wpm_his       wam_his'                                  &
     & /5d14.6                                                          &
     & /'      a1ln_his      a2ln_his       dln_his'                    &
     &, '     wpmln_his     wamln_his'                                  &
     & /5d14.6)
!
!
      write(34,3452)
 3452 format(' aln_dos_ie_o,  ieintv=0,neintv+1:'     &
     &,'                            enrg_ie([last col.])'               &
     &)
!
      ieintv=-1
      do leintv=1,neintv
        do icol=1,5
          ieintv_o=ieintv+icol
          if(ieintv_o.le.(neintv+1)) then
            anum(icol)=aln_dos_ie_o(ieintv_o)
          else
            anum(icol)=-1.d0
          endif
        enddo
        ieintv=ieintv+5
        if(ieintv.le.neintv) then
          anum(6)=enrg_ie(ieintv)
        else
          anum(6)=enrg_ie(neintv)
        endif
        write(34,3455) (anum(icol),icol=1,6)
 3455 format(5d14.6,d12.4)
        if(ieintv.ge.(neintv+1)) goto 455
      enddo
  455 continue
!
!
      write(34,3462)
 3462 format(' hist_ie_o,  ieintv=0,neintv+1:'     &
     &,'                               enrg_ie([last col.])'            &
     &)
!
      ieintv=-1
      do leintv=1,neintv
        do icol=1,5
          ieintv_o=ieintv+icol
          if(ieintv_o.le.(neintv+1)) then
            anum(icol)=hist_ie_o(ieintv_o)
          else
            anum(icol)=-1.d0
          endif
        enddo
        ieintv=ieintv+5
        if(ieintv.le.neintv) then
          anum(6)=enrg_ie(ieintv)
        else
          anum(6)=enrg_ie(neintv)
        endif
        write(34,3465) (anum(icol),icol=1,6)
 3465 format(5d14.6,d12.4)
        if(ieintv.ge.(neintv+1)) goto 465
      enddo
  465 continue
!
!
      close(34)
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine odat_ar
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
      open(31,file='ens.o01',status='old')
      iun=31
      call efile(iun)
!
!
!CHG190516-1747: Enable ODE solver stats output for all iout_th blocks,
!              w/ jo_th_mchi==1.
      write(31,*) '   '
      write(31,3102)                                                    &
     &                jo_ar    , jo_xspec                               &
     &              , jo_sxt   , jo_cfi    , jo_xdi , jo_xko            &
     &              , jo_th    , jo_th_opt1, jo_th_opt2                 &
     &              , jo_th_mvs                                         &
     &              , jo_th_xo , jo_th_wg , jo_th_cu, jo_th_sw          &
     &              , jo_th_bxx, jo_th_bxn, jo_th_ft, jo_th_hto         &
     &              , jo_th_ark, jo_th_mine, jo_th_dprec, jo_th_mchi
 3102 format(/     &
     &       '   jo_ar        jo_xspec'                                 &
     &      /i8,i16                                                     &
     &      /'      jo_... sxt cfi xdi xko'                             &
     &      /12x,4i4                                                    &
     &      /'   jo_th      jo_th_opt1      jo_th_opt2'                 &
     &      /i8, 2i16                                                   &
     &      /'   jo_th_... mvs  xo  wg  cu  sw bxx bxn  ft hto'         &
     &      /12x,9i4                                                    &
     &      /'   jo_th_... ark mne dpr mch'                             &
     &      /12x,4i4                                                    &
     &      )
!:CHG190516-1747
!
!
      write(31,*) '   '
      write(31,3104) nmc_rep,nmc_eql,nmc_acc,nmc_upd                    &
     &              ,mth_tot,mth_spec,mth_reac,mdokin                   &
     &              ,muf_tot,muf_spec,muf_reac                          &
     &              ,muv_tot,muv_spec,muv_reac                          &
     &              ,mdtin,mdtin_raw,mdtin_odp,ndtin,nipch              &
     &              ,ndpen_tot,ndpen_spec,ndpen_reac                    &
     &              ,nms_spec,nsft_spec,nvs_spec,nfs_spec               &
     &              ,ntime,no_time,ntxpt,nexpt,nspec,nreac
 3104 format(     &
     &       '   nmc_rep   nmc_eql   nmc_acc   nmc_upd'                 &
     &      /4i10                                                       &
     &      /'   mth_tot  mth_spec  mth_reac    mdokin'                 &
     &      /4i10                                                       &
     &      /'   muf_tot  muf_spec  muf_reac'                           &
     &      /3i10                                                       &
     &      /'   muv_tot  muv_spec  muv_reac'                           &
     &      /3i10                                                       &
     &      /'     mdtin mdtin_raw mdtin_odp     ndtin     nipch'       &
     &      /5i10                                                       &
     &      /' ndpen_tot ndpen_spec ndpen_reac'                         &
     &      /3i10                                                       &
     &      /'  nms_spec nsft_spec  nvs_spec  nfs_spec'                 &
     &      /4i10                                                       &
     &      /'     ntime   no_time     ntxpt     nexpt'                 &
     &      ,'     nspec     nreac'                                     &
     &      /6i10                                                       &
     &      )
!
!V090927:
      write(31,*) '   '
      write(31,*) '  Monte Carlo averages of fits and model parameters'
      if(jrpwgt(2).eq.1.or.jrpwgt(2).eq.2) then
        write(31,3106) imc_rep_min,arwgt,am_chisq_min(nmc_rep)
 3106   format(                                                         &
     &  /' imc_rep_min       arwgt  am_chisq_minn'                      &
     &  /i8,2d16.8                                                      &
     &  /' imc_rep       amwgt_rep     am_chisq_th    am_chisq_min'     &
     &  ,        '     arenorm_rep'                                     &
     &  )
        do imc_rep=1,nmc_rep
          write(31,3108)                                                &
     &    imc_rep                                                       &
     &    ,amwgt_rep(imc_rep)                                           &
     &    ,am_chisq_th(imc_rep)                                         &
     &    ,am_chisq_min(imc_rep)                                        &
     &    ,arenorm_rep(imc_rep)
 3108     format(i8,4d16.8)
        enddo
      endif
!:V090927
!
!
      write(31,*) '   '
      write(31,3110) ar_chisq_n, dr_chisq_n, mdtin                      &
     &              ,ar_chisq, dr_chisq                                 &
     &              ,chisq_tru
 3110 format(     &
     &       /'      ar_chisq_n      dr_chisq_n   mdtin'                &
     &       /2d16.8,i8                                                 &
     &       /'        ar_chisq        dr_chisq'                        &
     &       /2d16.8                                                    &
     &       /'    chisq_tru '                                          &
     &       /d16.8)
!
!
        write(31,*) '   '
        write(31,3116)
 3116   format(     &
     &         /'   kscal   lscal      ar_chi1_ks      dr_chi1_ks'      &
     &         /'      /               ar_chi2_ks      dr_chi2_ks'      &
     &         /'      /  chi0_ks    ar_sxplog_ks    dr_sxplog_ks'      &
     &        )
!
      do kscal=1,nkscal
        write(31,3117)                                                  &
     &   kscal, mscal_ks(kscal)                                         &
     &  ,ar_chi1_ks(kscal)                                              &
     &  ,dr_chi1_ks(kscal)                                              &
!
     &  ,ar_chi2_ks(kscal)                                              &
     &  ,dr_chi2_ks(kscal)                                              &
!
     &  ,   chi0_ks(kscal)                                              &
     &  ,ar_sxplog_ks(kscal)                                            &
     &  ,dr_sxplog_ks(kscal)
 3117   format(2i8,2d16.8/16x,2d16.8/3d16.8)
      enddo
!
        write(31,*) '   '
        write(31,3118)
 3118   format(     &
     &         /'   iscal   lscal      ar_chi1_is      dr_chi1_is'      &
     &         /'      /               ar_chi2_is      dr_chi2_is'      &
     &         /'      /  chi0_is    ar_sxplog_is    dr_sxplog_is'      &
     &        )
!
      do iscal=1,niscal
        write(31,3119)                                                  &
     &   iscal, lscal_is(iscal)                                         &
     &  ,ar_chi1_is(iscal)                                              &
     &  ,dr_chi1_is(iscal)                                              &
!
     &  ,ar_chi2_is(iscal)                                              &
     &  ,dr_chi2_is(iscal)                                              &
!
     &  ,   chi0_is(iscal)                                              &
     &  ,ar_sxplog_is(iscal)                                            &
     &  ,dr_sxplog_is(iscal)
 3119   format(2i8,2d16.8/16x,2d16.8/3d16.8)
      enddo
!
!
!
      if(jo_th_hto.ge.1) then
        write(31,3131)                                                  &
     &                           ar_htot                                &
     &                         , dr_htot                                &
     &                         , htot_tru                               &
!
     &                         , ar_hwall                               &
     &                         , dr_hwall                               &
     &                         , hwall_tru                              &
!
     &                         , ar_hbxx                                &
     &                         , dr_hbxx                                &
     &                         , hbxx_tru                               &
!
     &                         , ar_hbxn                                &
     &                         , dr_hbxn                                &
     &                         , hbxn_tru
 3131   format(//     &
     &   '         ar_htot         dr_htot        htot_tru'             &
     &  /3d16.8                                                         &
     &  /'        ar_hwall        dr_hwall       hwall_tru'             &
     &  /3d16.8                                                         &
     &  /'         ar_hbxx         dr_hbxx        hbxx_tru'             &
     &  /3d16.8                                                         &
     &  /'         ar_hbxn         dr_hbxn        hbxn_tru'             &
     &  /3d16.8                                                         &
     &  )
!
        write(31,3132)                                                  &
     &                           ar_hfour                               &
     &                         , dr_hfour                               &
     &                         , hfour_tru                              &
!
     &                         , ar_hfous                               &
     &                         , dr_hfous                               &
     &                         , hfous_tru                              &
!
     &                         , ar_hfout                               &
     &                         , dr_hfout                               &
     &                         , hfout_tru
 3132   format(     &
     &   '        ar_hfour        dr_hfour       hfour_tru'             &
     &  /3d16.8                                                         &
     &  /'        ar_hfous        dr_hfous       hfous_tru'             &
     &  /3d16.8                                                         &
     &  /'        ar_hfout        dr_hfout       hfout_tru'             &
     &  /3d16.8                                                         &
     &  )
      endif
!
!
!
      write(31,*) '   '
      write(31,3170)
 3170 format(/' MC averages of dependent parameters')
!
      ispre0=-1
!V090911:
!Fixed lcrdp-Bug:
!!!   do idpen=1,mdpen_tot
      do lcrdp=1,mdpen_tot
        idpen=idpen_crdp(lcrdp)
!:V090911
        ipm=ipm_dpen(idpen)
        ispre=ispre_dpen(idpen)
        ispec=ispec_dpen(idpen)
        ireac=ireac_dpen(idpen)
!c      call tr_spre(ispec,ireac,ispre,nspec)
!
        if(ispre.ne.ispre0) then
          ispre0=ispre
!
          write(31,3172) ispre,ispec,ireac,namespre(ispre)
 3172     format(/'   ispre   ispec   ireac/ namespre'     &
     &          /3i8     &
     &          /a80     &
     &          /' lcrdp iexpt   ipm  ipow'     &
     &          ,'  ar_crdpen^ipow  dr_crdpen^ipow'     &
     &          ,' crdpen_tru^ipow'     &
     &          )
        endif
!
        if(ispec.gt.0) npow_dpen=npow_spec
        if(ireac.gt.0) npow_dpen=npow_reac
        do ipow=1,npow_dpen
          if(ispec.gt.0) r1=pmspec(ispec,ipm,5)**ipow
          if(ireac.gt.0) r1=pmreac(ireac,ipm,5)**ipow
!
          write(31,3174)     &
!V090911:
!Fixed lcrdp-Bug:
!!!  &    idpen,iexpt_crdp(idpen),ipm,ipow    &
!
     &    lcrdp,iexpt_crdp(lcrdp),ipm,ipow    &
!
!!!  &    ,ar_crdpen(idpen,ipow),dr_crdpen(idpen,ipow),r1
!
     &    ,ar_crdpen(lcrdp,ipow),dr_crdpen(lcrdp,ipow),r1
!:V090911
 3174     format(4i6,3d16.8)
        enddo
      enddo
!
!
!
      write(31,*) '   '
      write(31,3180)
 3180 format(/' MC averages of species parameters')
!
      ispec0=-1
      do ith=1,mth_spec
        ispec=ispec_th(ith)
        ipm=ipmspec_th(ith)
!
        if(ispec.ne.ispec0) then
          ispec0=ispec
          write(31,3182) ispec,namespec(ispec)
 3182     format('   ispec / namespec'     &
     &          /i8                                                     &
     &          /a80                                                    &
     &          /'   ith   ipm  ipow'                                   &
     &          ,'   ar_cspec^ipow   dr_cspec^ipow'                     &
     &          ,' cspec_tru^ipow'                                      &
     &          )
        endif
!
        do ipow=1,npow_spec
          r1=pmspec(ispec,ipm,5)**ipow
!
          write(31,3184)                                                &
     &    ith,ipm,ipow                                                  &
     &    ,ar_cspec(ith,ipow),dr_cspec(ith,ipow),r1
 3184     format(3i6,3d16.8)
        enddo
      enddo
!
!
      write(31,*) '   '
      write(31,3190)
 3190 format(/' MC averages of reaction parameters')
!
      ireac0=-1
      do ith=1,mth_reac
        ireac=ireac_th(ith)
        ipm=ipmreac_th(ith)
!
        if(ireac.ne.ireac0) then
          ireac0=ireac
          write(31,3192) ireac,namereac(ireac)
 3192     format('   ireac / namereac'     &
     &          /i8                                                     &
     &          /a80                                                    &
     &          /'   ith   ipm  ipow'                                   &
     &          ,'   ar_rreac^ipow   dr_rreac^ipow'                     &
     &          ,' rreac_tru^ipow'                                      &
     &          )
        endif
!
        do ipow=1,npow_reac
          r1=pmreac(ireac,ipm,5)**ipow
!
          write(31,3194)                                                &
     &    ith,ipm,ipow                                                  &
     &    ,ar_rreac(ith,ipow),dr_rreac(ith,ipow),r1
 3194     format(3i6,3d16.8)
        enddo
      enddo
!
! MC averages of species boundary contacts
! and out-of-bound species and reactions counts
!
      if(jo_th_bxx.ge.1.or.jo_th_bxn.ge.1)                              &
     &  write(31,3240)
 3240 format(/' MC averages of species boundary contacts')
!
      if(jo_th_bxx.ge.1) then
!        write(31,3241)
! 3241     format(
!     :     ' ispec / namespec'
!     :    /'   ivs         ar_qbxx         dr_qbxx        qbxx_tru'
!     :    /'               ar_fbxx         dr_fbxx'
!     :    )
!
        write(31,3242)
 3242   format(/' upper boundary contacts ')
!
        do ivs=0,nvs_spec
          if(ivs.gt.0) then
            ispec=ispec_vs(ivs)
            namespec0=namespec(ispec)
          else
            ispec=0
            namespec0='  average_over_all_species  '
          endif
!
          write(31,3244)                                                &
     &                   ispec,ivs                                      &
     &                 , namespec0                                      &
     &                 , ar_qbxx(ivs)                                   &
     &                 , dr_qbxx(ivs)                                   &
     &                 ,    qbxx_tru(ivs)                               &
     &                 , ar_fbxx(ivs)                                   &
     &                 , dr_fbxx(ivs)
 3244     format(     &
     &     ' ispec   ivs / namespec'                                    &
     &    /    2i6                                                      &
     &    /    a80                                                      &
     &    /'         ar_qbxx         dr_qbxx        qbxx_tru'           &
     &    /'         ar_fbxx         dr_fbxx'                           &
     &    /    3d16.8                                                   &
     &    /    2d16.8                                                   &
     &    )
        enddo
      endif
!
!
      if(jo_th_bxn.ge.1) then
!        write(31,3251)
! 3251     format(
!     :     ' ispec / namespec'
!     :    /'   ivs         ar_qbxn         dr_qbxn        qbxn_tru'
!     :    /'               ar_fbxn         dr_fbxn'
!     :    )
!
        write(31,3252)
 3252   format(/' lower boundary contacts ')
!
        do ivs=0,nvs_spec
          if(ivs.gt.0) then
            ispec=ispec_vs(ivs)
            namespec0=namespec(ispec)
          else
            ispec=0
            namespec0='  average_over_all_species  '
          endif
!
          write(31,3254)                                                &
     &                   ispec,ivs                                      &
     &                 , namespec0                                      &
     &                 , ar_qbxn(ivs)                                   &
     &                 , dr_qbxn(ivs)                                   &
     &                 ,    qbxn_tru(ivs)                               &
     &                 , ar_fbxn(ivs)                                   &
     &                 , dr_fbxn(ivs)
 3254     format(     &
     &     ' ispec   ivs / namespec'                                    &
     &    /     2i6                                                     &
     &    /    a80                                                      &
     &    /'         ar_qbxn         dr_qbxn        qbxn_tru'           &
     &    /'         ar_fbxn         dr_fbxn'                           &
     &    /     3d16.8                                                  &
     &    /     2d16.8                                                  &
     &    )
        enddo
      endif
!
!
! MC averages of species Fourier weights
!
      if(jo_th_ft.ge.1) then
        write(31,3260)
 3260   format(/' MC averages of species Fourier weights ')
!
        do iexpt=1,nexpt
          do isegft=1,nsegft(iexpt)
            write(31,3261)                                              &
     &      iexpt,isegft                                                &
     &      ,ar_pfour_seg(isegft,iexpt)                                 &
     &      ,dr_pfour_seg(isegft,iexpt)                                 &
     &      ,   pfour_seg_tru(isegft,iexpt)                             &
     &      ,ar_qfour_seg(isegft,iexpt)                                 &
     &      ,dr_qfour_seg(isegft,iexpt)                                 &
     &      ,   qfour_seg_tru(isegft,iexpt)
 3261       format(     &
     &       '   iexpt  isegft    ar_pfour_seg    dr_pfour_seg'         &
     &      ,                '   pfour_seg_tru'                         &
     &      /2i8,3d16.8                                                 &
     &      /'                    ar_qfour_seg    dr_qfour_seg'         &
     &      ,                '   qfour_seg_tru'                         &
     &      /16x,3d16.8)
!
            write(31,3262)
 3262       format('   is_ft   ispec'     &
     &            /'        namespec'                                   &
     &            /'   ar_pfour_sfil   dr_pfour_sfil  pfour_sfil_tru'   &
     &            /'   ar_pfour_stot   dr_pfour_stot  pfour_stot_tru'   &
     &            )
!
            do is_ft=1,nsft_spec
              ispec=ispec_sft(is_ft)
              write(31,3264)                                            &
     &         is_ft,ispec                                              &
     &        ,namespec(ispec)                                          &
!
     &        ,ar_pfour_sfil(is_ft,isegft,iexpt)                        &
     &        ,dr_pfour_sfil(is_ft,isegft,iexpt)                        &
     &        ,pfour_sfil_tru(is_ft,isegft,iexpt)                       &
!
     &        ,ar_pfour_stot(is_ft,isegft,iexpt)                        &
     &        ,dr_pfour_stot(is_ft,isegft,iexpt)                        &
     &        ,pfour_stot_tru(is_ft,isegft,iexpt)
 3264         format(     &
     &               2i8                                                &
     &              /a80                                                &
     &              /3d16.8                                             &
     &              /3d16.8                                             &
     &              )
            enddo
          enddo
        enddo
      endif
!
!
!   DEACTIVATED:
      if(jo_ar.gt.10000000) then
!
      write(31,3410) (jmvloop,nkin_run(jmvloop),jmvloop=1,2)
 3410 format(//' Out-of-bounds species'     &
     &        /' jmvloop nkin_run'                                      &
     &        /2i8                                                      &
     &        /2i8                                                      &
     &        /'        namespec'                                       &
     &        /'/  ispec jmvloop     a_lspec_min     a_lspec_max'       &
     &        /'/                    r_lspec_min     r_lspec_max'       &
     &      )
      do ispec=1,nspec
        write(31,3412)                                                  &
     &  namespec(ispec)
 3412   format(a80)
!
        do jmvloop=1,2
          write(31,3414)                                                &
     &    ispec,jmvloop                                                 &
     &    ,a_lspec_min(ispec,jmvloop)                                   &
     &    ,a_lspec_max(ispec,jmvloop)                                   &
     &    ,r_lspec_min(ispec,jmvloop)                                   &
     &    ,r_lspec_max(ispec,jmvloop)
 3414     format(2i8,2d16.8/16x,2d16.8)
        enddo
      enddo
!
      write(31,3416) (jmvloop,nkin_run(jmvloop),jmvloop=1,2)
 3416 format(//' Out-of-bounds reactions'     &
     &        /' jmvloop nkin_run'                                      &
     &        /2i8                                                      &
     &        /2i8                                                      &
     &        /'        namereac'                                       &
     &        /'/  ireac jmvloop'                                       &
     &        ,'         a_lvfor         a_lvbak        a_lvreac'       &
     &        /'/               '                                       &
     &        ,'         r_lvfor         r_lvbak        r_lvreac'       &
     &      )
      do ireac=1,nreac
        write(31,3412)                                                  &
     &  namereac(ireac)
!
        do jmvloop=1,2
          write(31,3418)                                                &
     &    ireac,jmvloop                                                 &
     &    ,a_lvfor(ireac,jmvloop)                                       &
     &    ,a_lvbak(ireac,jmvloop)                                       &
     &    ,a_lvreac(ireac,jmvloop)                                      &
     &    ,r_lvfor(ireac,jmvloop)                                       &
     &    ,r_lvbak(ireac,jmvloop)                                       &
     &    ,r_lvreac(ireac,jmvloop)
 3418     format(2i8,3d16.8/16x,3d16.8)
        enddo
      enddo
!
      endif
!
!
! Hamiltonian rms forces
!
      write(31,3420)                                                    &
     &               (jmvloop                                           &
     &               ,naccp_ham_fin(jmvloop)                            &
     &               ,nprop_ham_fin(jmvloop)                            &
     &               ,nprop_ham_ini(jmvloop)                            &
     &               ,jmvloop=1,2)
 3420 format(//' Hamiltonian rms forces and rel. move distances'     &
     &        /'                 jmvloop'                               &
     &        ,        '   naccp_ham_fin'                               &
     &        ,        '   nprop_ham_fin'                               &
     &        ,        '   nprop_ham_ini'                               &
     &        /16x,i8,3i16                                              &
     &        /16x,i8,3i16                                              &
     &      )
      write(31,3421)                                                    &
     &               (jmvloop                                           &
     &               ,htot_ham_accpf(jmvloop)                           &
     &               ,htot_ham_propf(jmvloop)                           &
     &               ,htot_ham_propi(jmvloop)                           &
     &               ,jmvloop=1,2)
 3421 format(     &
     &         '                 jmvloop'                               &
     &        ,        '  htot_ham_accpf'                               &
     &        ,        '  htot_ham_propf'                               &
     &        ,        '  htot_ham_propi'                               &
     &        /16x,i8,3d16.8                                            &
     &        /16x,i8,3d16.8                                            &
     &        /'        namespec-reac'                                  &
     &        /'/ispec-reac  ipm jmvloop'                               &
     &        ,        '    aforce_accpf'                               &
     &        ,        '    aforce_propf'                               &
     &        ,        '    aforce_propi'                               &
     &        /'/                       '                               &
     &        ,        '    adhevl_accpf'                               &
     &        ,        '    adhevl_propf'                               &
     &      )
!
      ispec0=-1
      ireac0=-1
      do ith_ham=1,mth_tot
        if(ith_ham.le.mth_spec) then
          ith=ith_ham
          ispec=ispec_th(ith)
          ipm=ipmspec_th(ith)
!
          if(ispec.ne.ispec0) then
            write(31,3422)                                              &
     &      namespec(ispec)
 3422       format(a80)
          endif
          ispec0=ispec
!
          do jmvloop=1,2
            write(31,3424)                                              &
     &      ispec,ipm,jmvloop                                           &
     &      ,aforce_accpf(ith_ham,jmvloop)                              &
     &      ,aforce_propf(ith_ham,jmvloop)                              &
     &      ,aforce_propi(ith_ham,jmvloop)                              &
     &      ,adhevl_accpf(ith_ham,jmvloop)                              &
     &      ,adhevl_propf(ith_ham,jmvloop)
 3424       format(3i8,3d16.8/24x,2d16.8)
          enddo
        endif
!
        if(ith_ham.gt.mth_spec) then
          ith=ith_ham-mth_spec
          ireac=ireac_th(ith)
          ipm=ipmreac_th(ith)
!
          if(ireac.ne.ireac0) then
            write(31,3426)                                              &
     &      namereac(ireac)
 3426       format(a80)
          endif
          ireac0=ireac
!
          do jmvloop=1,2
            write(31,3428)                                              &
     &      ireac,ipm,jmvloop                                           &
     &      ,aforce_accpf(ith_ham,jmvloop)                              &
     &      ,aforce_propf(ith_ham,jmvloop)                              &
     &      ,aforce_propi(ith_ham,jmvloop)                              &
     &      ,adhevl_accpf(ith_ham,jmvloop)                              &
     &      ,adhevl_propf(ith_ham,jmvloop)
 3428       format(3i8,3d16.8/24x,2d16.8)
          enddo
        endif
      enddo
      ith_ham=-1
!
!
! acceptance ratios
!
      write(31,*) '   '
      write(31,*) '   '
      write(31,3700)
 3700 format(/' MC acceptance ratios')
!
! ... by Theta parameter
!
      write(31,*) '   '
      ispec0=-1
      do ith=1,mth_spec
        ispec=ispec_th(ith)
        ipm=ipmspec_th(ith)
!
        if(ispec.ne.ispec0) then
          ispec0=ispec
          write(31,3712) ispec,namespec(ispec)
 3712     format('   ispec / namespec'     &
     &          /i8                                                     &
     &          /a80                                                    &
     &          /'     ith     ipm jmvloop'                             &
     &          ,'      raccp_spec naccp.. nprop..'                     &
     &          )
        endif
!
        do jmvloop=1,2
          write(31,3714)                                                &
     &    ith,ipm,jmvloop                                               &
     &    ,raccp_spec(ith,jmvloop)                                      &
     &    ,naccp_spec(ith,jmvloop)                                      &
     &    ,nprop_spec(ith,jmvloop)
 3714     format(3i8,d16.8,2i8)
        enddo
      enddo
!
!
      ireac0=-1
      do ith=1,mth_reac
        ireac=ireac_th(ith)
        ipm=ipmreac_th(ith)
!
        if(ireac.ne.ireac0) then
          ireac0=ireac
          write(31,3722) ireac,namereac(ireac)
 3722     format('   ireac / namereac'     &
     &          /i8                                                     &
     &          /a80                                                    &
     &          /'     ith     ipm jmvloop'                             &
     &          ,'      raccp_reac naccp.. nprop..'                     &
     &          )
        endif
!
        do jmvloop=1,2
          write(31,3724)                                                &
     &    ith,ipm,jmvloop                                               &
     &    ,raccp_reac(ith,jmvloop)                                      &
     &    ,naccp_reac(ith,jmvloop)                                      &
     &    ,nprop_reac(ith,jmvloop)
 3724     format(3i8,d16.8,2i8)
        enddo
      enddo
!
!
!
! ... for Hamiltonian moves
!
       write(31,3812)
 3812     format(//     &
     &           ' imvsequ jmvloop'                                     &
     &          ,'       raccp_ham naccp.. nprop..'                     &
     &          )
!
      do jmvloop=1,2
        do imvsequ=1,nmvsequ(jmvloop)
          if(jmty(imvsequ,jmvloop).eq.9) then
            write(31,3814)                                              &
     &      imvsequ,jmvloop                                             &
     &      ,raccp_ham(imvsequ,jmvloop)                                 &
     &      ,naccp_ham(imvsequ,jmvloop)                                 &
     &      ,nprop_ham(imvsequ,jmvloop)
 3814       format(2i8,d16.8,2i8)
          endif
        enddo
      enddo
!
!
! ... by move type:
!
      write(31,3830)
 3830 format(//     &
     & '   ipmty jmvloop    jmty     ith'                               &
     &,'        raccp_ty naccp.. nprop..')
!
!
      do ipmty=1,3
        do jmvloop=1,2
          do ljmty=1,njmty(jmvloop)
            do ith=1,mth_ty(ipmty)
              write(31,3832)                                            &
     &         ipmty,jmvloop,jmty_lj(ljmty,jmvloop),ith                 &
     &        ,raccp_ty(ith,ljmty,jmvloop,ipmty)                        &
     &        ,naccp_ty(ith,ljmty,jmvloop,ipmty)                        &
     &        ,nprop_ty(ith,ljmty,jmvloop,ipmty)
 3832         format(4i8,d16.8,2i8)
            enddo
          enddo
        enddo
      enddo
!
! ... by move sequence step:
!
      write(31,3840)
 3840 format(//     &
     & '   ipmty jmvloop imvsequ    jmty     ith'                       &
     &,'           raccp   naccp   nprop')
!
      do ipmty=1,3
        do jmvloop=1,2
          do imvsequ=1,nmvsequ(jmvloop)
            do ith=1,mth_ty(ipmty)
              write(31,3842)                                            &
     &         ipmty,jmvloop,imvsequ                                    &
     &        ,jmty(imvsequ,jmvloop),ith                                &
     &        ,raccp(ith,imvsequ,jmvloop,ipmty)                         &
     &        ,naccp(ith,imvsequ,jmvloop,ipmty)                         &
     &        ,nprop(ith,imvsequ,jmvloop,ipmty)
 3842         format(5i8,d16.8,2i8)
            enddo
          enddo
        enddo
      enddo
!
! exptl. observed species concentrations,
! scaled to model concentrations
!
      call get_odpen
!
      write(31,4102)
 4102 format(//     &
     &       1x                                                         &
     &      ,' exptl. observed species at exptl. time points'           &
     &      )
!
      do iexpt=1,nexpt
        do ims=1,nms_spec
          ispec=ispec_ms(ims)
          write(31,*) '  '
!
          write(31,4112) iexpt, ims, ispec, jfix(ispec)                 &
     &                 , namespec(ispec)
!
 4112     format(/'   iexpt     ims   ispec    jfix'     &
     &           /4i8                                                   &
     &           /' namespec:'                                          &
     &           /a80                                                   &
     &           /'   itxpt      time_xpt yspec_xpt-lnS'                &
     &           ,        '   xspec_xpt/S     yspec_wid'                &
     &           ,                      '     yspec_tru'                &
     &           ,                      '     xspec_tru')
!
!
          do itxpt=1,ntxpt
            itmx=itmx_xpt(ims,itxpt,iexpt)
            if(itmx.gt.0) then
              iscal=iscal_xpt(itmx_xpt(ims,itxpt,iexpt))
              if(iscal.gt.0) then
                kscal=kscal_is(iscal)
                if(mscal_ks(kscal).gt.0) then
                  sxplog=ar_sxplog_ks(kscal)
                else
                  sxplog=0.d0
                endif
!
                yspec_xpt_out=yspec_xpt(itmx_xpt(ims,itxpt,iexpt))      &
     &                       -sxplog
!
                xspec_xpt_out=xspec_xpt(itmx_xpt(ims,itxpt,iexpt))      &
     &                       *dexp(-sxplog)
!
                if(itmx.le.mdtin) then
                  yspec_wid_out=yspec_wid(itmx)
                  yspec_tru_out=yspec_tru(itmx)
                  xspec_tru_out=xspec_tru(itmx)
                else
                  yspec_wid_out=-1.d0
                  yspec_tru_out=0.d0
                  xspec_tru_out=-1.d0
                endif
!
                write(31,4114) itxpt                                    &
     &                        ,time_xpt(itxpt)                          &
     &                        ,yspec_xpt_out                            &
     &                        ,xspec_xpt_out                            &
     &                        ,yspec_wid_out                            &
     &                        ,yspec_tru_out                            &
     &                        ,xspec_tru_out
 4114           format(i8,4d14.6,2d14.6)
              endif
            endif
          enddo
        enddo
      enddo
!
! MC averages of model species concentrations
!
      if(jo_ar.eq.10) then
        write(31,4120)
 4120   format(//     &
     &         1x                                                       &
     &        ,' MC averaged model species concentrations'              &
     &        /' at exptl. and model-output time points'                &
     &        )
!
        do iexpt=1,nexpt
          nspec_o(iexpt)=nspec
!
!c        do ivs=1,nvs_spec_o(iexpt)
          do ispec=1,nspec_o(iexpt)
!
!c          ispec=ispec_vs(ivs)
!V090911:
!DEACTIVATED
!!!         if(ispec.gt.nspec) then
!!!           is_xdi=ispec-nspec
!!!         else
!!!           is_xdi=is_xdi_spec(ispec,iexpt)
!!!         endif
!:V090911
!
            write(31,*) '  '
!
            nprfix='      '
!
!V090911:
!DEACTIVATED
            is_xdi=0
            jo_xdi=0
!!!         if(is_xdi.gt.0.and.jo_xdi.gt.0) then
!c            if(ivs.gt.nvs_spec.or.jo_xdi.eq.2) then
!!!           if(ispec.gt.nspec.or.jo_xdi.eq.2) then
!!!             write(31,*)                                             &
!!!  &          ' driving species with'                                 &
!!!  &          ,' exptl. data insertion (XDI):'
!!!             nprfix=' :XDI:'
!!!           else
!!!             write(31,*)                                             &
!!!  &          ' kin-evolved species from'                             &
!!!  &          ,' exptl. data insertion (KEV):'
!!!             nprfix=' :KEV:'
!!!           endif
!!!         endif
!
!!!         aline=namespec_o(ispec,iexpt)
            aline=namespec(ispec)
!:V090911
            nprfix=nprfix(1:6)//aline(1:74)
!
            write(31,4122) iexpt,ispec,is_xdi                           &
     &                    ,nspec                                        &
     &                    ,nspec_o(iexpt)                               &
     &                    ,nprfix
 4122       format(     &
     &              '   iexpt   ispec is_xdi'                           &
     &            , '   nspec'                                          &
     &            , ' nspec_o'                                          &
     &             /5i8                                                 &
     &             /' namespec:'                                        &
     &             /a80                                                 &
     &            )
            do ipow=1,npow_spec
!
!iOF081018
              write(31,4123) ipow
 4123         format('    ipow'     &
     &               /i8                                                &
     &               /' io_time itxpt_o itime_o'                        &
     &               ,                '        time_o'                  &
     &               ,                '          ar_yspec'              &
     &               ,                '      dr_yspec'                  &
     &               ,                '          ar_xspec'              &
     &               ,                '      dr_xspec'                  &
     &              )
!fOF081018
!
              do io_time=1,no_time
                if(itxpt_o(io_time).gt.0) then
                  time_o=time_xpt(itxpt_o(io_time))
                else
                  time_o=  time_itim(itime_o(io_time))
                endif
!
                write(31,4124)                                          &
     &           io_time                                                &
     &          ,itxpt_o(io_time)                                       &
     &          ,itime_o(io_time)                                       &
     &          ,time_o                                                 &
     &          ,ar_yspec(io_time,ispec,iexpt,ipow)                     &
     &          ,dr_yspec(io_time,ispec,iexpt,ipow)                     &
     &          ,ar_xspec(io_time,ispec,iexpt,ipow)                     &
     &          ,dr_xspec(io_time,ispec,iexpt,ipow)
!
!iOF081018
!4124           format(3i8,3d14.6,2d14.6)
 4124           format(3i8,d14.6,d18.10,d14.6,d18.10,d14.6)
!fOF081018
!
              enddo
            enddo
          enddo
        enddo
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine zero_arkabd
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
      ark_ksol=-1.d-20
      ark_ksolxp=0.d0
!
      do itime=0,ntime
        ark_kstp(itime)=0.d0
        ark_kdrv(itime)=0.d0
        ark_ksto(itime)=0.d0
        ark_kbad(itime)=0.d0
        ark_koks(itime)=0.d0
        ark_kslo(itime)=0.d0
!
        ark_khlo(itime,1)=0.d0
        ark_khlo(itime,2)=0.d0
        ark_lhlo(itime,1)=0.d0
        ark_lhlo(itime,2)=0.d0
        ark_lerx(itime,1)=0.d0
        ark_lerx(itime,2)=0.d0
!
!
        abd_kfai(itime)=0.d0
        abd_krdo(itime)=0.d0
        abd_krin(itime)=0.d0
        abd_kjac(itime)=0.d0
!
        do idum=1,7
          abd_kist(itime,idum)=0.d0
        enddo
      enddo
!
!
!DRLIM190524-2244:
      do ith_limd=1,mth_limd
        nplimd(ith_limd)=0
        nmlimd(ith_limd)=0
        njlimd(ith_limd)=0
        rmlimd(ith_limd)=-2.d0
        rjlimd(ith_limd)=-2.d0
      enddo
!:DRLIM190524-2244
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine sum_arkabd
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
!DRLIM190524-2244:
!
      do itime=0,ntime
        ark_kstp_it(itime)=(1.d-20+ark_kstp(itime))/ark_ksol
        ark_kdrv_it(itime)=(1.d-20+ark_kdrv(itime))/ark_ksol
        ark_ksto_it(itime)=(1.d-20+ark_ksto(itime))/ark_ksol
        ark_kbad_it(itime)=(1.d-20+ark_kbad(itime))/ark_ksol
        ark_koks_it(itime)=(1.d-20+ark_koks(itime))/ark_ksol
        ark_kslo_it(itime)=(1.d-20+ark_kslo(itime))/ark_ksol
!
        ark_khlo_it(itime,1)=(1.d-20+ark_khlo(itime,1))/ark_ksol
        ark_khlo_it(itime,2)=(1.d-20+ark_khlo(itime,2))/ark_ksol
        ark_lhlo_it(itime,1)=(1.d-20+ark_lhlo(itime,1))/ark_ksol
        ark_lhlo_it(itime,2)=(1.d-20+ark_lhlo(itime,2))/ark_ksol
        ark_lerx_it(itime,1)=(1.d-20+ark_lerx(itime,1))/ark_ksol
        ark_lerx_it(itime,2)=(1.d-20+ark_lerx(itime,2))/ark_ksol
!
!
        abd_kfai_it(itime)=(1.d-20+abd_kfai(itime))/ark_ksol
        abd_krdo_it(itime)=(1.d-20+abd_krdo(itime))/ark_ksol
        abd_krin_it(itime)=(1.d-20+abd_krin(itime))/ark_ksol
        abd_kjac_it(itime)=(1.d-20+abd_kjac(itime))/ark_ksol
!
        do idum=1,7
          abd_kist_it(itime,idum)=abd_kist(itime,idum)/ark_ksol
        enddo
      enddo
!
!
      ark_kstp_av=0.d0
      ark_kdrv_av=0.d0
      ark_ksto_av=0.d0
      ark_kbad_av=0.d0
      ark_koks_av=0.d0
      ark_kslo_av=0.d0
!
      ark_khlo_av(1)=0.d0
      ark_khlo_av(2)=0.d0
      ark_lhlo_av(1)=0.d0
      ark_lhlo_av(2)=0.d0
      ark_lerx_av(1)=0.d0
      ark_lerx_av(2)=0.d0
!
      abd_kfai_av=0.d0
      abd_krdo_av=0.d0
      abd_krin_av=0.d0
      abd_kjac_av=0.d0
!
      do idum=1,7
        abd_kist_av(idum)=0.d0
      enddo
!
!
      do itime=0,ntime
        ark_kstp_av=ark_kstp_av+ark_kstp_it(itime)
        ark_kdrv_av=ark_kdrv_av+ark_kdrv_it(itime)
        ark_ksto_av=ark_ksto_av+ark_ksto_it(itime)
        ark_kbad_av=ark_kbad_av+ark_kbad_it(itime)
        ark_koks_av=ark_koks_av+ark_koks_it(itime)
        ark_kslo_av=ark_kslo_av+ark_kslo_it(itime)
!
        ark_khlo_av(1)=ark_khlo_av(1)+ark_khlo_it(itime,1)
        ark_khlo_av(2)=ark_khlo_av(2)+ark_khlo_it(itime,2)
        ark_lhlo_av(1)=ark_lhlo_av(1)+ark_lhlo_it(itime,1)
        ark_lhlo_av(2)=ark_lhlo_av(2)+ark_lhlo_it(itime,2)
        ark_lerx_av(1)=ark_lerx_av(1)+ark_lerx_it(itime,1)
        ark_lerx_av(2)=ark_lerx_av(2)+ark_lerx_it(itime,2)
!
!
        abd_kfai_av=abd_kfai_av+abd_kfai_it(itime)
        abd_krdo_av=abd_krdo_av+abd_krdo_it(itime)
        abd_krin_av=abd_krin_av+abd_krin_it(itime)
        abd_kjac_av=abd_kjac_av+abd_kjac_it(itime)
!
        do idum=1,7
          abd_kist_av(idum)=                                            &
     &    abd_kist_av(idum)+abd_kist_it(itime,idum)
        enddo
      enddo
!:DRLIM190524-2244
!
!
!DRLIM190524-2244:
      nplimd_tot=0
      nmlimd_tot=0
      njlimd_tot=0
!
      do ith_limd=1,mth_limd
        nplimd_tot=nplimd_tot+nplimd(ith_limd)
        nmlimd_tot=nmlimd_tot+nmlimd(ith_limd)
        njlimd_tot=njlimd_tot+njlimd(ith_limd)
!
        if(nplimd(ith_limd).gt.0) then
          rmlimd(ith_limd)=nmlimd(ith_limd)/(1.0*nplimd(ith_limd))
          rjlimd(ith_limd)=njlimd(ith_limd)/(1.0*nplimd(ith_limd))
        else
          rmlimd(ith_limd)=-1.0
          rjlimd(ith_limd)=-1.0
        endif
      enddo
!
      if(nplimd_tot.gt.0) then
        rmlimd_tot=nmlimd_tot/(1.0*nplimd_tot)
        rjlimd_tot=njlimd_tot/(1.0*nplimd_tot)
      else
        rmlimd_tot=-1.0
        rjlimd_tot=-1.0
      endif
!:DRLIM190524-2244
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine kin_ini
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!     calculate all dependent model parameters (cspec,rreac)
!     from the independent ones
!
      call get_pdpen
!
!   initialize species concentration
!
      do ispec=1,nspec
        if(jfix(ispec).eq.0) then
          xspec(ispec,0)=cspec(ispec,1)
          goto 20
        endif
!
        if(jfix(ispec).ge.1) then
          call fixspec                                                  &
     &    (ispec,nspec,jfix                                             &
     &    ,npulse,nperiod,npmspec,cspec                                 &
     &    ,xspec_min,xspec_max                                          &
     &    ,ntime,time_itim,xspec                                        &
     &    ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod                &
     &    ,nspec_y,npmspec_y,ntime_y,nms_spec_y)
        endif
!
   20   continue
      enddo
!
!   initialize reaction rate coefficients and,
!   if needed, initialize multiplicities, and cooperativities
!
      do ireac=1,nreac
        jgmult=0
!
        ipm=0
        if(jkin(ireac).ge.1.and.jkin(ireac).le.29) then
          rkfor(ireac)=rreac(ireac,1)
          rkbak(ireac)=rreac(ireac,2)
          ipm=2
        endif
!
        if(jkin(ireac).ge.10.and.jkin(ireac).le.29) then
          rkfor2(ireac)=rreac(ireac,3)
          rkbak2(ireac)=rreac(ireac,4)
          ipm=4
        endif
!
        if( jkin(ireac).eq. 2.or.jkin(ireac).eq. 3                      &
     &  .or.jkin(ireac).eq.12.or.jkin(ireac).eq.13                      &
     &  .or.jkin(ireac).eq.22.or.jkin(ireac).eq.23                      &
     &  .or.jkin(ireac).eq.30                                           &
     &  )then
          jgmult=1
!
          do ipart=1,nipart(ireac)
            ipm=ipm+1
            hicoop(ipart,ireac)=rreac(ireac,ipm)
            gispec(ipart,ireac)=rreac(ireac,ipm)
            if( jkin(ireac).eq. 3                                       &
     &      .or.jkin(ireac).eq.13                                       &
     &      .or.jkin(ireac).eq.23                                       &
     &      .or.jkin(ireac).eq.30                                       &
     &      )then
              ipm=ipm+1
              gispec(ipart,ireac)=rreac(ireac,ipm)
!
              if( jkin(ireac).eq.30)                                    &
     &        hicoop(ipart,ireac)=                                      &
     &        gispec(ipart,ireac)/                                      &
     &        hicoop(ipart,ireac)
            endif
          enddo
!
          do ipart=1,nopart(ireac)
            ipm=ipm+1
            hocoop(ipart,ireac)=rreac(ireac,ipm)
            gospec(ipart,ireac)=rreac(ireac,ipm)
            if( jkin(ireac).eq. 3                                       &
     &      .or.jkin(ireac).eq.13                                       &
     &      .or.jkin(ireac).eq.23                                       &
     &      )then
              ipm=ipm+1
              gospec(ipart,ireac)=rreac(ireac,ipm)
            endif
          enddo
        endif
!
        if(jkin(ireac).eq.40) then
          jgmult=1
          rkfor(ireac)=rreac(ireac,1)
          rkbak(ireac)=rreac(ireac,2)
!
          ipm=2
          do ipart=2,nipart(ireac)
            ipm=ipm+1
            hicoop(ipart,ireac)=rreac(ireac,ipm)
            gispec(ipart,ireac)=0.d0
          enddo
!
          gispec(1,ireac)=0.d0
          gispec(2,ireac)=1.d0
          gospec(1,ireac)=0.d0
          gospec(2,ireac)=1.d0
        endif
!
        if(jkin(ireac).eq.41) then
          jgmult=1
          rkfor(ireac)=rreac(ireac,1)
          rkbak(ireac)=rreac(ireac,2)
!
          ipm=2
          do icplex=1,ncplex(ireac)
            ipm=ipm+1
            hicoop(icplex,ireac)=rreac(ireac,ipm)
          enddo
!
!        to smuggle ncplex,iicplex,iocplex,ipart_[ini,fin]
!        into "drivs", use hocoop:
          hocoop(1,ireac)=ncplex(ireac)+1.d-3
          hocoop(2,ireac)=iicplex(ireac)+1.d-3
          hocoop(3,ireac)=iocplex(ireac)+1.d-3
          ipart=3
          do icplex=1,ncplex(ireac)
            ipart=ipart+1
            hocoop(ipart,ireac)=ipart_ini(icplex,ireac)+1.d-3
            ipart=ipart+1
            hocoop(ipart,ireac)=ipart_fin(icplex,ireac)+1.d-3
          enddo
!
          do ipart=1,nipart(ireac)
            gispec(ipart,ireac)=0.d0
          enddo
          do ipart=ipart_ini(iicplex(ireac),ireac)      &
     &            ,ipart_fin(iicplex(ireac),ireac)
            gispec(ipart,ireac)=1.d0
          enddo
!
          gospec(1,ireac)=0.d0
          do ipart=2,nopart(ireac)
            gospec(ipart,ireac)=1.d0
          enddo
        endif
!
!
        if(jgmult.eq.1) then
          do ipart=1,nipart(ireac)
            ispec=iispec(ipart,ireac)
            gimult(ipart,ireac)=0.d0
            do ipart1=1,nipart(ireac)
              if(iispec(ipart1,ireac).eq.ispec)                         &
     &        gimult(ipart,ireac)=                                      &
     &        gimult(ipart,ireac)                                       &
     &        +gispec(ipart1,ireac)
            enddo
            do ipart1=1,nopart(ireac)
              if(iospec(ipart1,ireac).eq.ispec)                         &
     &        gimult(ipart,ireac)=                                      &
     &        gimult(ipart,ireac)                                       &
     &        -gospec(ipart1,ireac)
            enddo
          enddo
!
          do ipart=1,nopart(ireac)
            ispec=iospec(ipart,ireac)
            gomult(ipart,ireac)=0.d0
            do ipart1=1,nopart(ireac)
              if(iospec(ipart1,ireac).eq.ispec)                         &
     &        gomult(ipart,ireac)=                                      &
     &        gomult(ipart,ireac)                                       &
     &        +gospec(ipart1,ireac)
            enddo
            do ipart1=1,nipart(ireac)
              if(iispec(ipart1,ireac).eq.ispec)                         &
     &        gomult(ipart,ireac)=                                      &
     &        gomult(ipart,ireac)                                       &
     &        -gispec(ipart1,ireac)
            enddo
          enddo
!
!
          ipart_vs=0
          do ipart=1,nipart(ireac)
            if(jfix(iispec(ipart,ireac)).eq.0.and.                      &
     &         gimult(ipart,ireac).gt.1.d-8)                            &
     &      then
              do ipart1=1,(ipart-1)
                if(iispec(ipart1,ireac).eq.iispec(ipart,ireac))         &
     &          goto 121
              enddo
              ipart_vs=ipart_vs+1
              iispec_vs(ipart_vs,ireac)=iispec(ipart,ireac)
              gimult_vs(ipart_vs,ireac)=gimult(ipart,ireac)
              iivs_vs(ipart_vs,ireac)=                                  &
     &        ivs_spec(iispec(ipart,ireac))
            endif
  121       continue
          enddo
          nipart_vs(ireac)=ipart_vs
!
          ipart_vs=0
          do ipart=1,nopart(ireac)
            if(jfix(iospec(ipart,ireac)).eq.0.and.                      &
     &         gomult(ipart,ireac).gt.1.d-8)                            &
     &      then
              do ipart1=1,(ipart-1)
                if(iospec(ipart1,ireac).eq.iospec(ipart,ireac))         &
     &          goto 122
              enddo
              ipart_vs=ipart_vs+1
              iospec_vs(ipart_vs,ireac)=iospec(ipart,ireac)
              gomult_vs(ipart_vs,ireac)=gomult(ipart,ireac)
              iovs_vs(ipart_vs,ireac)=                                  &
     &        ivs_spec(iospec(ipart,ireac))
            endif
  122       continue
          enddo
          nopart_vs(ireac)=ipart_vs
        endif
      enddo
!
!
!c    if(jkrxdi.ge.1.and.jkrxdi.le.9) then
!
!      Note: must do this here (not in "set_xdi"!)
!      b/c of "iexpt"-dependence, if nexpt>1.
!      If nexpt=1, can be done in "set_xdi", just once.
!c      if(nexpt.gt.1) then
!c        do ispec=1,nspec
!c          do itime=0,ntime
!c            jsegxd(ispec,itime)=0
!c          enddo
!
!c          is_xdi=is_xdi_spec(ispec,iexpt)
!c          if(is_xdi.gt.0) then
!c            do isegxd=1,nsegxd(is_xdi,iexpt)
!c              do itime=                                               &
!c   &           itime_xdii(isegxd,is_xdi,iexpt)                        &
!c   &          ,itime_xdif(isegxd,is_xdi,iexpt)
!c                jsegxd(ispec,itime)=isegxd
!c              enddo
!c            enddo
!c          endif
!c        enddo
!c      endif
!
!
!c      do is_xdi=1,nsxdi_spec(iexpt)
!c        ispec=ispec_xdi(is_xdi,iexpt)
!c        if(jfix(ispec).gt.0) then
!c          do itime=0,ntime
!c            xspec(ispecX_xdi(is_xdi,iexpt),itime)=                    &
!c   &        xspec( ispec_xdi(is_xdi,iexpt),itime)
!c          enddo
!c        endif
!
!
!c        do isegxd=1,nsegxd(is_xdi,iexpt)
!c          do itime=                                                   &
!c   &      itime_xdii(isegxd,is_xdi,iexpt),                            &
!c   &      itime_xdif(isegxd,is_xdi,iexpt)
!c              xspec(ispec,itime)=                                     &
!c   &          dexp(                                                   &
!c   &          xxdi(time_itim(itime),isegxd,is_xdi,iexpt               &
!c   &                    ,abaxdi,time_xdii,otime_xdifi                 &
!c   &                    ,nbaxdi,jbaxdi                                &
!c   &                    ,nbaxdi_y,nsegxd_y,nsxdi_y,nexpt_y)           &
!c   &          )
!c          enddo
!c        enddo
!c      enddo
!
!
!c      do is_xdi=1,nsxdi_spec(iexpt)
!c        if(jfix(ispec_xdi(is_xdi,iexpt)).eq.0) then
!c          xspec(ispecX_xdi(is_xdi,iexpt),0)=                          &
!c   &      xspec( ispec_xdi(is_xdi,iexpt),0)
!c        endif
!c      enddo
!c    endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine kin_run
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
      call kin_run0
!
!V090911:
!DEACTIVATED
!c    if(jkrxdi.eq.0.or.jkrxdi.ge.10) call kin_run0
!c    if(jkrxdi.ge.1.and.jkrxdi.le.9) call kin_run1
!:V090911
!
      call get_xdpen
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine kin_run0
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
      do ispec=1,nspec
        if(jfix(ispec).eq.0) then
          if(xspec(ispec,0).gt.xspec_max(ispec).or.                     &
     &       xspec(ispec,0).lt.xspec_min(ispec)    )                    &
     &    then
            errtag='000113'
            call err_term
          endif
        endif
      enddo
!
! zero counter for total number of rate fct evaluations (calls to "drivs").
!
!DRLIM190524-2244:
      n_drv=0 ! Must be set _here_, since n_drv is to count all rate fct calls,
              ! starting at itime=0.
!
!CORR190526-1736:
!     k_drv=0 ! <== Must _not_ be set here, but in "adodes" for all ODE solver options,
!             !     since k_drv is to count rate fct calls separately for each "itime",
!             !     see bottom of "adodes"
!:CORR190526-1736
!
!:DRLIM190524-2244
!
!
! Nonadaptive ODE Solver Choices:
! (equidistant grid only)
!
! jtime=1: Orig. Euler method
      if(jtime.eq.1) call kin_sol_e1
!
! jtime=2: Modified Euler method
      if(jtime.eq.2) call kin_sol_e2
!
!
!
! Adapative ODE Solver Method Choices:
!
! jtime= 10, 11, 20, 21 (, 18 ,19):
!   Adaptive Runge-Kutta (ARK) method
! jtime=110,111,120,121 (, 118, 119):
!   Adaptive Adams method (under LSODES)
! jtime=210,211,220,221 (, 218, 219):
!   Adaptive Backward Differentiation (ABD)
!   implicit method (under LSODES)
!
! t-Grid Choices:
!
! jtime=10,110,210(,18,118,218):
!   Equidist. grid solution only:
!   exptl. time pts. not included in grid, done by interpolation
!   tpulse-discontinuities not included in grid
! jtime=11,111,211(,19,119,219):
!   Non-equidist. grid solution:
!   exptl. t-pts. included in grid
!   tpulse-discontinuities not included in grid
! jtime=20,120,220:
!   Non-equidist. grid solution:
!   exptl. t-pts. not included in grid, done by interpolation
!   tpulse-discontinuities included in grid
! jtime=21,121,221:
!   Non-equidist. grid solution:
!   exptl. t-pts. included in grid
!   tpulse-discontinuities included in grid
!
!db
! old version of kin_sol_ads, keep/use
! for debugging only
!
      if(jtime.eq.18) call kin_sol_ads0
      if(jtime.eq.118) call kin_sol_ads0
      if(jtime.eq.218) call kin_sol_ads0
!
      if(jtime.eq.19) call kin_sol_ads1
      if(jtime.eq.119) call kin_sol_ads1
      if(jtime.eq.219) call kin_sol_ads1
!fb
      if(jtime.eq.10) call kin_sol_ads10
      if(jtime.eq.110) call kin_sol_ads10
      if(jtime.eq.210) call kin_sol_ads10
!
      if(jtime.eq.11) call kin_sol_ads11
      if(jtime.eq.111) call kin_sol_ads11
      if(jtime.eq.211) call kin_sol_ads11
!
      if(jtime.eq.20) call kin_sol_ads20
      if(jtime.eq.120) call kin_sol_ads20
      if(jtime.eq.220) call kin_sol_ads20
!
      if(jtime.eq.21) call kin_sol_ads21
      if(jtime.eq.121) call kin_sol_ads21
      if(jtime.eq.221) call kin_sol_ads21
!
!
      if(jmvloop.eq.1.or.jmvloop.eq.2) then
        nkin_run(jmvloop)=nkin_run(jmvloop)+1
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine kin_sol_e1
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! 1st-order Euler ODE solver with fixed time step dtime
!
      include 'ens.def'
!
!     remove upper limit on number of rate fct calls
      nlim_drv0=-1
!
        do ivs=1,nvs_spec
          if(jfox(ispec_vs(ivs)).eq.1.) then
            xspec(ispec_vs(ivs),0)=dloyy(xspec(ispec_vs(ivs),0)         &
     &                                  ,xspec_min(ispec_vs(ivs)))
          endif
        enddo
!
!
        do itime=1,ntime
          time_xr=time_itim(itime-1)
          do ispec=1,nspec
            xspec_itim(ispec)=xspec(ispec,itime-1)
          enddo
!
! Note that xspec_i, time_i_fs are not needed as inputs
! to drivs when jtime=1,2, since all species conc. are
! evaluated _only_ "on-grid", i.e. for times time_itim(itime).
! For these "on-grid" times, all fixed-spec concs. (jfix>0) are
! already stored in xspec, by "fix_spec" being called in "kin_ini".
!
          call drivs(time_xr,xspec_itim,vspec                           &
!
     &              ,time_i_fs,xspec_i                                  &
     &              ,vfor,vbak,xspec_min,xspec_max                      &
     &              ,yspec_min_vs,yspec_max_vs                          &
     &              ,wspec_vs_min,wspec_vs_max                          &
     &              ,frlim_vs_min,frlim_vs_max                          &
     &              ,rkfor,rkbak,rkfor2,rkbak2                          &
     &              ,odtime,jkin,jrlim                                  &
     &              ,lvfor,lvbak,lvreac                                 &
     &              ,iispec,iospec,nipart,nopart                        &
     &              ,hicoop,hocoop                                      &
     &              ,iispec_vs,iospec_vs,nipart_vs,nopart_vs            &
     &              ,gimult_vs,gomult_vs,iivs_vs,iovs_vs                &
     &              ,nspec,nreac,nfs_spec0,nvs_spec                     &
     &              ,ispec_fs,ispec_vs,nlim_drv0,n_drv,k_drv            &
     &              ,jtime,jfox,jfix,npulse,nperiod                     &
     &              ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod      &
     &              ,npmspec_y                                          &
     &              ,nspec_y,nreac_y,npart_y,ntime_y,nms_spec_y)
!
!
          do ivs=1,nvs_spec
            xnew=                                                       &
     &           xspec(ispec_vs(ivs),itime-1)                           &
     &          +vspec(ispec_vs(ivs))*dtime
            xspec(ispec_vs(ivs),itime)=xnew
!
            if(jfox(ispec_vs(ivs)).eq.0) then
              if(xnew.gt.xspec_max_lo(ispec_vs(ivs))) then
                xspec(ispec_vs(ivs),itime)                              &
     &          =xspec_max_lo(ispec_vs(ivs))
              endif
              if(xnew.lt.xspec_min_hi(ispec_vs(ivs))) then
                xspec(ispec_vs(ivs),itime)                              &
     &          =xspec_min_hi(ispec_vs(ivs))
              endif
            endif
!
            if(jfox(ispec_vs(ivs)).eq.1) then
              if(xnew.gt.yspec_max_lo_vs(ivs)) then
                xspec(ispec_vs(ivs),itime)                              &
     &          =yspec_max_lo_vs(ivs)
              endif
              if(xnew.lt.yspec_min_hi_vs(ivs)) then
                xspec(ispec_vs(ivs),itime)                              &
     &          =yspec_min_hi_vs(ivs)
              endif
            endif
          enddo
!
          time_w2sv=time_itim(itime)
          call mpm_kin_w2sv
        enddo
!
!
        do ivs=1,nvs_spec
          if(jfox(ispec_vs(ivs)).eq.1.) then
            do itime=0,ntime
              xspec(ispec_vs(ivs),itime)=                               &
     &        dexxp(xspec(ispec_vs(ivs),itime)                          &
     &             ,yspec_min_vs(ivs)                                   &
     &             ,yspec_max_vs(ivs))
            enddo
          endif
        enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine kin_sol_e2
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! 2nd-order (=modified) Euler ODE solver with fixed time step dtime
!
!
      include 'ens.def'
!
!
!     suppress upper limit on number of rate fct calls
      nlim_drv0=-1
!
!
        do ivs=1,nvs_spec
          if(jfox(ispec_vs(ivs)).eq.1.) then
            xspec(ispec_vs(ivs),0)=dloyy(xspec(ispec_vs(ivs),0)         &
     &                                  ,xspec_min(ispec_vs(ivs)))
          endif
        enddo
!
!
!
!
        do itime=1,ntime
          time_xr=time_itim(itime-1)
          do ispec=1,nspec
            xspec_itim(ispec)=xspec(ispec,itime-1)
          enddo
!
! Note that xspec_i, time_i_fs are not needed as inputs
! to drivs when jtime=1,2, since all species conc. are
! evaluated _only_ "on-grid", i.e. for times time_itim(itime).
! For these "on-grid" times, all fixed-spec concs. (jfix>0) are
! already stored in xspec, by "fix_spec" being called in "kin_ini".
!
          call drivs(time_xr,xspec_itim,vspec                           &
!
     &              ,time_i_fs,xspec_i                                  &
     &              ,vfor,vbak,xspec_min,xspec_max                      &
     &              ,yspec_min_vs,yspec_max_vs                          &
     &              ,wspec_vs_min,wspec_vs_max                          &
     &              ,frlim_vs_min,frlim_vs_max                          &
     &              ,rkfor,rkbak,rkfor2,rkbak2                          &
     &              ,odtime,jkin,jrlim                                  &
     &              ,lvfor,lvbak,lvreac                                 &
     &              ,iispec,iospec,nipart,nopart                        &
     &              ,hicoop,hocoop                                      &
     &              ,iispec_vs,iospec_vs,nipart_vs,nopart_vs            &
     &              ,gimult_vs,gomult_vs,iivs_vs,iovs_vs                &
     &              ,nspec,nreac,nfs_spec0,nvs_spec                     &
     &              ,ispec_fs,ispec_vs,nlim_drv0,n_drv,k_drv            &
     &              ,jtime,jfox,jfix,npulse,nperiod                     &
     &              ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod      &
     &              ,npmspec_y                                          &
     &              ,nspec_y,nreac_y,npart_y,ntime_y,nms_spec_y)
!
          do ivs=1,nvs_spec
            xspec(ispec_vs(ivs),itime)=                                 &
     &             xspec(ispec_vs(ivs),itime-1)                         &
     &             +vspec(ispec_vs(ivs))*dtime
          enddo
!
          time_xr=time_itim(itime)
          do ispec=1,nspec
            xspec_itim(ispec)=xspec(ispec,itime)
          enddo
!
          call drivs(time_xr,xspec_itim,vspec                           &
!
     &              ,time_i_fs,xspec_i                                  &
     &              ,vfor,vbak,xspec_min,xspec_max                      &
     &              ,yspec_min_vs,yspec_max_vs                          &
     &              ,wspec_vs_min,wspec_vs_max                          &
     &              ,frlim_vs_min,frlim_vs_max                          &
     &              ,rkfor,rkbak,rkfor2,rkbak2                          &
     &              ,odtime,jkin,jrlim                                  &
     &              ,lvfor,lvbak,lvreac                                 &
     &              ,iispec,iospec,nipart,nopart                        &
     &              ,hicoop,hocoop                                      &
     &              ,iispec_vs,iospec_vs,nipart_vs,nopart_vs            &
     &              ,gimult_vs,gomult_vs,iivs_vs,iovs_vs                &
     &              ,nspec,nreac,nfs_spec0,nvs_spec                     &
     &              ,ispec_fs,ispec_vs,nlim_drv0,n_drv,k_drv            &
     &              ,jtime,jfox,jfix,npulse,nperiod                     &
     &              ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod      &
     &              ,npmspec_y                                          &
     &              ,nspec_y,nreac_y,npart_y,ntime_y,nms_spec_y)
!
          do ivs=1,nvs_spec
            xnew=                                                       &
     &             0.5d0                                                &
     &             *(xspec(ispec_vs(ivs),itime)                         &
     &              +xspec(ispec_vs(ivs),itime-1)                       &
     &              +vspec(ispec_vs(ivs))*dtime                         &
     &              )
            xspec(ispec_vs(ivs),itime)=xnew
!
            if(jfox(ispec_vs(ivs)).eq.0) then
              if(xnew.gt.xspec_max_lo(ispec_vs(ivs))) then
                xspec(ispec_vs(ivs),itime)                              &
     &          =xspec_max_lo(ispec_vs(ivs))
              endif
              if(xnew.lt.xspec_min_hi(ispec_vs(ivs))) then
                xspec(ispec_vs(ivs),itime)                              &
     &          =xspec_min_hi(ispec_vs(ivs))
              endif
            endif
!
            if(jfox(ispec_vs(ivs)).eq.1) then
              if(xnew.gt.yspec_max_lo_vs(ivs)) then
                xspec(ispec_vs(ivs),itime)                              &
     &          =yspec_max_lo_vs(ivs)
              endif
              if(xnew.lt.yspec_min_hi_vs(ivs)) then
                xspec(ispec_vs(ivs),itime)                              &
     &          =yspec_min_hi_vs(ivs)
              endif
            endif
          enddo
!
          time_w2sv=time_itim(itime)
          call mpm_kin_w2sv
        enddo
!
!
        do ivs=1,nvs_spec
          if(jfox(ispec_vs(ivs)).eq.1.) then
            do itime=0,ntime
              xspec(ispec_vs(ivs),itime)=                               &
     &        dexxp(xspec(ispec_vs(ivs),itime)                          &
     &             ,yspec_min_vs(ivs)                                   &
     &             ,yspec_max_vs(ivs))
            enddo
          endif
        enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine kin_sol_ads0
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
      if(jtime.ge.100.and.jtime.le.299) then
        time_ir=time_itim(0)
        call set_lss_ini
!
!c      iun=31
!c      call XSETUN(iun)
!c      open(31,file='ens.o01',status='old')
!c      call efile(iun)
!
!c      mflag_lss=1
        mflag_lss=0
        call XSETF(mflag_lss)
      endif
!
      ark_ksol=ark_ksol+1.d0
!
      hini_ark= dtime_ark*rhini_ark
!
      do ispec=1,nspec
        xspec_i(ispec,0)                                                &
     &  =xspec(ispec,0)
      enddo
!
      do itime_f=1,ntime
        time_i=time_itim(itime_f-1)
        time_f=time_itim(itime_f)
!
        time_i_fs=time_i
        do ifs=1,nfs_spec
          xspec_i(ispec_fs(ifs),1)=                                     &
     &    (xspec(ispec_fs(ifs),itime_f)-xspec(ispec_fs(ifs),itime_f-1)) &
     &    *odtime
        enddo
!
        call adodes ! kin_sol_ads0-01
!
        do ivs=1,nvs_spec
          xspec(ispec_vs(ivs),itime_f)=xspec_i(ispec_vs(ivs),0)
        enddo
      enddo
!
      close(31)
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine kin_sol_ads1
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
      ark_ksol=ark_ksol+1.d0
!
!
      itxpt_i=-1
      itime_i=0
!
      time_i=time_itim(0)
      if(jtime.ge.100.and.jtime.le.299) then
        time_ir=time_itim(0)
        call set_lss_ini
!
!c      iun=31
!c      call XSETUN(iun)
!c      open(31,file='ens.o01',status='old')
!c      call efile(iun)
!
!c      mflag_lss=1
        mflag_lss=0
        call XSETF(mflag_lss)
      endif
!
      do ispec=1,nspec
        xspec_i(ispec,0)                                                &
     &  =xspec(ispec,0)
      enddo
!
      hini_ark=dtime_ark*rhini_ark
!
      do irkit=1,nrkit
        itxpt_f=itxpt_rki(irkit)
        if(itxpt_f.ge.1) then
          if(jrkit_xpt(itxpt_f).lt.0) then
            itime_f=itime_rki(irkit)+1
            time_f=time_xpt(itxpt_f)
          else
            goto 190
          endif
        else
          itime_f=itime_rki(irkit)
          time_f=time_itim(itime_f)
        endif
!
        time_i_fs=time_itim(itime_i)
        do ifs=1,nfs_spec
          xspec_i(ispec_fs(ifs),0)=                                     &
     &    xspec(ispec_fs(ifs),itime_i)
!
          xspec_i(ispec_fs(ifs),1)=                                     &
     &    (xspec(ispec_fs(ifs),itime_f)-xspec(ispec_fs(ifs),itime_i))   &
     &    *odtime
        enddo
!
        call adodes ! kin_sol_ads1-01
!
        if(itxpt_f.le.0) then
          do ivs=1,nvs_spec
            xspec(ispec_vs(ivs),itime_f)=                               &
     &      xspec_i(ispec_vs(ivs),0)
          enddo
        else
          do ivs=1,nvs_spec
            ims=ims_spec(ispec_vs(ivs))
            if(ims.gt.0)                                                &
     &      xspec_ms(ims)=                                              &
     &      xspec_i(ispec_vs(ivs),0)
          enddo
!
          dtime_xr=time_xpt(itxpt_f)-time_i_fs
          do ifs=1,nfs_spec
            ims=ims_spec(ispec_fs(ifs))
            if(ims.gt.0) then
              if(jfix(ispec_fs(ifs)).lt.5000) then
                xspec_ms(ims)=                                          &
     &           xspec_i(ispec_fs(ifs),0)                               &
     &          +dtime_xr*xspec_i(ispec_fs(ifs),1)
              else
                xspec_ms(ims)=                                          &
     &          fspec_ti(                                               &
     &                   time_xpt(itxpt_f)                              &
     &                  ,jfix,ispec_fs(ifs),xspec_min,xspec_max         &
     &                  ,npulse,nperiod                                 &
     &                  ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod  &
     &                  ,nspec_y,npmspec_y                              &
     &                  )
              endif
            endif
          enddo
!
          do ims=1,nms_spec
            do itxpt=itxpt_f,ntxpt
              if(itxpt.gt.itxpt_f.and.jrkit_xpt(itxpt).lt.0) goto 90
              if(                                                       &
     &        itmx_xpt(ims,itxpt,iexpt).gt.0.and.                       &
     &        (jrkit_xpt(itxpt).eq.1.or.itxpt.eq.itxpt_f)               &
     &        )                                                         &
     &        xspec_chi(itmx_xpt(ims,itxpt,iexpt))=                     &
     &        xspec_ms(ims)
            enddo
   90       continue
          enddo
        endif
!
        time_i=time_f
!
        itxpt_i=itxpt_f
        if(itxpt_i.le.0) itime_i=itime_f
!
  190   continue
      enddo
!
      do ims=1,nms_spec
        do itxpt=1,ntxpt
          if(itmx_xpt(ims,itxpt,iexpt).gt.0) then
            if(jrkit_xpt(itxpt).eq.0)                                   &
     &        xspec_chi(itmx_xpt(ims,itxpt,iexpt))=                     &
     &        xspec(ispec_ms(ims),itime_xpt(itxpt))
!
            if(jrkit_xpt(itxpt).eq.2)                                   &
     &        xspec_chi(itmx_xpt(ims,itxpt,iexpt))=                     &
     &        xspec(ispec_ms(ims),itime_xpt(itxpt)+1)
          endif
        enddo
      enddo
!
      close(31)
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine kin_sol_ads10
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
      ark_ksol=ark_ksol+1.d0
!
!
      if(jtime.ge.100.and.jtime.le.299) then
        time_ir=time_itim(0)
        call set_lss_ini
!
!c      iun=31
!c      call XSETUN(iun)
!c      open(31,file='ens.o01',status='old')
!c      call efile(iun)
!
!c      mflag_lss=1
        mflag_lss=0
        call XSETF(mflag_lss)
      endif
!
      do ispec=1,nspec
        xspec_i(ispec,0)                                                &
     &  =xspec(ispec,0)
      enddo
!
      hini_ark=dtime_ark*rhini_ark
!
      do itgri=1,ntgri
        time_i=time_tgr(itgri-1)
        time_f=time_tgr(itgri)
!
        itime_i=itime_tgr(itgri-1)
        itime_f=itime_i+1
!
        time_i_fs=time_itim(itime_i)
        do ifs=1,nfs_spec
          ispec=ispec_fs(ifs)
          xspec_i(ispec,0)=xspec(ispec,itime_i)
          xspec_i(ispec,1)=                                             &
     &    (xspec(ispec,itime_f)-xspec(ispec,itime_i))                   &
     &    *odtime
        enddo
!
        call adodes ! kin_sol_ads10-01
!
        do ivs=1,nvs_spec
          xspec(ispec_vs(ivs),itime_f)=                                 &
     &    xspec_i(ispec_vs(ivs),0)
        enddo
      enddo
!
!
      close(31)
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine kin_sol_ads11
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
      ark_ksol=ark_ksol+1.d0
!
!
      if(jtime.ge.100.and.jtime.le.299) then
        time_ir=time_itim(0)
        call set_lss_ini
!
!c      iun=31
!c      call XSETUN(iun)
!c      open(31,file='ens.o01',status='old')
!c      call efile(iun)
!
!c      mflag_lss=1
        mflag_lss=0
        call XSETF(mflag_lss)
      endif
!
      do ispec=1,nspec
        xspec_i(ispec,0)                                                &
     &  =xspec(ispec,0)
      enddo
!
      hini_ark=dtime_ark*rhini_ark
!
      do itgri=1,ntgri
        time_i=time_tgr(itgri-1)
        time_f=time_tgr(itgri)
!
        itime_i=itime_tgr(itgri-1)
        itime_f=itime_i+1
!
        itxpt_f=itxpt_tgr(itgri)
!
        time_i_fs=time_itim(itime_i)
        do ifs=1,nfs_spec
          ispec=ispec_fs(ifs)
          xspec_i(ispec,0)=xspec(ispec,itime_i)
          xspec_i(ispec,1)=                                             &
     &    (xspec(ispec,itime_f)-xspec(ispec,itime_i))                   &
     &    *odtime
        enddo
!
        call adodes ! kin_sol_ads11
!
        if(itxpt_f.le.0) then
          do ivs=1,nvs_spec
            xspec(ispec_vs(ivs),itime_f)=                               &
     &      xspec_i(ispec_vs(ivs),0)
          enddo
        else
          do ims=1,nms_spec
            if(jfix(ispec_ms(ims)).eq.0)                                &
     &      xspec_ms(ims)=                                              &
     &      xspec_i(ispec_ms(ims),0)
          enddo
!
          dtime_xr=time_xpt(itxpt_f)-time_i_fs
          do ifs=1,nfs_spec
            ims=ims_spec(ispec_fs(ifs))
            if(ims.gt.0) then
              if(jfix(ispec_fs(ifs)).lt.5000) then
                xspec_ms(ims)=                                          &
     &           xspec_i(ispec_fs(ifs),0)                               &
     &          +dtime_xr*xspec_i(ispec_fs(ifs),1)
              else
                xspec_ms(ims)=                                          &
     &          fspec_ti(                                               &
     &                   time_xpt(itxpt_f)                              &
     &                  ,jfix,ispec_fs(ifs),xspec_min,xspec_max         &
     &                  ,npulse,nperiod                                 &
     &                  ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod  &
     &                  ,nspec_y,npmspec_y                              &
     &                  )
              endif
            endif
          enddo
!
          do ims=1,nms_spec
            do itxpt=itxpt_f,ntxpt
              if(itxpt.gt.itxpt_f.and.jtgri_xpt(itxpt).lt.0) goto 90
              if(                                                       &
     &        itmx_xpt(ims,itxpt,iexpt).gt.0.and.                       &
     &        (jtgri_xpt(itxpt).ge.3.or.itxpt.eq.itxpt_f)               &
     &        )                                                         &
     &        xspec_chi(itmx_xpt(ims,itxpt,iexpt))=                     &
     &        xspec_ms(ims)
            enddo
   90       continue
          enddo
        endif
      enddo
!
!
      do ims=1,nms_spec
        do itxpt=1,ntxpt
          if(itmx_xpt(ims,itxpt,iexpt).gt.0) then
            if(jtgri_xpt(itxpt).eq.0)                                   &
     &        xspec_chi(itmx_xpt(ims,itxpt,iexpt))=                     &
     &        xspec(ispec_ms(ims),itime_xpt(itxpt))
!
            if(jtgri_xpt(itxpt).eq.2)                                   &
     &        xspec_chi(itmx_xpt(ims,itxpt,iexpt))=                     &
     &        xspec(ispec_ms(ims),itime_xpt(itxpt)+1)
          endif
        enddo
      enddo
!
!
      close(31)
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine kin_sol_ads20
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
      ark_ksol=ark_ksol+1.d0
!
!
      if(jtime.ge.100.and.jtime.le.299) then
        time_ir=time_itim(0)
        call set_lss_ini
!
!c      iun=31
!c      call XSETUN(iun)
!c      open(31,file='ens.o01',status='old')
!c      call efile(iun)
!
!c      mflag_lss=1
        mflag_lss=0
        call XSETF(mflag_lss)
      endif
!
      do ispec=1,nspec
        xspec_i(ispec,0)                                                &
     &  =xspec(ispec,0)
      enddo
!
      hini_ark=dtime_ark*rhini_ark
!
      call ini_tifodes
!
      do itgri=1,ntgri
        time_ib=time_tgr(itgri-1)
        time_fb=time_tgr(itgri)
!
        itime_i=itime_tgr(itgri-1)
        itime_f=itime_i+1
!
        call upd_tifodes
!
        do itifode=1,ntifode
          time_i=time_tif(itifode-1)
          time_f=time_tif(itifode)
          time_i_fs=0.5d0*(time_i+time_f)
          do ifs=1,nfs_spec
            ispec=ispec_fs(ifs)
            xspec_i(ispec,0)=                                           &
     &      fspec_ti(                                                   &
     &               time_i_fs,jfix,ispec,xspec_min,xspec_max           &
     &              ,npulse,nperiod                                     &
     &              ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod      &
     &              ,nspec_x,npmspec_x                                  &
     &              )
!
            xspec_i(ispec,1)=                                           &
     &      spulse(ispec,-2)
          enddo
          if(ntifode.gt.1.or.ntifode_prv.gt.1) call set_lss_ini
          call adodes ! kin_sol_ads20
        enddo
        ntifode_prv=ntifode
!
!
        do ivs=1,nvs_spec
          xspec(ispec_vs(ivs),itime_f)=                                 &
     &    xspec_i(ispec_vs(ivs),0)
        enddo
      enddo
!
!
      close(31)
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine kin_sol_ads21
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
      ark_ksol=ark_ksol+1.d0
!
      if(jtime.ge.100.and.jtime.le.299) then
        time_ir=time_itim(0)
        call set_lss_ini
!
!c      iun=31
!c      call XSETUN(iun)
!c      open(31,file='ens.o01',status='old')
!c      call efile(iun)
!
!c      mflag_lss=1
        mflag_lss=0
        call XSETF(mflag_lss)
      endif
!
      do ispec=1,nspec
        xspec_i(ispec,0)                                                &
     &  =xspec(ispec,0)
        xspec_i(ispec,1)=0.d0
      enddo
!
      hini_ark=dtime_ark*rhini_ark
!
      call ini_tifodes
!
      do itgri=1,ntgri
        time_ib=time_tgr(itgri-1)
        time_fb=time_tgr(itgri)
!
        itime_i=itime_tgr(itgri-1)
        itime_f=itime_i+1
!
        itxpt_f=itxpt_tgr(itgri)
!
        call upd_tifodes
!
        do itifode=1,ntifode
          time_i=time_tif(itifode-1)
          time_f=time_tif(itifode)
          time_i_fs=0.5d0*(time_i+time_f)
          do ifs=1,nfs_spec
            ispec=ispec_fs(ifs)
            xspec_i(ispec,0)=                                           &
     &      fspec_ti(                                                   &
     &               time_i_fs,jfix,ispec,xspec_min,xspec_max           &
     &              ,npulse,nperiod                                     &
     &              ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod      &
     &              ,nspec_x,npmspec_x                                  &
     &              )
!
            xspec_i(ispec,1)=                                           &
     &      spulse(ispec,-2)
          enddo
          if(ntifode.gt.1.or.ntifode_prv.gt.1) call set_lss_ini
          call adodes ! kin_sol_ads21
        enddo
        ntifode_prv=ntifode
!
        if(itxpt_f.le.0) then
          do ivs=1,nvs_spec
            xspec(ispec_vs(ivs),itime_f)=                               &
     &      xspec_i(ispec_vs(ivs),0)
          enddo
        else
          do ims=1,nms_spec
            if(jfix(ispec_ms(ims)).eq.0)                                &
     &      xspec_ms(ims)=                                              &
     &      xspec_i(ispec_ms(ims),0)
          enddo
!
          dtime_xr=time_xpt(itxpt_f)-time_i_fs
          do ifs=1,nfs_spec
            ims=ims_spec(ispec_fs(ifs))
            if(ims.gt.0) then
              if(jfix(ispec_fs(ifs)).lt.5000) then
                xspec_ms(ims)=                                          &
     &           xspec_i(ispec_fs(ifs),0)                               &
     &          +dtime_xr*xspec_i(ispec_fs(ifs),1)
              else
                xspec_ms(ims)=                                          &
     &          fspec_ti(                                               &
     &                   time_xpt(itxpt_f)                              &
     &                  ,jfix,ispec_fs(ifs),xspec_min,xspec_max         &
     &                  ,npulse,nperiod                                 &
     &                  ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod  &
     &                  ,nspec_y,npmspec_y                              &
     &                  )
              endif
            endif
          enddo
!
          do ims=1,nms_spec
            do itxpt=itxpt_f,ntxpt
              if(itxpt.gt.itxpt_f.and.jtgri_xpt(itxpt).lt.0) goto 90
              if(                                                       &
     &        itmx_xpt(ims,itxpt,iexpt).gt.0.and.                       &
     &        (jtgri_xpt(itxpt).ge.3.or.itxpt.eq.itxpt_f)               &
     &        )                                                         &
     &        xspec_chi(itmx_xpt(ims,itxpt,iexpt))=                     &
     &        xspec_ms(ims)
            enddo
   90       continue
          enddo
        endif
      enddo
!
!
      do ims=1,nms_spec
        do itxpt=1,ntxpt
          if(itmx_xpt(ims,itxpt,iexpt).gt.0) then
            if(jtgri_xpt(itxpt).eq.0)                                   &
     &        xspec_chi(itmx_xpt(ims,itxpt,iexpt))=                     &
     &        xspec(ispec_ms(ims),itime_xpt(itxpt))
!
            if(jtgri_xpt(itxpt).eq.2)                                   &
     &        xspec_chi(itmx_xpt(ims,itxpt,iexpt))=                     &
     &        xspec(ispec_ms(ims),itime_xpt(itxpt)+1)
          endif
        enddo
      enddo
!
!
      close(31)
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ini_tifodes
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! initializes tables for merging tpulse t-pts. into ODE solver grid
!
!
      do ifs=1,nfs_spec
        if(jfix(ispec_fs(ifs)).eq.1) then
          jfin_tif_fs(ifs)=190
        else
          ipulse_tif_fs(ifs)=-1
          mshift_tif_fs(ifs)=0
          jfin_tif_fs(ifs)=0
        endif
      enddo
!
      ntifode_prv=0
      ntifal_fin=0
!
      itifal=0
      time_tifal(itifal)=time0
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine upd_tifodes
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! constructs tables for merging tpulse t-pts. into ODE solver grid
!
!
! tabulate tpulse-values w/in search interval [time_ib,time_fb)
! by fixed species
!
      itifode=0
!
      itifal=ntifal_fin
      ntifal_ini=ntifal_fin+1
!
      do ifs=1,nfs_spec
!c      itifal_fs(ifs)=itifal
        if(jfin_tif_fs(ifs).gt.0) goto 190
        if(jfin_tif_fs(ifs).eq.-1) then
          tpulse_tif=tpulse(ispec,-2)
          ipulse=-2
          mshift=0
          goto 120
        endif
!
        ispec=ispec_fs(ifs)
        ipulse=ipulse_tif_fs(ifs)
        mshift=mshift_tif_fs(ifs)
        tshift=mshift*tperiod(ispec)
!
  110   continue
        if(jfin_tif_fs(ifs).gt.0) goto 190
!
        if(ipulse.ge.-1) ipulse=ipulse+1
        if(ipulse.gt.npulse(ispec)) then
          ipulse=1
          mshift=mshift+1
          tshift=tshift+tperiod(ispec)
        endif
        if(ipulse.ge.0) tpulse_tif=tpulse(ispec,ipulse)+tshift
!
        if(tpulse_tif.ge.tpulse(ispec,-2)) then
          jfin_tif_fs(ifs)=-1
          tpulse_tif=tpulse(ispec,-2)
          ipulse=-2
          mshift=0
        endif
!
        if(tpulse_tif.gt.time1) then
          jfin_tif_fs(ifs)=1
          goto 190
        endif
!
  120   continue
        if(tpulse_tif.gt.time_ib.and.tpulse_tif.le.time_fb) then
          itifal=itifal+1
          if(itifal.gt.ntifal_x) goto 390
!
          time_tifal(itifal)=tpulse_tif
!
          ipulse_tif_fs(ifs)=ipulse
          mshift_tif_fs(ifs)=mshift
!
          if(ipulse.ge.0) goto 110
        endif
!
!
  190   continue
      enddo
!
      ntifal_fin=itifal
!
!
      itifode=0
      time_tif(0)=time_ib
      if(ntifal_ini.gt.ntifal_fin) goto 290
!
  210 continue
      tpulse_tif=time1+dtime
      jtifode=0
      do itif=ntifal_ini,ntifal_fin
        if(                                                             &
     &  time_tifal(itif).gt.(time_tif(itifode)+eps_time)                &
     &  .and.                                                           &
     &  time_tifal(itif).lt.(time_fb-eps_time)                          &
     &  .and.                                                           &
     &  time_tifal(itif).lt.tpulse_tif                                  &
     &  ) then
          tpulse_tif=time_tifal(itif)
          jtifode=1
        endif
      enddo
!
      if(jtifode.eq.1) then
        itifode=itifode+1
        if(itifode.gt.ntifode_x) goto 390
!
        time_tif(itifode)=tpulse_tif
        goto 210
      endif
!
  290 continue
      ntifode=itifode+1
      time_tif(ntifode)=time_fb
!
!
      return
!
!
  390 continue
      if(itifode.gt.ntifode_x.or.itifal.gt.ntifode_x) then
            errtag='000114'
            call err_term
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine adodes
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!DRLIM190524-2244:
!
! Runs all adaptive-dtime ODE solvers (ARK, LSODES), being invoked by 
! solver wrapper subrts 
!   kin_sol_ads0,  kin_sol_ads1,  
!   kin_sol_ads10, kin_sol_ads11,
!   kin_sol_ads20, kin_sol_ads21.
! Fixed-dtime Euler solvers, kin_sol_e1 and kin_sol_e2, do not invoke adodes.
!
!:DRLIM190524-2244
!
! set initial and final time of ODE integration interval
! for input into ODE solver; note: time_ir and/or time_fr
! may be altered by ODE solver; but want to keep time_i
! and time_f unchanged
      time_ir=time_i
      time_fr=time_f
!
! zero/initial ODE step and error counters
      k_stp=0
!
!CORR190526-1736:
      k_drv=0 ! <== Must be set _here_, not in " kin_run0", for all ODE solver options,
              !     since k_drv is to count rate fct calls separately for each "itime",
              !     see bottom of "adodes"
!:CORR190526-1736
!
      k_sto=-1
      k_bad=0
      k_oks=0
      k_slo=0
!
      k_hlo(1)=0
      k_hlo(2)=0
      aln_hlo(1)=0.d0
      aln_hlo(2)=0.d0
      aln_erx(1)=0.d0
      aln_erx(2)=0.d0
!
      k_fai=0
      k_rdo=0
      k_rin=0
      k_jac=0
      do idum=1,7
        k_ist(idum)=0
      enddo
!
!DRLIM190527-0046:
! Skip ODE solvers of rate fct call limit is being exceeded:
      if(n_drv.gt.nlim_drv.and.nlim_drv.gt.0) then
        do ivs=1,nvs_spec
          xspec_f(ispec_vs(ivs))=xspec_i(ispec_vs(ivs),0)
        enddo
        goto 400
      endif
!:DRLIM190527-0046
!
!
! copy initial species concentration xspec_i to xspec_f
! and, if required, do species variable (log) transformation on xspec_f
      do ivs=1,nvs_spec
        if(jfox(ispec_vs(ivs)).eq.1) then
          xspec_f(ispec_vs(ivs))=dloyy(xspec_i(ispec_vs(ivs),0)         &
     &                               ,xspec_min(ispec_vs(ivs)))
        else
          xspec_f(ispec_vs(ivs))=xspec_i(ispec_vs(ivs),0)
        endif
      enddo
!
!
! run adaptive Runge-Kutta solver
  100 continue
      if((jtime.ge.10.and.jtime.le.29)                                  &
     &.or.jfail_lss.eq.1) then
        time_fi=time_fr
!LATER:
!==> "drivs" arg-list revise
!==> Must set: jtevol=jtime_ark before "call call odeint_ark"
        call odeint_ark(                                                &
     &   vspec,xspec_i,xspec_f                                          &
     &  ,vfor,vbak,xspec_min,xspec_max                                  &
     &  ,yspec_min_vs,yspec_max_vs                                      &
     &  ,wspec_vs_min,wspec_vs_max                                      &
     &  ,frlim_vs_min,frlim_vs_max                                      &
     &  ,rkfor,rkbak,rkfor2,rkbak2                                      &
     &  ,odtime_rl,jkin,jrlim,lvfor,lvbak,lvreac                        &
     &  ,iispec,iospec,nipart,nopart                                    &
     &  ,hicoop,hocoop                                                  &
     &  ,iispec_vs,iospec_vs,nipart_vs,nopart_vs                        &
     &  ,gimult_vs,gomult_vs,iivs_vs,iovs_vs                            &
     &  ,nspec,nreac,nfs_spec,nvs_spec,ispec_fs,ispec_vs                &
     &  ,jtime_ark,jfox,jfix,npulse,nperiod                             &
     &  ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod                  &
     &  ,npmspec_y                                                      &
     &  ,nspec_y,nreac_y,npart_y,ntime_y,nms_spec_y                     &
!
     &  ,time_i_fs,time_ir,time_fr,eps_ark,aln_hlo,aln_erx              &
     &  ,hini_ark,hmin1_ark,hmin2_ark                                   &
     &  ,nlim_drv,n_drv,k_drv,k_oks,k_bad,k_sto                         &
     &  ,k_hlo,k_slo,k_stp                                              &
     &  ,dtime_sto,time_sto,xspec_sto                                   &
     &  ,nstp_ark,nsto_ark,nsto_ark_y)
!
!
        time_fo=time_fr
!
        if(jfail_lss.eq.1) then
          jfail_lss=-1
          goto 300
        endif
      endif
!
!
! run adaptive BDF or Adams solver
  200 continue
      if(jtime.ge.100.and.jtime.le.299) then
        time_fi=time_fr
!
!      pack xspec_f from expanded to compressed format
        do ivs=1,nvs_spec
          xspec_f(ivs)=xspec_f(ispec_vs(ivs))
        enddo
!
!
        mf_lssr=mf_lss
        ido_lss=0
        jfail_lss=0
!
  210   continue
        ido_lss=ido_lss+1
        if(ido_lss.gt.1) k_rdo=k_rdo+1
        if(istate_lss.eq.3) k_jac=k_jac+1
!
!==> "drivs" arg-list revise
!==> Must set: jtevol=jtime_abd before "call DLSODES"
        call DLSODES (neq_lss, xspec_f, time_ir, time_fr                &
     &              , itol_lss, rtol_lss, atol_lss, itask_lss           &
     &              , istate_lss, iopt_lss                              &
     &              , rwork_lss, lrw_lss_y, iwork_lss, liw_lss_y        &
     &              , mf_lssr                                           &
!
     &              ,time_i_fs,xspec_i                                  &
     &              ,vfor,vbak,xspec_min,xspec_max                      &
     &              ,yspec_min_vs,yspec_max_vs                          &
     &              ,wspec_vs_min,wspec_vs_max                          &
     &              ,frlim_vs_min,frlim_vs_max                          &
     &              ,rkfor,rkbak,rkfor2,rkbak2                          &
     &              ,odtime_rl,jkin,jrlim                               &
     &              ,lvfor,lvbak,lvreac                                 &
     &              ,iispec,iospec,nipart,nopart                        &
     &              ,hicoop,hocoop                                      &
     &              ,iispec_vs,iospec_vs,nipart_vs,nopart_vs            &
     &              ,gimult_vs,gomult_vs,iivs_vs,iovs_vs                &
     &              ,nspec,nreac,nfs_spec,nvs_spec                      &
     &              ,ispec_fs,ispec_vs,nlim_drv,n_drv,k_drv             &
     &              ,jtime_abd,jfox,jfix,npulse,nperiod                 &
     &              ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod      &
     &              ,npmspec_x                                          &
     &              ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x)
!
! initial error handling, trying to do BDF/Adams re-run
! after re-calculating the Jacobian
        if(istate_lss.le.-1.and.istate_lss.ge.-7) then
          k_ist(-istate_lss)=k_ist(-istate_lss)+1
        endif
        if((istate_lss.eq.-1.or.istate_lss.eq.-4.or.istate_lss.eq.-5)   &
     &  .and.ido_lss.le.1) then
          istate_lss=3
          goto 210
        endif
!
! unpack xspec_f from compressed to expanded format
        ivs=nvs_spec
        do ivs0=1,nvs_spec
          xspec_f(ispec_vs(ivs))=xspec_f(ivs)
          ivs=ivs-1
        enddo
!
! final error handling using ARK instead of BDF/Adams
        if(istate_lss.lt.0) then
          call set_lss_ini
!         note: final xspec_f will now be calculated
!         by ARK/odeint_ark; therefore, need to
!         re-initial w/ istate_lss=1 before next
!         dlsodes call, in order to make dlsodes
!         start with the correct initial condition (xspec_f);
!         otherwise, in next call to dlsodes, it will use the xspec_f
!         output from last dlsodes call as initial for the new call,
!         since xspec_f is internally stored by dlsodes between calls
!         and automatically used as initial when istate_lss=2,3
!
          jfail_lss=1
          k_fai=k_fai+1
!
!         initial BDF error handling has failed; try ARK instead
          goto 100
        endif
!
        time_fo=time_ir
      endif
!
!
! undo species variable (log) transformation on xspec_f
  300 continue
      do ivs=1,nvs_spec
        if(jfox(ispec_vs(ivs)).eq.1)                                    &
     &  xspec_f(ispec_vs(ivs))=dexxp(xspec_f(ispec_vs(ivs))             &
     &                              ,yspec_min_vs(ivs)                  &
     &                              ,yspec_max_vs(ivs)                  &
     &                              )
      enddo
!
! impose xspec_min and xspec_max limits on xspec_f
        do ivs=1,nvs_spec
          xnew=                                                         &
     &         xspec_f(ispec_vs(ivs))
          if(xnew.gt.xspec_max_lo(ispec_vs(ivs))) then
            xnew                                                        &
     &      =xspec_max_lo(ispec_vs(ivs))
            call set_lss_ini
          endif
          if(xnew.lt.xspec_min_hi(ispec_vs(ivs))) then
            xnew                                                        &
     &      =xspec_min_hi(ispec_vs(ivs))
            call set_lss_ini
          endif
          xspec_f(ispec_vs(ivs))=xnew
        enddo
!       note: if final xspec_f is being altered from its last
!       dlsodes output we need to re-initial w/ istate_lss=1
!       here before next dlsodes call, in order to make dlsodes
!       re-start with the correct initial condition (xspec_f);
!       otherwise, in next call to dlsodes, it will use the xspec_f
!       output from prior dlsodes call as initial for the new call,
!       since xspec_f is internally stored by dlsodes between calls
!       and automatically re-used as initial when istate_lss=2,3
!
        if(istate_lss.eq.1) k_rin=k_rin+1
!
! copy final species concentration xspec_f to xspec_i
      do ivs=1,nvs_spec
        xspec_i(ispec_vs(ivs),0)                                        &
     &  =xspec_f(ispec_vs(ivs))
      enddo
!
! accumulate erorr/re-try counts
      if(jo_th_ark.ge.1) then
        ark_kstp(itime_f)=ark_kstp(itime_f)+k_stp
        ark_kdrv(itime_f)=ark_kdrv(itime_f)+k_drv
        ark_ksto(itime_f)=ark_ksto(itime_f)+k_sto
        ark_kbad(itime_f)=ark_kbad(itime_f)+k_bad
        ark_koks(itime_f)=ark_koks(itime_f)+k_oks
        ark_kslo(itime_f)=ark_kslo(itime_f)+k_slo
!
        ark_khlo(itime_f,1)=ark_khlo(itime_f,1)+k_hlo(1)
        ark_khlo(itime_f,2)=ark_khlo(itime_f,2)+k_hlo(2)
        ark_lhlo(itime_f,1)=ark_lhlo(itime_f,1)+aln_hlo(1)
        ark_lhlo(itime_f,2)=ark_lhlo(itime_f,2)+aln_hlo(2)
        ark_lerx(itime_f,1)=ark_lerx(itime_f,1)+aln_erx(1)
        ark_lerx(itime_f,2)=ark_lerx(itime_f,2)+aln_erx(2)
!
        abd_kfai(itime_f)=abd_kfai(itime_f)+k_fai
        abd_krdo(itime_f)=abd_krdo(itime_f)+k_rdo
        abd_krin(itime_f)=abd_krin(itime_f)+k_rin
        abd_kjac(itime_f)=abd_kjac(itime_f)+k_jac
!
        do idum=1,7
          abd_kist(itime_f,idum)=abd_kist(itime_f,idum)+k_ist(idum)
        enddo
      endif
!
      if(dabs(time_fi-time_fo).gt.(1.d-2*hmin0_ark)) then
            errtag='000115'
            call err_term
      endif
!
!
      ido_lss=0
      jfail_lss=0
!
!DRLIM190527-0046:
  400 continue
!:DRLIM190527-0046
!
      time_w2sv=time_f
      call mpm_kin_w2sv
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine kin_run1
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!V090911:
!DEACTIVATED
!R    This subrt is not being called anymore, since all solvers kin_sol_...xd
!R    have been deactivated.
!:V090911
!
      include 'ens.def'
!
!
      do ispec=1,nspec
        if(jfix(ispec).eq.0) then
          if(xspec(ispec,0).gt.xspec_max(ispec).or.                     &
     &       xspec(ispec,0).lt.xspec_min(ispec)    )                    &
     &    then
            errtag='000116'
            call err_term
          endif
        endif
      enddo
!
! jtime=1: Orig. Euler method
!
!V090911:
!DEACTIVATED
!R    if(jtime.eq.1) call kin_sol_e1xd
!:V090911
!
! jtime=2: Modified Euler method
!
!V090911:
!DEACTIVATED
!R    if(jtime.eq.2) call kin_sol_e2xd
!:V090911
!
! jtime=10,11: Adaptive Runge-Kutta method
! (NOT YET IMPLEMENTED for XDI processeing!!!)
!V090911:
!DEACTIVATED
!R    if(jtime.eq.10) call kin_sol_ads0xd
!R    if(jtime.eq.11) call kin_sol_ads1xd
!R    if(jtime.eq.20) call kin_sol_ads0xd
!R    if(jtime.eq.21) call kin_sol_ads1xd
!R    if(jtime.eq.110) call kin_sol_ads0xd
!R    if(jtime.eq.111) call kin_sol_ads1xd
!R    if(jtime.eq.120) call kin_sol_ads0xd
!R    if(jtime.eq.121) call kin_sol_ads1xd
!R    if(jtime.eq.210) call kin_sol_ads0xd
!R    if(jtime.eq.211) call kin_sol_ads1xd
!R    if(jtime.eq.220) call kin_sol_ads0xd
!R    if(jtime.eq.221) call kin_sol_ads1xd
!:V090911
!
!
      if(jmvloop.eq.1.or.jmvloop.eq.2) then
        nkin_run(jmvloop)=nkin_run(jmvloop)+1
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine kin_sol_e1xd
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!V190211:
!DEACTIVATED
!:V190211
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine kin_sol_e2xd
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!V190211:
!DEACTIVATED
!:V190211
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine kin_sol_ads0xd
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
            errtag='000117'
            call err_term
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine kin_sol_ads1xd
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
            errtag='000118'
            call err_term
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine odat_xspec
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
        if(jo_xko.eq.1) then
          call odat_xspec1
        endif
!
        if(jo_xko.eq.2) then
          call odat_xspec1
          call odat_xspec2
        endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine odat_xspec1
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
      open(41,file='ens.o11',status='old')
      iun=41
      call efile(iun)
!
      write(41,*) '  '
!
      if(jmvloop.eq.2) then
        write(41,3002) jmvloop,imc_rep,imc_acc,imc_upd,iexpt
 3002   format(' jmvloop imc_rep imc_acc imc_upd   iexpt'     &
     &         /5i8)
        goto 20
      endif
!
      if(jmvloop.eq.1) then
        write(41,3003) jmvloop,imc_rep,imc_eql,iexpt
 3003   format(' jmvloop imc_rep imc_eql   iexpt'     &
     &         /4i8)
        goto 20
      endif
!
      if(jmvloop.eq.0) then
        write(41,3004) jmvloop,iexpt
 3004   format(     &
     &         /'start configuration'                                   &
     &         /' jmvloop   iexpt'                                      &
     &         /2i8)
        goto 20
      endif
!
   20 continue
!
      if(jmvloop.gt.0) then
        write(41,3005)                                                  &
     &   jmvloop                                                        &
     &  ,imvsequ                                                        &
     &  ,jmty(imvsequ,jmvloop)                                          &
     &  ,imove                                                          &
     &  ,ith_upd                                                        &
     &  ,iexpt                                                          &
     &  ,jaccp
 3005   format(     &
     &  ' jmvloop imvsequ    jmty   imove ith_upd   iexpt   jaccp'      &
     &  /7i8)
      endif
!
!
      write(41,3010)
 3010 format( 1x,' initial and final species concentrations'     &
     &       /   '   ispec         timei         xspec'                 &
     &      )
!
      do ispec=1,nspec
        write(41,3020) namespec(ispec)
 3020   format(a80)
!
        itime=0
        timei=time0
        write(41,3030) ispec,timei,xspec(ispec,itime)
 3030   format(i8,2d14.6)
!
        itime=ntime
        timei=time1
        write(41,3035) ispec,timei,xspec(ispec,itime)
 3035   format(i8,2d14.6)
      enddo
!
!
!   DEACTIVATED:
      if(jo_xko.gt.100000) then
        write(41,3040)
 3040   format( 1x,' final reaction concentrations')
!
        write(41,3050)
 3050   format(     &
     &          '   ireac         timei         xreac')
        do ireac=1,nreac
          itime=ntime
          timei=time1
          write(41,3060) ireac,timei,xreac(ireac,itime)
 3060     format(i8,2d14.6)
        enddo
      endif
!   :DEACTIVATED
!
!
      write(41,3110)
 3110 format(//     &
     &       1x                                                         &
     &      ,' observable species at exptl. time points'                &
     &      )
!
      do ims=1,nms_spec
        ispec=ispec_ms(ims)
        write(41,3120) ims, ispec,namespec(ispec)
 3120   format(/'     ims   ispec'     &
     &         /2i8                                                     &
     &         /' namespec:'                                            &
     &         /a80                                                     &
     &         /'   iexpt    itxpt      time_xpt     xspec_chi')
!
!cc     do iexpt=1,nexpt
          do itxpt=1,ntxpt
            write(41,3130) iexpt,itxpt,time_xpt(itxpt)                  &
     &                    ,xspec_chi(itmx_xpt(ims,itxpt,iexpt))
 3130       format(2i8,2d14.6)
          enddo
        enddo
!cc   enddo
!
!
      write(41,3150)
 3150 format(1x,' all species at all times')
!
      do ispec=1,nspec
        write(41,3160) ispec,namespec(ispec)
 3160   format( '   ispec'     &
     &         /i8                                                      &
     &         /' namespec:'                                            &
     &         /a80                                                     &
     &         /'   itime         timei         xspec')
!
        mtime=-1
        do itime=0,ntime
          mtime=mtime+1
          if(mtime.eq.ntskip) mtime=0
          if(mtime.eq.0.or.itime.eq.ntime) then
            timei=time0+itime*dtime
            write(41,3170) itime,timei,xspec(ispec,itime)
 3170       format(i8,2d14.6)
          endif
        enddo
      enddo
!
!   DEACTIVATED:
      if(jo_xko.gt.100000) then
        write(41,3210)
 3210   format(1x,' time-dep. reaction concentrations')
!
        do ireac=1,nreac
          write(41,3220) ireac
 3220     format( '   ireac'     &
     &           /i8                                                    &
     &           /'   itime         timei         xreac')
!
          mtime=-1
          do itime=0,ntime
            mtime=mtime+1
            if(mtime.eq.ntskip) mtime=0
            if(mtime.eq.0.or.itime.eq.ntime) then
              timei=time0+itime*dtime
              write(41,3230) itime,timei,xreac(ireac,itime)
 3230         format(i8,2d14.6)
            endif
          enddo
        enddo
      endif
!   :DEACTIVATED
!
      close(41)
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine odat_xspec2
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
      open(42,file='ens.o12',status='old')
      iun=42
      call efile(iun)
!
      write(42,3110)
 3110 format('#'/'#',/'#',1x,' time-dep. species concentrations'/'#')
!
      do ispec=1,nspec
        write(42,3120) iexpt,ispec,namespec(ispec)
 3120   format('#'     &
     &         /'#','   iexpt   ispec'                                  &
     &         /'#',2i8                                                 &
     &         /'#',' namespec:'                                        &
     &         /'#',a80                                                 &
     &         /'#', '  itime         timei         xspec')
!
        mtime=-1
        do itime=0,ntime
          mtime=mtime+1
          if(mtime.eq.ntskip) mtime=0
          if(mtime.eq.0.or.itime.eq.ntime) then
            timei=time0+itime*dtime
            write(42,3130) itime,timei,xspec(ispec,itime)
 3130       format(i8,2d14.6)
          endif
        enddo
        write(42,*) ' '
        write(42,*) ' '
      enddo
!
      close(42)
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine odat_xspec3
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!     this subprogram is currently DEACTIVATED !
!
!
      inquire(file='ens.o13',exist=fexist)
      if(fexist) then
        open(43,file='ens.o13',status='old')
      else
!BLADE:
!       open(43,file='ens.o13',status='new')
        open(43,file='ens.o13')
!:BLADE
      endif
!
      if(nset.ge.2) then
        iun=43
        call efile(iun)
      else
        rewind(43)
      endif
!
!
      write(43,3210)
 3210 format('#'/'#',/'#',1x,' time-dep. reaction concentrations')
!
      do ireac=1,nreac
        write(43,3220) ireac
 3220   format('#'     &
     &         /'#','   ireac'                                          &
     &         /'#',i8                                                  &
     &         /'#', '  itime         timei         xreac')
!
        mtime=-1
        do itime=0,ntime
          mtime=mtime+1
          if(mtime.eq.ntskip) mtime=0
          if(mtime.eq.0.or.itime.eq.ntime) then
            timei=time0+itime*dtime
            write(43,3230) itime,timei,xreac(ireac,itime)
 3230       format(i8,2d14.6)
          endif
        enddo
        write(43,*) ' '
        write(43,*) ' '
      enddo
!
!
      iun=43
      close(iun)
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine refl_th                                                &
     &    (theta1,ahi_th,alo_th,isign_pi)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! reflects Theta-component off boundary
!
      implicit none
!
      integer isign_pi, isign_dt, isign_bc, jct_th, mbounc
!
      real*8 theta1, theta1x, alo_th, ahi_th, dahilo, dtheta1x, sahilo
      real*8 dexp, dlog
!
!cc jct_th=1 NOT NEEDED:
      jct_th=0
!
      isign_pi=1
!
   20 continue
      isign_dt=0
!
      if(theta1.gt.ahi_th) then
        theta1x=ahi_th
        isign_dt=1
      endif
!
      if(theta1.lt.alo_th) then
        theta1x=alo_th
        isign_dt=-1
      endif
!
      if(isign_dt.eq.0) goto 22
!
      if(jct_th.eq.0) then
        dahilo=ahi_th-alo_th
        sahilo=(ahi_th+alo_th)*0.5d0
!
        dtheta1x=theta1-theta1x
!
        mbounc=(dabs(dtheta1x)/dahilo)
        if((mbounc*dahilo).gt.dabs(dtheta1x)) mbounc=mbounc-1
        isign_bc=(-1)**mbounc
!
        theta1x=sahilo+0.4999999999d0*isign_bc*isign_dt*dahilo
        dtheta1x=0.999999998d0*isign_bc                                 &
     &     *(dtheta1x-mbounc*isign_dt*dahilo)
!
        theta1=theta1x-dtheta1x
      endif
!
!
!cc jct_th=1 NOT NEEDED:
      if(jct_th.eq.1) then
        dahilo=dlog(ahi_th/alo_th)
        sahilo=dlog(ahi_th*alo_th)*0.5d0
!
        dtheta1x=dlog(theta1/theta1x)
!
        mbounc=(dabs(dtheta1x)/dahilo)
        if((mbounc*dahilo).gt.dabs(dtheta1x)) mbounc=mbounc-1
        isign_bc=(-1)**mbounc
!
        theta1x=sahilo+0.4999999999d0*isign_bc*isign_dt*dahilo
        dtheta1x=0.999999998d0*isign_bc                                 &
     &     *(dtheta1x-mbounc*isign_dt*dahilo)
!
        theta1=dexp(theta1x-dtheta1x)
      endif
!
!      ... and reverse conj. momentum sign (for fict. Ham. evol.):
      isign_pi=-isign_bc*isign_pi
!
      goto 20
   22 continue
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine fixspec                                                &
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
     &    (ispec,nspec,jfix                                             &
     &    ,npulse,nperiod,npmspec,cspec                                 &
     &    ,xspec_min,xspec_max                                          &
     &    ,ntime,time_itim,xspec                                        &
     &    ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod                &
     &    ,nspec_x,npmspec_x,ntime_x,nms_spec_x)
!
      implicit none
!
      integer ispec,nspec,ntime,mshift,ipulse,itime,jperiod,jslope      &
     &       ,nspec_x,npmspec_x,ntime_x,nms_spec_x
!
      integer jfix(1:nspec_x)                                           &
     &       ,npulse(1:nspec_x)                                         &
     &       ,nperiod(1:nspec_x)                                        &
     &       ,npmspec(1:nspec_x)
!
      real*8 xtix, tix, rshift, fspec_ti, owid, ortpi
      real*8 datan
!
      real*8 cspec(1:nspec_x,0:npmspec_x)                               &
     &      ,xspec(1:(nspec_x+nms_spec_x),0:ntime_x)                    &
     &      ,xspec_min(1:nspec_x)                                       &
     &      ,xspec_max(1:nspec_x)                                       &
     &      ,time_itim(0:ntime_x)                                       &
     &      ,tpulse(1:nspec_x,-2:npmspec_x)                             &
     &      ,cpulse(1:nspec_x,-2:npmspec_x)                             &
     &      ,dtpulse(1:nspec_x,0:npmspec_x)                             &
     &      ,spulse(1:nspec_x,-2:npmspec_x)                             &
     &      ,tperiod(1:nspec_x)                                         &
     &      ,otperiod(1:nspec_x)
!
!
      if(jfix(ispec).eq.1) then
        do itime=0,ntime
          xspec(ispec,itime)=cspec(ispec,1)
        enddo
!
        cpulse(ispec,0)=cspec(ispec,1)
        cpulse(ispec,-2)=0.d0
!c      spulse(ispec,0)=0.d0
!c      spulse(ispec,-1)=0.d0
        spulse(ispec,-2)=0.d0
        tpulse(ispec,-1)=time_itim(0)
        tpulse(ispec,-2)=                                               &
     &   10.d0*(dabs(time_itim(0))+dabs(time_itim(ntime))               &
     &         +dabs(time_itim(ntime)-time_itim(0)))
!
        return
      endif
!
!V090831:
      jperiod=0
      if(jfix(ispec).eq.11                                              &
     &.or.jfix(ispec).eq.21                                             &
     &.or.jfix(ispec).eq.31                                             &
     &.or.jfix(ispec).eq.5011                                           &
     &.or.jfix(ispec).eq.5021                                           &
     &.or.jfix(ispec).eq.5031)                                          &
     &jperiod=1
!:V090831
!
      jslope=0
      if(jfix(ispec).eq.10                                              &
     &.or.jfix(ispec).eq.11                                             &
     &.or.jfix(ispec).eq.5010                                           &
     &.or.jfix(ispec).eq.5011)                                          &
     &jslope=1
!
!V090831:
      if(jfix(ispec).eq.10                                              &
     &.or.jfix(ispec).eq.11                                             &
     &.or.jfix(ispec).eq.20                                             &
     &.or.jfix(ispec).eq.21                                             &
     &.or.jfix(ispec).eq.5010                                           &
     &.or.jfix(ispec).eq.5011                                           &
     &.or.jfix(ispec).eq.5020                                           &
     &.or.jfix(ispec).eq.5021                                           &
     &)then
!:V090831
        tpulse(ispec,-1)=time_itim(0)
        do ipulse=0,npulse(ispec)
          dtpulse(ispec,ipulse)=cspec(ispec,2*ipulse+1)
          tpulse(ispec,ipulse)=                                         &
     &    tpulse(ispec,ipulse-1)+dtpulse(ispec,ipulse)
          cpulse(ispec,ipulse)=cspec(ispec,2*ipulse+2)
        enddo
        cpulse(ispec,-2)=0.d0
        if(jslope.eq.1) then
          cpulse(ispec,-2)=cpulse(ispec,npulse(ispec))
          cpulse(ispec,npulse(ispec))=cpulse(ispec,0)
        endif
!
        tperiod(ispec)=                                                 &
     &  tpulse(ispec,npulse(ispec))-tpulse(ispec,0)
        otperiod(ispec)=1.d0/tperiod(ispec)
!
        if(jperiod.eq.0)                                                &
     &  tpulse(ispec,-2)=                                               &
     &   10.d0*(dabs(time_itim(0))+dabs(time_itim(ntime))               &
     &         +dabs(time_itim(ntime)-time_itim(0)))
!
        if(jperiod.eq.1)                                                &
     &  tpulse(ispec,-2)=                                               &
     &  tpulse(ispec,0)+nperiod(ispec)*tperiod(ispec)
!
        if(jslope.eq.1) then
          do ipulse=1,npulse(ispec)
            spulse(ispec,ipulse)=                                       &
     &      (cpulse(ispec,ipulse)-cpulse(ispec,ipulse-1))               &
     &      /dtpulse(ispec,ipulse)
          enddo
        else
          do ipulse=1,npulse(ispec)
            spulse(ispec,ipulse)=0.d0
          enddo
        endif
!V090831:
      endif
!:V090831
!
!
!V090831:
      if(jfix(ispec).eq.30                                              &
     &.or.jfix(ispec).eq.31                                             &
     &.or.jfix(ispec).eq.5030                                           &
     &.or.jfix(ispec).eq.5031                                           &
     &)then
        ortpi=0.5d0/dsqrt(datan(1.d0))
        do ipulse=1,npulse(ispec)
          tpulse(ispec,ipulse)=cspec(ispec,3*ipulse-2)
          owid=1.d0/cspec(ispec,3*ipulse-1)
          spulse(ispec,ipulse)=owid**2
          cpulse(ispec,ipulse)=owid*ortpi*cspec(ispec,3*ipulse)
        enddo
!
        tpulse(ispec,-1)=time_itim(0)
!
        if(jperiod.eq.0) then
          tpulse(ispec,0)              =time_itim(0)
          tpulse(ispec,npulse(ispec)+1)=time_itim(ntime)
!
          tperiod(ispec)=                                                 &
     &    tpulse(ispec,npulse(ispec)+1)-tpulse(ispec,0)
          otperiod(ispec)=1.d0/tperiod(ispec)
!
          tpulse(ispec,-2)=                                              &
     &    10.d0*(dabs(time_itim(0))+dabs(time_itim(ntime))               &
     &          +dabs(time_itim(ntime)-time_itim(0)))
        endif
!
        if(jperiod.eq.1) then
          tpulse(ispec,0)              =cspec(ispec,3*npulse(ispec)+1)
          tpulse(ispec,npulse(ispec)+1)=cspec(ispec,3*npulse(ispec)+2)
!
          tperiod(ispec)=                                                 &
     &    tpulse(ispec,npulse(ispec)+1)-tpulse(ispec,0)
          otperiod(ispec)=1.d0/tperiod(ispec)
!
          tpulse(ispec,-2)=                                               &
     &    tpulse(ispec,0)+nperiod(ispec)*tperiod(ispec)
        endif
!
      endif
!:V090831
!
      if(jfix(ispec).ge.1.and.jfix(ispec).le.9999) then
        do itime=0,ntime
          xspec(ispec,itime)=                                           &
     &    fspec_ti(                                                     &
     &             time_itim(itime),jfix,ispec,xspec_min,xspec_max      &
     &            ,npulse,nperiod                                       &
     &            ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod        &
     &            ,nspec_x,npmspec_x                                    &
     &            )
        enddo
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      function fspec_ti(                                                &
     &                  time_xr,jfix,ispec,xspec_min,xspec_max          &
     &                 ,npulse,nperiod                                  &
     &                 ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod   &
     &                 ,nspec_x,npmspec_x                               &
     &                 )
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      implicit none
!
      integer ispec,mshift,ipulse,jperiod                               &
     &       ,nspec_x,npmspec_x
!
      integer jfix(1:nspec_x)                                           &
     &       ,npulse(1:nspec_x)                                         &
     &       ,nperiod(1:nspec_x)
!
      real*8 fspec_ti
      real*8 time_xr,xtix, tix, rshift                                  &
     &      ,tpulse(1:nspec_x,-2:npmspec_x)                             &
     &      ,cpulse(1:nspec_x,-2:npmspec_x)                             &
     &      ,dtpulse(1:nspec_x,0:npmspec_x)                             &
     &      ,spulse(1:nspec_x,-2:npmspec_x)                             &
     &      ,tperiod(1:nspec_x)                                         &
     &      ,otperiod(1:nspec_x)                                        &
     &      ,xspec_min(1:nspec_x)                                       &
     &      ,xspec_max(1:nspec_x)
!
!
!
!=====================================================================
! Calculates periodically repeated trapezoidal or rectangle
! pulse train function and returns pulse train value
!          fspec_ti    at input time   t = time_xr;
!
! Also returns in output array elements
!     spulse(0), spulse(-1), spulse(-2)
! the following values:
!
!   spulse(0) := time_shift-time_xr  || COMMENTED OUT !!
!     time-periodicity shift where
!            time_shift=time_xr-mshift*tperiod
!     with integer mshift such that time_shift falls
!     within the first periodicity interval of the
!     pulse train
!            ( tpulse(0) , tpulse(npulse) ]
!     as defined below;
!
!   spulse(-1) := ipulse             || COMMENTED OUT !!
!     pulse interval number containing period.-shifted input time,
!            tpulse(ipulse-1) < time_shift =< tpulse(ipulse) ;
!
!   spulse(-2) := spulse(ipulse)
!     linear slope (=1st derivative of pulse train) inside
!     the pulse interval number ipulse, containing time_shift
!=====================================================================
!
! jfix=1:
! concentration is constant at all times
      if(jfix(ispec).eq.1) then
        fspec_ti=cpulse(ispec,0)
!c      spulse(ispec,0)=0.d0
!c      spulse(ispec,-1)=0.d0
        spulse(ispec,-2)=0.d0
      endif
!
! jfix=10,11,5010,5011:
! continuous, periodically repeated polygon (trapezoidal) pulse train
!   npulse(ispec):
!     no. of polygon trapeze intervals
!
!   cspec(ispec,ipm) with ipm=1,2,...2*npulse(ispec)+2
!     contains the following pulse train parameters:
!
!     ipm=1,3,5,...,2*npulse+1:
!        dtpulse(0), dtpulse(1), ....dtpulse(npulse)
!       are the interval lengths so that the interval grid points
!            tpulse(i)=tpulse(i-1)+dtpulse(i) for i=1,...npulse
!       and dtpulse(0) is the off-set of the start time of
!       the polygon,
!            tpulse(0)= time0+dtpulse(0),
!        measured from the start time "time0" of simulation interval.
!
!     ipm=2,4,6,...,2*npulse:
!            cpulse(0), cpulse(1), ...cpulse(npulse-1)
!       and
!            cpulse(npulse):=cpulse(0)
!       are the concentration values at the interval grid points
!            tpulse(i) fir i=0,1,...npulse
!
!     ipm=2*npulse+2:
!           cpulse(-2)
!       is the constant concentration value for
!           t>tpulse(-2),
!       as given below.
!
!   The resulting trapezoidal/polygon pulse train is defined so that
!           xspec(t)=cpulse(i)
!   at all interval grid points
!           t = tpulse(i) for i=0,...npulse
!
!   For times   t > tpulse(npulse) , the polygon train of the
!   periodicity interval
!         ( tpulse(0) , tpulse(npulse) ]
!   is periodically repeated with period length
!         tperiod:=tpulse(npulse)-tpulse(0)
!   up to and including
!         t = tpulse(-2)
!   where
!         tpulse(-2):=infinity             if jfix=10,5010,
!   or
!         tpulse(-2):=tpulse(0)
!                    +nperiod*tperiod      if jfix=11,5011;
!
!   For times   t < tpulse(0), the concentration is set to
!   a constant initial pulse value, i.e.
!         xspec(t)=cpulse(0)         for   t =< tpulse(0) .
!
!   The resulting polygon train is continuous on the entire interval
!           [ time0 , tpulse(-2) )
!   since cpulse(npulse)=cpulse(0) (see above).
!
!   Lastly, xspec(t) is set to a constant value
!         xspec(t)=cpulse(-2)    for   t > tpulse(-2) .
!   Hence, there will  a discontinuity at t=tpulse(-2) with a jump
!         Delta xspec = cpulse(-2) - cpulse(npulse)
!   if the input values
!         cpulse(-2) |= cpulse(0)=:cpulse(npulse)
!
!
!cc [OLD <050326:
!cc "near zero" value, i.e.
!cc       xspec=1.d-6*xspec_min   for   t =< tpulse(0) .]
!
      if( jfix(ispec).eq.5010                                           &
     &.or.jfix(ispec).eq.5011                                           &
     &.or.jfix(ispec).eq.10                                             &
     &.or.jfix(ispec).eq.11                                             &
     &  ) then
          tix=time_xr
!
          if(tix.le.tpulse(ispec,0)                                     &
     &    ) then
            xtix=cpulse(ispec,0)
!c          spulse(ispec,0)=0.d0
!c          spulse(ispec,-1)=0.d0
            spulse(ispec,-2)=0.d0
            goto 110
          endif
!
          if(tix.gt.tpulse(ispec,-2)                                    &
     &    ) then
            xtix=cpulse(ispec,-2)
!c          spulse(ispec,0)=0.d0
!c          spulse(ispec,-1)=-2.d0
            spulse(ispec,-2)=0.d0
            goto 110
          endif
!
          if(tix.gt.tpulse(ispec,npulse(ispec))) then
            rshift=(tix-tpulse(ispec,npulse(ispec)))                    &
     &            *otperiod(ispec)
            mshift=rshift
            mshift=mshift+1
            tix=tix-mshift*tperiod(ispec)
            if(tix.le.tpulse(ispec,0))                                  &
     &      tix=tpulse(ispec,npulse(ispec))
            if(tix.gt.tpulse(ispec,npulse(ispec)))                      &
     &      tix=tpulse(ispec,npulse(ispec))
          endif
!
          do ipulse=1,npulse(ispec)
            if(tpulse(ispec,ipulse).ge.tix) then
              xtix=cpulse(ispec,ipulse)                                 &
     &            +(tix-tpulse(ispec,ipulse))*spulse(ispec,ipulse)
              if(xtix.lt.xspec_min(ispec)) xtix=xspec_min(ispec)
              if(xtix.gt.xspec_max(ispec)) xtix=xspec_max(ispec)
              goto 105
            endif
          enddo
  105     continue
!c        spulse(ispec,0)=tix-time_xr
!c        spulse(ispec,-1)=ipulse
          spulse(ispec,-2)=spulse(ispec,ipulse)
!
  110     continue
          fspec_ti=xtix
!
!
          return
      endif
!
!
! jfix=20,21,5020,5021:
! periodically repeated rectangle pulse train
!   npulse(ispec):
!     no. of reactangle pulses/intervals per period
!
!   cspec(ispec,ipm) with ipm=1,2,...2*npulse(ispec)+2
!     contains the pulse train parameters:
!
!     ipm=1,3,5,...,2*npulse+1:
!        dtpulse(0), dtpulse(1), ....dtpulse(npulse)
!        are the interval lengths so that the interval grid points
!            tpulse(i)=tpulse(i-1)+dtpulse(i) for i=1,...npulse
!        and dtpulse(0) is the off-set of the start time of the
!        1st periodically repeated rectangle,
!            tpulse(0)= time0+dtpulse(0),
!        measured from the start time "time0" of simulation interval.
!
!     ipm=2,4,6,...,2*npulse+2:
!        cpulse(0), cpulse(1), ...cpulse(npulse)
!        are the constant, "rectangular" concentration values
!        between the interval grid points
!
!   The rectangle pulse train is then defined so that:
!        xspec=cpulse(ipulse)
!             for tpulse(ipulse-1) < t =< tpulse(ipulse)
!             ipulse=1,...npulse
!
!   For times   t =< tpulse(0), the concentration is set to
!   constant initial pulse value, i.e.
!         xspec=cpulse(0)
!              for   t =< tpulse(0) .
!
!   For times   t > tpulse(npulse) , the polygon train on the
!   periodicity interval
!         ( tpulse(0) , tpulse(npulse) ]
!   is periodically repeated with period length
!         tperiod:=tpulse(npulse)-tpulse(0)
!   up to and including
!         t = tpulse(-2)
!   where
!         tpulse(-2):=infinity             if jfix=20,5020,
!   or
!         tpulse(-2):=tpulse(0)
!                    +nperiod*tperiod      if jfix=21,5021,
!
!   Lastly, xspec is set to
!         xspec="near zero" =1.d-6*xspec_min
!              for   t > tpulse(-2) .
!
!
      if( jfix(ispec).eq.5020                                           &
     &.or.jfix(ispec).eq.5021                                           &
     &.or.jfix(ispec).eq.20                                             &
     &.or.jfix(ispec).eq.21                                             &
     &  ) then
          tix=time_xr
!
          spulse(ispec,-2)=0.d0
!
          if(tix.le.tpulse(ispec,0)                                     &
     &    ) then
            xtix=cpulse(ispec,0)
!c          spulse(ispec,0)=0.d0
!c          spulse(ispec,-1)=0.d0
            goto 210
          endif
!
          if(tix.gt.tpulse(ispec,-2)                                    &
     &    ) then
            xtix=1.d-6*xspec_min(ispec)
!c          spulse(ispec,0)=0.d0
!c          spulse(ispec,-1)=-2.d0
            goto 210
          endif
!
          if(tix.gt.tpulse(ispec,npulse(ispec))) then
            rshift=(tix-tpulse(ispec,npulse(ispec)))                    &
     &            *otperiod(ispec)
            mshift=rshift
            mshift=mshift+1
            tix=tix-mshift*tperiod(ispec)
            if(tix.le.tpulse(ispec,0))                                  &
     &      tix=tpulse(ispec,npulse(ispec))
            if(tix.gt.tpulse(ispec,npulse(ispec)))                      &
     &      tix=tpulse(ispec,npulse(ispec))
          endif
!
          do ipulse=1,npulse(ispec)
            if(tix.le.tpulse(ispec,ipulse)) then
              xtix=cpulse(ispec,ipulse)
              if(xtix.lt.xspec_min(ispec)) xtix=xspec_min(ispec)
              if(xtix.gt.xspec_max(ispec)) xtix=xspec_max(ispec)
              goto 205
            endif
          enddo
  205     continue
!c        spulse(ispec,0)=tix-time_xr
!c        spulse(ispec,-1)=ipulse
!
  210     continue
          fspec_ti=xtix
          return
      endif
!
!V090831:
!
! jfix=30,31,5030,5031:
! Gaussian pulse train:
!    number of pulses on train:
!      npulse(ispec)
!    requiring ipm-variables:
!      ipm=1,...3*npulse    if jfix=30,5030
!      ipm=1,...3*npulse+2  if jfix=31,5031
!    center (max.) of pulse:
!      tpulse=cspec(ispec,ipm) for ipm=1,4,7,10,...3*npulse-2
!    half-width at (1/e)-max. of pulse:
!      wpulse=cspec(ispec,ipm) for ipm=2,5,8,11,...3*npulse-1
!     stored as
!      spulse==1/wpulse**2
!    time-integrated pulse area:
!      apulse=cspec(ispec,ipm) for ipm=3,6,9,12,...3*npulse
!     stored as pulse height at max.
!      cpulse==apulse/(\sqrt(\pi)*wpulse)
!    so that
!      xpulse(t)=cpulse * dexp[-spulse*(t-tpulse)**2]
!
!  If jfix=31 or =5031, pulse train is periodically repeated
!  by period-shifting time "tix=time_xr" into periodicity interval
!       (tpulse0,tpulse1]
!  with
!     tpulse0==cspec(ispec,ipm) with ipm=3*npulse+1
!     tpulse1==cspec(ispec,ipm) with ipm=3*npulse+2
!    stored as
!     tpulse0==tpulse(ispec,0)
!     tpulse1==tpulse(ispec,npulse(ispec)+1)
!  and period length
!     tperiod=tpulse1-tpulse0
!
      if( jfix(ispec).eq.5030                                           &
     &.or.jfix(ispec).eq.5031                                           &
     &.or.jfix(ispec).eq.30                                             &
     &.or.jfix(ispec).eq.31                                             &
     &)then
          tix=time_xr
!
          if(tix.le.tpulse(ispec,0)) then
            rshift=-(tix-tpulse(ispec,0))                               &
     &            *otperiod(ispec)
            mshift=rshift
            mshift=mshift+1
            tix=tix+mshift*tperiod(ispec)
          endif
!
          if(tix.gt.tpulse(ispec,npulse(ispec)+1)) then
            rshift=(tix-tpulse(ispec,npulse(ispec)+1))                  &
     &            *otperiod(ispec)
            mshift=rshift
            mshift=mshift+1
            tix=tix-mshift*tperiod(ispec)
          endif
!
          if(tix.le.tpulse(ispec,0))                                  &
     &    tix=tpulse(ispec,npulse(ispec)+1)
          if(tix.gt.tpulse(ispec,npulse(ispec)+1))                    &
     &    tix=tpulse(ispec,npulse(ispec)+1)
!
          fspec_ti=0.d0
          do ipulse=1,npulse(ispec)
            fspec_ti=fspec_ti                                               &
     &      +cpulse(ispec,ipulse)                                           &
     &      *dexp(-spulse(ispec,ipulse)*(tix-tpulse(ispec,ipulse))**2)
          enddo
!
          return
      endif
!:V090831
!
!
      return
      end
!
!
!XXX: Check "call DLSODES" arg-list against "call drivs" arg-list:
!YDLS &              ,time_i_fs,xspec_i                                  &
!Xdrv &              ,time_i_fs,xspec_i                                &
!
!YDLS &              ,vfor,vbak,xspec_min,xspec_max                      &
!Xdrv &              ,vfor,vbak,xspec_min,xspec_max                    &
!
!YDLS &              ,yspec_min_vs,yspec_max_vs                          &
!Xdrv &              ,yspec_min_vs,yspec_max_vs                        &
!
!YDLS &              ,wspec_vs_min,wspec_vs_max                          &
!Xdrv &              ,wspec_vs_min,wspec_vs_max                        &
!
!YDLS &              ,frlim_vs_min,frlim_vs_max                          &
!Xdrv &              ,frlim_vs_min,frlim_vs_max                        &
!
!YDLS &              ,rkfor,rkbak,rkfor2,rkbak2                          &
!Xdrv &              ,rkfor,rkbak,rkfor2,rkbak2                        &
!
!YDLS &              ,odtime_rl,jkin,jrlim                               &
!Xdrv &              ,odtime_rl,jkin,jrlim                             &
!
!YDLS &              ,lvfor,lvbak,lvreac                                 &
!Xdrv &              ,lvfor,lvbak,lvreac                               &
!
!YDLS &              ,iispec,iospec,nipart,nopart                        &
!Xdrv &              ,iispec,iospec,nipart,nopart                      &
!
!YDLS &              ,hicoop,hocoop                                      &
!Xdrv &              ,hicoop,hocoop                                    &
!
!YDLS &              ,iispec_vs,iospec_vs,nipart_vs,nopart_vs            &
!Xdrv &              ,iispec,iospec,nipart,nopart                      &
!
!YDLS &              ,gimult_vs,gomult_vs,iivs_vs,iovs_vs                &
!Xdrv &              ,gimult_vs,gomult_vs,iivs_vs,iovs_vs              &
!
!YDLS &              ,nspec,nreac,nfs_spec,nvs_spec                      &
!Xdrv &              ,nspec,nreac,nfs_spec,nvs_spec                    &
!
!YDLS &              ,ispec_fs,ispec_vs,nlim_drv,n_drv,k_drv             &
!Xdrv &              ,ispec_fs,ispec_vs,nlim_drv,n_drv,k_drv           &
!
!YDLS &              ,jtime_abd,jfox,jfix,npulse,nperiod                 &
!Xdrv &              ,jtevol,   jfox,jfix,npulse,nperiod                  & 
!==> Must set: jtevol=jtime_abd before "call DLSODES"
!==> Must set: jtevol=jtime_ark before "call call odeint_ark"
!
!YDLS &              ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod      &
!Xdrv &              ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod    &
!
!YDLS &              ,npmspec_x                                          &
!Xdrv &              ,npmspec_x                                        &
!
!YDLS &              ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x)
!Xdrv &              ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x)
!
!:XXX drivs arg-list:
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine drivs(time_xr,xspec_vs,vspec_vs                        &
!
     &                ,time_i_fs,xspec_i                                &
     &                ,vfor,vbak,xspec_min,xspec_max                    &
     &                ,yspec_min_vs,yspec_max_vs                        &
     &                ,wspec_vs_min,wspec_vs_max                        &
     &                ,frlim_vs_min,frlim_vs_max                        &
     &                ,rkfor,rkbak,rkfor2,rkbak2                        &
     &                ,odtime_rl,jkin,jrlim                             &
     &                ,lvfor,lvbak,lvreac                               &
     &                ,iispec,iospec,nipart,nopart                      &
     &                ,hicoop,hocoop                                    &
     &                ,iispec_vs,iospec_vs,nipart_vs,nopart_vs          &
     &                ,gimult_vs,gomult_vs,iivs_vs,iovs_vs              &
     &                ,nspec,nreac,nfs_spec,nvs_spec                    &
     &                ,ispec_fs,ispec_vs,nlim_drv,n_drv,k_drv           &
     &                ,jtevol,jfox,jfix,npulse,nperiod                  &
     &                ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod    &
     &                ,npmspec_x                                        &
     &                ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
!
! Output:
! --reaction forward + backward reaction
!   rates "vfor", "vbak" for each reaction "ireac"
! --net production rate "vspec_vs" for each var. species "ispec"/"ivs"
!
! Input:
! --var. species concentrations "xspec_vs", at time step "itime-1",
! --forward + backward rate constants "rkfor", "rkbak", and
! --reaction network lists, "iispec", "iospec", "nipart", "nopart"
!
!
      implicit none
!
      integer jrlim,nspec,nreac,nfs_spec,nvs_spec,jtevol                &
     &       ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x                &
     &       ,npmspec_x
!
      integer ifs,ivs,ivs0,ispec,ireac,ipart,jvfor,jvbak                &
     &       ,nlim_drv,n_drv,k_drv                                      &
     &       ,jgridip
!
      integer myint
!
      integer ncplex0,iicplex0,iocplex0,icplex,ipart_ini0,ipart_fin0
!
      integer iispec(1:npart_x,1:nreac_x)                               &
     &       ,iospec(1:npart_x,1:nreac_x)                               &
     &       ,nipart(1:nreac_x)                                         &
     &       ,nopart(1:nreac_x)                                         &
     &       ,iispec_vs(1:npart_x,1:nreac_x)                            &
     &       ,iospec_vs(1:npart_x,1:nreac_x)                            &
     &       ,iivs_vs(1:npart_x,1:nreac_x)                              &
     &       ,iovs_vs(1:npart_x,1:nreac_x)                              &
     &       ,nipart_vs(1:nreac_x)                                      &
     &       ,nopart_vs(1:nreac_x)                                      &
     &       ,jkin(1:nreac_x)                                           &
     &       ,lvfor(1:nreac_x)                                          &
     &       ,lvbak(1:nreac_x)                                          &
     &       ,lvreac(1:nreac_x)                                         &
     &       ,ispec_fs(1:(nspec_x+nms_spec_x))                          &
     &       ,ispec_vs(1:(nspec_x+nms_spec_x))
!
      integer jfox(1:nspec_x)                                           &
     &       ,jfix(1:nspec_x)                                           &
     &       ,npulse(1:nspec_x)                                         &
     &       ,nperiod(1:nspec_x)
!
      real*8 fspec_ti, dexxp
!
      real*8 smm, smm_i, smm_o
!
      real*8 odtime_rl,fmm,freac,ffor,fbak                              &
     &      ,time_xr,time_i_fs,time_i,dtime_xr                          &
     &      ,wspec_lim                                                  &
     &      ,hicoop(1:npart_x,1:nreac_x)                                &
     &      ,hocoop(1:npart_x,1:nreac_x)                                &
     &      ,gimult_vs(1:npart_x,1:nreac_x)                             &
     &      ,gomult_vs(1:npart_x,1:nreac_x)
!
      real*8                                                            &
     &       vspec_vs(*)                                                &
     &      ,xspec_vs(*)
!
      real*8 vspec(1:(nspec_x+nms_spec_x))                              &
     &      ,xspec_i(1:(nspec_x+nms_spec_x),0:3)                        &
     &      ,xspec(1:(nspec_x+nms_spec_x))                              &
     &      ,xspec_min(1:nspec_x)                                       &
     &      ,xspec_max(1:nspec_x)                                       &
     &      ,yspec_min_vs(1:nspec_x)                                    &
     &      ,yspec_max_vs(1:nspec_x)                                    &
     &      ,frlim_vs_min(1:nspec_x)                                    &
     &      ,frlim_vs_max(1:nspec_x)                                    &
     &      ,wspec_vs_min(1:nspec_x)                                    &
     &      ,wspec_vs_max(1:nspec_x)                                    &
     &      ,aXspec(1:nspec_x)                                          &
!
     &      ,tpulse(1:nspec_x,-2:npmspec_x)                             &
     &      ,cpulse(1:nspec_x,-2:npmspec_x)                             &
     &      ,dtpulse(1:nspec_x,0:npmspec_x)                             &
     &      ,spulse(1:nspec_x,-2:npmspec_x)                             &
     &      ,tperiod(1:nspec_x)                                         &
     &      ,otperiod(1:nspec_x)                                        &
!
     &      ,yspec_vs(1:nspec_x)
!
      real*8 vfor(1:nreac_x)                                            &
     &      ,vfor0(1:nreac_x)                                           &
     &      ,vbak(1:nreac_x)                                            &
     &      ,vbak0(1:nreac_x)                                           &
     &      ,rkfor(1:nreac_x)                                           &
     &      ,rkbak(1:nreac_x)                                           &
     &      ,rkfor2(1:nreac_x)                                          &
     &      ,rkbak2(1:nreac_x)                                          &
     &      ,vreac(1:nreac_x)                                           &
     &      ,vreac0(1:nreac_x)
!
!
!   increment call counter for single ODE soln
      k_drv=k_drv+1
!
!DRLIM190524-2244:
!   increment call counter for single ODE soln
      n_drv=n_drv+1
!
!     Turn off regular model rate fcts when n_drv exceeds limit, nlim_drv, 
!     of max. no. of allowed rate fct calls.
!     Option 1: Set all var. species rates, vspec_vs, to zero.
!       This option is the easiest to implement and gives the
!       max. speedup of "drivs" execution for "turned off" model rate fct
!     Option 2: Switch to a simple exp-decay model (NOT YET IMPLEMENTED).
!       This option may be used to avoid discontinuity of rate fct
!       at time of switch, but may not be very useful b/c
!       the simple exp-decay model may then still be stiff, 
!       unless special precautions are built in to make the
!       exp. decay very slow for all var. species.
!
      if(n_drv.gt.nlim_drv.and.nlim_drv.gt.0) then
        if(jtevol.ge.100.and.jtevol.le.299) then
          do ivs=1,nvs_spec
            vspec_vs(ivs)=0.d0
          enddo
        else
          do ivs=1,nvs_spec
            vspec_vs(ispec_vs(ivs))=0.d0
          enddo
        endif
!
        do ireac=1,nreac
          vfor(ireac)=0.d0
          vbak(ireac)=0.d0
        enddo
!
        return
      endif
!:DRLIM190524-2244
!
!   unpack ODE-evolved species concentrations
!   from compressed to expanded format
!
      if(jtevol.ge.100.and.jtevol.le.299) then
        do ivs=1,nvs_spec
          xspec(ispec_vs(ivs))=xspec_vs(ivs)
        enddo
      else
        do ivs=1,nvs_spec
          xspec(ispec_vs(ivs))=xspec_vs(ispec_vs(ivs))
        enddo
      endif
!
!   ...and then un-do species variable (log) transform
!
      do ivs=1,nvs_spec
        if(jfox(ispec_vs(ivs)).eq.1) then
          yspec_vs(ivs)=xspec(ispec_vs(ivs))
          xspec(ispec_vs(ivs))=                                         &
     &         dexxp(xspec(ispec_vs(ivs))                               &
     &              ,yspec_min_vs(ivs)                                  &
     &              ,yspec_max_vs(ivs))
        endif
      enddo
!
!   NOTE/WARNING:
!   The I/O Arrays
!        "xspec_vs" and "vspec_vs"
!   of this subrprg. "drivs" MUST NOT be altered /re-stored
!   in any way during execution; otherwise, may overwrite
!   data in more extended arrays of calling dlsodes subprogs;
!   hence, have allocated extra internal arrays
!        "xspec" and "vspec"
!   here to handle intermed. storage and pack/unpack
!   operations.
!
!   either:
!     interpolate "fixed" (5000>jfix>1 or XDI) species concentrations
!     (XDI not yet implemented for ARK/off-grid ODE solvers)
!   or:
!     calculate "fixed" species concentration (jfix>=5000)
!
      if(nfs_spec.gt.0) then
        if(jtevol.eq.20.or.jtevol.eq.21                                 &
     &  .or.jtevol.eq.120.or.jtevol.eq.121                              &
     &  .or.jtevol.eq.220.or.jtevol.eq.221) then
          jgridip=1
        else
          jgridip=0
        endif
!
        dtime_xr=time_xr-time_i_fs
        do ifs=1,nfs_spec
          ispec=ispec_fs(ifs)
!
          if(jfix(ispec).lt.5000.or.jgridip.eq.1) then
            xspec(ispec)=xspec_i(ispec,0)                               &
     &                  +dtime_xr*xspec_i(ispec,1)
          else
            xspec(ispec)=                                               &
     &      fspec_ti(                                                   &
     &               time_xr,jfix,ispec,xspec_min,xspec_max             &
     &              ,npulse,nperiod                                     &
     &              ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod      &
     &              ,nspec_x,npmspec_x                                  &
     &              )
          endif
        enddo
      endif
!
!
!
!N180810:
! Calculate and store t-evol dependent (child) species (jfix=-110) that enter as
! reactants into rate fcts vspec
      call get_rdpen(time_xr,xspec)
!:N180810
!
!
!   zero species rate accumulators and take abs of all species concs
!
      do ispec=1,nspec
        aXspec(ispec)=dabs(xspec(ispec))
        vspec(ispec)=0.d0
        wspec_vs_max(ispec)=0.d0
        wspec_vs_min(ispec)=0.d0
      enddo
!    Note: can use "ispec=1,nspec" instead of "ivs=1,nvs_spec" here,
!    since  nspec > nvs_spec  and  wspec_vs_...(...)arrays are
!    dimensioned to size nspec_x
!
! calculate each reaction's forward and backward reaction rates,
! then accumulate into species net production rates
!
      do ireac=1,nreac
!       jkin=1: standard multiplicative kinetics with
!               integer cooperativity exponents only
!           rkfor <-> ipm=1
!           rkbak <-> ipm=2
!
        if(jkin(ireac).eq.1) then
          vfor(ireac)=rkfor(ireac)
          do ipart=1,nipart(ireac)
            vfor(ireac)=vfor(ireac)*aXspec(iispec(ipart,ireac))
          enddo
!
          vbak(ireac)=rkbak(ireac)
          do ipart=1,nopart(ireac)
            vbak(ireac)=vbak(ireac)*aXspec(iospec(ipart,ireac))
          enddo
!
          goto 190
        endif
!
!       jkin=2: standard kinetics with
!           arbitrary fractional cooperativity exponents
!           and molec. multiplicity = cooperativity exponent
!           rkfor(.) <-> ipm=1
!           rkbak(.) <-> ipm=2
!           for ipart=1,...nipart(.):
!             hicoop(ipart,.) <-> ipm=2+ipart
!             gispec(ipart,.) = hicoop(ipart,.)
!           for ipart=1,...nopart(.):
!             hocoop(ipart,.) <-> ipm=2+nipart(.)+ipart
!             gospec(ipart,.) = hocoop(ipart,.)
!
!       jkin=3: standard kinetics with
!           arbitrary fractional cooperativity exponents
!           and arbitrary fractional molec. multiplicities
!           rkfor(.) <-> ipm=1
!           rkbak(.) <-> ipm=2
!           for ipart=1,...nipart(.):
!             hicoop(ipart,.) <-> ipm=2+(2*ipart-1)
!             gispec(ipart,.) <-> ipm=2+(2*ipart)
!           for ipart=1,...nopart(.):
!             hocoop(ipart,.) <-> ipm=2+2*nipart(.)+(2*ipart-1)
!             gospec(ipart,.) <-> ipm=2+2*nipart(.)+(2*ipart)
!
        if(jkin(ireac).eq.2.or.jkin(ireac).eq.3) then
          vfor(ireac)=rkfor(ireac)
          do ipart=1,nipart(ireac)
            vfor(ireac)=vfor(ireac)                                     &
     &                 *aXspec(iispec(ipart,ireac))                     &
     &                  **hicoop(ipart,ireac)
          enddo
!
          vbak(ireac)=rkbak(ireac)
          do ipart=1,nopart(ireac)
            vbak(ireac)=vbak(ireac)                                     &
     &                 *aXspec(iospec(ipart,ireac))                     &
     &                  **hocoop(ipart,ireac)
          enddo
!
          goto 190
        endif
!
!
!       jkin=11: Generalized non-coop. Michaelis-Menten kinetics;
!         1st reactn. step has rate constants "rkfor", "rkbak"
!         2nd reactn. step has rate constants "rkfor2", "rkbak2":
!           rkfor <-> ipm=1
!           rkbak <-> ipm=2
!           rkfor2 <-> ipm=3
!           rkbak2 <-> ipm=4 ;
!         the enzyme species must be listed as "ipart=1"
!         on input and on output side of the reaction;
!         substrate / product species must be listed w/ "ipart>=2"
!
        if(jkin(ireac).eq.11) then
          vfor(ireac)=rkfor(ireac)
          do ipart=2,nipart(ireac)
            vfor(ireac)=vfor(ireac)*aXspec(iispec(ipart,ireac))
          enddo
!
          vbak(ireac)=rkbak2(ireac)
          do ipart=2,nopart(ireac)
            vbak(ireac)=vbak(ireac)*aXspec(iospec(ipart,ireac))
          enddo
!
          fmm=aXspec(iispec(1,ireac))                                   &
     &       /(vfor(ireac)+vbak(ireac)+rkbak(ireac)+rkfor2(ireac))
!
          vfor(ireac)=                                                  &
     &    fmm*rkfor2(ireac)*vfor(ireac)
!
          vbak(ireac)=                                                  &
     &    fmm*rkbak(ireac)*vbak(ireac)
!
          goto 190
        endif
!
!     jkin=40: Non-coop MM three-step two-way kinetics
!                   E+S <--> ES <--> EP <--> P+E
!              with multiple competing substrates per enzyme
!              and quasi-equilibria for E+S<-->ES and EP<-->E+P
!                nipart=3+n, nopart=2, npmreac=4+n
!                ipart=1: E, =2: S, =3: P, 4: C1, ..., =3+n: Cn
!              where C1,...Cn are other competing substrates
!              (which are the same for input S,ES and output P,EP);
!              Also, in "idat" and "set_fix_reac", we set
!                iospec(1,.) :=iispec(1,.) == E
!                iospec(2,.) :=iispec(3,.) == P
!              so that automatically:
!                iopart=1: E, =2: P
!              The list of output species names in ens.i01
!              must then contain _no_ entries, i.e., species
!              names for E and P must _not_ be listed in ens.i01
!              for iopart=1,2, even though nopart=2 is set
!              in ens.i01. This is done to simplify ens.i01 input.
!              Then, kin. param. vars. are stored as ...
!              rkfor, rkbak:
!                ipm=1:     \Gamma(ES-->EP)
!                ipm=2:     \Gamma(EP-->ES)
!              hicoop(ipart,.), ipart=2,...n+3==nipart:
!                ipm=3:     Q(E+S<-->ES)
!                ipm=4:     Q(E+P<-->EP)
!                ipm=5:     Q(E+C1<-->EC1)
!                ...
!                ipm=4+n:   Q(E+Cn<-->ECn)    [where: 4+n=nipart+1]
!              and with constant stoich. coeffs. set to
!                gispec(ipart,.)=0,1,0,0,... 0,
!                  for ipart=1,2,...n+3==nipart;
!                gospec(iopart,.)=0,1
!                  for iopart=1,2==nopart.
!
        if(jkin(ireac).eq.40) then
          fmm=1.d0+hicoop(2,ireac)                                   &
     &           *aXspec(iispec(2,ireac))
          do ipart=3,nipart(ireac)
            fmm=fmm+hicoop(ipart,ireac)                              &
     &             *aXspec(iispec(ipart,ireac))
          enddo
          fmm=1.d0/fmm
!
          vfor(ireac)=                                       &
     &     rkfor(ireac)                                      &
     &    *hicoop(2,ireac)                                   &
     &    *aXspec(iispec(1,ireac))                           &
     &    *aXspec(iispec(2,ireac))*fmm
!
          vbak(ireac)=                                       &
     &     rkbak(ireac)                                      &
     &    *hicoop(3,ireac)                                   &
     &    *aXspec(iispec(1,ireac))                           &
     &    *aXspec(iispec(3,ireac))*fmm
!      Note: in "idat" and "set_fix_reac", we automatically set
!       iospec(1,.) :=iispec(1,.) == E
!       iospec(2,.) :=iispec(3,.) == P
!      which is needed to get correct vspec-calc. w/ correct
!      gomult_vs==gospec, below.
!
          goto 190
        endif
!
!     jkin=41: Non-coop multinary MM three-step two-way kinetics
!                E+C_k <--> EC_k <--> EC_j <--> E+C_j
!              with multi-species reactant complexes C_k, C_j
!                k from 1,...K;   j from 1,...K
!                k from 1,...K;   j from 1,...K
!              multiple competing substrates per enzyme and quasi-equilibria for
!                E+S_1,n+...S_M_n,n<-->EC_n
!              for all competing reactant complexes
!                C_n:=(S_{1,n},...S_{M_n,n})  with  n=1,...K
!              of total complex no. K and complex sizes M_n and
!                nipart=1+sum_n M_n, nopart=1+M_j, npmreac=K+2
!              Also, in "idat" and "set_fix_reac", for reaction
!                EC_k <--> EC_j
!              we orde/storer iispec and iospec so that
!                iospec(1,.)=iispec(1,.)              == E
!              and
!                iispec(I_n+1,.)                      == S_{1,n}
!                ...                                  ...
!                iispec(I_n+M_n,.)                    == S_{M_n,n}
!              and
!                iospec(2,.)=iispec(I_j+1,.)          == S_{1,j}
!                ...                                  ...
!                iospec(1+M_j,.)=iispec(I_j+M_j,.)    == S_{M_j,j}
!              where
!                I_n:=1+sum_{m,1=<m<n} M_m  for  n=1,...K
!              The list of output species names in ens.i01 must then
!              contain _no_ entries, i.e., species names for
!                E and S_{1,j}, ...S_{M_j,j}  must _not_ be listed in
!              ens.i01 for iopart=1,...M_j+1, even though we set
!                nopart=M_j+1
!              in ens.i01. This is done to simplify ens.i01 input.
!
!              Then, kin. param. vars. are stored as ...
!              rkfor, rkbak:
!                ipm=1:     \Gamma(EC_k-->EC_j) = fwd rate coeff.
!                ipm=2:     \Gamma(EC_j-->EC_k) = bwd rate coeff.
!              hicoop(icplex,.), icplex=1,...ncplex:
!                ipm=3:     Q(E+C_1<-->EC_1), icplex=1
!                ipm=4:     Q(E+C_2<-->EC_2), icplex=2
!                ...        ...               ...
!                ipm=2+K:   Q(E+C_K<-->EC_K), icplex=K
!              and with constant stoich. coeffs. set to
!                gispec(ipart,.)=1 for ipart=2,M_k+1, else: =0
!                gospec(ipart,.)=1 for ipart=2,M_j+1, else: =0
!
!              We also smuggle into drivs via hocoop
!              hocoop(1,.):
!                ncplex== K =no. of reactant complexes
!              hocoop(2,.):
!                iicplex== k =ID of (input) substrate complex C_k in fwd-dir
!              hocoop(3,.):
!                iocplex== j =ID of (output) product complex C_j in fwd-dir
!              hocoop(3+2n-1):
!                ipart_ini(n)== I_n+1  for  n=1,...K
!              hocoop(3+2n):
!                ipart_fin(n)== I_n+M_n  for  n=1,...K
!
        if(jkin(ireac).eq.41) then
          ncplex0=myint(hocoop(1,ireac))
          iicplex0=myint(hocoop(2,ireac))
          iocplex0=myint(hocoop(3,ireac))
!
          fmm=1.d0
          do icplex=1,ncplex0
            ipart_ini0=myint(hocoop(3+2*icplex-1,ireac))
            ipart_fin0=myint(hocoop(3+2*icplex,ireac))
!
            smm=hicoop(icplex,ireac)
            do ipart=ipart_ini0,ipart_fin0
              smm=smm*aXspec(iispec(ipart,ireac))
            enddo
!
            fmm=fmm+smm
            if(icplex.eq.iicplex0) smm_i=smm
            if(icplex.eq.iocplex0) smm_o=smm
          enddo
          fmm=1.d0/fmm
!
          vfor(ireac)=rkfor(ireac)*smm_i*fmm     &
     &               *aXspec(iispec(1,ireac))
!
          vbak(ireac)=rkbak(ireac)*smm_o*fmm     &
     &               *aXspec(iispec(1,ireac))
!
          goto 190
        endif
!
!       jkin=21: cooperatively activated transcription (CAT) kinetics
!       rkfor <-> ipm=1:
!         fully activated/repressed transcription rate "V"
!         (inducer/repressor bound to its DNA binding site)
!       rkbak <-> ipm=2:
!         non-activated/non-repressed transcription rate "U"
!         (inducer/repressor not bound to its DNA binding site)
!       rkfor2 <-> ipm=3:
!         half-activation inducer (geom. mean) concentration "C_o"
!       rkbak2 <-> ipm=4:
!         extra Hill exponent "h"
!         where total Hill exponent H=M*h (see below for "M")
!       These parameters enter as follows into the
!           Transcription rate = V + (U-V)/[1+(C_1...C_M/C_o^M))^h]
!       where C_1, ...C_M are the concs. of the "M" monomer (protein)
!       species which form the inducer complex, listed as input and
!       output species of the reaction with ipart=1,...M, so that
!            nipart(ireac)=M ,   nopart(ireac)=M+1 ;
!       the mRNA product should be listed as output species with
!            ipart=M+1
!
        if(jkin(ireac).eq.21) then
!c        r1=         rkfor2(ireac)**(-nipart(ireac))
          vfor(ireac)=rkfor2(ireac)**(-nipart(ireac))
          do ipart=1,nipart(ireac)
!c          r1=                  r1*aXspec(iispec(ipart,ireac))
            vfor(ireac)=vfor(ireac)*aXspec(iispec(ipart,ireac))
          enddo
          vfor(ireac)=                                                  &
     &    rkfor(ireac)                                                  &
     &    +((rkbak(ireac)-rkfor(ireac))                                 &
     &     /(1.d0+vfor(ireac)**rkbak2(ireac)))
!c   1     /(1.d0+         r1**rkbak2(ireac)))
!
          vbak(ireac)=0.d0
!
          goto 190
        endif
!
!       jkin=30: Poisson polymerization kinetics
        if(jkin(ireac).eq.30) then
          vfor(ireac)=hicoop(nipart(ireac),ireac)
          do ipart=1,nipart(ireac)-1
            vfor(ireac)=vfor(ireac)+                                    &
     &                 hicoop(ipart,ireac)                              &
     &                 /aXspec(iispec(ipart,ireac))
          enddo
          vfor(ireac)=                                                  &
     &                aXspec(iispec(nipart(ireac),ireac))               &
     &               /vfor(ireac)
!
          vbak(ireac)=0
!
          goto 190
        endif
!
  190   continue
!
        vfor(ireac)=dabs(vfor(ireac))
        vbak(ireac)=dabs(vbak(ireac))
!
!      accumulate rate limitation weight factors
!
        if(jrlim.eq.1) then
          vfor0(ireac)=vfor(ireac)
          vbak0(ireac)=vbak(ireac)
!
          do ipart=1,nopart_vs(ireac)
              wspec_vs_max(iovs_vs(ipart,ireac))=                       &
     &        wspec_vs_max(iovs_vs(ipart,ireac))                        &
     &        +vfor0(ireac)                                             &
     &        *gomult_vs(ipart,ireac)
!
              wspec_vs_min(iovs_vs(ipart,ireac))=                       &
     &        wspec_vs_min(iovs_vs(ipart,ireac))                        &
     &        +vbak0(ireac)                                             &
     &        *gomult_vs(ipart,ireac)
          enddo
!
          do ipart=1,nipart_vs(ireac)
              wspec_vs_max(iivs_vs(ipart,ireac))=                       &
     &        wspec_vs_max(iivs_vs(ipart,ireac))                        &
     &        +vbak0(ireac)                                             &
     &        *gimult_vs(ipart,ireac)
!
              wspec_vs_min(iivs_vs(ipart,ireac))=                       &
     &        wspec_vs_min(iivs_vs(ipart,ireac))                        &
     &        +vfor0(ireac)                                             &
     &        *gimult_vs(ipart,ireac)
          enddo
        endif
!
        if(jrlim.eq.2) then
          vreac0(ireac)=vfor(ireac)-vbak(ireac)
!
          if(vreac0(ireac).gt.0.d0) then
            do ipart=1,nopart_vs(ireac)
                wspec_vs_max(iovs_vs(ipart,ireac))=                     &
     &          wspec_vs_max(iovs_vs(ipart,ireac))                      &
     &          +vreac0(ireac)                                          &
     &          *gomult_vs(ipart,ireac)
            enddo
!
            do ipart=1,nipart_vs(ireac)
                wspec_vs_min(iivs_vs(ipart,ireac))=                     &
     &          wspec_vs_min(iivs_vs(ipart,ireac))                      &
     &          +vreac0(ireac)                                          &
     &          *gimult_vs(ipart,ireac)
            enddo
          endif
!
          if(vreac0(ireac).lt.0.d0) then
            do ipart=1,nopart_vs(ireac)
                wspec_vs_min(iovs_vs(ipart,ireac))=                     &
     &          wspec_vs_min(iovs_vs(ipart,ireac))                      &
     &          -vreac0(ireac)                                          &
     &          *gomult_vs(ipart,ireac)
            enddo
!
            do ipart=1,nipart_vs(ireac)
                wspec_vs_max(iivs_vs(ipart,ireac))=                     &
     &          wspec_vs_max(iivs_vs(ipart,ireac))                      &
     &          -vreac0(ireac)                                          &
     &          *gimult_vs(ipart,ireac)
            enddo
          endif
        endif
      enddo
!
!
!   impose max-min-limits on "vreac" or "vfor", "vbak"
!
      if(jrlim.ge.1) then
        do ivs=1,nvs_spec
          if(xspec_max(ispec_vs(ivs)).le.xspec(ispec_vs(ivs))) then
            frlim_vs_max(ivs)=0.d0
          else
            wspec_lim=                                                  &
     &      odtime_rl                                                   &
     &      *(xspec_max(ispec_vs(ivs))-xspec(ispec_vs(ivs)))
!
            if(wspec_vs_max(ivs).gt.wspec_lim) then
              frlim_vs_max(ivs)=                                        &
     &        wspec_lim/wspec_vs_max(ivs)
            else
              frlim_vs_max(ivs)=1.d0
            endif
          endif
!
          if(xspec(ispec_vs(ivs)).le.xspec_min(ispec_vs(ivs))) then
            frlim_vs_min(ivs)=0.d0
          else
            wspec_lim=                                                  &
     &      odtime_rl                                                   &
     &      *(xspec(ispec_vs(ivs))-xspec_min(ispec_vs(ivs)))
!
            if(wspec_vs_min(ivs).gt.wspec_lim) then
              frlim_vs_min(ivs)=                                        &
     &        wspec_lim/wspec_vs_min(ivs)
            else
              frlim_vs_min(ivs)=1.d0
            endif
          endif
        enddo
!
        if(jrlim.eq.1) then
          do ireac=1,nreac
            ffor=1.d0
            fbak=1.d0
            do ipart=1,nopart_vs(ireac)
                if(ffor.gt.frlim_vs_max(iovs_vs(ipart,ireac)))          &
     &                ffor=frlim_vs_max(iovs_vs(ipart,ireac))
!
                if(fbak.gt.frlim_vs_min(iovs_vs(ipart,ireac)))          &
     &                fbak=frlim_vs_min(iovs_vs(ipart,ireac))
            enddo
!
            do ipart=1,nipart_vs(ireac)
              if(ffor.gt.frlim_vs_min(iivs_vs(ipart,ireac)))            &
     &              ffor=frlim_vs_min(iivs_vs(ipart,ireac))
!
              if(fbak.gt.frlim_vs_max(iivs_vs(ipart,ireac)))            &
     &              fbak=frlim_vs_max(iivs_vs(ipart,ireac))
            enddo
!
            vfor(ireac)=ffor*vfor0(ireac)
            vbak(ireac)=fbak*vbak0(ireac)
!
!cc          if(ffor.lt.1.d0) lvfor(ireac)=lvfor(ireac)+1
!cc          if(fbak.lt.1.d0) lvbak(ireac)=lvbak(ireac)+1
!
            vreac(ireac)=vfor(ireac)-vbak(ireac)
          enddo
        endif
!
        if(jrlim.eq.2) then
          do ireac=1,nreac
            freac=1.d0
!
            if(vreac0(ireac).gt.0.d0) then
              do ipart=1,nopart_vs(ireac)
                if(freac.gt.frlim_vs_max(iovs_vs(ipart,ireac)))         &
     &                freac=frlim_vs_max(iovs_vs(ipart,ireac))
              enddo
!
              do ipart=1,nipart_vs(ireac)
                if(freac.gt.frlim_vs_min(iivs_vs(ipart,ireac)))         &
     &                freac=frlim_vs_min(iivs_vs(ipart,ireac))
              enddo
            endif
!
            if(vreac0(ireac).lt.0.d0) then
              do ipart=1,nopart_vs(ireac)
                if(freac.lt.frlim_vs_min(iovs_vs(ipart,ireac)))         &
     &                freac=frlim_vs_min(iovs_vs(ipart,ireac))
              enddo
!
              do ipart=1,nipart_vs(ireac)
                if(freac.lt.frlim_vs_max(iivs_vs(ipart,ireac)))         &
     &                freac=frlim_vs_max(iivs_vs(ipart,ireac))
              enddo
            endif
!
            vreac(ireac)=freac*vreac0(ireac)
            if(freac.lt.1.d0) lvreac(ireac)=lvreac(ireac)+1
!
          enddo
        endif
      else
        do ireac=1,nreac
          vreac(ireac)=vfor(ireac)-vbak(ireac)
        enddo
      endif
!
!
!   accumulate each species' net production rate
!   (= total creation rate - total annihilation rate)
!
      do ireac=1,nreac
        do ipart=1,nipart_vs(ireac)
          vspec(iispec_vs(ipart,ireac))=                                &
     &    vspec(iispec_vs(ipart,ireac))                                 &
     &    -vreac(ireac)*gimult_vs(ipart,ireac)
        enddo
!
        do ipart=1,nopart_vs(ireac)
          vspec(iospec_vs(ipart,ireac))=                                &
     &    vspec(iospec_vs(ipart,ireac))                                 &
     &    +vreac(ireac)*gomult_vs(ipart,ireac)
        enddo
      enddo
!
  900 continue
!
!   restore species variable (log) transform
      do ivs=1,nvs_spec
        if(jfox(ispec_vs(ivs)).eq.1) then
          vspec(ispec_vs(ivs))=vspec(ispec_vs(ivs))                     &
     &                        /xspec(ispec_vs(ivs))
          xspec(ispec_vs(ivs))=yspec_vs(ivs)
        endif
      enddo
!
!   ...and then pack ODE-evolved species concentrations and rates
!   from expanded to compressed format
      if(jtevol.ge.100.and.jtevol.le.299) then
        do ivs=1,nvs_spec
          xspec_vs(ivs)=xspec(ispec_vs(ivs))
          vspec_vs(ivs)=vspec(ispec_vs(ivs))
        enddo
      else
        do ivs=1,nvs_spec
          xspec_vs(ispec_vs(ivs))=xspec(ispec_vs(ivs))
          vspec_vs(ispec_vs(ivs))=vspec(ispec_vs(ivs))
        enddo
      endif
!
!   NOTE/WARNING:
!   The I/O Arrays
!        "xspec_vs" and "vspec_vs"
!   of this subrprg. "drivs" MUST NOT be altered /re-stored
!   in any way during execution; otherwise, may overwrite
!   data in more extended arrays of calling dlsodes subprogs;
!   hence, have allocated extra internal arrays
!        "xspec" and "vspec"
!   here to handle intermed. storage and pack/unpack
!   operations.
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine djacs(NEQ_djacs, T_djacs, Y_djacs, J_djacs             &
     &               , IAN_djacs, JAN_djacs, PDJ_djacs)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
      integer NEQ_djacs(*), J_djacs, IAN_djacs(*), JAN_djacs(*)
!
      real*8  T_djacs, Y_djacs(*), PDJ_djacs(*)
!
            errtag='000119'
            call err_term
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      function gomv(lh,ih,inc)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! check whether counter "lh" has reached at least "ih"
! then increment "lh" by "inc"; used at re-start to suppress
! updating moves until move counters from previous run have
! been restored
!
      implicit none
!
      logical gomv
      integer lh,ih,inc
!
      gomv=(lh.ge.ih)
      if(.not.gomv) lh=lh+inc
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      function ispre4name(ierrtag,namespre,nspre_i                              &
     &                   ,name2look,nspre_x)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! finds spec/reac number "ispre" for
! spec/reac name given in "name2look"
!
      implicit none
!
      integer nch4name
      parameter(nch4name=80)
!
      integer ispre4name, nspre, nspre_x, nspre_i, iun                           &
     &      , ierrtag
!
      character*80 aname,name2look,namespre(1:nspre_x)
!
!
      integer ich1,ich1i,ich1f,ich1b                                    &
     &       ,ich2,ich2i,ich2f,ich2b,ispre
!
      nspre=nspre_i
      if(nspre_i.lt.0) nspre=-nspre_i
!
      ich2i=1
      ich2f=nch4name
!
!   find initial and final non-blank character
!
      do ich2=1,nch4name
        if(index(name2look(ich2:ich2),' ').eq.0                         &
     &    ) then
          ich2i=ich2
          goto 10
        endif
      enddo
   10 continue
!
!
      do ich2b=1,nch4name
        ich2=1+nch4name-ich2b
!
        if(index(name2look(ich2:ich2),' ').eq.0                         &
     &    ) then
          ich2f=ich2
          goto 20
        endif
      enddo
   20 continue
!
!
      if(ich2i.gt.ich2f) then
        ierrtag=nspre+1
        return
!           errtag='000120'
!           call err_term
      endif
!
      ispre4name=0
      do ispre=1,nspre
        aname=namespre(ispre)
!
        do ich1=1,nch4name
          if(index(aname(ich1:ich1),' ').eq.0                           &
     &      ) then
            ich1i=ich1
            goto 110
          endif
        enddo
  110   continue
!
!
        do ich1b=1,nch4name
          ich1=1+nch4name-ich1b
!
          if(index(aname(ich1:ich1),' ').eq.0                           &
     &      ) then
            ich1f=ich1
            goto 120
          endif
        enddo
  120   continue
!
        if(ich1i.gt.ich1f) then
          ierrtag=ispre
          return
!           errtag='000120'
!           call err_term
        endif
!
!
        if(index(aname,name2look(ich2i:ich2f)).ne.0 .and.               &
     &     index(name2look,aname(ich1i:ich1f)).ne.0) then
          ispre4name=ispre
          goto 30
        endif
      enddo
   30 continue
!
      if(ispre4name.eq.0) then
          ierrtag=nspre+2
          return
!           errtag='000120'
!           call err_term
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      function eqname(name0,name1)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! checks whether 2 input char*80  names are equal
!
      implicit none
!
      logical eqname
!
      integer nch4name
      parameter(nch4name=80)
!
      character*80 name0,name1
!
!
      integer ichi0,ichf0
      integer ichi1,ichf1
!
      eqname=.false.
!
      call chif(name0,ichi0,ichf0)
!
      call chif(name1,ichi1,ichf1)
!
      if(                                                               &
     & index(name0(ichi0:ichf0),name1(ichi1:ichf1)).ne.0                &
     &.and.                                                             &
     & index(name1(ichi1:ichf1),name0(ichi0:ichf0)).ne.0                &
     &.and.                                                             &
     & (ichf0-ichi0).eq.(ichf1-ichi1)                                   &
     &)                                                                 &
     & eqname=.true.
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine all_name(mname,ispre_nam                               &
     &                   ,namefrag                                      &
     &                   ,namespre,nspre,nspre_x)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! checks input name fragment "namefrag" for multiple
! occurences in input namelist "namespre" and
! tabulates list names for all such occurences as output
!
      implicit none
!
      logical eqname
!
      integer nch4name
      parameter(nch4name=80)
!
      integer nspre_x
!
      character*80 namefrag,aname,namespre(1:nspre_x)
!
      integer mname,nspre,ispre,ispre_nam(1:nspre_x)
      integer ichi1,ichf1,ichi0,ichf0
!
!
      call chif(namefrag,ichi0,ichf0)
!
      mname=0
      do ispre=1,nspre
        aname=namespre(ispre)
        if(eqname(aname,namefrag)) then
          mname=mname+1
          ispre_nam(mname)=ispre
        endif
      enddo
!
      if(mname.eq.1) then
        mname=-1
        return
      endif
!
      mname=0
      do ispre=1,nspre
        aname=namespre(ispre)
        call chif(aname,ichi1,ichf1)
        if(index(aname(ichi1:ichf1),namefrag(ichi0:ichf0)).ne.0         &
     &  )then
          mname=mname+1
          ispre_nam(mname)=ispre
        endif
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine chif(name2look,ichi,ichf)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! finds initial and final non-blank character positions
! "ichi" and "ichf" in a char*80 name
!
      implicit none
!
      integer nch4name
      parameter(nch4name=80)
!
      character*80 name2look
!
      integer ich,ichi,ichf,ichb
!
!
      ichi=1
      ichf=nch4name
!
!   find initial and final non-blank character
!
      do ich=1,nch4name
        if(index(name2look(ich:ich),' ').eq.0                           &
     &    ) then
          ichi=ich
          goto 10
        endif
      enddo
   10 continue
!
!
      do ichb=1,nch4name
        ich=1+nch4name-ichb
!
        if(index(name2look(ich:ich),' ').eq.0                           &
     &    ) then
          ichf=ich
          goto 20
        endif
      enddo
   20 continue
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine store_rnd2st
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! generate random Theta
      do ith=1,mth_spec
        ispec=ispec_th(ith)
        ipm=ipmspec_th(ith)
!
        rstep=randx()
        if(jctspec(ispec,ipm).eq.0) then
          cspec(ispec,ipm)=                                             &
     &      rlospec(ith)                                                &
     &    +((rhispec(ith)-rlospec(ith))*rstep)
        endif
        if(jctspec(ispec,ipm).eq.1) then
          cspec(ispec,ipm)=                                             &
     &      rlospec(ith)                                                &
     &    *((rhispec(ith)/rlospec(ith))**rstep)
        endif
      enddo
!
      do ith=1,mth_reac
        ireac=ireac_th(ith)
        ipm=ipmreac_th(ith)
!
        if(jctreac(ireac,ipm).eq.0) then
          rstep=randx()
          rreac(ireac,ipm)=                                             &
     &      rloreac(ith)                                                &
     &    +((rhireac(ith)-rloreac(ith))*rstep)
        endif
        if(jctreac(ireac,ipm).eq.1) then
          rstep=randx()
          rreac(ireac,ipm)=                                             &
     &      rloreac(ith)                                                &
     &    *((rhireac(ith)/rloreac(ith))**rstep)
        endif
      enddo
!
      do ith=1,mth_spec
        ispec=ispec_th(ith)
        ipm=ipmspec_th(ith)
        theta_st(ith,iorst(ipop_upd))=cspec(ispec,ipm)
      enddo
!
      do ith=1,mth_reac
        ireac=ireac_th(ith)
        ipm=ipmreac_th(ith)
        theta_st(ith+mth_spec,iorst(ipop_upd))=rreac(ireac,ipm)
      enddo
!
      jDB_get_chi=22
      call get_chi ! store_rnd2st-01
!
!DRLIM190524-2244:
!     See error handling after two possible calls of store_rnd2st.
!:DRLIM190524-2244
!
      call store_chi_th
!
      jo_pst=1
!Db
      jclC=1000
!Fb
      call ck_chimin
      jo_pst=0
!
!
      htot_st(iorst(ipop_upd))=htot_th
      chisq_st(iorst(ipop_upd))=chisq_th
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine store_th2st
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! store Theta
!   from cspec, rreac, htot_th
!   into theta_st, htot_st
!
! input:  ipop_upd, cspec, rreac, htot_th
! output: theta_st, htot_st
!
          do ith=1,mth_spec
            ispec=ispec_th(ith)
            ipm=ipmspec_th(ith)
            theta_st(ith,iorst(ipop_upd))=cspec(ispec,ipm)
          enddo
!
          do ith=1,mth_reac
            ireac=ireac_th(ith)
            ipm=ipmreac_th(ith)
            theta_st(ith+mth_spec,iorst(ipop_upd))=rreac(ireac,ipm)
          enddo
!
          htot_st(iorst(ipop_upd))=htot_th
          chisq_st(iorst(ipop_upd))=chisq_th
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine store_st2th
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! store Theta
!   from theta_st, htot_st
!   into cspec, rreac, htot_th
!
! input:  ipop_upd, theta_st, htot_st
! output: cspec, rreac, htot_th
!
      do ith=1,mth_spec
        ispec=ispec_th(ith)
        ipm=ipmspec_th(ith)
        cspec(ispec,ipm)=theta_st(ith,iorst(ipop_upd))
      enddo
!
      do ith=1,mth_reac
        ireac=ireac_th(ith)
        ipm=ipmreac_th(ith)
        rreac(ireac,ipm)=theta_st(ith+mth_spec,iorst(ipop_upd))
      enddo
!
      htot_th=htot_st(iorst(ipop_upd))
      chisq_th=chisq_st(iorst(ipop_upd))
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine reord_st
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! store Theta
!   from theta_st, htot_st
!   into theta_st, htot_st w/ iorst=ipop
!
! input:  ipop_upd, cspec, rreac, htot_th
! output: theta_st, htot_st
!
!
      do ipop=0,npopst
        htot_st0(ipop)=htot_st(iorst(ipop))
        chisq_st0(ipop)=chisq_st(iorst(ipop))
!
        do ith=1,mth_tot
          theta_st0(ith,ipop)=                                          &
     &    theta_st(ith,iorst(ipop))
        enddo
      enddo
!
!
      do ipop=0,npopst
        iorst(ipop)=ipop
!
        htot_st(ipop)=htot_st0(ipop)
        chisq_st(ipop)=chisq_st0(ipop)
!
        do ith=1,mth_tot
          theta_st(ith,ipop)=                                           &
     &    theta_st0(ith,ipop)
        enddo
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine store_st2repl
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! store Theta
!   from theta_st, htot_st, chisq_st
!   into theta_repl, htot_repl, chisq_repl
!
      jtrepl=2
      nthr_repl(jtrepl)=npopst
!
      do kthr=0,nthr_repl(jtrepl)
        do ith=1,mth_tot
          theta_repl(ith,kthr,jtrepl)=theta_st(ith,iorst(kthr))
        enddo
!
        htot_repl(kthr,jtrepl)=htot_st(iorst(kthr))
        chisq_repl(kthr,jtrepl)=chisq_st(iorst(kthr))
        beta_repl(kthr,jtrepl)=beta_st(kthr)
      enddo
!
      kthr_upd=ipop_upd
      kthr_xch=ipop_xch
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine store_rnd2ge
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! generate random Theta
      do ith=1,mth_spec
        ispec=ispec_th(ith)
        ipm=ipmspec_th(ith)
!
        rstep=randx()
        if(jctspec(ispec,ipm).eq.0) then
          cspec(ispec,ipm)=                                             &
     &      rlospec(ith)                                                &
     &    +((rhispec(ith)-rlospec(ith))*rstep)
        endif
        if(jctspec(ispec,ipm).eq.1) then
          cspec(ispec,ipm)=                                             &
     &      rlospec(ith)                                                &
     &    *((rhispec(ith)/rlospec(ith))**rstep)
        endif
      enddo
!
      do ith=1,mth_reac
        ireac=ireac_th(ith)
        ipm=ipmreac_th(ith)
!
        if(jctreac(ireac,ipm).eq.0) then
          rstep=randx()
          rreac(ireac,ipm)=                                             &
     &      rloreac(ith)                                                &
     &    +((rhireac(ith)-rloreac(ith))*rstep)
        endif
        if(jctreac(ireac,ipm).eq.1) then
          rstep=randx()
          rreac(ireac,ipm)=                                             &
     &      rloreac(ith)                                                &
     &    *((rhireac(ith)/rloreac(ith))**rstep)
        endif
      enddo
!
      do ith=1,mth_spec
        ispec=ispec_th(ith)
        ipm=ipmspec_th(ith)
        theta_ge(ith,iorge(ipop_upd))=cspec(ispec,ipm)
      enddo
!
      do ith=1,mth_reac
        ireac=ireac_th(ith)
        ipm=ipmreac_th(ith)
        theta_ge(ith+mth_spec,iorge(ipop_upd))=rreac(ireac,ipm)
      enddo
!
      jDB_get_chi=23
      call get_chi ! store_rnd2ge-01
!
!DRLIM190524-2244:
!     See error handling after two possible calls of store_rnd2ge.
!:DRLIM190524-2244
!
      call store_chi_th
!
      jo_pge=1
!Db
      jclC=3000
!Fb
      call ck_chimin
      jo_pge=0
!
!
      htot_ge(iorge(ipop_upd))=htot_th
      chisq_ge(iorge(ipop_upd))=chisq_th
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine store_th2ge
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! store Theta
!   from cspec, rreac, htot_th
!   into theta_ge, htot_ge
!
! input:  ipop_upd, cspec, rreac, htot_th
! output: theta_ge, htot_ge
!
      do ith=1,mth_spec
        ispec=ispec_th(ith)
        ipm=ipmspec_th(ith)
        theta_ge(ith,iorge(ipop_upd))=cspec(ispec,ipm)
      enddo
!
      do ith=1,mth_reac
        ireac=ireac_th(ith)
        ipm=ipmreac_th(ith)
        theta_ge(ith+mth_spec,iorge(ipop_upd))=rreac(ireac,ipm)
      enddo
!
      htot_ge(iorge(ipop_upd))=htot_th
      chisq_ge(iorge(ipop_upd))=chisq_th
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine store_ge2th
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! store Theta
!   from theta_ge, htot_ge
!   into cspec, rreac, htot_th
!
! input:  ipop_upd, theta_ge, htot_ge
! output: cspec, rreac, htot_th
!
      do ith=1,mth_spec
        ispec=ispec_th(ith)
        ipm=ipmspec_th(ith)
        cspec(ispec,ipm)=theta_ge(ith,iorge(ipop_upd))
      enddo
!
      do ith=1,mth_reac
        ireac=ireac_th(ith)
        ipm=ipmreac_th(ith)
        rreac(ireac,ipm)=theta_ge(ith+mth_spec,iorge(ipop_upd))
      enddo
!
      htot_th=htot_ge(iorge(ipop_upd))
      chisq_th=chisq_ge(iorge(ipop_upd))
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine store_ge2repl
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
! store Theta
!   from theta_ge, htot_ge, chisq_ge
!   into theta_repl, htot_repl, chisq_repl
!
      jtrepl=3
      nthr_repl(jtrepl)=npopge
!
      do kthr=0,nthr_repl(jtrepl)
        do ith=1,mth_tot
          theta_repl(ith,kthr,jtrepl)=theta_ge(ith,iorge(kthr))
        enddo
!
        htot_repl(kthr,jtrepl)=htot_ge(iorge(kthr))
        chisq_repl(kthr,jtrepl)=chisq_ge(iorge(kthr))
        beta_repl(kthr,jtrepl)=beta_ge
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      function dqbx(yspec,ybx_lo,ybx_ct,ybx_hi,sbx,jbx_qb)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! boundary contact weight function,
!     0.0 <= dqbx <= 1.0
! On input, must have prepared:
!     sbx:=1/|ybx_hi - ybx_lo|
!     ybx_ct:=(ybx_hi + ybx_lo)/2
! so that dqbx rises continuously with yspec from
!     dqbx=0.0 at yspec=ybx_lo   to
!     dqbx=1.0 at yspec=ybx_hi   to
! for 0 <= yspec   and ybx_lo < ybx_hi
!
      implicit none
!
      integer jbx_qb
      real*8 dqbx,yspec,ybx_lo,ybx_ct,ybx_hi,sbx,dybx
!
      dqbx=0.d0
      if(yspec.le.ybx_lo) then
        return
      endif
!
      if(yspec.ge.ybx_hi) then
        dqbx=1.d0
        return
      endif
!
      if(jbx_qb.eq.1) then
        dqbx=sbx*(yspec-ybx_lo)
        return
      endif
!
      if(jbx_qb.eq.2) then
        dybx=sbx*(yspec-ybx_ct)
        dqbx=0.5d0+1.5d0*dybx-2.0d0*(dybx**3)
        return
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      function wtshape(txpt,tcent,tleng,trise,jshape)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      implicit none
!
!
      integer jshape
!
      real*8  tcent, tleng, trise, txpt, t1, t2, t3, t4, trise0         &
     &      , wtshape
!
!
      wtshape=0.d0
      trise0=dabs(trise)+1.d-14*(dabs(tleng)+1.d0)
!
! jshape=0: symmetric trapezoidal weight pulse
      if(jshape.eq.0) then
        t1=tcent-(tleng+0.5d0*trise)
        t2=tcent-(tleng-0.5d0*trise)
        t3=tcent+(tleng-0.5d0*trise)
        t4=tcent+(tleng+0.5d0*trise)
!
        if(t1.lt.txpt.and.txpt.le.t2)                                   &
     &  wtshape=(txpt-t1)/trise0
!
        if(t2.lt.txpt.and.txpt.le.t3)                                   &
     &  wtshape=1.d0
!
        if(t3.lt.txpt.and.txpt.le.t4)                                   &
     &  wtshape=1.d0-(txpt-t3)/trise0
      endif
!
! jshape=1: NOT YET IMPLEMENTED
!
      if(wtshape.lt.0.d0) wtshape=0.d0
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine htot_amlr(y_amlf,z_amlf,ptheta_amlf)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!   declare "htot_amlr"-local I/O variables and arrays
!     NOTE: all following local variable/array decl.s
!     (w/ names ending in "..._amlf") MUST NOT appear
!     in "ens.def" var./arr. decl.s or common blocks
!
      integer ith_amlf,ispec_amlf,ireac_amlf,ipm_amlf,jct_amlf          &
     &      , isign_pi_amlf
!
      real*8  y_amlf                                                    &
     &       ,z_amlf                                                    &
     &       ,theta0_amlf                                               &
     &       ,rhi_amlf,rlo_amlf                                         &
     &       ,ptheta_amlf(mth_tot_x)
!
!   advance htot_amlr-function call counter
      ihtot_amb=ihtot_amb+1
      mhtot_amb=mhtot_amb+1
!
      call save_chi_th
      call save_theta
!
!
      do ith_amlf=1,mth_tot
        theta0_amlf=ptheta_amlf(ith_amlf)
!
        if(ith_amlf.le.mth_spec) then
          ispec_amlf=ispec_th(ith_amlf)
          ireac_amlf=-1
          ipm_amlf=ipmspec_th(ith_amlf)
!
          rhi_amlf=rhispec(ith_amlf)
          rlo_amlf=rlospec(ith_amlf)
          jct_amlf=jctspec(ispec_amlf,ipm_amlf)
        endif
!
        if(ith_amlf.gt.mth_spec) then
          ispec_amlf=-1
          ireac_amlf=ireac_th(ith_amlf-mth_spec)
          ipm_amlf=ipmreac_th(ith_amlf-mth_spec)
!
          rhi_amlf=rhireac(ith_amlf-mth_spec)
          rlo_amlf=rloreac(ith_amlf-mth_spec)
          jct_amlf=jctreac(ireac_amlf,ipm_amlf)
        endif
!
!     jctspec/reac=0: move Theta
        if(jct_amlf.eq.0) then
          rhi_amlf=rhi_amlf
          rlo_amlf=rlo_amlf
        endif
!
!     jctspec/reac=1: move ln(Theta)
        if(jct_amlf.eq.1) then
          rhi_amlf=dlog(rhi_amlf)
          rlo_amlf=dlog(rlo_amlf)
        endif
!
!   enforce lo- and hi-Theta boundaries
        call refl_th(theta0_amlf                                        &
     &              ,rhi_amlf                                           &
     &              ,rlo_amlf                                           &
     &              ,isign_pi_amlf)
!
!   store boundary-reflected Theta as cspec or rreac
        if(jct_amlf.eq.1) theta0_amlf=dexp(theta0_amlf)
        if(ispec_amlf.gt.0) cspec(ispec_amlf,ipm_amlf)=theta0_amlf
        if(ireac_amlf.gt.0) rreac(ireac_amlf,ipm_amlf)=theta0_amlf
      enddo
!
      jDB_get_chi=24
      call get_chi ! htot_amlr-01
!
!DRLIM190524-2244:
      if(  mlimdrv.ge.1) then ! htot_amlr-01
        errtag='000121.005: # rate fct calls > nlim_drv, during amoeba'
        call err_term
      endif
!     May evolve a Theta with mlimdrv>=1 here.
!     Need to implement better handling for that case!! 
!:DRLIM190524-2244
!
      call store_chi_th
!
      ith_cs=-1
      if(mth_tot.gt.0) then
        imove_amb=(ihtot_amb-1)/mth_tot
        imove_amb=imove_amb+1
        ith_cs=ihtot_amb-mth_tot*(imove_amb-1)
      endif
!Db
      jclC=22
!Fb
      call ck_chimin
      ith_cs=-1
      imove_amb=-1
!
      y_amlf=htot_th
      z_amlf=chisq_th
!
!   generate "ens.o02" output, for jo_th=41:
      if(mhtot_amb.eq.mth_tot) then
        if(mth_tot.gt.0) then
          imove_amb=(ihtot_amb-1)/mth_tot
          imove_amb=imove_amb+1
          ith_cs=ihtot_amb-mth_tot*(imove_amb-1)
        endif
!
!
        jclO=145
        if(jo_th.eq.41) call odat_th ! htot_amlr
        call ck_stop_swp
!
        mhtot_amb=0
        ith_cs=-1
        imove_amb=-1
      endif
!
!
      call reset_chi_th
      call reset_theta
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine store_pth2repl(y_amlr,z_amlr,ptheta_amlr)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! stores amoeba Theta-array and htot- and chisq-vectors
! into restart output arrays
!
      include 'ens.def'
!
!   declare "amoeba"-local I/O variables and arrays
!     NOTE: all following local variable/array decl's.
!     (w/ names ending in "..._amlr") MUST NOT appear
!     in "ens.def" var./arr. decl's. or common blocks
!
      integer                                                           &
     &        jct_amlr                                                  &
     &      , ivec_amlr                                                 &
     &      , ivlo_amlr                                                 &
     &      , ith_amlr                                                  &
     &      , ispec_amlr                                                &
     &      , ireac_amlr                                                &
     &      , ipm_amlr                                                  &
     &      , isign_pi_amlr                                             &
     &      , kthr_amlr
!
      real*8  ptheta_amlr(1:(mth_tot_x+1),mth_tot_x)                    &
     &      , y_amlr(1:(mth_tot_x+1))                                   &
     &      , z_amlr(1:(mth_tot_x+1))                                   &
     &      , rhi_amlr                                                  &
     &      , rlo_amlr                                                  &
     &      , p0_amlr
!
!
      jtrepl=1
      nthr_repl(jtrepl)=mth_tot
!
!     re-order arrays so that "htot" values  and Theta-vectors
!     are stored in order of ascending "htot"...
      do ivec_amlr=1,(mth_tot+1)
        kthr_amlr=0
        do ivlo_amlr=1,(mth_tot+1)
          if(ivlo_amlr.ne.ivec_amlr) then
            if(y_amlr(ivlo_amlr).lt.y_amlr(ivec_amlr))                  &
     &      kthr_amlr=kthr_amlr+1
!
            if(y_amlr(ivlo_amlr).eq.y_amlr(ivec_amlr)                   &
     &      .and.ivlo_amlr.lt.ivec_amlr)                                &
     &      kthr_amlr=kthr_amlr+1
          endif
        enddo
!
!       ...then reflect Theta-components into boundaries,
!       transform to lin. scale, if needed, and store:
        do ith_amlr=1,mth_tot
          if(ith_amlr.le.mth_spec) then
            ispec_amlr=ispec_th(ith_amlr)
            ipm_amlr=ipmspec_th(ith_amlr)
!
            rhi_amlr=rhispec(ith_amlr)
            rlo_amlr=rlospec(ith_amlr)
            jct_amlr=jctspec(ispec_amlr,ipm_amlr)
          endif
!
          if(ith_amlr.gt.mth_spec) then
            ireac_amlr=ireac_th(ith_amlr-mth_spec)
            ipm_amlr=ipmreac_th(ith_amlr-mth_spec)
!
            rhi_amlr=rhireac(ith_amlr-mth_spec)
            rlo_amlr=rloreac(ith_amlr-mth_spec)
            jct_amlr=jctreac(ireac_amlr,ipm_amlr)
          endif
!
          if(jct_amlr.eq.1) then
            rhi_amlr=dlog(rhi_amlr)
            rlo_amlr=dlog(rlo_amlr)
          endif
!
          p0_amlr=ptheta_amlr(ivec_amlr,ith_amlr)
!
          call refl_th(p0_amlr                                          &
     &                ,rhi_amlr                                         &
     &                ,rlo_amlr                                         &
     &                ,isign_pi_amlr)
!
!
          if(p0_amlr.gt.rhi_amlr)                                       &
     &    p0_amlr=rhi_amlr
          if(p0_amlr.lt.rlo_amlr)                                       &
     &    p0_amlr=rlo_amlr
!
          if(jct_amlr.eq.1) then
            p0_amlr                                                     &
     &      =dexp(p0_amlr)
          endif
!
          theta_repl(ith_amlr,kthr_amlr,jtrepl)                         &
     &     =p0_amlr
        enddo
!
        htot_repl(kthr_amlr,jtrepl)=y_amlr(ivec_amlr)
        chisq_repl(kthr_amlr,jtrepl)=z_amlr(ivec_amlr)
      enddo
!
      kthr_upd=-1
      kthr_xch=-1
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine amoeba(p,y,z,mp,np,ndim,ftol,funk,iter,NMAX,ITMAX)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      implicit none
!
      INTEGER iter,mp,ndim,np,NMAX,ITMAX
      REAL*8 ftol,p(mp,np),y(mp),z(mp)
!c   1      ,funk
!cHBS PARAMETER (NMAX=20,ITMAX=5000)
      EXTERNAL funk
!u    USES amotry,funk
      INTEGER i,ihi,ilo,inhi,j,m,n
!
      REAL*8 rtol,sum,swap,ysave,ytry,ztry,psum(NMAX)                   &
     &      ,c1d0m,c2d0p,c0d5p
!c   1      ,amotry
!
!cHBS:
      data c1d0m /-1.0d0/
      data c2d0p /+2.0d0/
      data c0d5p /+0.5d0/
!c:HBS
!
!
      iter=0
    1 continue
      do 12 n=1,ndim
        sum=0.d0
        do 11 m=1,ndim+1
          sum=sum+p(m,n)
   11   continue
        psum(n)=sum
   12 continue
!
    2 continue
      ilo=1
      if (y(1).gt.y(2)) then
        ihi=1
        inhi=2
      else
        ihi=2
        inhi=1
      endif
      do 13 i=1,ndim+1
        if(y(i).le.y(ilo)) ilo=i
        if(y(i).gt.y(ihi)) then
          inhi=ihi
          ihi=i
        else if(y(i).gt.y(inhi)) then
          if(i.ne.ihi) inhi=i
        endif
   13 continue
      rtol=2.d0*dabs(y(ihi)-y(ilo))/(dabs(y(ihi))+dabs(y(ilo)))
      if (rtol.lt.ftol) then
        swap=y(1)
        y(1)=y(ilo)
        y(ilo)=swap
!
        swap=z(1)
        z(1)=z(ilo)
        z(ilo)=swap
!
        do 14 n=1,ndim
          swap=p(1,n)
          p(1,n)=p(ilo,n)
          p(ilo,n)=swap
   14   continue
        return
      endif
      if (iter.ge.ITMAX) return
!
      iter=iter+2
      call store_pth2repl(y,z,p)
!
!c    ytry=amotry(p,y,...
      call amotry(ytry,ztry,p,y,z                                       &
     &           ,psum,mp,np,ndim,funk,ihi,c1d0m,NMAX)
      if (ytry.le.y(ilo)) then
!c      ytry=amotry(p,y,...
        call amotry(ytry,ztry,p,y,z                                     &
     &             ,psum,mp,np,ndim,funk,ihi,c2d0p,NMAX)
      else if (ytry.ge.y(inhi)) then
        ysave=y(ihi)
!c      ytry=amotry(p,y,...
        call amotry(ytry,ztry,p,y,z                                     &
     &             ,psum,mp,np,ndim,funk,ihi,c0d5p,NMAX)
        if (ytry.ge.ysave) then
          do 16 i=1,ndim+1
            if(i.ne.ilo)then
              do 15 j=1,ndim
                psum(j)=0.5d0*(p(i,j)+p(ilo,j))
                p(i,j)=psum(j)
   15         continue
!c            y(i)=funk(psum)
              call funk(y(i),z(i),psum)
            endif
   16     continue
          iter=iter+ndim
          goto 1
        endif
      else
        iter=iter-1
      endif
      goto 2
!
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine amotry(ytry,ztry,p,y,z                                 &
     &                 ,psum,mp,np,ndim,funk,ihi,fac,NMAX)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      implicit none
!
      INTEGER ihi,mp,ndim,np,NMAX
      REAL*8                                                            &
     &       fac,p(mp,np),psum(np),y(mp),z(mp)
!c   1      ,amotry,funk
!cHBS PARAMETER (NMAX=20)
      EXTERNAL funk
!u    USES funk
      INTEGER j
      REAL*8 fac1,fac2,ytry,ztry,ptry(NMAX)
!
!cHBS fac1=(1.-fac)/ndim
      fac1=(1.d0-fac)/ndim
      fac2=fac1-fac
      do 11 j=1,ndim
        ptry(j)=psum(j)*fac1-p(ihi,j)*fac2
   11 continue
!c    ytry=funk(ptry)
      call funk(ytry,ztry,ptry)
      if (ytry.lt.y(ihi)) then
        y(ihi)=ytry
        z(ihi)=ztry
        do 12 j=1,ndim
          psum(j)=psum(j)-p(ihi,j)+ptry(j)
          p(ihi,j)=ptry(j)
   12   continue
      endif
!
!c    amotry=ytry
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine efile(iun)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
!
      implicit none
      character*80 line
      integer iun, iline, nline
!
      nline=0
!
   10 continue
!
      read(iun,2010,end=90) line
      nline=nline+1
 2010 format(a80)
      goto 10
!
!
   90 continue
      rewind(iun)
      do iline=1,nline
        read(iun,2010) line
      enddo
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine erasefi(fname)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
!
      implicit none
!
      character*80 fname
      logical fexist
!
!
      inquire(file=fname,exist=fexist)
      if(fexist) then
        open(99,file=fname,status='old')
        rewind(99)
        write(99,*) ' ERASED'
        close(99)
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine copyfi(fname0,fname1)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
!
      implicit none
!
      integer nch4name
      parameter(nch4name=80)
!
      character*80 fname0,fname1,aline
      logical fexist
      integer iun,ich2,ich2b,ich2f
!
!
      inquire(file=fname1,exist=fexist)
      if(fexist) then
        open(91,file=fname1,status='old')
      else
!BLADE:
!       open(91,file=fname1,status='new')
        open(91,file=fname1)
!:BLADE
      endif
      rewind(91)
!
!
      inquire(file=fname0,exist=fexist)
      if(fexist) then
        open(90,file=fname0,status='old')
        rewind(90)
!
   10   continue
          read(90,2010,end=190) aline
 2010     format(a80)
!
          do ich2b=1,nch4name
            ich2=1+nch4name-ich2b
!
            if(index(aline(ich2:ich2),' ').eq.0                         &
     &        ) then
              ich2f=ich2
              goto 20
            endif
          enddo
   20     continue
!
          write(91,2020) (aline(ich2:ich2),ich2=1,ich2f)
 2020     format(80a1)
        goto 10
!
  190   continue
        close(90)
      else
        write(91,*) 'ErroR in "copyfi": copy input file named'
        write(91,2010) fname0
        write(91,*) 'was not found'
      endif
!
      close(91)
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ck_stop_now
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
      if(mp_myid.ne.mp_mrid) return
!
!
      inquire(file='ens.stop',exist=fexist)
      if(fexist) then
        open(99,file='ens.stop',status='old')
        read(99,2010,end=190,err=190) aline
 2010   format(a80)
!
        if(index(aline(1:80),'STOP NOW').ne.0) then
          do iun=1,98
            close(iun)
          enddo
          call mp_stopabort
        endif
      endif
!
!
  190 continue
      close(99)
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ck_stop_swp
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      include 'ens.def'
!
!
      if(mp_myid.ne.mp_mrid) return
!
!
      inquire(file='ens.stop',exist=fexist)
      if(fexist) then
        open(99,file='ens.stop',status='old')
        read(99,2010,end=190,err=190) aline
 2010   format(a80)
!
        if(index(aline(1:80),'STOP SWP').ne.0) then
          do iun=1,98
            close(iun)
          enddo
          call mp_stopabort
        endif
      endif
!
!
  190 continue
      close(99)
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine fdigit(jf,mbase,jdig,nzdig,ndig_x)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
!
      implicit none
!
      integer ndig_x
!
      integer jf,nzdig,mbase,jres,jdiv,idig
      integer jdig(1:ndig_x)
!
!
      if(jf.lt.0) then
        do idig=1,ndig_x
          jdig(idig)=-1
        enddo
        return
      endif
!
      do idig=1,ndig_x
        jdig(idig)=0
      enddo
!
      nzdig=0
      jdiv=jf
      do idig=1,ndig_x
        nzdig=nzdig+1
        jres=jdiv
        jdiv=jdiv/mbase
        jdig(nzdig)=jres-mbase*jdiv
        if(jdiv.eq.0) goto 10
        if(nzdig.eq.ndig_x) goto 10
      enddo
   10 continue
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine fdigit_abs(jf,mbase,jdig,nzdig,ndig_x)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
!
      implicit none
!
      integer ndig_x
!
      integer jf,nzdig,mbase,jres,jdiv,idig
      integer jdig(1:ndig_x)
!
!
      do idig=1,ndig_x
        jdig(idig)=0
      enddo
!
      nzdig=0
      jdiv=jf
      if(jdiv.lt.0) jdiv=-jdiv
      do idig=1,ndig_x
        nzdig=nzdig+1
        jres=jdiv
        jdiv=jdiv/mbase
        jdig(nzdig)=jres-mbase*jdiv
        if(jdiv.eq.0) goto 10
        if(nzdig.eq.ndig_x) goto 10
      enddo
   10 continue
!
!
      return
      end
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      FUNCTION pythag(a,b)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      REAL*8 a,b,pythag
      REAL*8 absa,absb
!
      absa=dabs(a)
      absb=dabs(b)
      if(absa.gt.absb)then
        pythag=absa*dsqrt(1.d0+(absb/absa)**2)
      else
        if(absb.eq.0.d0)then
          pythag=0.d0
        else
          pythag=absb*dsqrt(1.d0+(absa/absb)**2)
        endif
      endif
      return
      END
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine svbksb(u,w,v,m,n,mp,np,b,x,NMAX)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      INTEGER m,mp,n,np,NMAX
      REAL*8 b(mp),u(mp,np),v(np,np),w(np),x(np)
!cc   PARAMETER (NMAX=500)
      INTEGER i,j,jj
      REAL*8 s,tmp(NMAX)
!
      do 12 j=1,n
        s=0.d0
        if(w(j).ne.0.d0)then
          do 11 i=1,m
            s=s+u(i,j)*b(i)
   11     continue
          s=s/w(j)
        endif
        tmp(j)=s
   12 continue
      do 14 j=1,n
        s=0.d0
        do 13 jj=1,n
          s=s+v(j,jj)*tmp(jj)
   13   continue
        x(j)=s
   14 continue
      return
      END
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine svdcmp(a,m,n,mp,np,w,v,NMAX,ierrtag)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      INTEGER m,mp,n,np,NMAX
      REAL*8 a(mp,np),v(np,np),w(np)
!cc   PARAMETER (NMAX=500)
!u    USES pythag
      INTEGER i,its,j,jj,k,l,nm,ierrtag                                &
     &       ,iun
      REAL*8 anorm,c,f,g,h,s,scale,x,y,z,rv1(NMAX),pythag,one
!
      one=1.d0
!
      g=0.d0
      scale=0.d0
      anorm=0.d0
      do 25 i=1,n
        l=i+1
        rv1(i)=scale*g
        g=0.d0
        s=0.d0
        scale=0.d0
        if(i.le.m)then
          do 11 k=i,m
            scale=scale+dabs(a(k,i))
   11     continue
          if(scale.ne.0.d0)then
            do 12 k=i,m
              a(k,i)=a(k,i)/scale
              s=s+a(k,i)*a(k,i)
   12       continue
            f=a(i,i)
            g=-dsign(dsqrt(s),f)
            h=f*g-s
            a(i,i)=f-g
            do 15 j=l,n
              s=0.d0
              do 13 k=i,m
                s=s+a(k,i)*a(k,j)
   13         continue
              f=s/h
              do 14 k=i,m
                a(k,j)=a(k,j)+f*a(k,i)
   14         continue
   15       continue
            do 16 k=i,m
              a(k,i)=scale*a(k,i)
   16       continue
          endif
        endif
        w(i)=scale *g
        g=0.d0
        s=0.d0
        scale=0.d0
        if((i.le.m).and.(i.ne.n))then
          do 17 k=l,n
            scale=scale+dabs(a(i,k))
   17     continue
          if(scale.ne.0.d0)then
            do 18 k=l,n
              a(i,k)=a(i,k)/scale
              s=s+a(i,k)*a(i,k)
   18       continue
            f=a(i,l)
            g=-dsign(dsqrt(s),f)
            h=f*g-s
            a(i,l)=f-g
            do 19 k=l,n
              rv1(k)=a(i,k)/h
   19       continue
            do 23 j=l,m
              s=0.d0
              do 21 k=l,n
                s=s+a(j,k)*a(i,k)
   21         continue
              do 22 k=l,n
                a(j,k)=a(j,k)+s*rv1(k)
   22         continue
   23       continue
            do 24 k=l,n
              a(i,k)=scale*a(i,k)
   24       continue
          endif
        endif
        anorm=max(anorm,(dabs(w(i))+dabs(rv1(i))))
   25 continue
      do 32 i=n,1,-1
        if(i.lt.n)then
          if(g.ne.0.d0)then
            do 26 j=l,n
              v(j,i)=(a(i,j)/a(i,l))/g
   26       continue
            do 29 j=l,n
              s=0.d0
              do 27 k=l,n
                s=s+a(i,k)*v(k,j)
   27         continue
              do 28 k=l,n
                v(k,j)=v(k,j)+s*v(k,i)
   28         continue
   29       continue
          endif
          do 31 j=l,n
            v(i,j)=0.d0
            v(j,i)=0.d0
   31     continue
        endif
        v(i,i)=1.d0
        g=rv1(i)
        l=i
   32 continue
      do 39 i=min(m,n),1,-1
        l=i+1
        g=w(i)
        do 33 j=l,n
          a(i,j)=0.d0
   33   continue
        if(g.ne.0.d0)then
          g=1.d0/g
          do 36 j=l,n
            s=0.d0
            do 34 k=l,m
              s=s+a(k,i)*a(k,j)
   34       continue
            f=(s/a(i,i))*g
            do 35 k=i,m
              a(k,j)=a(k,j)+f*a(k,i)
   35       continue
   36     continue
          do 37 j=i,m
            a(j,i)=a(j,i)*g
   37     continue
        else
          do 38 j= i,m
            a(j,i)=0.d0
   38     continue
        endif
        a(i,i)=a(i,i)+1.d0
   39 continue
      do 49 k=n,1,-1
        do 48 its=1,30
          do 41 l=k,1,-1
            nm=l-1
            if((dabs(rv1(l))+anorm).eq.anorm)  goto 2
            if((dabs(w(nm))+anorm).eq.anorm)  goto 1
   41     continue
    1     c=0.d0
          s=1.d0
          do 43 i=l,k
            f=s*rv1(i)
            rv1(i)=c*rv1(i)
            if((dabs(f)+anorm).eq.anorm) goto 2
            g=w(i)
            h=pythag(f,g)
            w(i)=h
            h=1.d0/h
            c= (g*h)
            s=-(f*h)
            do 42 j=1,m
              y=a(j,nm)
              z=a(j,i)
              a(j,nm)=(y*c)+(z*s)
              a(j,i)=-(y*s)+(z*c)
   42       continue
   43     continue
    2     z=w(k)
          if(l.eq.k)then
            if(z.lt.0.d0)then
              w(k)=-z
              do 44 j=1,n
                v(j,k)=-v(j,k)
   44         continue
            endif
            goto 3
          endif
!
          if(its.ge.30) then
!c          no convergence in svdcmp:
!!!!        errtag='000123'
!!!!        call err_term
            ierrtag=its
            return
          endif
!
          x=w(l)
          nm=k-1
          y=w(nm)
          g=rv1(nm)
          h=rv1(k)
          f=((y-z)*(y+z)+(g-h)*(g+h))/(2.d0*h*y)
          g=pythag(f,one)
          f=((x-z)*(x+z)+h*((y/(f+dsign(g,f)))-h))/x
          c=1.d0
          s=1.d0
          do 47 j=l,nm
            i=j+1
            g=rv1(i)
            y=w(i)
            h=s*g
            g=c*g
            z=pythag(f,h)
            rv1(j)=z
            c=f/z
            s=h/z
            f= (x*c)+(g*s)
            g=-(x*s)+(g*c)
            h=y*s
            y=y*c
            do 45 jj=1,n
              x=v(jj,j)
              z=v(jj,i)
              v(jj,j)= (x*c)+(z*s)
              v(jj,i)=-(x*s)+(z*c)
   45       continue
            z=pythag(f,h)
            w(j)=z
            if(z.ne.0.d0)then
              z=1.d0/z
              c=f*z
              s=h*z
            endif
            f= (c*g)+(s*y)
            x=-(s*g)+(c*y)
            do 46 jj=1,m
              y=a(jj,j)
              z=a(jj,i)
              a(jj,j)= (y*c)+(z*s)
              a(jj,i)=-(y*s)+(z*c)
   46       continue
   47     continue
          rv1(l)=0.d0
          rv1(k)=f
          w(k)=x
   48   continue
    3   continue
   49 continue
      return
      END
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine svdfit(                                                &
     &                  x,y,sig,ndata                                   &
     &                 ,a,ma,ma1                                        &
     &                 ,u                                               &
     &                 ,v                                               &
     &                 ,w                                               &
     &                 ,chisq                                           &
     &                 ,x_i,o_fi                                        &
     &                 ,jbas                                            &
     &                 ,mp                                              &
     &                 ,np                                              &
     &                 ,NMAX                                            &
     &                 ,MMAX,ierrtag                                   &
     &                 ,funcs)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! on input set
!   NMAX = mp = max(ndata)
!        = max(no. of data pts.)
!        = max(dim(x)) = max(dim(y)),
!   MMAX = np =max(ma)
!        = max.(no. of fitting amplitudes)
!        = max(dim(a))
!
      INTEGER ma,mp,ndata,np,NMAX,MMAX,ierrtag
      REAL*8 chisq,a(ma),sig(ndata),u(mp,np),v(np,np),w(np)             &
     &      ,x(ndata)                                                   &
     &      ,y(ndata)                                                   &
     &      ,TOL
!
! HBS-added input params:
      INTEGER ma1,jbas
      REAL*8 x_i,o_fi
!
      EXTERNAL funcs
!cc   PARAMETER (NMAX=1000,MMAX=50,TOL=1.d-5)
      PARAMETER (TOL=1.d-8)
!u    USES svbksb,svdcmp
      INTEGER i,j                &
     &       ,NMAXsvbk                                                  &
     &       ,NMAXsvdc
      REAL*8 sum,thresh,tmp,wmax,afunc(MMAX),b(NMAX)
!
      NMAXsvbk=2*np
      NMAXsvdc=2*np
!
      do 12 i=1,ndata
! HBS   call funcs(x(i),afunc,ma)
        call funcs(x(i),x_i,o_fi,afunc,ma,ma1,jbas,NMAX)
        tmp=1.d0/sig(i)
        do 11 j=1,ma
          u(i,j)=afunc(j)*tmp
   11   continue
        b(i)=y(i)*tmp
   12 continue
      call svdcmp(u,ndata,ma,mp,np,w,v,NMAXsvd,ierrtag)
      if(ierrtag.gt.0) return
!
      wmax=0.d0
      do 13 j=1,ma
        if(w(j).gt.wmax)wmax=w(j)
   13 continue
      thresh=TOL*wmax
      do 14 j=1,ma
        if(w(j).lt.thresh)w(j)=0.d0
   14 continue
      call svbksb(u,w,v,ndata,ma,mp,np,b,a,NMAXsvbk)
      chisq=0.d0
      do 16 i=1,ndata
! HBS   call funcs(x(i),afunc,ma)
        call funcs(x(i),x_i,o_fi,afunc,ma,ma1,jbas,NMAX)
        sum=0.d0
        do 15 j=1,ma
          sum=sum+a(j)*afunc(j)
   15   continue
        chisq=chisq+((y(i)-sum)/sig(i))**2
   16 continue
!
      return
      END
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      function xxdi(time,isegxd,is_xdi,iexpt                            &
     &              ,abaxdi,time_xdii,otime_xdifi                       &
     &              ,nbaxdi,jbaxdi                                      &
     &              ,nbaxdi_y,nsegxd_y,nsxdi_y,nexpt_y)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      implicit none
!
      integer isegxd,is_xdi,iexpt,ibas                                  &
     &       ,nbaxdi_y,nsegxd_y,nsxdi_y,nexpt_y
!
      integer nbaxdi(0:1,1:nsegxd_y,nsxdi_y,nexpt_y)                    &
     &       ,jbaxdi(    1:nsegxd_y,nsxdi_y,nexpt_y)
!
      real*8 xxdi,time
!
      real*8 abaxdi(1:nbaxdi_y,1:nsegxd_y,nsxdi_y,nexpt_y)              &
     &      ,time_xdii(1:nsegxd_y,nsxdi_y,nexpt_y)                      &
     &      ,otime_xdifi(1:nsegxd_y,nsxdi_y,nexpt_y)                    &
     &      ,fbas_vec(1:(nbaxdi_y+2))
!
!
      call sbaxdi(                                                      &
     &                     time                                         &
     &                    ,time_xdii(isegxd,is_xdi,iexpt)               &
     &                    ,otime_xdifi(isegxd,is_xdi,iexpt)             &
     &                    ,fbas_vec                                     &
     &                    ,nbaxdi(0,isegxd,is_xdi,iexpt)                &
     &                    ,nbaxdi(1,isegxd,is_xdi,iexpt)                &
     &                    ,jbaxdi(isegxd,is_xdi,iexpt)                  &
     &                    ,nbaxdi_y)
!
      xxdi=0.d0
      do ibas=1,nbaxdi(0,isegxd,is_xdi,iexpt)
        xxdi=xxdi                                                       &
     &            +abaxdi(ibas,isegxd,is_xdi,iexpt)*fbas_vec(ibas)
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine sbaxdi(                                                &
     &                   time,time_i,otime_fi                           &
     &                  ,fbas_vec,nbas,nbas1i,jbas                      &
     &                  ,nbas_y)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! Provides basis function selection (jbas) and evaluation
! for SVD-fitting of exptl. data
!
! Input:
!   time,
!   time_i,
!   otime_fi:=1/((time_f-time_i)*fdtxdi),
!   nbas, nbas1i, jbas
!
! Output:
!   fbas_vec(ibas), ibas=1,...nbas
!     fbas_vec contains the values of "nbas" basis
!     fctns. \phi_i(t), evaluated at input time "t"
!     i==ibas, t==time
!
! Available basis options:
!   jbas=0:
!     exponential+trig. (ET) basis
!     augmented by straight line basis fctns. (at+b)
!   jbas=10,11:
!     polynomial basis
!
! Invoked in "svdfit" as:
!     call funcs(x(i),x_i,o_fi,afunc,ma,ma1,jbas,NMAX)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      INTEGER nbas,nbas1i,jbas,nbas_y
      REAL*8  time,time_i,otime_fi,fbas_vec(1:(nbas_y+2))
!
      integer ibas,nbas1,nbas2,iodd
!
      real*8  utim,phi,pi2,datan,em,ep,cphi,sphi
!
!
!cc   data pi2   / 8.d0*datan(1.d0) /
!
!
!cc   otime_fi=1.d0/(time_f-time_i)
      utim=(time-time_i)*otime_fi
      pi2=8.d0*datan(1.d0)
!
!
      if(jbas.eq.0) then
        nbas1=nbas1i
        if(nbas1i.gt.51) nbas1=51
        if(nbas1i.eq.0) nbas1=1
        nbas2=nbas-nbas1
!
        fbas_vec(1)=1.d0
!
        if(nbas1.gt.1) then
          ep=dexp(utim-1.d0)
          em=dexp(-utim)
          fbas_vec(2)=ep
          iodd=0
!
          do ibas=3,nbas1
            iodd=1-iodd
!
            if(iodd.eq.1) then
              fbas_vec(ibas)=fbas_vec(ibas-2)*em
            else
              fbas_vec(ibas)=fbas_vec(ibas-2)*ep
            endif
          enddo
        endif
        if(nbas2.le.0) return
!
        fbas_vec(nbas1+1)=2.d0*utim-1.d0
!
        if(nbas2.ge.2) then
!cc       pi2=8.d0*datan(1.d0)
          phi=pi2*utim
          cphi=dcos(phi)
          sphi=dsin(phi)
!
          fbas_vec(nbas1+2)=cphi
          fbas_vec(nbas1+3)=sphi
        endif
!
        if(nbas2.ge.4) then
          iodd=1
          do ibas=(nbas1+4),nbas
            iodd=1-iodd
            if( iodd.eq.0) then
              fbas_vec(ibas)=                                           &
     &         fbas_vec(ibas-2)*cphi                                    &
     &        -fbas_vec(ibas-1)*sphi
            else
              fbas_vec(ibas)=                                           &
     &         fbas_vec(ibas-2)*cphi                                    &
     &        +fbas_vec(ibas-3)*sphi
            endif
          enddo
        endif
      endif
!
!
      if(jbas.eq.10) then
        fbas_vec(1)=1.d0
        do ibas=2,nbas
          fbas_vec(ibas)=utim*fbas_vec(ibas-1)
        enddo
      endif
!
!
      if(jbas.eq.11) then
        fbas_vec(1)=1.d0
        do ibas=2,nbas
          fbas_vec(ibas)=(2.d0*utim-1.0d0)*fbas_vec(ibas-1)
        enddo
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine odeint_ark(                                            &
     &        vspec,xspec_i,xspec_f                                     &
     &       ,vfor,vbak,xspec_min,xspec_max                             &
     &       ,yspec_min_vs,yspec_max_vs                                 &
     &       ,wspec_vs_min,wspec_vs_max                                 &
     &       ,frlim_vs_min,frlim_vs_max                                 &
     &       ,rkfor,rkbak,rkfor2,rkbak2                                 &
     &       ,odtime_rl,jkin,jrlim,lvfor,lvbak,lvreac                   &
     &       ,iispec,iospec,nipart,nopart                               &
     &       ,hicoop,hocoop                                             &
     &       ,iispec_vs,iospec_vs,nipart_vs,nopart_vs                   &
     &       ,gimult_vs,gomult_vs,iivs_vs,iovs_vs                       &
     &       ,nspec,nreac,nfs_spec,nvs_spec,ispec_fs,ispec_vs           &
     &       ,jtevol,jfox,jfix,npulse,nperiod                           &
     &       ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod             &
     &       ,npmspec_x                                                 &
     &       ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x                &
!
     &       ,time_i_fs,time_i,time_f,eps,aln_hlo,aln_erx               &
     &       ,hini,hmin1,hmin2                                          &
     &       ,nlim_drv,n_drv,k_drv,k_oks,k_bad,k_sto                    &
     &       ,k_hlo,k_slo,k_stp                                         &
     &       ,dtime_sto,time_sto,xspec_sto                              &
     &       ,nstp_ark,nsto_ark,nsto_ark_x  )
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      implicit none
!
!
      integer jrlim,nspec,nreac,nfs_spec,nvs_spec,jtevol                &
     &       ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x                &
     &       ,npmspec_x
!
      integer ivs,ispec,ireac,ipart,jvfor,jvbak
!
      integer iispec(1:npart_x,1:nreac_x)                               &
     &       ,iospec(1:npart_x,1:nreac_x)                               &
     &       ,nipart(1:nreac_x)                                         &
     &       ,nopart(1:nreac_x)                                         &
     &       ,iispec_vs(1:npart_x,1:nreac_x)                            &
     &       ,iospec_vs(1:npart_x,1:nreac_x)                            &
     &       ,iivs_vs(1:npart_x,1:nreac_x)                              &
     &       ,iovs_vs(1:npart_x,1:nreac_x)                              &
     &       ,nipart_vs(1:nreac_x)                                      &
     &       ,nopart_vs(1:nreac_x)                                      &
     &       ,jkin(1:nreac_x)                                           &
     &       ,lvfor(1:nreac_x)                                          &
     &       ,lvbak(1:nreac_x)                                          &
     &       ,lvreac(1:nreac_x)                                         &
     &       ,ispec_fs(1:(nspec_x+nms_spec_x))                          &
     &       ,ispec_vs(1:(nspec_x+nms_spec_x))
!
      integer jfox(1:nspec_x)                                           &
     &       ,jfix(1:nspec_x)                                           &
     &       ,npulse(1:nspec_x)                                         &
     &       ,nperiod(1:nspec_x)
!
      real*8 odtime_rl                                                  &
     &       ,hicoop(1:npart_x,1:nreac_x)                               &
     &       ,hocoop(1:npart_x,1:nreac_x)                               &
     &       ,gimult_vs(1:npart_x,1:nreac_x)                            &
     &       ,gomult_vs(1:npart_x,1:nreac_x)
!
      real*8 vspec(1:(nspec_x+nms_spec_x))                              &
     &      ,xspec_i(1:(nspec_x+nms_spec_x),0:3)                        &
     &      ,xspec(1:(nspec_x+nms_spec_x))                              &
     &      ,xspec_min(1:nspec_x)                                       &
     &      ,xspec_max(1:nspec_x)                                       &
     &      ,yspec_min_vs(1:nspec_x)                                    &
     &      ,yspec_max_vs(1:nspec_x)                                    &
     &      ,frlim_vs_min(1:nspec_x)                                    &
     &      ,frlim_vs_max(1:nspec_x)                                    &
     &      ,wspec_vs_min(1:nspec_x)                                    &
     &      ,wspec_vs_max(1:nspec_x)                                    &
     &      ,vfor(1:nreac_x)                                            &
     &      ,vbak(1:nreac_x)                                            &
     &      ,rkfor(1:nreac_x)                                           &
     &      ,rkbak(1:nreac_x)                                           &
     &      ,rkfor2(1:nreac_x)                                          &
     &      ,rkbak2(1:nreac_x)
!
!
      INTEGER k_bad,k_oks,k_sto,k_hlo(1:2),k_slo,k_stp                  &
     &       ,nlim_drv,n_drv,k_drv                                      &
     &       ,nsto_ark_x,nstp_ark,jfin_time                             &
     &       ,nsto_ark,istp_ark,mstp_ark
!
      REAL*8                                                            &
     &       eps,hini,hmin,hmin1,hmin2,aln_hlo(1:2),aln_erx(1:2)        &
     &      ,h,hdid,hnext                                               &
     &      ,time_i_fs,time_i,time_f,time_xr,time_xsav,dtime_sto
!
      REAL*8 TINY
      PARAMETER (TINY=1.d-30)
!
      REAL*8                                                            &
     &       time_sto(0:nsto_ark_x)                                     &
     &      ,xspec_sto(1:(nspec_x+nms_spec_x),0:nsto_ark_x)             &
     &      ,xspec_f(1:(nspec_x+nms_spec_x))                            &
     &      ,yscal(1:(nspec_x+nms_spec_x))                              &
!
     &      ,tpulse(1:nspec_x,-2:npmspec_x)                             &
     &      ,cpulse(1:nspec_x,-2:npmspec_x)                             &
     &      ,dtpulse(1:nspec_x,0:npmspec_x)                             &
     &      ,spulse(1:nspec_x,-2:npmspec_x)                             &
     &      ,tperiod(1:nspec_x)                                         &
     &      ,otperiod(1:nspec_x)
!
!
      jfin_time=0
!
      time_xr=time_i
      h=dsign(hini,time_f-time_i)
      hmin=hmin1
!
      do 11 ispec=1,nspec
        xspec(ispec)=xspec_f(ispec)
   11 continue
!
      if(nsto_ark.gt.0) time_xsav=time_xr-2.d0*dtime_sto
!
!
      do 17 mstp_ark=1,2
        do 16 istp_ark=1,nstp_ark
!
          call drivs(time_xr,xspec,vspec                                &
!
     &              ,time_i_fs,xspec_i                                  &
     &              ,vfor,vbak,xspec_min,xspec_max                      &
     &              ,yspec_min_vs,yspec_max_vs                          &
     &              ,wspec_vs_min,wspec_vs_max                          &
     &              ,frlim_vs_min,frlim_vs_max                          &
     &              ,rkfor,rkbak,rkfor2,rkbak2                          &
     &              ,odtime_rl,jkin,jrlim                               &
     &              ,lvfor,lvbak,lvreac                                 &
     &              ,iispec,iospec,nipart,nopart                        &
     &              ,hicoop,hocoop                                      &
     &              ,iispec_vs,iospec_vs,nipart_vs,nopart_vs            &
     &              ,gimult_vs,gomult_vs,iivs_vs,iovs_vs                &
     &              ,nspec,nreac,nfs_spec,nvs_spec                      &
     &              ,ispec_fs,ispec_vs,nlim_drv,n_drv,k_drv             &
     &              ,jtevol,jfox,jfix,npulse,nperiod                    &
     &              ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod      &
     &              ,npmspec_x                                          &
     &              ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x)
!
!
          do 12 ivs=1,nvs_spec
            yscal(ispec_vs(ivs))=                                       &
     &      dabs(xspec(ispec_vs(ivs)))                                  &
     &      +dabs(h*vspec(ispec_vs(ivs)))+TINY
   12     continue
!
          if(nsto_ark.gt.0)then
            if(dabs(time_xr-time_xsav).gt.dabs(dtime_sto)) then
              if(k_sto.lt.nsto_ark-1)then
                k_sto=k_sto+1
                time_sto(k_sto)=time_xr
                do 13 ivs=1,nvs_spec
                  xspec_sto(ispec_vs(ivs),k_sto)=                       &
     &            xspec(ispec_vs(ivs))
   13           continue
                time_xsav=time_xr
              endif
            endif
          endif
!
          jfin_time=0
          if((time_xr+h-time_f)*(time_xr+h-time_i).gt.0.d0) then
            h=time_f-time_xr
            jfin_time=1
          endif
!
          k_stp=k_stp+1
!
          call rkqs(                                                    &
     &              time_xr,time_i_fs,time_i,xspec,vspec,xspec_i        &
     &             ,vfor,vbak,xspec_min,xspec_max                       &
     &             ,yspec_min_vs,yspec_max_vs                           &
     &             ,wspec_vs_min,wspec_vs_max                           &
     &             ,frlim_vs_min,frlim_vs_max                           &
     &             ,rkfor,rkbak,rkfor2,rkbak2                           &
     &             ,odtime_rl,jkin,jrlim                                &
     &             ,lvfor,lvbak,lvreac                                  &
     &             ,iispec,iospec,nipart,nopart                         &
     &             ,hicoop,hocoop                                       &
     &             ,iispec_vs,iospec_vs,nipart_vs,nopart_vs             &
     &             ,gimult_vs,gomult_vs,iivs_vs,iovs_vs                 &
     &             ,nspec,nreac,nfs_spec,nvs_spec                       &
     &             ,ispec_fs,ispec_vs,nlim_drv,n_drv,k_drv              &
     &             ,jtevol,jfox,jfix,npulse,nperiod                     &
     &             ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod       &
     &             ,npmspec_x                                           &
     &             ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x          &
!
     &             ,h,eps,aln_hlo(mstp_ark),aln_erx(mstp_ark)           &
     &             ,k_hlo(mstp_ark),yscal                               &
     &             ,hdid,hnext,hmin)
!
!
          if(hdid.eq.h)then
            k_oks=k_oks+1
          else
            k_bad=k_bad+1
          endif
!
          if(dabs(hnext).le.hmin) hnext=dsign(dabs(hmin),hnext)
!
          if((time_xr-time_f)*(time_xr-time_i).ge.0.d0.or.              &
     &    dabs(time_xr-time_f).lt.(1.d-3*hmin)) goto 9
!
          h=hnext
   16   continue
!
        if(jfin_time.eq.0) hmin=hmin2
        if(dabs(h).le.hmin)  h=dsign(dabs(hmin),h)
!
        k_slo=k_slo+1
   17 continue
!
    9 continue
      do 18 ivs=1,nvs_spec
        xspec_f(ispec_vs(ivs))=xspec(ispec_vs(ivs))
   18 continue
!
      if(nsto_ark.ne.0)then
        k_sto=k_sto+1
        time_sto(k_sto)=time_xr
!
        do 19 ivs=1,nvs_spec
          xspec_sto(ispec_vs(ivs),k_sto)=xspec(ispec_vs(ivs))
   19   continue
      endif
!
      hini=dabs(hnext)
      time_f=time_xr
!
!
      return
      END
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine rkqs(                                                  &
     &                  time_xr,time_i_fs,time_i,xspec,vspec,xspec_i    &
     &                 ,vfor,vbak,xspec_min,xspec_max                   &
     &                 ,yspec_min_vs,yspec_max_vs                       &
     &                 ,wspec_vs_min,wspec_vs_max                       &
     &                 ,frlim_vs_min,frlim_vs_max                       &
     &                 ,rkfor,rkbak,rkfor2,rkbak2                       &
     &                 ,odtime_rl,jkin,jrlim                            &
     &                 ,lvfor,lvbak,lvreac                              &
     &                 ,iispec,iospec,nipart,nopart                     &
     &                 ,hicoop,hocoop                                   &
     &                 ,iispec_vs,iospec_vs,nipart_vs,nopart_vs         &
     &                 ,gimult_vs,gomult_vs,iivs_vs,iovs_vs             &
     &                 ,nspec,nreac,nfs_spec,nvs_spec                   &
     &                 ,ispec_fs,ispec_vs,nlim_drv,n_drv,k_drv          &
     &                 ,jtevol,jfox,jfix,npulse,nperiod                 &
     &                 ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod   &
     &                 ,npmspec_x                                       &
     &                 ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x      &
!
     &                 ,htry,eps,aln_hlo,aln_erx                        &
     &                 ,k_hlo,yscal                                     &
     &                 ,hdid,hnext,hmin)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
!
      implicit none
!
!
      integer jrlim,nspec,nreac,nfs_spec,nvs_spec,jtevol                &
     &       ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x                &
     &       ,npmspec_x
!
      integer ivs,ispec,ireac,ipart,jvfor,jvbak
!
      integer iispec(1:npart_x,1:nreac_x)                               &
     &       ,iospec(1:npart_x,1:nreac_x)                               &
     &       ,nipart(1:nreac_x)                                         &
     &       ,nopart(1:nreac_x)                                         &
     &       ,iispec_vs(1:npart_x,1:nreac_x)                            &
     &       ,iospec_vs(1:npart_x,1:nreac_x)                            &
     &       ,iivs_vs(1:npart_x,1:nreac_x)                              &
     &       ,iovs_vs(1:npart_x,1:nreac_x)                              &
     &       ,nipart_vs(1:nreac_x)                                      &
     &       ,nopart_vs(1:nreac_x)                                      &
     &       ,jkin(1:nreac_x)                                           &
     &       ,lvfor(1:nreac_x)                                          &
     &       ,lvbak(1:nreac_x)                                          &
     &       ,lvreac(1:nreac_x)                                         &
     &       ,ispec_fs(1:(nspec_x+nms_spec_x))                          &
     &       ,ispec_vs(1:(nspec_x+nms_spec_x))
!
      integer jfox(1:nspec_x)                                           &
     &       ,jfix(1:nspec_x)                                           &
     &       ,npulse(1:nspec_x)                                         &
     &       ,nperiod(1:nspec_x)
!
      real*8 odtime_rl                                                  &
     &       ,hicoop(1:npart_x,1:nreac_x)                               &
     &       ,hocoop(1:npart_x,1:nreac_x)                               &
     &       ,gimult_vs(1:npart_x,1:nreac_x)                            &
     &       ,gomult_vs(1:npart_x,1:nreac_x)
!
      real*8 vspec(1:(nspec_x+nms_spec_x))                              &
     &      ,xspec_i(1:(nspec_x+nms_spec_x),0:3)                        &
     &      ,xspec(1:(nspec_x+nms_spec_x))                              &
     &      ,xspec_min(1:nspec_x)                                       &
     &      ,xspec_max(1:nspec_x)                                       &
     &      ,yspec_min_vs(1:nspec_x)                                    &
     &      ,yspec_max_vs(1:nspec_x)                                    &
     &      ,frlim_vs_min(1:nspec_x)                                    &
     &      ,frlim_vs_max(1:nspec_x)                                    &
     &      ,wspec_vs_min(1:nspec_x)                                    &
     &      ,wspec_vs_max(1:nspec_x)                                    &
     &      ,vfor(1:nreac_x)                                            &
     &      ,vbak(1:nreac_x)                                            &
     &      ,rkfor(1:nreac_x)                                           &
     &      ,rkbak(1:nreac_x)                                           &
     &      ,rkfor2(1:nreac_x)                                          &
     &      ,rkbak2(1:nreac_x)
!
!
      INTEGER nlim_drv,n_drv,k_drv,k_hlo
!
      REAL*8 eps,hdid,hnext,htry,hmin,time_xr,time_i_fs,time_i          &
     &      ,errmax,h,htemp,time_xnew,aln_hlo,aln_erx
!
      REAL*8                                                            &
     &       yerr(1:(nspec_x+nms_spec_x))                               &
     &      ,ytemp(1:(nspec_x+nms_spec_x))                              &
     &      ,yscal(1:(nspec_x+nms_spec_x))                              &
!
     &      ,tpulse(1:nspec_x,-2:npmspec_x)                             &
     &      ,cpulse(1:nspec_x,-2:npmspec_x)                             &
     &      ,dtpulse(1:nspec_x,0:npmspec_x)                             &
     &      ,spulse(1:nspec_x,-2:npmspec_x)                             &
     &      ,tperiod(1:nspec_x)                                         &
     &      ,otperiod(1:nspec_x)
!
      REAL*8                                                            &
     &       SAFETY,PGROW,PSHRNK,ERRCON
      PARAMETER (SAFETY=0.9d0,PGROW=-0.2d0                              &
     &          ,PSHRNK=-0.25d0,ERRCON=1.89d-4)
!
!
      h=htry
!
    1 continue
!
      call rkck(                                                        &
     &          time_xr,time_i_fs,time_i,xspec,vspec,xspec_i            &
     &         ,vfor,vbak,xspec_min,xspec_max                           &
     &         ,yspec_min_vs,yspec_max_vs                               &
     &         ,wspec_vs_min,wspec_vs_max                               &
     &         ,frlim_vs_min,frlim_vs_max                               &
     &         ,rkfor,rkbak,rkfor2,rkbak2                               &
     &         ,odtime_rl,jkin,jrlim                                    &
     &         ,lvfor,lvbak,lvreac                                      &
     &         ,iispec,iospec,nipart,nopart                             &
     &         ,hicoop,hocoop                                           &
     &         ,iispec_vs,iospec_vs,nipart_vs,nopart_vs                 &
     &         ,gimult_vs,gomult_vs,iivs_vs,iovs_vs                     &
     &         ,nspec,nreac,nfs_spec,nvs_spec                           &
     &         ,ispec_fs,ispec_vs,nlim_drv,n_drv,k_drv                  &
     &         ,jtevol,jfox,jfix,npulse,nperiod                         &
     &         ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod           &
     &         ,npmspec_x                                               &
     &         ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x              &
!
     &         ,h,ytemp,yerr)
!
!
      errmax=0.d0
      do 11 ivs=1,nvs_spec
        errmax=dmax1(errmax                                             &
     &              ,dabs(yerr(ispec_vs(ivs))                           &
     &                   /yscal(ispec_vs(ivs)))                         &
     &              )
   11 continue
      errmax=errmax/eps
!
      if(dabs(h).le.(1.000001d0*dabs(hmin))) then
        hnext=h
!
        if(errmax.gt.1.d0) then
          htemp=dabs(SAFETY*h*(errmax**PSHRNK))
          if(htemp.le.hmin) then
            aln_hlo=aln_hlo+dlog(hmin/htemp)
            aln_erx=aln_erx+dlog(errmax)
            k_hlo=k_hlo+1
          endif
        endif
!
        goto 2
      endif
!
      if(errmax.gt.1.d0) then
        htemp=SAFETY*h*(errmax**PSHRNK)
        h=dsign(dmax1(dabs(htemp),0.1d0*dabs(h)),h)
        if(dabs(h).le.hmin) then
          h=dsign(hmin,h)
        endif
!
        goto 1
      endif
!
    2 continue
      if(errmax.le.1.d0) then
        if(errmax.gt.ERRCON) then
          hnext=SAFETY*h*(errmax**PGROW)
        else
          hnext=5.d0*h
        endif
      endif
!
      hdid=h
      time_xr=time_xr+h
!
      do 12 ivs=1,nvs_spec
        xspec(ispec_vs(ivs))=ytemp(ispec_vs(ivs))
   12 continue
!
!
      return
      END
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine rkck(                                                  &
     &                  time_xr,time_i_fs,time_i,xspec,vspec,xspec_i    &
     &                 ,vfor,vbak,xspec_min,xspec_max                   &
     &                 ,yspec_min_vs,yspec_max_vs                       &
     &                 ,wspec_vs_min,wspec_vs_max                       &
     &                 ,frlim_vs_min,frlim_vs_max                       &
     &                 ,rkfor,rkbak,rkfor2,rkbak2                       &
     &                 ,odtime_rl,jkin,jrlim                            &
     &                 ,lvfor,lvbak,lvreac                              &
     &                 ,iispec,iospec,nipart,nopart                     &
     &                 ,hicoop,hocoop                                   &
     &                 ,iispec_vs,iospec_vs,nipart_vs,nopart_vs         &
     &                 ,gimult_vs,gomult_vs,iivs_vs,iovs_vs             &
     &                 ,nspec,nreac,nfs_spec,nvs_spec                   &
     &                 ,ispec_fs,ispec_vs,nlim_drv,n_drv,k_drv          &
     &                 ,jtevol,jfox,jfix,npulse,nperiod                 &
     &                 ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod   &
     &                 ,npmspec_x                                       &
     &                 ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x      &
!
     &                 ,h,yout,yerr)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      implicit none
!
      integer jrlim,nspec,nreac,nfs_spec,nvs_spec,jtevol                &
     &       ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x                &
     &       ,npmspec_x
!
      integer ivs,ispec,ireac,ipart,jvfor,jvbak
!
      integer iispec(1:npart_x,1:nreac_x)                               &
     &       ,iospec(1:npart_x,1:nreac_x)                               &
     &       ,nipart(1:nreac_x)                                         &
     &       ,nopart(1:nreac_x)                                         &
     &       ,iispec_vs(1:npart_x,1:nreac_x)                            &
     &       ,iospec_vs(1:npart_x,1:nreac_x)                            &
     &       ,iivs_vs(1:npart_x,1:nreac_x)                              &
     &       ,iovs_vs(1:npart_x,1:nreac_x)                              &
     &       ,nipart_vs(1:nreac_x)                                      &
     &       ,nopart_vs(1:nreac_x)                                      &
     &       ,jkin(1:nreac_x)                                           &
     &       ,lvfor(1:nreac_x)                                          &
     &       ,lvbak(1:nreac_x)                                          &
     &       ,lvreac(1:nreac_x)                                         &
     &       ,ispec_fs(1:(nspec_x+nms_spec_x))                          &
     &       ,ispec_vs(1:(nspec_x+nms_spec_x))
!
      integer jfox(1:nspec_x)                                           &
     &       ,jfix(1:nspec_x)                                           &
     &       ,npulse(1:nspec_x)                                         &
     &       ,nperiod(1:nspec_x)
!
      real*8 odtime_rl                                                  &
     &       ,hicoop(1:npart_x,1:nreac_x)                               &
     &       ,hocoop(1:npart_x,1:nreac_x)                               &
     &       ,gimult_vs(1:npart_x,1:nreac_x)                            &
     &       ,gomult_vs(1:npart_x,1:nreac_x)
!
      real*8 vspec(1:(nspec_x+nms_spec_x))                              &
     &      ,xspec_i(1:(nspec_x+nms_spec_x),0:3)                        &
     &      ,xspec(1:(nspec_x+nms_spec_x))                              &
     &      ,xspec_min(1:nspec_x)                                       &
     &      ,xspec_max(1:nspec_x)                                       &
     &      ,yspec_min_vs(1:nspec_x)                                    &
     &      ,yspec_max_vs(1:nspec_x)                                    &
     &      ,frlim_vs_min(1:nspec_x)                                    &
     &      ,frlim_vs_max(1:nspec_x)                                    &
     &      ,wspec_vs_min(1:nspec_x)                                    &
     &      ,wspec_vs_max(1:nspec_x)                                    &
     &      ,vfor(1:nreac_x)                                            &
     &      ,vbak(1:nreac_x)                                            &
     &      ,rkfor(1:nreac_x)                                           &
     &      ,rkbak(1:nreac_x)                                           &
     &      ,rkfor2(1:nreac_x)                                          &
     &      ,rkbak2(1:nreac_x)
!
      real*8 tpulse(1:nspec_x,-2:npmspec_x)                             &
     &      ,cpulse(1:nspec_x,-2:npmspec_x)                             &
     &      ,dtpulse(1:nspec_x,0:npmspec_x)                             &
     &      ,spulse(1:nspec_x,-2:npmspec_x)                             &
     &      ,tperiod(1:nspec_x)                                         &
     &      ,otperiod(1:nspec_x)
!
      INTEGER nlim_drv,n_drv,k_drv
!
      REAL*8 h,time_xh,time_xr,time_i_fs,time_i
!
      REAL*8 ak2(1:(nspec_x+nms_spec_x))                                &
     &      ,ak3(1:(nspec_x+nms_spec_x))                                &
     &      ,ak4(1:(nspec_x+nms_spec_x))                                &
     &      ,ak5(1:(nspec_x+nms_spec_x))                                &
     &      ,ak6(1:(nspec_x+nms_spec_x))                                &
     &      ,ytemp(1:(nspec_x+nms_spec_x))                              &
     &      ,yerr(1:(nspec_x+nms_spec_x))                               &
     &      ,yout(1:(nspec_x+nms_spec_x))
!
      REAL*8                                                            &
     &       A2,A3,A4,A5,A6                                             &
     &      ,B21                                                        &
     &      ,B31,B32                                                    &
     &      ,B41,B42,B43                                                &
     &      ,B51,B52,B53,B54                                            &
     &      ,B61,B62,B63,B64,B65                                        &
     &      ,C1,C3,C4,C6                                                &
     &      ,DC1,DC3,DC4,DC5,DC6
!
      common /rkck01/                                                   &
     &       A2,A3,A4,A5,A6                                             &
     &      ,B21                                                        &
     &      ,B31,B32                                                    &
     &      ,B41,B42,B43                                                &
     &      ,B51,B52,B53,B54                                            &
     &      ,B61,B62,B63,B64,B65                                        &
     &      ,C1,C3,C4,C6                                                &
     &      ,DC1,DC3,DC4,DC5,DC6
!
!
!c      PARAMETER (
!c     1            A2=.2d0
!c     1          , A3=.3d0
!c     1          , A4=.6d0
!c     1          , A5=1.d0
!c     1          , A6=.875d0
!c     1          )
!c      PARAMETER (
!c     *            B21=.2d0
!c     1          , B31=3.d0/40.0d0
!c     1          , B32=9.d0/40.0d0
!c     1          , B41=.3d0
!c     1          , B42=-.9d0
!c     1          , B43=1.2d0
!c     1          , B51=-11.d0/54.d0
!c     1          , B52=2.5d0
!c     1          , B53=-70.d0/27.d0
!c     1          , B54=35.d0/27.d0
!c     1          , B61=1631.d0/55296.d0
!c     1          , B62=175.d0/512.d0
!c     1          , B63=575.d0/13824.d0
!c     1          , B64=44275.d0/110592.d0
!c     1          , B65=253.d0/4096.d0
!c     1          )
!c      PARAMETER (
!c     *            C1=37.d0/378.d0
!c     1          , C3=250.d0/621.d0
!c     1          , C4=125.d0/594.d0
!c     *          , C6=512.d0/1771.d0
!c     1          )
!c      PARAMETER (
!c     *            DC1=C1-2825.d0/27648.d0
!c     *          , DC3=C3-18575.d0/48384.d0
!c     1          , DC4=C4-13525.d0/55296.d0
!c     *          , DC5=-277.d0/14336.d0
!c     1          , DC6=C6-.25d0
!ccc     *          )
!c
!c                A2=.2d0
!c                A3=.3d0
!c                A4=.6d0
!c                A5=1.d0
!c                A6=.875d0
!c                B21=.2d0
!c                B31=3.d0/40.0d0
!c                B32=9.d0/40.0d0
!c                B41=.3d0
!c                B42=-.9d0
!c                B43=1.2d0
!c                B51=-11.d0/54.d0
!c                B52=2.5d0
!c                B53=-70.d0/27.d0
!c                B54=35.d0/27.d0
!c                B61=1631.d0/55296.d0
!c                B62=175.d0/512.d0
!c                B63=575.d0/13824.d0
!c                B64=44275.d0/110592.d0
!c                B65=253.d0/4096.d0
!c                C1=37.d0/378.d0
!c                C3=250.d0/621.d0
!c                C4=125.d0/594.d0
!c                C6=512.d0/1771.d0
!c                DC1=C1-2825.d0/27648.d0
!c                DC3=C3-18575.d0/48384.d0
!c                DC4=C4-13525.d0/55296.d0
!c                DC5=-277.d0/14336.d0
!c                DC6=C6-.25d0
!c
!
!
      do 11 ivs=1,nvs_spec
        ytemp(ispec_vs(ivs))=xspec(ispec_vs(ivs))                       &
     &  +B21*h*vspec(ispec_vs(ivs))
   11 continue
!
      time_xh=time_xr+A2*h
      call drivs(time_xh,ytemp,ak2                                      &
!
     &              ,time_i_fs,xspec_i                                  &
     &              ,vfor,vbak,xspec_min,xspec_max                      &
     &              ,yspec_min_vs,yspec_max_vs                          &
     &              ,wspec_vs_min,wspec_vs_max                          &
     &              ,frlim_vs_min,frlim_vs_max                          &
     &              ,rkfor,rkbak,rkfor2,rkbak2                          &
     &              ,odtime_rl,jkin,jrlim                               &
     &              ,lvfor,lvbak,lvreac                                 &
     &              ,iispec,iospec,nipart,nopart                        &
     &              ,hicoop,hocoop                                      &
     &              ,iispec_vs,iospec_vs,nipart_vs,nopart_vs            &
     &              ,gimult_vs,gomult_vs,iivs_vs,iovs_vs                &
     &              ,nspec,nreac,nfs_spec,nvs_spec                      &
     &              ,ispec_fs,ispec_vs,nlim_drv,n_drv,k_drv             &
     &              ,jtevol,jfox,jfix,npulse,nperiod                    &
     &              ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod      &
     &              ,npmspec_x                                          &
     &              ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x)
!
!
      do 12 ivs=1,nvs_spec
        ytemp(ispec_vs(ivs))=xspec(ispec_vs(ivs))                       &
     &  +h*(B31*vspec(ispec_vs(ivs))+B32*ak2(ispec_vs(ivs)))
   12 continue
!
      time_xh=time_xr+A3*h
      call drivs(time_xh,ytemp,ak3                                      &
!
     &              ,time_i_fs,xspec_i                                  &
     &              ,vfor,vbak,xspec_min,xspec_max                      &
     &              ,yspec_min_vs,yspec_max_vs                          &
     &              ,wspec_vs_min,wspec_vs_max                          &
     &              ,frlim_vs_min,frlim_vs_max                          &
     &              ,rkfor,rkbak,rkfor2,rkbak2                          &
     &              ,odtime_rl,jkin,jrlim                               &
     &              ,lvfor,lvbak,lvreac                                 &
     &              ,iispec,iospec,nipart,nopart                        &
     &              ,hicoop,hocoop                                      &
     &              ,iispec_vs,iospec_vs,nipart_vs,nopart_vs            &
     &              ,gimult_vs,gomult_vs,iivs_vs,iovs_vs                &
     &              ,nspec,nreac,nfs_spec,nvs_spec                      &
     &              ,ispec_fs,ispec_vs,nlim_drv,n_drv,k_drv             &
     &              ,jtevol,jfox,jfix,npulse,nperiod                    &
     &              ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod      &
     &              ,npmspec_x                                          &
     &              ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x)
!
      do 13 ivs=1,nvs_spec
        ytemp(ispec_vs(ivs))=xspec(ispec_vs(ivs))                       &
     &  +h*(B41*vspec(ispec_vs(ivs))                                    &
     &     +B42*ak2(ispec_vs(ivs))                                      &
     &     +B43*ak3(ispec_vs(ivs)))
   13 continue
!
      time_xh=time_xr+A4*h
      call drivs(time_xh,ytemp,ak4                                      &
!
     &              ,time_i_fs,xspec_i                                  &
     &              ,vfor,vbak,xspec_min,xspec_max                      &
     &              ,yspec_min_vs,yspec_max_vs                          &
     &              ,wspec_vs_min,wspec_vs_max                          &
     &              ,frlim_vs_min,frlim_vs_max                          &
     &              ,rkfor,rkbak,rkfor2,rkbak2                          &
     &              ,odtime_rl,jkin,jrlim                               &
     &              ,lvfor,lvbak,lvreac                                 &
     &              ,iispec,iospec,nipart,nopart                        &
     &              ,hicoop,hocoop                                      &
     &              ,iispec_vs,iospec_vs,nipart_vs,nopart_vs            &
     &              ,gimult_vs,gomult_vs,iivs_vs,iovs_vs                &
     &              ,nspec,nreac,nfs_spec,nvs_spec                      &
     &              ,ispec_fs,ispec_vs,nlim_drv,n_drv,k_drv             &
     &              ,jtevol,jfox,jfix,npulse,nperiod                    &
     &              ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod      &
     &              ,npmspec_x                                          &
     &              ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x)
!
!
      do 14 ivs=1,nvs_spec
        ytemp(ispec_vs(ivs))=xspec(ispec_vs(ivs))                       &
     &  +h*(B51*vspec(ispec_vs(ivs))                                    &
     &     +B52*ak2(ispec_vs(ivs))                                      &
     &     +B53*ak3(ispec_vs(ivs))                                      &
     &     +B54*ak4(ispec_vs(ivs)))
   14 continue
!
      time_xh=time_xr+A5*h
      call drivs(time_xh,ytemp,ak5                                      &
!
     &              ,time_i_fs,xspec_i                                  &
     &              ,vfor,vbak,xspec_min,xspec_max                      &
     &              ,yspec_min_vs,yspec_max_vs                          &
     &              ,wspec_vs_min,wspec_vs_max                          &
     &              ,frlim_vs_min,frlim_vs_max                          &
     &              ,rkfor,rkbak,rkfor2,rkbak2                          &
     &              ,odtime_rl,jkin,jrlim                               &
     &              ,lvfor,lvbak,lvreac                                 &
     &              ,iispec,iospec,nipart,nopart                        &
     &              ,hicoop,hocoop                                      &
     &              ,iispec_vs,iospec_vs,nipart_vs,nopart_vs            &
     &              ,gimult_vs,gomult_vs,iivs_vs,iovs_vs                &
     &              ,nspec,nreac,nfs_spec,nvs_spec                      &
     &              ,ispec_fs,ispec_vs,nlim_drv,n_drv,k_drv             &
     &              ,jtevol,jfox,jfix,npulse,nperiod                    &
     &              ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod      &
     &              ,npmspec_x                                          &
     &              ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x)
!
!
      do 15 ivs=1,nvs_spec
        ytemp(ispec_vs(ivs))=xspec(ispec_vs(ivs))                       &
     &  +h*(B61*vspec(ispec_vs(ivs))                                    &
     &     +B62*ak2(ispec_vs(ivs))                                      &
     &     +B63*ak3(ispec_vs(ivs))                                      &
     &     +B64*ak4(ispec_vs(ivs))                                      &
     &     +B65*ak5(ispec_vs(ivs)))
   15 continue
!
      time_xh=time_xr+A6*h
      call drivs(time_xh,ytemp,ak6                                      &
!
     &              ,time_i_fs,xspec_i                                  &
     &              ,vfor,vbak,xspec_min,xspec_max                      &
     &              ,yspec_min_vs,yspec_max_vs                          &
     &              ,wspec_vs_min,wspec_vs_max                          &
     &              ,frlim_vs_min,frlim_vs_max                          &
     &              ,rkfor,rkbak,rkfor2,rkbak2                          &
     &              ,odtime_rl,jkin,jrlim                               &
     &              ,lvfor,lvbak,lvreac                                 &
     &              ,iispec,iospec,nipart,nopart                        &
     &              ,hicoop,hocoop                                      &
     &              ,iispec_vs,iospec_vs,nipart_vs,nopart_vs            &
     &              ,gimult_vs,gomult_vs,iivs_vs,iovs_vs                &
     &              ,nspec,nreac,nfs_spec,nvs_spec                      &
     &              ,ispec_fs,ispec_vs,nlim_drv,n_drv,k_drv             &
     &              ,jtevol,jfox,jfix,npulse,nperiod                    &
     &              ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod      &
     &              ,npmspec_x                                          &
     &              ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x)
!
!
      do 16 ivs=1,nvs_spec
        yout(ispec_vs(ivs))=xspec(ispec_vs(ivs))                        &
     &  +h*(C1*vspec(ispec_vs(ivs))                                     &
     &     +C3*ak3(ispec_vs(ivs))                                       &
     &     +C4*ak4(ispec_vs(ivs))                                       &
     &     +C6*ak6(ispec_vs(ivs)))
   16 continue
!
      do 17 ivs=1,nvs_spec
        yerr(ispec_vs(ivs))=                                            &
     &  h*(DC1*vspec(ispec_vs(ivs))                                     &
     &    +DC3*ak3(ispec_vs(ivs))                                       &
     &    +DC4*ak4(ispec_vs(ivs))                                       &
     &    +DC5*ak5(ispec_vs(ivs))                                       &
     &    +DC6*ak6(ispec_vs(ivs)))
   17 continue
!
!
      return
      END
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine set_ark_ck
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      implicit none
!
! initialize "Cash-Karp" adaptive Runge-Kutta coefficients
!
!
      REAL*8                                                            &
     &       A2,A3,A4,A5,A6                                             &
     &      ,B21                                                        &
     &      ,B31,B32                                                    &
     &      ,B41,B42,B43                                                &
     &      ,B51,B52,B53,B54                                            &
     &      ,B61,B62,B63,B64,B65                                        &
     &      ,C1,C3,C4,C6                                                &
     &      ,DC1,DC3,DC4,DC5,DC6
!
      common /rkck01/                                                   &
     &       A2,A3,A4,A5,A6                                             &
     &      ,B21                                                        &
     &      ,B31,B32                                                    &
     &      ,B41,B42,B43                                                &
     &      ,B51,B52,B53,B54                                            &
     &      ,B61,B62,B63,B64,B65                                        &
     &      ,C1,C3,C4,C6                                                &
     &      ,DC1,DC3,DC4,DC5,DC6
!
!c
                  A2=.2d0
                  A3=.3d0
                  A4=.6d0
                  A5=1.d0
                  A6=.875d0
                  B21=.2d0
                  B31=3.d0/40.0d0
                  B32=9.d0/40.0d0
                  B41=.3d0
                  B42=-.9d0
                  B43=1.2d0
                  B51=-11.d0/54.d0
                  B52=2.5d0
                  B53=-70.d0/27.d0
                  B54=35.d0/27.d0
                  B61=1631.d0/55296.d0
                  B62=175.d0/512.d0
                  B63=575.d0/13824.d0
                  B64=44275.d0/110592.d0
                  B65=253.d0/4096.d0
                  C1=37.d0/378.d0
                  C3=250.d0/621.d0
                  C4=125.d0/594.d0
                  C6=512.d0/1771.d0
                  DC1=C1-2825.d0/27648.d0
                  DC3=C3-18575.d0/48384.d0
                  DC4=C4-13525.d0/55296.d0
                  DC5=-277.d0/14336.d0
                  DC6=C6-.25d0
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine four1(data,nn,isign)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      integer nn, isign
!
      real*8 WR,WI,WPR,WPI,WTEMP,THETA                                  &
     &,      TEMPR, TEMPI                                               &
     &,      DATA(*)
!
      N=2*NN
      J=1
      DO 11 I=1,N,2
        IF(J.GT.I)THEN
          TEMPR=DATA(J)
          TEMPI=DATA(J+1)
          DATA(J)=DATA(I)
          DATA(J+1)=DATA(I+1)
          DATA(I)=TEMPR
          DATA(I+1)=TEMPI
        ENDIF
        M=N/2
    1   IF ((M.GE.2).AND.(J.GT.M)) THEN
          J=J-M
          M=M/2
        GO TO 1
        ENDIF
        J=J+M
   11 CONTINUE
      MMAX=2
    2 IF (N.GT.MMAX) THEN
        ISTEP=2*MMAX
        THETA=6.28318530717959D0/(ISIGN*MMAX)
        WPR=-2.D0*DSIN(0.5D0*THETA)**2
        WPI=DSIN(THETA)
        WR=1.D0
        WI=0.D0
        DO 13 M=1,MMAX,2
          DO 12 I=M,N,ISTEP
            J=I+MMAX
            TEMPR=WR*DATA(J)-WI*DATA(J+1)
            TEMPI=WR*DATA(J+1)+WI*DATA(J)
            DATA(J)=DATA(I)-TEMPR
            DATA(J+1)=DATA(I+1)-TEMPI
            DATA(I)=DATA(I)+TEMPR
            DATA(I+1)=DATA(I+1)+TEMPI
   12     CONTINUE
          WTEMP=WR
          WR=WR*WPR-WI*WPI+WR
          WI=WI*WPR+WTEMP*WPI+WI
   13   CONTINUE
        MMAX=ISTEP
      GO TO 2
      ENDIF
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine fourn(data,nn,ndim,isign)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      integer isign, ndim
!
      real*8 WR,WI,WPR,WPI,WTEMP,THETA                                  &
     &,      TEMPR, TEMPI                                               &
     &,      DATA(*)
!
      INTEGER NN(NDIM)
!
      NTOT=1
      DO 11 IDIM=1,NDIM
        NTOT=NTOT*NN(IDIM)
   11 CONTINUE
      NPREV=1
      DO 18 IDIM=1,NDIM
        N=NN(IDIM)
        NREM=NTOT/(N*NPREV)
        IP1=2*NPREV
        IP2=IP1*N
        IP3=IP2*NREM
        I2REV=1
        DO 14 I2=1,IP2,IP1
          IF(I2.LT.I2REV)THEN
            DO 13 I1=I2,I2+IP1-2,2
              DO 12 I3=I1,IP3,IP2
                I3REV=I2REV+I3-I2
                TEMPR=DATA(I3)
                TEMPI=DATA(I3+1)
                DATA(I3)=DATA(I3REV)
                DATA(I3+1)=DATA(I3REV+1)
                DATA(I3REV)=TEMPR
                DATA(I3REV+1)=TEMPI
   12         CONTINUE
   13       CONTINUE
          ENDIF
          IBIT=IP2/2
    1     IF ((IBIT.GE.IP1).AND.(I2REV.GT.IBIT)) THEN
            I2REV=I2REV-IBIT
            IBIT=IBIT/2
          GO TO 1
          ENDIF
          I2REV=I2REV+IBIT
   14   CONTINUE
        IFP1=IP1
    2   IF(IFP1.LT.IP2)THEN
          IFP2=2*IFP1
          THETA=ISIGN*6.28318530717959D0/(IFP2/IP1)
          WPR=-2.D0*DSIN(0.5D0*THETA)**2
          WPI=DSIN(THETA)
          WR=1.D0
          WI=0.D0
          DO 17 I3=1,IFP1,IP1
            DO 16 I1=I3,I3+IP1-2,2
              DO 15 I2=I1,IP3,IFP2
                K1=I2
                K2=K1+IFP1
                TEMPR=WR*DATA(K2)-WI*DATA(K2+1)
                TEMPI=WR*DATA(K2+1)+WI*DATA(K2)
                DATA(K2)=DATA(K1)-TEMPR
                DATA(K2+1)=DATA(K1+1)-TEMPI
                DATA(K1)=DATA(K1)+TEMPR
                DATA(K1+1)=DATA(K1+1)+TEMPI
   15         CONTINUE
   16       CONTINUE
            WTEMP=WR
            WR=WR*WPR-WI*WPI+WR
            WI=WI*WPR+WTEMP*WPI+WI
   17     CONTINUE
          IFP1=IFP2
        GO TO 2
        ENDIF
        NPREV=N*NPREV
   18 CONTINUE
!
!
      return
      END
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      function dexxp(yy,yymin,yymax)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      implicit none
!
      real*8 yy, yymin, yymax, dexxp, dexp
!
!
      if(yy.le.yymin) then
        dexxp=dexp(yymin)
        return
      endif
!
      if(yy.ge.yymax) then
        dexxp=dexp(yymax)
        return
      endif
!
      dexxp=dexp(yy)
!
!
      return
      END
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      function dloyy(xx,xxmin)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      implicit none
!
      real*8 xx, xxmin, dloyy, dlog
!
!
      dloyy=dabs(xx)+1.d-8*dabs(xxmin)
      dloyy=dlog(dloyy)
!
!
      return
      end
!
!
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! EISPACK real symmetric e-value and e-vector solver
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ev_rs(nm,n,a,w,matz,z,fv1,fv2,ierr)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
!
      integer n,nm,ierr,matz
      real*8 a(nm,n),w(n),z(nm,n),fv1(n),fv2(n)
!
!     this subroutine calls the recommended sequence of
!     subroutines from the eigensystem subroutine package (eispack)
!     to find the eigenvalues and eigenvectors (if desired)
!     of a real symmetric matrix.
!
!     on input
!
!        nm  must be set to the row dimension of the two-dimensional
!        array parameters as declared in the calling program
!        dimension statement.
!
!        n  is the order of the matrix  a.
!
!        a  contains the real symmetric matrix.
!
!        matz  is an integer variable set equal to zero if
!        only eigenvalues are desired.  otherwise it is set to
!        any non-zero integer for both eigenvalues and eigenvectors.
!
!     on output
!
!        w  contains the eigenvalues in ascending order.
!
!        z  contains the eigenvectors if matz is not zero.
!
!        ierr  is an integer output variable set equal to an error
!           completion code described in the documentation for tqlrat
!           and tql2.  the normal completion code is zero.
!
!        fv1  and  fv2  are temporary storage arrays.
!
!     questions and comments should be directed to burton s. garbow,
!     mathematics and computer science div, argonne national laboratory
!
!     this version dated august 1983.
!
!     ------------------------------------------------------------------
!
      if (n .le. nm) go to 10
      ierr = 10 * n
      go to 50
!
   10 continue
      if (matz .ne. 0) go to 20
!     .......... find eigenvalues only ..........
      call  tred1(nm,n,a,w,fv1,fv2)
!! tqlrat encounters catastrophic underflow on the Vax
!!    call  tqlrat(n,w,fv2,ierr)
      call  tql1(n,w,fv1,ierr)
      go to 50
!     .......... find both eigenvalues and eigenvectors ..........
   20 continue
      call  tred2(nm,n,a,w,fv1,z)
      call  tql2(nm,n,w,fv1,z,ierr)
   50 continue
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine tql1(n,d,e,ierr)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
!
      integer i,j,l,m,n,ii,l1,l2,mml,ierr
      real*8 d(n),e(n)
      real*8 c,c2,c3,dl1,el1,f,g,h,p,r,s,s2,tst1,tst2,pythag_rs
!
!     this subroutine is a translation of the algol procedure tql1,
!     num. math. 11, 293-306(1968) by bowdler, martin, reinsch, and
!     wilkinson.
!     handbook for auto. comp., vol.ii-linear algebra, 227-240(1971).
!
!     this subroutine finds the eigenvalues of a symmetric
!     tridiagonal matrix by the ql method.
!
!     on input
!
!        n is the order of the matrix.
!
!        d contains the diagonal elements of the input matrix.
!
!        e contains the subdiagonal elements of the input matrix
!          in its last n-1 positions.  e(1) is arbitrary.
!
!      on output
!
!        d contains the eigenvalues in ascending order.  if an
!          error exit is made, the eigenvalues are correct and
!          ordered for indices 1,2,...ierr-1, but may not be
!          the smallest eigenvalues.
!
!        e has been destroyed.
!
!        ierr is set to
!          zero       for normal return,
!          j          if the j-th eigenvalue has not been
!                     determined after 30 iterations.
!
!     calls pythag_rs for  dsqrt(a*a + b*b) .
!
!     questions and comments should be directed to burton s. garbow,
!     mathematics and computer science div, argonne national laboratory
!
!     this version dated august 1983.
!
!     ------------------------------------------------------------------
!
      ierr = 0
      if (n .eq. 1) go to 1001
!
      do 100 i = 2, n
      e(i-1) = e(i)
  100 continue
!
      f = 0.0d0
      tst1 = 0.0d0
      e(n) = 0.0d0
!
      do 290 l = 1, n
         j = 0
         h = dabs(d(l)) + dabs(e(l))
         if (tst1 .lt. h) tst1 = h
!     .......... look for small sub-diagonal element ..........
         do 110 m = l, n
            tst2 = tst1 + dabs(e(m))
            if (tst2 .eq. tst1) go to 120
!     .......... e(n) is always zero, so there is no exit
!                through the bottom of the loop ..........
  110    continue
!
  120    continue
         if (m .eq. l) go to 210
  130    continue
         if (j .eq. 30) go to 1000
         j = j + 1
!     .......... form shift ..........
         l1 = l + 1
         l2 = l1 + 1
         g = d(l)
         p = (d(l1) - g) / (2.0d0 * e(l))
         r = pythag_rs(p,1.0d0)
         d(l) = e(l) / (p + dsign(r,p))
         d(l1) = e(l) * (p + dsign(r,p))
         dl1 = d(l1)
         h = g - d(l)
         if (l2 .gt. n) go to 145
!
         do 140 i = l2, n
         d(i) = d(i) - h
  140    continue
!
  145    continue
         f = f + h
!     .......... ql transformation ..........
         p = d(m)
         c = 1.0d0
         c2 = c
         el1 = e(l1)
         s = 0.0d0
         mml = m - l
!     .......... for i=m-1 step -1 until l do -- ..........
         do 200 ii = 1, mml
            c3 = c2
            c2 = c
            s2 = s
            i = m - ii
            g = c * e(i)
            h = c * p
            r = pythag_rs(p,e(i))
            e(i+1) = s * r
            s = e(i) / r
            c = p / r
            p = c * d(i) - s * g
            d(i+1) = h + s * (c * g + s * d(i))
  200    continue
!
         p = -s * s2 * c3 * el1 * e(l) / dl1
         e(l) = s * p
         d(l) = c * p
         tst2 = tst1 + dabs(e(l))
         if (tst2 .gt. tst1) go to 130
  210    continue
         p = d(l) + f
!     .......... order eigenvalues ..........
         if (l .eq. 1) go to 250
!     .......... for i=l step -1 until 2 do -- ..........
         do 230 ii = 2, l
            i = l + 2 - ii
            if (p .ge. d(i-1)) go to 270
            d(i) = d(i-1)
  230    continue
!
  250    continue
         i = 1
  270    continue
         d(i) = p
  290 continue
!
      go to 1001
!     .......... set error -- no convergence to an
!                eigenvalue after 30 iterations ..........
 1000 continue
      ierr = l
 1001 continue
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine tql2(nm,n,d,e,z,ierr)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
!
      integer i,j,k,l,m,n,ii,l1,l2,nm,mml,ierr
      real*8 d(n),e(n),z(nm,n)
      real*8 c,c2,c3,dl1,el1,f,g,h,p,r,s,s2,tst1,tst2,pythag_rs
!
!     this subroutine is a translation of the algol procedure tql2,
!     num. math. 11, 293-306(1968) by bowdler, martin, reinsch, and
!     wilkinson.
!     handbook for auto. comp., vol.ii-linear algebra, 227-240(1971).
!
!     this subroutine finds the eigenvalues and eigenvectors
!     of a symmetric tridiagonal matrix by the ql method.
!     the eigenvectors of a full symmetric matrix can also
!     be found if  tred2  has been used to reduce this
!     full matrix to tridiagonal form.
!
!     on input
!
!        nm must be set to the row dimension of two-dimensional
!          array parameters as declared in the calling program
!          dimension statement.
!
!        n is the order of the matrix.
!
!        d contains the diagonal elements of the input matrix.
!
!        e contains the subdiagonal elements of the input matrix
!          in its last n-1 positions.  e(1) is arbitrary.
!
!        z contains the transformation matrix produced in the
!          reduction by  tred2, if performed.  if the eigenvectors
!          of the tridiagonal matrix are desired, z must contain
!          the identity matrix.
!
!      on output
!
!        d contains the eigenvalues in ascending order.  if an
!          error exit is made, the eigenvalues are correct but
!          unordered for indices 1,2,...,ierr-1.
!
!        e has been destroyed.
!
!        z contains orthonormal eigenvectors of the symmetric
!          tridiagonal (or full) matrix.  if an error exit is made,
!          z contains the eigenvectors associated with the stored
!          eigenvalues.
!
!        ierr is set to
!          zero       for normal return,
!          j          if the j-th eigenvalue has not been
!                     determined after 30 iterations.
!
!     calls pythag_rs for  dsqrt(a*a + b*b) .
!
!     questions and comments should be directed to burton s. garbow,
!     mathematics and computer science div, argonne national laboratory
!
!     this version dated august 1983.
!
!     ------------------------------------------------------------------
!
      ierr = 0
      if (n .eq. 1) go to 1001
!
      do 100 i = 2, n
      e(i-1) = e(i)
  100 continue
!
      f = 0.0d0
      tst1 = 0.0d0
      e(n) = 0.0d0
!
      do 240 l = 1, n
         j = 0
         h = dabs(d(l)) + dabs(e(l))
         if (tst1 .lt. h) tst1 = h
!     .......... look for small sub-diagonal element ..........
         do 110 m = l, n
            tst2 = tst1 + dabs(e(m))
            if (tst2 .eq. tst1) go to 120
!     .......... e(n) is always zero, so there is no exit
!                through the bottom of the loop ..........
  110    continue
!
  120    continue
         if (m .eq. l) go to 220
  130    continue
         if (j .eq. 30) go to 1000
         j = j + 1
!     .......... form shift ..........
         l1 = l + 1
         l2 = l1 + 1
         g = d(l)
         p = (d(l1) - g) / (2.0d0 * e(l))
         r = pythag_rs(p,1.0d0)
         d(l) = e(l) / (p + dsign(r,p))
         d(l1) = e(l) * (p + dsign(r,p))
         dl1 = d(l1)
         h = g - d(l)
         if (l2 .gt. n) go to 145
!
         do 140 i = l2, n
         d(i) = d(i) - h
  140    continue
!
  145    continue
         f = f + h
!     .......... ql transformation ..........
         p = d(m)
         c = 1.0d0
         c2 = c
         el1 = e(l1)
         s = 0.0d0
         mml = m - l
!     .......... for i=m-1 step -1 until l do -- ..........
         do 200 ii = 1, mml
            c3 = c2
            c2 = c
            s2 = s
            i = m - ii
            g = c * e(i)
            h = c * p
            r = pythag_rs(p,e(i))
            e(i+1) = s * r
            s = e(i) / r
            c = p / r
            p = c * d(i) - s * g
            d(i+1) = h + s * (c * g + s * d(i))
!     .......... form vector ..........
            do 180 k = 1, n
               h = z(k,i+1)
               z(k,i+1) = s * z(k,i) + c * h
               z(k,i) = c * z(k,i) - s * h
  180       continue
!
  200    continue
!
         p = -s * s2 * c3 * el1 * e(l) / dl1
         e(l) = s * p
         d(l) = c * p
         tst2 = tst1 + dabs(e(l))
         if (tst2 .gt. tst1) go to 130
  220    continue
         d(l) = d(l) + f
  240 continue
!     .......... order eigenvalues and eigenvectors ..........
      do 300 ii = 2, n
         i = ii - 1
         k = i
         p = d(i)
!
         do 260 j = ii, n
            if (d(j) .ge. p) go to 260
            k = j
            p = d(j)
  260    continue
!
         if (k .eq. i) go to 300
         d(k) = d(i)
         d(i) = p
!
         do 280 j = 1, n
            p = z(j,i)
            z(j,i) = z(j,k)
            z(j,k) = p
  280    continue
!
  300 continue
!
      go to 1001
!     .......... set error -- no convergence to an
!                eigenvalue after 30 iterations ..........
 1000 continue
      ierr = l
 1001 continue
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine tred1(nm,n,a,d,e,e2)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
!
      integer i,j,k,l,n,ii,nm,jp1
      real*8 a(nm,n),d(n),e(n),e2(n)
      real*8 f,g,h,scale
!
!     this subroutine is a translation of the algol procedure tred1,
!     num. math. 11, 181-195(1968) by martin, reinsch, and wilkinson.
!     handbook for auto. comp., vol.ii-linear algebra, 212-226(1971).
!
!     this subroutine reduces a real symmetric matrix
!     to a symmetric tridiagonal matrix using
!     orthogonal similarity transformations.
!
!     on input
!
!        nm must be set to the row dimension of two-dimensional
!          array parameters as declared in the calling program
!          dimension statement.
!
!        n is the order of the matrix.
!
!        a contains the real symmetric input matrix.  only the
!          lower triangle of the matrix need be supplied.
!
!     on output
!
!        a contains information about the orthogonal trans-
!          formations used in the reduction in its strict lower
!          triangle.  the full upper triangle of a is unaltered.
!
!        d contains the diagonal elements of the tridiagonal matrix.
!
!        e contains the subdiagonal elements of the tridiagonal
!          matrix in its last n-1 positions.  e(1) is set to zero.
!
!        e2 contains the squares of the corresponding elements of e.
!          e2 may coincide with e if the squares are not needed.
!
!     questions and comments should be directed to burton s. garbow,
!     mathematics and computer science div, argonne national laboratory
!
!     this version dated august 1983.
!
!     ------------------------------------------------------------------
!
      do 100 i = 1, n
         d(i) = a(n,i)
         a(n,i) = a(i,i)
  100 continue
!     .......... for i=n step -1 until 1 do -- ..........
      do 300 ii = 1, n
         i = n + 1 - ii
         l = i - 1
         h = 0.0d0
         scale = 0.0d0
         if (l .lt. 1) go to 130
!     .......... scale row (algol tol then not needed) ..........
         do 120 k = 1, l
         scale = scale + dabs(d(k))
  120    continue
!
         if (scale .ne. 0.0d0) go to 140
!
         do 125 j = 1, l
            d(j) = a(l,j)
            a(l,j) = a(i,j)
            a(i,j) = 0.0d0
  125    continue
!
  130    continue
         e(i) = 0.0d0
         e2(i) = 0.0d0
         go to 300
!
  140    continue
         do 150 k = 1, l
            d(k) = d(k) / scale
            h = h + d(k) * d(k)
  150    continue
!
         e2(i) = scale * scale * h
         f = d(l)
         g = -dsign(dsqrt(h),f)
         e(i) = scale * g
         h = h - f * g
         d(l) = f - g
         if (l .eq. 1) go to 285
!     .......... form a*u ..........
         do 170 j = 1, l
         e(j) = 0.0d0
  170    continue
!
         do 240 j = 1, l
            f = d(j)
            g = e(j) + a(j,j) * f
            jp1 = j + 1
            if (l .lt. jp1) go to 220
!
            do 200 k = jp1, l
               g = g + a(k,j) * d(k)
               e(k) = e(k) + a(k,j) * f
  200       continue
!
  220       continue
            e(j) = g
  240    continue
!     .......... form p ..........
         f = 0.0d0
!
         do 245 j = 1, l
            e(j) = e(j) / h
            f = f + e(j) * d(j)
  245    continue
!
         h = f / (h + h)
!     .......... form q ..........
         do 250 j = 1, l
         e(j) = e(j) - h * d(j)
  250    continue
!     .......... form reduced a ..........
         do 280 j = 1, l
            f = d(j)
            g = e(j)
!
            do 260 k = j, l
            a(k,j) = a(k,j) - f * e(k) - g * d(k)
  260       continue
!
  280    continue
!
  285    continue
         do 290 j = 1, l
            f = d(j)
            d(j) = a(l,j)
            a(l,j) = a(i,j)
            a(i,j) = f * scale
  290    continue
!
  300 continue
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine tred2(nm,n,a,d,e,z)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
!
      integer i,j,k,l,n,ii,nm,jp1
      real*8 a(nm,n),d(n),e(n),z(nm,n)
      real*8 f,g,h,hh,scale
!
!     this subroutine is a translation of the algol procedure tred2,
!     num. math. 11, 181-195(1968) by martin, reinsch, and wilkinson.
!     handbook for auto. comp., vol.ii-linear algebra, 212-226(1971).
!
!     this subroutine reduces a real symmetric matrix to a
!     symmetric tridiagonal matrix using and accumulating
!     orthogonal similarity transformations.
!
!     on input
!
!        nm must be set to the row dimension of two-dimensional
!          array parameters as declared in the calling program
!          dimension statement.
!
!        n is the order of the matrix.
!
!        a contains the real symmetric input matrix.  only the
!          lower triangle of the matrix need be supplied.
!
!     on output
!
!        d contains the diagonal elements of the tridiagonal matrix.
!
!        e contains the subdiagonal elements of the tridiagonal
!          matrix in its last n-1 positions.  e(1) is set to zero.
!
!        z contains the orthogonal transformation matrix
!          produced in the reduction.
!
!        a and z may coincide.  if distinct, a is unaltered.
!
!     questions and comments should be directed to burton s. garbow,
!     mathematics and computer science div, argonne national laboratory
!
!     this version dated august 1983.
!
!     ------------------------------------------------------------------
!
      do 100 i = 1, n
!
         do 80 j = i, n
         z(j,i) = a(j,i)
   80    continue
!
         d(i) = a(n,i)
  100 continue
!
      if (n .eq. 1) go to 510
!     .......... for i=n step -1 until 2 do -- ..........
      do 300 ii = 2, n
         i = n + 2 - ii
         l = i - 1
         h = 0.0d0
         scale = 0.0d0
         if (l .lt. 2) go to 130
!     .......... scale row (algol tol then not needed) ..........
         do 120 k = 1, l
         scale = scale + dabs(d(k))
  120    continue
!
         if (scale .ne. 0.0d0) go to 140
  130    continue
         e(i) = d(l)
!
         do 135 j = 1, l
            d(j) = z(l,j)
            z(i,j) = 0.0d0
            z(j,i) = 0.0d0
  135    continue
!
         go to 290
!
  140    continue
         do 150 k = 1, l
            d(k) = d(k) / scale
            h = h + d(k) * d(k)
  150    continue
!
         f = d(l)
         g = -dsign(dsqrt(h),f)
         e(i) = scale * g
         h = h - f * g
         d(l) = f - g
!     .......... form a*u ..........
         do 170 j = 1, l
         e(j) = 0.0d0
  170    continue
!
         do 240 j = 1, l
            f = d(j)
            z(j,i) = f
            g = e(j) + z(j,j) * f
            jp1 = j + 1
            if (l .lt. jp1) go to 220
!
            do 200 k = jp1, l
               g = g + z(k,j) * d(k)
               e(k) = e(k) + z(k,j) * f
  200       continue
!
  220       continue
            e(j) = g
  240    continue
!     .......... form p ..........
         f = 0.0d0
!
         do 245 j = 1, l
            e(j) = e(j) / h
            f = f + e(j) * d(j)
  245    continue
!
         hh = f / (h + h)
!     .......... form q ..........
         do 250 j = 1, l
         e(j) = e(j) - hh * d(j)
  250    continue
!     .......... form reduced a ..........
         do 280 j = 1, l
            f = d(j)
            g = e(j)
!
            do 260 k = j, l
            z(k,j) = z(k,j) - f * e(k) - g * d(k)
  260       continue
!
            d(j) = z(l,j)
            z(i,j) = 0.0d0
  280    continue
!
  290    continue
         d(i) = h
  300 continue
!     .......... accumulation of transformation matrices ..........
      do 500 i = 2, n
         l = i - 1
         z(n,l) = z(l,l)
         z(l,l) = 1.0d0
         h = d(i)
         if (h .eq. 0.0d0) go to 380
!
         do 330 k = 1, l
         d(k) = z(k,i) / h
  330    continue
!
         do 360 j = 1, l
            g = 0.0d0
!
            do 340 k = 1, l
            g = g + z(k,i) * z(k,j)
  340       continue
!
            do 360 k = 1, l
              z(k,j) = z(k,j) - g * d(k)
  360       continue
!
  380    continue
         do 400 k = 1, l
         z(k,i) = 0.0d0
  400    continue
!
  500 continue
!
  510 continue
      do 520 i = 1, n
         d(i) = z(n,i)
         z(n,i) = 0.0d0
  520 continue
!
      z(n,n) = 1.0d0
      e(1) = 0.0d0
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      real*8 function pythag_rs(a,b)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      real*8 a,b
!
!     finds dsqrt(a**2+b**2) without overflow or destructive underflow
!
      real*8 p,r,s,t,u
      p = dmax1(dabs(a),dabs(b))
      if (p .eq. 0.0d0) go to 20
      r = (dmin1(dabs(a),dabs(b))/p)**2
   10 continue
         t = 4.0d0 + r
         if (t .eq. 4.0d0) go to 20
         s = r/t
         u = 1.0d0 + 2.0d0*s
         p = u*p
         r = (s/u)**2 * r
      go to 10
   20 continue
      pythag_rs = p
!
!
      return
      end
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! FINISHED: EISPACK real symmetric e-value and e-vector solver
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! PACKAGE of Random Number Generators (RNGs)  V090822-1500hbs
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Two [0,1]-uniform RNGs (Fibonacci and Mersenne Twister)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine srandx(iseed1,iseed2,jrand)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      implicit none
!
! Random Number Generator (RNG) Initialization Driver
!
      integer iseed1,iseed2,jrand
!
      integer jrandi, ismod, imult1, ismod1, ismod2
      common /iv_jrand/ jrandi
      save /iv_jrand/
!
      jrandi=jrand
!
! jrand=1: Initialize Fibonacci RNG
!
!       Requires 2 seed numbers: iseed1, iseed2
!
!       The seed variables must have values between:
!          0 <= iseed1 <= iseed1max:=31328
!          0 <= iseed2 <= iseed2max:=30081
!       or else: they will be "folded" back into the allowed
!       bounds (if their input values are outside of these bounds)
!       with 0-reflected, periodic boundaries, as follows:
!
!       iseed1 is replaced by
!          ismod1 := mod(|iseed1|,iseed1max+1);
!       then, iseed2 is replaced by
!          ismod2 := mod(|iseed2|+imult1,iseed2max+1);
!       where
!          imult1 := int(|iseed1|/(iseed1max+1))
!       and
!          int(x) := largest integer ix with  ix =< x
!
!       By this folding procedure, input values of iseed1
!       (=imc_ran or ixpt_ran) exceeding iseed1max can be used
!       to modify the effective value of iseed2 w/out changing
!       the input value od iseed2. Input values of iseed1 exceeding
!       iseed1max are therefore legal and will each produce a
!       different random sequence (for fixed input value of iseed2).
!       Input values of iseed2 exceeding iseed2max are also
!       legal, but will produce the same random sequence as the
!       corresponding effective iseed2-value, ismod2.
!
      if(jrandi.eq.1) then
        ismod=iseed1
        if(ismod.lt.0) ismod=-ismod
        imult1=ismod/31329
        ismod1=ismod-31329*imult1
        if(ismod1.lt.0) ismod1=0
        if(ismod1.gt.31328) ismod1=31328
!
        ismod=iseed2
        if(ismod.lt.0) ismod=-ismod
        ismod=ismod+imult1
        imult1=ismod/30082
        ismod2=ismod-30082*imult1
        if(ismod2.lt.0) ismod2=0
        if(ismod2.gt.30081) ismod2=30081
!
        call rmarin(ismod1,ismod2)
      endif
!
!
! jrand=2: Initialize Mersenne Twister RNG
!
!       Requires 1 seed number: iseed1
!
      if(jrandi.eq.2) then
        call sgrnd(iseed1)
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      function randx()
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      implicit none
!
! Random Number Generator (RNG) Driver
!
      real*8 randx, randi
      real*8 ranvec(2), grnd
!
      integer jrandi,lenran
      common /iv_jrand/ jrandi
      save /iv_jrand/
!
! jrand=1: Use Fibonacci RNG
      if(jrandi.eq.1) then
        lenran=1
        call ranmar(ranvec,lenran)
        randi=ranvec(1)
      endif
!
! jrand=2: Use Mersenne Twister RNG
      if(jrandi.eq.2) then
        randi=grnd()
      endif
!
!
      if(randi.le.0.d0) randi=1.d-9
      if(randi.ge.1.d0) randi=1.d0-1.d-9
      randx=randi
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine sgrnd(iseed)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! Initializer for Mersenne Twister Random Number Generator (RNG)
!
      implicit integer(a-z)
!
! Period parameters
      parameter(N     =  624)
!
      dimension mt(0:N-1)
!                     the array for the state vector
      common /iv_grnd/mti,mt
      save   /iv_grnd/
!
!      setting initial seeds to mt[N] using
!      the generator Line 25 of Table 1 in
!      [KNUTH 1981, The Art of Computer Programming
!         Vol. 2 (2nd Ed.), pp102]
!
      mt(0)= iand(iseed,-1)
      do mti=1,N-1
        mt(mti) = iand(69069 * mt(mti-1),-1)
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      function grnd()
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! Mersenne Twister Random Number Generator (RNG)
!
! From: http://www.math.keio.ac.jp/~matumoto/emt.html#fortran
!
! A C-program for MT19937: Real number version
!   genrand() generates one pseudorandom real number (double)
! which is uniformly distributed on [0,1]-interval, for each
! call. sgenrand(seed) set initial values to the working area
! of 624 words. Before genrand(), sgenrand(seed) must be
! called once. (seed is any 32-bit integer except for 0).
! Integer generator is obtained by modifying two lines.
!   Coded by Takuji Nishimura, considering the suggestions by
! Topher Cooper and Marc Rieffel in July-Aug. 1997.
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later
! version.
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
! See the GNU Library General Public License for more details.
! You should have received a copy of the GNU Library General
! Public License along with this library; if not, write to the
! Free Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
! 02111-1307  USA
!
! Copyright (C) 1997 Makoto Matsumoto and Takuji Nishimura.
! When you use this, send an email to: matumoto@math.keio.ac.jp
! with an appropriate reference to your work.
!
!***********************************************************************
! Fortran translation by Hiroshi Takano.  Jan. 13, 1999.
!
!   genrand()      -> double precision fctn. grnd()
!   sgenrand(seed) -> subrt. sgrnd(iseed)
!                     integer seed
!
! This program uses the following non-standard intrinsics.
!   ishft(i,n): If n>0, shifts bits in i by n positions to left.
!               If n<0, shifts bits in i by n positions to right.
!   iand (i,j): Performs logical AND on corresponding bits of i and j.
!   ior  (i,j): Performs inclusive OR on corresponding bits of i and j.
!   ieor (i,j): Performs exclusive OR on corresponding bits of i and j.
!
!***********************************************************************
!
      implicit integer(a-z)
!
      real*8 grnd
!
! Period parameters
      parameter(N     =  624)
      parameter(N1    =  N+1)
      parameter(M     =  397)
      parameter(MATA  = -1727483681)
!                                    constant vector a
!X orig. code:
      parameter(UMASK = -2147483648)
!                                    most significant w-r bits
!X                                   UMASK=-2**31 here
      parameter(LMASK =  2147483647)
!                                    least significant r bits
! Tempering parameters
      parameter(TMASKB= -1658038656)
      parameter(TMASKC= -272236544)
!
      dimension mt(0:N-1)
!                     the array for the state vector
      common /iv_grnd/mti,mt,iumask
      save   /iv_grnd/
!X    data   mti/N1/
!                     mti==N+1 means mt[N] is not initialized;
!X                    not needed if sgrnd is called at least
!X                    once prior to grnd
!
      dimension mag01(0:1)
      data mag01/0, MATA/
      save mag01
!                        mag01(x) = x * MATA for x=0,1
!
      TSHFTU(y)=ishft(y,-11)
      TSHFTS(y)=ishft(y,7)
      TSHFTT(y)=ishft(y,15)
      TSHFTL(y)=ishft(y,-18)
!                        these 4 in-line function declarations,
!                        TSHFTU(y), TSHFTU(y), TSHFTU(y), TSHFTU(y),
!                        must precede all executable statemts.
!
      if(mti.ge.N) then
!                       generate N words at one time
!X      if(mti.eq.N+1) then
!                            if sgrnd() has not been called,
!X        call sgrnd(4357)
!                              a default initial seed is used
!X      endif
!X                    not needed if sgrnd is called at least
!X                    once prior to grnd
!
        do kk=0,N-M-1
            y=ior(iand(mt(kk),UMASK),iand(mt(kk+1),LMASK))
            mt(kk)=ieor(ieor(mt(kk+M),ishft(y,-1)),mag01(iand(y,1)))
        enddo
!
        do kk=N-M,N-2
            y=ior(iand(mt(kk),UMASK),iand(mt(kk+1),LMASK))
            mt(kk)=ieor(ieor(mt(kk+(M-N)),ishft(y,-1)),mag01(iand(y,1)))
        enddo
!
        y=ior(iand(mt(N-1),UMASK),iand(mt(0),LMASK))
        mt(N-1)=ieor(ieor(mt(M-1),ishft(y,-1)),mag01(iand(y,1)))
        mti = 0
      endif
!
      y=mt(mti)
      mti=mti+1
      y=ieor(y,TSHFTU(y))
      y=ieor(y,iand(TSHFTS(y),TMASKB))
      y=ieor(y,iand(TSHFTT(y),TMASKC))
      y=ieor(y,TSHFTL(y))
!
      if(y.lt.0) then
        grnd=(dble(y)+2.0d0**32)/(2.0d0**32-1.0d0)
      else
        grnd=dble(y)/(2.0d0**32-1.0d0)
      endif
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine RMARIN(IJ,KL)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! Initializer for Fibonacci Random Number Generator (RNG)
!
! This is the initialization routine for the random number
! generator RANMAR()
!
! NOTE: The seed variables can have values between:
!    0 <= IJ <= 31328
!    0 <= KL <= 30081
! The random number sequences created by these two seeds are of
! sufficient
! length to complete an entire calculation with. For example,
! if sveral
! different groups are working on different parts of the same
! calculation,
! each group could be assigned its own IJ seed. This would leave
! each group
! with 30000 choices for the second seed. That is to say, this
! random
! number generator can create 900 million different subsequences
!-- with
! each subsequence having a length of approximately 10^30.
!
! Use IJ = 1802 & KL = 9373 to test the random number generator.
! The
! subroutine RANMAR should be used to generate 20000 random
! numbers.
! Then display the next six random numbers generated multiplied by
! 4096*4096.
! If the random number generator is working properly, the random
! numbers
! should be:
!           6533892.0  14220222.0  7275067.0
!           6172232.0  8354498.0   10633180.0
!
      real U(97), C, CD, CM
      integer I97, J97
      logical RTEST
!X    data RTEST /.FALSE./
      common /raset1/ U, C, CD, CM, I97, J97, RTEST
      save /raset1/
!
!X    if( IJ .lt. 0  .or.  IJ .gt. 31328  .or.    &
!X   &    KL .lt. 0  .or.  KL .gt. 30081 ) then
!X        print '(A)', ' The first random number seed must have a value &
!X   &between 0 and 31328'
!X        print '(A)',' The second seed must have a value between 0 and &
!X   &30081'
!X          stop
!X    endif
!
      i = mod(IJ/177, 177) + 2
      j = mod(IJ    , 177) + 2
      k = mod(KL/169, 178) + 1
      l = mod(KL,     169)
!
!X    do 2 ii = 1, 97
      do ii = 1, 97
         s = 0.0
         t = 0.5
!X       do 3 jj = 1, 24
         do jj = 1, 24
            m = mod(mod(i*j, 179)*k, 179)
            i = j
            j = k
            k = m
            l = mod(53*l+1, 169)
            if (mod(l*m, 64) .ge. 32) then
               s = s + t
            endif
            t = 0.5 * t
         enddo
!X3      continue
         U(ii) = s
      enddo
!X2   continue
!
      C = 362436.0 / 16777216.0
      CD = 7654321.0 / 16777216.0
      CM = 16777213.0 /16777216.0
!
      I97 = 97
      J97 = 33
!
!X    RTEST = .TRUE.
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ranmar(RVEC, LEN)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! Fibonacci Random Number Generator (RNG)
!
! This is the random number generator proposed by George Marsaglia in
! Florida State University Report: FSU-SCRI-87-50
! It was slightly modified by F. James to produce an array of pseudorandom
! numbers.
!
! This random number generator originally appeared in "Toward a Universal
! Random Number Generator" by George Marsaglia and Arif Zaman.
! Florida State University Report: FSU-SCRI-87-50 (1987)
!
! It was later modified by F. James and published in "A Review of Pseudo-
! random Number Generators"
!
! THIS IS THE BEST KNOWN RANDOM NUMBER GENERATOR AVAILABLE.
!       (However, a newly discovered technique can yield
!         a period of 10^600. But that is still in the development stage.)
!
! It passes ALL of the tests for random number generators and has a period
!   of 2^144, is completely portable (gives bit identical results on all
!   machines with at least 24-bit mantissas in the floating point
!   representation).
!
! The algorithm is a combination of a Fibonacci sequence (with lags of 97
!   and 33, and operation "subtraction plus one, modulo one") and an
!   "arithmetic sequence" (using subtraction).
!
! On a Vax 11/780, this random number generator can produce a number in
!    13 microseconds.
!========================================================================
!
!X    REAL RVEC(*)
      REAL*8 RVEC(*)
      real U(97), C, CD, CM
      integer I97, J97
      logical RTEST
      common /raset1/ U, C, CD, CM, I97, J97, RTEST
      save /raset1/
!
      integer ivec
!
!X    if( .NOT. RTEST ) then
!X       print '(A)',' Call the init routine (RMARIN) before calling RAN &
!X   &MAR'
!X       stop
!X    endif
!
!X    do 100 ivec = 1, LEN
      do ivec = 1, LEN
         uni = U(I97) - U(J97)
         if( uni .lt. 0.0 ) uni = uni + 1.0
         U(I97) = uni
         I97 = I97 - 1
         if(I97 .eq. 0) I97 = 97
         J97 = J97 - 1
         if(J97 .eq. 0) J97 = 97
         C = C - CD
         if( C .lt. 0.0 ) C = C + CM
         uni = uni - C
         if( uni .lt. 0.0 ) uni = uni + 1.0
         RVEC(ivec) = uni
      enddo
!X100 continue
!
!
      return
      end
!
!
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Truncated Gaussian RNG and auxiliaries
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine tgauss(z,zlo,zhi,jpoiss,jclev,jerrivn,jerrtg)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      implicit none
!
! Truncated Standardized Gaussian/Normal Random Number Generator.
!
! Uses Gauss error function erf(x)==derf, scaled complementary
! Gauss error function erfcx(x)==derfcx_anl, inverse cumulative standardized
! Gaussian/normal distribution R(p)==dinvnorm, and a uniform random
! number generator on [0,1], randx(), to generate a random number z that
! is drawn from the truncated standardized Gaussian/normal distribution
!   P_TG(z) = const * exp(-z^2/2)   if   zlo < z < zhi
!   P_TG(z) = 0                     if   z =< zlo  or  zhi =< z
!
! jpoiss, jclev: read below
! jerrivn: error flag from dinvnorm (normal termination: =0)
! jerrtg:  error flag from tgauss itself (normal termination: =<0)
!
! Definitions and Math Background:
! --------------------------------
! Let
!    p=Q(z)==(1/2)[1+erf(x)]   with  x==z/\sqrt(2)
! and Gaussian error function
!    erf(x)==(2/\sqrt(\pi)) \int_0^x exp(-t^2) dt.
! and complementary Gaussian error function
!    erfc(x)==1-erf(x)                                 [C]
! Then R(p) is defined for 0<p<1 so that
!       z=R(p)   <-->  p=Q(z).
! with R(p) obeying the symmetry relation
!    R(p) = -R(1-p)                                    [R]
!
! We use erf(x) and R(p) to draw a random z from P_TG(z) as follows:
! Given zlo and zhi, draw a uniform RN, r, from [0,1], using uniform
! RNG randx(), and let
!   p=(1/2)[ 1 + erf(xlo) + (erf(xhi)-erf(xlo))*r ]    [P]
! where
!   xlo==zlo/\sqrt(2),    xhi==zhi/\sqrt(2).           [L]
! Then
!   z=R(p)                                             [Z}
! will be a random draw from P_TG(z), as defined above.
!
! In ens-MC applications, zlo and zhi themselves may vary randomly
! they may (initially) acquire large values with [zlo,zhi] far off
! in the Gaussian "tails", i.e., with either
!    zlo >> 1   or   -zhi >> 1                         [T]
! When this "tail" condition [T] is realized, special care must be taken
! to avoid rounding/underflow problems in the evaluations of erf(xlo)
! and erf(xhi) entering into the p-evaluation [P]. Note that the RNG
! algorithm breaks down if numerically p=0 or p=1 is set due to underflow
! of erf(x) or 1-erf(x).
!
! This underflow problem is especially severe here, since
! erfc(x) has very rapid asymptotic decay,
!    erfc(x) ~= (1/(\sqrt(\pi)*x) exp(-x^2) [1+O(1/x^2], x-->\infty
! To deal with large |x|, we therefore use the
!      scaled complementary error function,
! defined by
!    erfcx(x)==exp(x^2) [1-erf(x)],
!    erfcx(x) ~= 1/(\sqrt(\pi)*x) [1+O(1/x^2], x-->+\infty       [A]
! To convert neg. x-arguments to pos. x-arguments for erfcx,
! we also use symmetry relations
!    erf(x)=-erf(-x)
!    erfc(x)=2-erfc(-x)=2-exp(-x^2)erfcx(-x)                     [S]
! In this manner, erfcx needs to be evaluated only for x>=0
! where its large-x asymptotics [A} is benign (see above). Note
! that we do not want to ever evaluate erfcx(x) for x<0 with
! large |x|, since erfcx(x)~=2exp(+x^2) for x--> -\infty.
!
! By proper re-arrangment of [P], using [C] and [S], we can
! directly evaluate
!    alnpbar==ln(1-p) if p>1/2, incl. p arb. close to upper limit 1;
! or
!    alnprob==ln(p) if p<1/2, incl. p arb. close to lower limit 0;
! and this can be done for arbiratrily negative values of ln(p) or ln(1-p),
! without ever calculating, storing or using the value p or 1-p itself,
! i.e., without underflow.
!
! Next, for p>1/2, incl. p arb. close to 1, the R(p)-function, dinvnorm,
! has been configured to directly use alnpbar==ln(1-p) as input (jpinp=3)
! to evaluate R(p), without having to convert to, store or use the
! value of p or 1-p, and it can thereby handle p-values arb. close to 1.
! Also, p-values arb. close to 0 are then handled by using [R], i.e.,
! calculating R(p) as -R(1-p). [P] and [Z} generate a reasonably accurate
! P_TG(z) if at least (conservatively!)
!          -50 ~< zhi  and  zlo ~<      +50, using dinvnorm0 (jclev=0)
!        -1000 ~< zhi  and  zlo ~<    +1000, using dinvnorm1 (jclev=1)
!     -1000000 ~< zhi  and  zlo ~< +1000000, using dinvnorm2 (jclev=2)
!
! If either one of the foregoing zlo- and zhi-limits, zlo_X or zhi_N, is
! violated, the erf(x)-R(p)-based P_TG RNG [P]-[Z}-algorithm breaks down.
! Howewer, in that case, P_TG is well approximated by a
!   tuncated Poisson distribution P_TP(z),
! given for z inside [zlo,zhi] by
!   P_TP(z) = const * exp(-zlo*(z-zlo))  if 0 < zlo_X < zlo < z < zhi
!   P_TP(z) = const * exp(+zhi*(zhi-z))  if zlo < z < zhi < zhi_N < 0
! with P_TP(z)==0 for z outside of [zlo,zhi]. This "tail end" Poisson
! approximation should be used when zlo>zlo_X or zhi<zhi_N, by setting
! jpoiss=1; else [P]-[Z] Gaussian should be used by setting jpoiss=0.
!
! Random values of z drawn from P_TP(z) are generated by
!   z=-(1/zw) ln[(1-r)*exp(-zw*zlo) + r*exp(-zw*zhi)]
! where r is a uniform RN drawn from [0,1] and
!   zw==zlo if zlo>zlo_x  or  zw==zhi if zhi<zhi_n.
! To avoid over-/underflow problems either
!   exp(-zw*zlo) (if zlo>zlo_x>0)  or  exp(-zw*zhi) (if zhi<zhi_n<0)
! is factored out from the ln[...]-term, so that the only exp(...)
! to be evaluated is exp(-|zw|*(zhi-zlo))<1, inside ln[...]-term..
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
      integer jpinp, jerrivn, jerrtg, jzsgn                        &
     &     , jpoiss, jclev
!
      real*8 z, zlo, zhi, xzlo, xzhi, zlo_x, zhi_n                 &
     &     , dprobz, adprobz, adprobz_lim, epspz                   &
     &     , probz, pbarz, urand, zprob                            &
     &     , erfzhi, erfzlo, erfcxhi, erfcxlo, ort2                &
     &     , alnprob, alnpbar, bprob, bpbar, cprob, cpbar
!
      real*8 dinvnorm, randx, derf, derfcx_anl, dexp, dlog
!
! limit on proximity of p to 1 or 0:
      data epspz /1.0d-2/
! 1/sqrt(2.d0)
      data ort2 /0.707106781186547524d0/
!
!!    data jclev /0/
!!    data zlo_x, zhi_n /50.d0,-50.d0/
!
!!    data jclev /1/
!!    data zlo_x, zhi_n /1000.d0,-1000.d0/
!
!!    data jclev /2/
!!    data zlo_x, zhi_n /1000000.d0,-1000000.d0/
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
      jerrivn=0
      jerrtg=0
      if(zlo.ge.zhi) then
        jerrtg=1
        zprob=1.d38
        goto 902
      endif
!
      urand=randx()
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Case 0: [zlo,zhi] is "far off" in the Gaussian tails:
!   approximate P_TG by truncated Poisson distribution
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      if(jpoiss.eq.1) then
!!      if(zlo.gt.zlo_x) then
        if(zlo.gt.0.d0) then
          zprob=zlo-dlog( (1.d0-urand +urand*dexp(-zlo*(zhi-zlo))) )/zlo
          goto 902
        endif
!!      if(zhi.lt.zhi_n) then
        if(zhi.lt.0.d0) then
          zprob=zhi-dlog( (urand +(1.d0-urand)*dexp(zhi*(zhi-zlo))) )/zhi
          goto 902
        endif
      endif
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Cases 1,2,3:
!   must calc. P_TG by Case1:erf(x) or Case2:erfcx(x)
!   and R(p)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!    set by data stmt:
!!    ort2=1.d0/dsqrt(2.d0)
!
      xzhi=zhi*ort2
      xzlo=zlo*ort2
      erfzhi=derf(xzhi)
      erfzlo=derf(xzlo)
!
      dprobz=0.5d0*(erfzlo+(erfzhi-erfzlo)*urand )
      adprobz=dabs(dprobz)
      adprobz_lim=0.5d0-epspz
!      Note: dprobz==p-1/2, hence   -1/2 < dprobz < +1/2
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Cases 1:
!   probz is sufficiently far from its limits 0 and 1;
!   can calc. P_TG by erf(x) and R(p)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      if(adprobz.lt.adprobz_lim) then
        probz=0.5d0+adprobz
        jpinp=1
        zprob=dinvnorm(probz,jpinp,jclev,jerrivn)
        if(dprobz.lt.0.d0) zprob=-zprob
        jerrtg=-100
        goto 902
      endif
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Cases 2,3:
!   probz is too close to one of its limits 1 or 0, either
!   pbarz==1-probz or probz maybe underflowing and/or
!   swamped by rounding errors in erf(x);
!   must calc. P_TG by erfcx(x) and R(p), using/storing
!   either only alnpbar==ln(1-probz) or only alnprob==ln(probz),
!   but not pbar or probz itself
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      erfcxhi=derfcx_anl(dabs(xzhi))
      erfcxlo=derfcx_anl(dabs(xzlo))
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Case 2:
!   probz is too close to upper limit of 1
!   and pbarz==1-probz maybe underflowing and/or swamped
!   by rounding errors in erf(x);
!   must calc. P_TG by erfcx(x) and R(p), using/storing
!   only alnpbar==ln(1-probz), but not probz or pbarz itself
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      if(dprobz.gt.0.d0) then
        if(xzlo.ge.0.d0) then
          bpbar=xzhi**2-xzlo**2-dlog(erfcxhi/erfcxlo)
          cpbar=xzlo**2-dlog(0.5d0*erfcxlo)
        else
          bpbar=xzhi**2-dlog( (erfcxhi/(2.d0-dexp(-xzlo**2)*erfcxlo)) )
          cpbar=-dlog( ( 1.d0-0.5d0*dexp(-xzlo**2)*erfcxlo ) )
        endif
!
        alnpbar=-cpbar+dlog( (1.d0-urand+urand*dexp(-bpbar)) )
        jpinp=3
        zprob=dinvnorm(alnpbar,jpinp,jclev,jerrivn)
        jerrtg=-200
        goto 902
      endif
!
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Case 3:
!   probz is too close to lower limit of 0
!   and probz maybe underflowing and/or swamped
!   by rounding errors in erf(x);
!   must calc. P_TG by erfcx(x) and R(pbarz), using/storing
!   only alnprob==ln(probz), but not probz or pbarz itself
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!    if(dprobz.lt.0.d0) then
        if(xzhi.le.0.d0) then
          bprob=xzlo**2-xzhi**2-dlog(erfcxlo/erfcxhi)
          cprob=xzhi**2-dlog(0.5d0*erfcxhi)
        else
          bprob=xzlo**2-dlog( (erfcxlo/(2.d0-dexp(-xzhi**2)*erfcxhi)) )
          cprob=-dlog( ( 1.d0-0.5d0*dexp(-xzhi**2)*erfcxhi ) )
        endif
!
        alnprob=-cprob+dlog( (urand+(1.d0-urand)*dexp(-bprob)) )
        jpinp=3
        zprob=-dinvnorm(alnprob,jpinp,jclev,jerrivn)
        jerrtg=-300
!!      goto 902
!!    endif
!
  902 continue
      z=zprob
      if(z.le.zlo) then
        z=zlo+1.d-3*(zhi-zlo)*urand
        jerrtg=jerrtg-10
      endif
      if(z.ge.zhi) then
        z=zhi-1.d-3*(zhi-zlo)*urand
        jerrtg=jerrtg-11
      endif
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      SUBROUTINE CALERF(ARG,RESULT,JINT)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!!
!!HBS: MODIFIED 090814-1505
!! changed to f90 format, real*8 precision
!! set most conservative mach-dep. constants
!!:HBS
!!
!C
!C This packet evaluates  erf(x),  erfc(x),  and  exp(x*x)*erfc(x)
!C   for a real argument  x.  It contains three FUNCTION type
!C   subprograms: ERF, ERFC, and ERFCX (or DERF_anl, DERFC_anl, and DERFCX_anl),
!C   and one SUBROUTINE type subprogram, CALERF.  The calling
!C   statements for the primary entries are:
!C
!C                   Y=ERF(X)     (or   Y=DERF(X)),
!C
!C                   Y=ERFC(X)    (or   Y=DERFC(X)),
!C   and
!C                   Y=ERFCX(X)   (or   Y=DERFCX(X)).
!C
!C   The routine  CALERF  is intended for internal packet use only,
!C   all computations within the packet being concentrated in this
!C   routine.  The function subprograms invoke  CALERF  with the
!C   statement
!C
!C          CALL CALERF(ARG,RESULT,JINT)
!C
!C   where the parameter usage is as follows
!C
!C      Function                     Parameters for CALERF
!C       call              ARG                  Result          JINT
!C
!C     ERF(ARG)      ANY REAL ARGUMENT         ERF(ARG)          0
!C     ERFC(ARG)     ABS(ARG) .LT. XBIG        ERFC(ARG)         1
!C     ERFCX(ARG)    XNEG .LT. ARG .LT. XMAX   ERFCX(ARG)        2
!C
!C   The main computation evaluates near-minimax approximations
!C   from "Rational Chebyshev approximations for the error function"
!C   by W. J. Cody, Math. Comp., 1969, PP. 631-638.  This
!C   transportable program uses rational functions that theoretically
!C   approximate  erf(x)  and  erfc(x)  to at least 18 significant
!C   decimal digits.  The accuracy achieved depends on the arithmetic
!C   system, the compiler, the intrinsic functions, and proper
!C   selection of the machine-dependent constants.
!C
!C*******************************************************************
!C*******************************************************************
!C
!C Explanation of machine-dependent constants
!C
!C   XMIN   = the smallest positive floating-point number.
!C   XINF   = the largest positive finite floating-point number.
!C   XNEG   = the largest negative argument acceptable to ERFCX;
!C            the negative of the solution to the equation
!C            2*exp(x*x) = XINF.
!C   XSMALL = argument below which erf(x) may be represented by
!C            2*x/sqrt(pi)  and above which  x*x  will not underflow.
!C            A conservative value is the largest machine number X
!C            such that   1.0 + X = 1.0   to machine precision.
!C   XBIG   = largest argument acceptable to ERFC;  solution to
!C            the equation:  W(x) * (1-0.5/x**2) = XMIN,  where
!C            W(x) = exp(-x*x)/[x*sqrt(pi)].
!C   XHUGE  = argument above which  1.0 - 1/(2*x*x) = 1.0  to
!C            machine precision.  A conservative value is
!C            1/[2*sqrt(XSMALL)]
!C   XMAX   = largest acceptable argument to ERFCX; the minimum
!C            of XINF and 1/[sqrt(pi)*XMIN].
!C
!C   Approximate values for some important machines are:
!C
!C                          XMIN       XINF        XNEG     XSMALL
!C
!C  CDC 7600      (S.P.)  3.13E-294   1.26E+322   -27.220  7.11E-15
!C  CRAY-1        (S.P.)  4.58E-2467  5.45E+2465  -75.345  7.11E-15
!C  IEEE (IBM/XT,
!C    SUN, etc.)  (S.P.)  1.18E-38    3.40E+38     -9.382  5.96E-8
!C  IEEE (IBM/XT,
!C    SUN, etc.)  (D.P.)  2.23D-308   1.79D+308   -26.628  1.11D-16
!C  IBM 195       (D.P.)  5.40D-79    7.23E+75    -13.190  1.39D-17
!C  UNIVAC 1108   (D.P.)  2.78D-309   8.98D+307   -26.615  1.73D-18
!C  VAX D-Format  (D.P.)  2.94D-39    1.70D+38     -9.345  1.39D-17
!C  VAX G-Format  (D.P.)  5.56D-309   8.98D+307   -26.615  1.11D-16
!C
!C
!C                          XBIG       XHUGE       XMAX
!C
!C  CDC 7600      (S.P.)  25.922      8.39E+6     1.80X+293
!C  CRAY-1        (S.P.)  75.326      8.39E+6     5.45E+2465
!C  IEEE (IBM/XT,
!C    SUN, etc.)  (S.P.)   9.194      2.90E+3     4.79E+37
!C  IEEE (IBM/XT,
!C    SUN, etc.)  (D.P.)  26.543      6.71D+7     2.53D+307
!C  IBM 195       (D.P.)  13.306      1.90D+8     7.23E+75
!C  UNIVAC 1108   (D.P.)  26.582      5.37D+8     8.98D+307
!C  VAX D-Format  (D.P.)   9.269      1.90D+8     1.70D+38
!C  VAX G-Format  (D.P.)  26.569      6.71D+7     8.98D+307
!C
!C*******************************************************************
!C*******************************************************************
!C
!C Error returns
!C
!C  The program returns  ERFC = 0      for  ARG .GE. XBIG;
!C
!C                       ERFCX = XINF  for  ARG .LT. XNEG;
!C      and
!C                       ERFCX = 0     for  ARG .GE. XMAX.
!C
!C
!C Intrinsic functions required are:
!C
!!HBS:
!!    DABS, DINT,DEXP
!C     ABS, AINT, EXP
!!
!C
!C
!C  Author: W. J. Cody
!C          Mathematics and Computer Science Division
!C          Argonne National Laboratory
!C          Argonne, IL 60439
!C
!C  Latest modification: March 19, 1990
!C
!C------------------------------------------------------------------
      INTEGER I,JINT
      REAL*8                                                       &
     &     A,ARG,B,C,D,DEL,FOUR,HALF,P,ONE,Q,RESULT,SIXTEN,SQRPI,  &
     &     TWO,THRESH,X,XBIG,XDEN,XHUGE,XINF,XMAX,XNEG,XNUM,XSMALL,&
     &     Y,YSQ,ZERO
      DIMENSION A(5),B(4),C(9),D(8),P(6),Q(5)
!C------------------------------------------------------------------
!C  Mathematical constants
!C------------------------------------------------------------------
      DATA FOUR,ONE,HALF,TWO,ZERO/4.0D0,1.0D0,0.5D0,2.0D0,0.0D0/,  &
     &     SQRPI/5.6418958354775628695D-1/,THRESH/0.46875D0/,      &
     &     SIXTEN/16.0D0/
!C------------------------------------------------------------------
!C  Machine-dependent constants
!C------------------------------------------------------------------
!!HBS: MODIFIED 090818-1434:
!!
!!                          XMIN       XINF        XNEG     XSMALL
!!  VAX D-Format  (D.P.)  2.94D-39    1.70D+38     -9.345  1.39D-17
!!
!!                          XBIG       XHUGE       XMAX
!!  VAX D-Format  (D.P.)   9.269      1.90D+8     1.70D+38
!!
      DATA XINF,XNEG,XSMALL/1.70d38,-9.345d0,1.39d-17/,           &
     &     XBIG,XHUGE,XMAX/9.269d0,1.90d8,1.70d38/
!!
!! Original settings:
!!    DATA XINF,XNEG,XSMALL/1.79D308,-26.628D0,1.11D-16/,          &
!!   &     XBIG,XHUGE,XMAX/26.543D0,6.71D7,2.53D307/
!!:HBS
!C------------------------------------------------------------------
!C  Coefficients for approximation to  erf  in first interval
!C------------------------------------------------------------------
      DATA A/3.16112374387056560D00,1.13864154151050156D02,        &
     &       3.77485237685302021D02,3.20937758913846947D03,        &
     &       1.85777706184603153D-1/
      DATA B/2.36012909523441209D01,2.44024637934444173D02,        &
     &       1.28261652607737228D03,2.84423683343917062D03/
!C------------------------------------------------------------------
!C  Coefficients for approximation to  erfc  in second interval
!C------------------------------------------------------------------
      DATA C/5.64188496988670089D-1,8.88314979438837594D0,         &
     &       6.61191906371416295D01,2.98635138197400131D02,        &
     &       8.81952221241769090D02,1.71204761263407058D03,        &
     &       2.05107837782607147D03,1.23033935479799725D03,        &
     &       2.15311535474403846D-8/
      DATA D/1.57449261107098347D01,1.17693950891312499D02,        &
     &       5.37181101862009858D02,1.62138957456669019D03,        &
     &       3.29079923573345963D03,4.36261909014324716D03,        &
     &       3.43936767414372164D03,1.23033935480374942D03/
!C------------------------------------------------------------------
!C  Coefficients for approximation to  erfc  in third interval
!C------------------------------------------------------------------
      DATA P/3.05326634961232344D-1,3.60344899949804439D-1,        &
     &       1.25781726111229246D-1,1.60837851487422766D-2,        &
     &       6.58749161529837803D-4,1.63153871373020978D-2/
      DATA Q/2.56852019228982242D00,1.87295284992346047D00,        &
     &       5.27905102951428412D-1,6.05183413124413191D-2,        &
     &       2.33520497626869185D-3/
!C------------------------------------------------------------------
      X = ARG
!!HBS:
      Y = DABS(X)
      IF (Y .LE. THRESH) THEN
!C------------------------------------------------------------------
!C  Evaluate  erf  for  |X| <= 0.46875
!C------------------------------------------------------------------
            YSQ = ZERO
            IF (Y .GT. XSMALL) YSQ = Y * Y
            XNUM = A(5)*YSQ
            XDEN = YSQ
            DO 20 I = 1, 3
               XNUM = (XNUM + A(I)) * YSQ
               XDEN = (XDEN + B(I)) * YSQ
   20       CONTINUE
            RESULT = X * (XNUM + A(4)) / (XDEN + B(4))
            IF (JINT .NE. 0) RESULT = ONE - RESULT
!!HBS:
            IF (JINT .EQ. 2) RESULT = DEXP(YSQ) * RESULT
            GO TO 800
!C------------------------------------------------------------------
!C  Evaluate  erfc  for 0.46875 <= |X| <= 4.0
!C------------------------------------------------------------------
         ELSE IF (Y .LE. FOUR) THEN
            XNUM = C(9)*Y
            XDEN = Y
            DO 120 I = 1, 7
               XNUM = (XNUM + C(I)) * Y
               XDEN = (XDEN + D(I)) * Y
  120       CONTINUE
            RESULT = (XNUM + C(8)) / (XDEN + D(8))
            IF (JINT .NE. 2) THEN
!!HBS:
               YSQ = DINT(Y*SIXTEN)/SIXTEN
               DEL = (Y-YSQ)*(Y+YSQ)
!!HBS:
               RESULT = DEXP(-YSQ*YSQ) * DEXP(-DEL) * RESULT
            END IF
!C------------------------------------------------------------------
!C  Evaluate  erfc  for |X| > 4.0
!C------------------------------------------------------------------
         ELSE
            RESULT = ZERO
            IF (Y .GE. XBIG) THEN
               IF ((JINT .NE. 2) .OR. (Y .GE. XMAX)) GO TO 300
               IF (Y .GE. XHUGE) THEN
                  RESULT = SQRPI / Y
                  GO TO 300
               END IF
            END IF
            YSQ = ONE / (Y * Y)
            XNUM = P(6)*YSQ
            XDEN = YSQ
            DO 240 I = 1, 4
               XNUM = (XNUM + P(I)) * YSQ
               XDEN = (XDEN + Q(I)) * YSQ
  240       CONTINUE
            RESULT = YSQ *(XNUM + P(5)) / (XDEN + Q(5))
            RESULT = (SQRPI -  RESULT) / Y
            IF (JINT .NE. 2) THEN
!!HBS:
               YSQ = DINT(Y*SIXTEN)/SIXTEN
               DEL = (Y-YSQ)*(Y+YSQ)
!!HBS:
               RESULT = DEXP(-YSQ*YSQ) * DEXP(-DEL) * RESULT
            END IF
      END IF
!C------------------------------------------------------------------
!C  Fix up for negative argument, erf, etc.
!C------------------------------------------------------------------
  300 IF (JINT .EQ. 0) THEN
            RESULT = (HALF - RESULT) + HALF
            IF (X .LT. ZERO) RESULT = -RESULT
         ELSE IF (JINT .EQ. 1) THEN
            IF (X .LT. ZERO) RESULT = TWO - RESULT
         ELSE
            IF (X .LT. ZERO) THEN
               IF (X .LT. XNEG) THEN
                     RESULT = XINF
                  ELSE
!!HBS:
                     YSQ = DINT(X*SIXTEN)/SIXTEN
                     DEL = (X-YSQ)*(X+YSQ)
!!HBS:
                     Y = DEXP(YSQ*YSQ) * DEXP(DEL)
                     RESULT = (Y+Y) - RESULT
               END IF
            END IF
      END IF
!
  800 CONTINUE
!
!
      RETURN
      END
!C---------- Last card of CALERF ----------
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      REAL*8 FUNCTION DERF_anl(X)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!C
!C This subprogram computes approximate values for erf(x).
!C   (see comments heading CALERF).
!C
!C   Author/date: W. J. Cody, January 8, 1985
!C
!C--------------------------------------------------------------------
      INTEGER JINT
      REAL*8           X, RESULT
!C------------------------------------------------------------------
      JINT = 0
      CALL CALERF(X,RESULT,JINT)
      DERF_anl = RESULT
!
!
      RETURN
      END
!C---------- Last card of DERF ----------
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      REAL*8 FUNCTION DERFC_anl(X)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!C
!C This subprogram computes approximate values for erfc(x).
!C   (see comments heading CALERF).
!C
!C   Author/date: W. J. Cody, January 8, 1985
!C
!C--------------------------------------------------------------------
      INTEGER JINT
      REAL*8           X, RESULT
!C------------------------------------------------------------------
      JINT = 1
      CALL CALERF(X,RESULT,JINT)
      DERFC_anl = RESULT
!
!
      RETURN
      END
!C---------- Last card of DERFC ----------
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      REAL*8 FUNCTION DERFCX_anl(X)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!C
!C This subprogram computes approximate values for exp(x*x) * erfc(x).
!C   (see comments heading CALERF).
!C
!C   Author/date: W. J. Cody, March 30, 1987
!C
!C------------------------------------------------------------------
      INTEGER JINT
      REAL*8           X, RESULT
!C------------------------------------------------------------------
      JINT = 2
      CALL CALERF(X,RESULT,JINT)
      DERFCX_anl = RESULT
!
!
      RETURN
      END
!C---------- Last card of DERFCX ----------
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      function dinvnorm(xp_input,jpinp,jclev,jerr)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      implicit none
!
! calls dinvnorm functions of error correction levels jclev=0,1 or2:
!
! jclev=0:
!   z=dinvnorm0(p,...) is a basic rational-function interpolation
!   for the inverse z=R(p) of the cumulative normal distribution
!      p=Q(z)==(1/2)[1+erf(x)]   with  x==z/\sqrt(2)
!   and Gaussian error function
!      erf(x)==(2/\sqrt(\pi)) \int_0^x exp(-t^2) dt
!   i.e., R(p)==dinvnorm is defined so that
!         z=R(p)   <-->  p=Q(z).
!
!   For large |z|-values (i.e. 1-p or p underflow-close to 0), accuracy
!   of dinvnorm0 rat.-func. interpolation is far less than mach. precis.
!   (i.e., systematic interpolation error >> rounding error).
!   This systematic error can be corrected for by passing z through
!   one numerical z->p=Q(z)->zp=R(p) eval./invert cycle to estimate the
!   systematic error as:
!      dzp==zp-z,
!   then calculating corrected z-value:
!      zcorr = z-dzp = 2*z-zp.
!   This correction is implemented by dinvnorm1, with analogous
!   correction of remaining dinvnorm1 systematic errors by dinvnorm2.
!
! jclev=1:
!   dinvnorm1 estimates and corrects systematic errors in
!   output from dinvnorm0. Correction procedure uses dinvnorm0
!   only with jpinp=3 and input ln(p) or ln(1-p), to allow for
!   arb. large z-values without being restricted by
!   p- or (1-p)-underflow. dinvnorm1 requires 2 evals of
!   dinvnorm0, hence is >2 times slower than dinvnorm0.
!
! jclev=2:
!   dinvnorm2 estimates and corrects systematic errors in
!   output from dinvnorm1. Correction procedure uses dinvnorm1
!   only with jpinp=3 and input ln(p) or ln(1-p), to allow for
!   arb. large z-values without being restricted by
!   p- or (1-p)-underflow. dinvnorm2 requires 2 evals of
!   dinvnorm1, i.e., 4 evals of dinvnorm0, hence is >4 times
!   slower than dinvnorm0.
!
      integer jerr, jpinp, jclev
!
      real*8 xp_input
      real*8 dinvnorm
      real*8 dinvnorm0, dinvnorm1, dinvnorm2
!
      if(jclev.eq.0) dinvnorm=dinvnorm0(xp_input,jpinp,jerr)
      if(jclev.eq.1) dinvnorm=dinvnorm1(xp_input,jpinp,jerr)
      if(jclev.eq.2) dinvnorm=dinvnorm2(xp_input,jpinp,jerr)
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      function dinvnorm2(xp_input,jpinp,jerr)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
!
      implicit none
!
      integer jerr, jpinp, jpinp2
!
      real*8 dinvnorm2
      real*8 xp_input,z, zp, zrt2, zprt2, ort2
      real*8 alnp, alnpz, alnprob, alnprobz, alnpbar, alnpbarz
!
      real*8 derfcx_anl, dinvnorm1, dexp, dlog
!
!
      ort2=dsqrt(0.5d0)
      jpinp2=3
!
      z=dinvnorm1(xp_input,jpinp,jerr)
!
      if(z.ge.0.d0) then
        zrt2=z*ort2
        alnpbar=-0.5d0*z**2+dlog(0.5d0*derfcx_anl(zrt2))
!
        zp=dinvnorm1(alnpbar,jpinp2,jerr)
      else
        zrt2=-z*ort2
        alnprob=-0.5d0*z**2+dlog(0.5d0*derfcx_anl(zrt2))
!
        zp=-dinvnorm1(alnprob,jpinp2,jerr)
      endif
!
      dinvnorm2=2.d0*z-zp
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      function dinvnorm1(xp_input,jpinp,jerr)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
!
      implicit none
!
      integer jerr, jpinp, jpinp1
!
      real*8 dinvnorm1
      real*8 xp_input,z, zp, zrt2, zprt2, ort2
      real*8 alnp, alnpz, alnprob, alnprobz, alnpbar, alnpbarz
!
      real*8 derfcx_anl, dinvnorm0, dexp, dlog
!
!
      ort2=dsqrt(0.5d0)
      jpinp1=3
!
      z=dinvnorm0(xp_input,jpinp,jerr)
!
      if(z.ge.0.d0) then
        zrt2=z*ort2
        alnpbar=-0.5d0*z**2+dlog(0.5d0*derfcx_anl(zrt2))
!
        zp=dinvnorm0(alnpbar,jpinp1,jerr)
      else
        zrt2=-z*ort2
        alnprob=-0.5d0*z**2+dlog(0.5d0*derfcx_anl(zrt2))
!
        zp=-dinvnorm0(alnprob,jpinp1,jerr)
      endif
!
      dinvnorm1=2.d0*z-zp
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      function dinvnorm0(xp_input,jpinp,jerr)
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! ren-raw chen, rutgers business school
! normal inverse
! translated from
! http://home.online.no/~pjacklam/notes/invnorm
! a routine written by john herrero
!
! modified by HBSchuttler to accept ln of near-zero
! p- or (1-p) arguments, instead of p only, etc.
!
!HBS:
! This function calculates the
!     Inverse of the Cumulative Standardized Normal Distribution
! i.e., not the inverse of the errror function!
! (Modified by HBS 090818-1347)
!
! Let...
! Cumulative standardized normal Q and inverse R be given by:
!     Q(z) = (1/2)[1+erf(z/\sqrt(2))]  for  -\inf < z < \inf
!     R=Q^{-1}:  R(p)=z <==> Q(z)=p    for      0 < p < 1
! Then:
!     dinvnorm0(xp_input,jpinp,jclev,jerr) ~== R(p)
! where
!     derf(x) == erf(x) (built-in real*8 Fortran error function)
! and
!     erf(x) = (2/\sqrt(\pi)) \int_0^x exp(-s^2) ds
! and the cumulative Q(z) corresponds to the standardized
! normal (Gaussian) distribution function
!     P(z) = dQ(z)/dz = (2\sqrt(\pi))^{-1} exp(-z^2/2)
!
! Output:
!   z==dinvnorm0
!
! Input:
! Value for p can be passed to this function via argument xp_input
! in three different formats:
! jpinp=1:
!   p = xp_input
! jpinp=2:
!   pbar==1-p = xp_input,   p=1-pbar
! jpinp=3:
!   alnpbar==ln(1-p) = xp_input,  pbar=exp(alnpbar),  p=1-pbar
!
! Options jpinp=2,3 are provided to avoid underflow problems when
! expected output value is very large, |z| >>1, and therefore,
! input value of p is very close (within rounding error) of 1, or
! worse, when pbar=1-p is underflowing and only ln(pbar), but not
! pbar itself, can be accurately stored. This scenario arises, for
! example, when using this function to generate Gaussian-, or
! truncated-Gaussian-distributed random numbers which are far from
! the mean, in the tails of the Gaussian bell curve. In that case,
! p and pbar themselves are defined as superpositions of error functions
! erf(x). One must then use the erf(x)-expression for p or pbar
! to directly calculate
!   alnpbar==ln(1-p)
! in terms of the "scaled complementary error function"
!   erfcx(x) == exp(x^2) * [1-erf(x)]
! without actually calculating or storing precise p or  pbar. Then
! use jpinp=3 to calculate z=dinvnorm directly from alnpbar, without
! storing or using precise values of p or pbar. This will avoid loss
! of precision due to underflowing pbar, or p=1-pbar being swamped
! by rounding errors. Recall here that, asymptotically,
!   1-erf(x) ~= (1/\sqrt(\pi))*exp(-x^2)/x*[1+O(1/x^2)]; x==z/sqrt(2)
! for x-->\infinity. This is the cause of the foregoing undeflow
! problems which can be severe already for moderate x-values,
! (|x|>5, say). Since erfcx(x) has a more benign asymptotic
! behavior, namely,
!   erfcx(x) ~= (1/\sqrt(\pi))*(1/x)*[1+ O(1/x^2)];  x==z/sqrt(2),
! it is easier to calculate and store precise erfcx-values,
! even for very large positive x-argument values.
!
! Using jpinp=2 is actually discouraged: better use jpinp=3
! if expected |z| gets very large, i.e., p gets very close to 1.
! jpinp=3 covers a much wider range of |z|. For moderate-to-small
! z- and p-values, with z>0, i.e. p>1/2, use jpinp=1, if p is given,
! since it's faster. For z<0, i.e. p<1/2, calculate first
!   -z = R(1-p) == R(pbar)
! using the symmetry relation R(1-p)=-R(p), and using pbar=1-p>1/2
! instead of p.
!:HBS
!
      implicit none
!
      integer jerr, jpinp
!
      real*8 dinvnorm0,dexp
      real*8 p,p_low,p_high,pbar,alnpbar,xp_input
      real*8 a1,a2,a3,a4,a5,a6
      real*8 b1,b2,b3,b4,b5
      real*8 c1,c2,c3,c4,c5,c6
      real*8 d1,d2,d3,d4
      real*8 z,q,r
!
!
      a1=-39.6968302866538d0
      a2=220.946098424521d0
      a3=-275.928510446969d0
      a4=138.357751867269d0
      a5=-30.6647980661472d0
      a6=2.50662827745924d0
      b1=-54.4760987982241d0
      b2=161.585836858041d0
      b3=-155.698979859887d0
      b4=66.8013118877197d0
      b5=-13.2806815528857d0
      c1=-0.00778489400243029d0
      c2=-0.322396458041136d0
      c3=-2.40075827716184d0
      c4=-2.54973253934373d0
      c5=4.37466414146497d0
      c6=2.93816398269878d0
      d1=0.00778469570904146d0
      d2=0.32246712907004d0
      d3=2.445134137143d0
      d4=3.75440866190742d0
!
!HBS:
      jerr=0
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Case 1,2; jpinp=1 or 2, xp_input is p or pbar==1-p:
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      if(jpinp.eq.1) then
        p=xp_input
        pbar=1.d0-p
        goto 101
      endif
      if(jpinp.eq.2) then
        pbar=xp_input
        p=1.d0-pbar
        goto 101
      endif
      goto 103
!
  101 continue
! input error check
      if(xp_input.le.0.d0.or.xp_input.ge.1.d0) then
        dinvnorm0=1.0d25
        if(xp_input.le.0.d0) jerr=1
        if(xp_input.ge.1.d0) jerr=2
        if(jpinp.eq.2) jerr=3-jerr
        goto 905
      endif
      goto 104
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Case 3; jpinp=3, xp_input is ln(1-p):
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  103 continue
      if(jpinp.eq.3) then
        alnpbar=xp_input
        if(alnpbar.gt.-18.d0) then
          pbar=dexp(alnpbar)
          p=1.d0-pbar
        else
!!        pbar=dexp(-18.d0)
          pbar=1.522997974d-8
          p=1.d0-pbar
!          Note: p is used here only to direct code to the "p>p_high" case;
!          only the input value of alnpbar==ln(1-p), but not the values stored
!          in p or pbar, is/are then used to actually calculate z==dinvnorm0
        endif
      endif
!
! input error check
      if(xp_input.ge.0.d0) then
        dinvnorm0=1.0d26
        jerr=3
        goto 905
      endif
      goto 104
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Case 4; jpinp is invalid:
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      jerr=4
      dinvnorm0=-1.0d25
      goto 905
!:HBS
!
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Calculate z==dinvnorm0 from p, pbar or alnpbar
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  104 continue
      p_low=0.02425d0
      p_high=1.d0-p_low
!
!!HBS: NOT NEEDED
!!    if(p.lt.p_low) goto 201
!!    if(p.ge.p_low) goto 301
!!:HBS
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 0 < p < p_low:
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!201 continue
      if(p.lt.p_low) then
        q=dsqrt(-2.d0*dlog(p))
        z=(((((c1*q+c2)*q+c3)*q+c4)*q+c5)*q+c6)/                 &
     &  ((((d1*q+d2)*q+d3)*q+d4)*q+1)
        goto 204
      endif
!
!
!!301 continue
!!HBS: NOT NEEDED
!!    if((p.ge.p_low).and.(p.le.p_high)) goto 202
!!    if(p.gt.p_high) goto 302
!
!!:HBS
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! p_low =< p =< p_high:
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!202 continue
      if((p.ge.p_low).and.(p.le.p_high)) then
        q=p-0.5d0
        r=q*q
        z=(((((a1*r+a2)*r+a3)*r+a4)*r+a5)*r+a6)*q/                 &
     &  (((((b1*r+b2)*r+b3)*r+b4)*r+b5)*r+1.d0)
        goto 204
      endif
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! p_high < p <1:
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!302 continue
!
!!HBS: NOT NEEDED
!!    if((p.gt.p_high).and.(p.lt.1.d0)) goto 203
!!203 continue
!!:HBS
!
      if(p.gt.p_high) then
!!HBS: MODIFIED
!!      q=dsqrt(-2.d0*dlog(1.d0-p))
        if(jpinp.le.2) q=dsqrt(dabs(2.d0*dlog(dabs(pbar))))
        if(jpinp.eq.3) q=dsqrt(dabs(2.d0*alnpbar))
!!:HBS
        z=-(((((c1*q+c2)*q+c3)*q+c4)*q+c5)*q+c6)/                 &
     &  ((((d1*q+d2)*q+d3)*q+d4)*q+1.d0)
      endif
!
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
  204 continue
      dinvnorm0=z
!
  905 continue
!
!
      return
      end
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!    RNG Test Routines
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine test_ran
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! (A) Testing uniform RNG "randx()", "srandx"
!
      call ts_randx
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! (B) Testing inverse function "dinvnorm" of cumulative normal
! (Gaussian) distribution of unit standard deviation, \sigma=1.
! Correct inverse is checked by testing that
!      |p-pz| << 1  and  |z-zp| << 1
! in output from ts_dinvnorm
!
! Also testing scaled complementary error function "derfcx_anl"
! by comparison to exp(x**2)*[1-derf(x)] in non-overflow x-range
!
!!    call ts_dinvnorm
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! (C) Testing truncated Gaussian RNG "tgauss"
!
!!    call ts_tgauss
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
      stop
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ts_randx
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
!     uniform RNG Tester
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      integer nbin, nrand, mrand, jrand, mcmax, ibin, i2sig, n2sig, kr, ir
      integer mcount(1:20000), movflo(1:20000), ibin2s(1:20000)
!
      real*8 crand, abin, c2sig, d2sig, dfcount, r1
      real*8 fcount(1:20000)
!
      real*8 ranvec(20007)
!
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!     Testing Fibonacci only, following instructions:
! Use IJ = 1802 & KL = 9373 to test the random number generator.
! The subrt. RANMAR should be used to generate 20000 random
! numbers.
! Then display the next six random numbers generated multiplied by
! 4096*4096.
! If the random number generator is working properly, the random
! numbers
! should be:
!           6533892.0  14220222.0  7275067.0
!           6172232.0  8354498.0   10633180.0
!
!
      fcount(1)= 6533892.0
      fcount(2)= 14220222.0
      fcount(3)= 7275067.0
!
      fcount(4)= 6172232.0
      fcount(5)= 8354498.0
      fcount(6)= 10633180.0
!
      ir=1802
      kr=9373
      call RMARIN(ir,kr)
!
      ibin=20006
      call ranmar(ranvec,ibin)
!
      write(*,*) ' '
      write(*,*) 'Testing Fibonacci, after 20000 RNs, 1 "ranmar"-call'
      write(*,*) ' (4096^2)*randx: ...(IS), ...(SHOULD)='
!
      abin=4096*4096
      do ibin=1,6
        crand=ranvec(20000+ibin)*abin
        write(*,*) crand, fcount(ibin)
      enddo
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
      ir=1802
      kr=9373
      call RMARIN(ir,kr)
!
      ibin=20000
      call ranmar(ranvec,ibin)
      ibin=6
      call ranmar(ranvec,ibin)
!
      write(*,*) ' '
      write(*,*) 'Testing Fibonacci, after 20000 RNs, 2 "ranmar"-calls'
      write(*,*) ' (4096^2)*randx: ...(IS), ...(SHOULD)='
!
      abin=4096*4096
      do ibin=1,6
        crand=ranvec(ibin)*abin
        write(*,*) crand, fcount(ibin)
      enddo
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!
      write(*,*) ' '
      write(*,*) ' '
      write(*,*) 'skipping all *odd* rands, jrand=1'
      write(*,*) ' '
!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Inputs
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!
!! Testing ens-run b18 RNG seeds:
!!nmc_rep jmc_eql nmc_eql nmc_acc nmc_upd imc_ran npow_sp npow_re   jrand  iseed2
!!      1      21       1       1       0 9462758       2       2       1       1
!!
      iseed1=9462758
      iseed2=1
!
      nbin=10000
      nrand=1000000
      mrand=1
      jrand=1
      mcmax=1000000
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
      call srandx(iseed1,iseed2,jrand)
!
      do ibin=1,nbin
        mcount(ibin)=0
        movflo(ibin)=0
      enddo
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!! skipping odd rands by extra randx-calls:
!!!!  r1=randx()
      do kr=1,mrand
        do ir=1,nrand
          r1=randx()
          abin=nbin*randx()+1.d0
          ibin=abin
          if(ibin.lt.1) ibin=1
          if(ibin.gt.nbin) ibin=nbin
          mcount(ibin)=mcount(ibin)+1
          if(mcount(ibin).eq.mcmax) then
            mcount(ibin)=0
            movflo(ibin)=movflo(ibin)+1
          endif
        enddo
      enddo
!
!
      crand=mrand*nrand
      c2sig=crand/nbin
      d2sig=2.d0/sqrt(c2sig)
!
!
      write(*,*) 'iseed1,iseed2=', iseed1,iseed2
      write(*,*) 'nbin,nrand,mrand,jrand,mcmax=',nbin,nrand,mrand,jrand,mcmax
      write(*,*) ' '
      write(*,*) 'ibin,fcount(ibin)-1='
!
      i2sig=0
      do ibin=1,nbin
        abin=mcmax*movflo(ibin)
        abin=abin+mcount(ibin)
        abin=abin/crand
        fcount(ibin)=abin*nbin
        dfcount=fcount(ibin)-1.d0
!
        if(dabs(dfcount).le.d2sig) then
          write(*,*) ibin,dfcount
        else
          i2sig=i2sig+1
          ibin2s(i2sig)=ibin
          write(*,*) ibin,dfcount,' 2SIG'
        endif
      enddo
      n2sig=i2sig
!
!
      write(*,*) ' '
      write(*,*) ' '
      write(*,*) '2Std.Dev.(SD)==d2sig, n2sig=', d2sig,n2sig
      write(*,*) 'bins with deviation > 2SD:'
      write(*,*) 'i2sig, ibin, fcount-1='
!
      do i2sig=1,n2sig
        ibin=ibin2s(i2sig)
        dfcount=fcount(ibin)-1.d0
        write(*,*) i2sig, ibin, dfcount
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ts_dinvnorm
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      implicit none
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! Testing inverse function "dinvnorm" of cumulative normal
! (Gaussian) distribution of unit standard deviation, \sigma=1.
! Correct inverse is checked by testing that
!      |p-pz| << 1  and  |z-zp| << 1
! in output below.
!
! Also testing scaled complementary error function "derfcx_anl"
! by comparison to exp(x**2)*[1-derf(x)] in non-overflow x-range
!
! Cumulative standardized normal Q and inverse R:
!     Q(z) = (1/2)[1+erf(z/\sqrt(2))]  for  -\inf < z < \inf
!     R=Q^{-1}:  R(p)=z <==> Q(z)=p    for      0 < p < 1
! Then:
!     dinvnorm(p,jpinp,jclev,jerr) == R(p)
! where
!     derf(x) == erf(x) (built-in real*8 Fortran error function)
! and
!     erf(x) = (2/\sqrt(\pi)) \int_0^x exp(-s^2) ds
! and the cumulative Q(z) corresponds to the standardized
! normal (Gaussian) distribution function
!     P(z) = dQ(z)/dz = (2\sqrt(\pi))^{-1} exp(-z^2/2)
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
      integer jerr1, jerr2, ip, np, iz, nz, jpinp, jdpstp, jlogp, jclev
!
      real*8 p, z, zrt2, pz, zp, dp, plo, phi, pi, rt2, rtpi_o2
      real*8 zlo, zhi, dz, anp, pbar, ex2erfc, erfcx_z
      real*8 ez, ortpi, oz, erfcx_as1, erfcx_as2
      real*8 zplo, zphi, dzp, zp0rt2, zp0
      real*8 alnp, alnpz, alnprob, alnprobz, alnpbar, alnpbarz
!
      real*8 derf, datan, derfcx_anl, dinvnorm, dexp, dlog
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
      zplo=-1000.d0
      zphi=+1000.d0
      np=500
!
      plo=1.d-20
      phi=1.d0-1.d-16
!
      jlogp=1
      jclev=1
      jdpstp=1
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
      pi=4.d0*datan(1.d0)
      rt2=dsqrt(2.d0)
      rtpi_o2=dsqrt(pi)/2.d0
      ortpi=1.d0/dsqrt(pi)
!
      anp=np
      if(jdpstp.eq.0) dp=(phi-plo)/(1.d0*anp)
      if(jdpstp.eq.1) dp=(phi/plo)**(1.d0/(1.d0*anp))
      dzp=(zphi-zplo)/(1.d0*anp)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!!
!!    testing "dinvnorm" for cases jpinp=1,2,3, using z- and p-values
!!
      if(jlogp.eq.0) then
        do jpinp=1,3
!
          write(*, 310) np,jpinp,jclev
  310     format(                                                   &
     &    /' Testing "dinvnorm" for np,jpinp,jclev='                &
     &    /3i8                                                      &
     &    /'                   p                   z je1 je2'       &
     &    )
!
          if(jdpstp.eq.0) p=plo-2*dp
          if(jdpstp.eq.1) p=plo/dp**2
!
          do ip=-1,np+1
            if(jdpstp.eq.0) p=p+dp
            if(jdpstp.eq.1) p=p*dp
!
            if(jpinp.eq.1) then
              z=dinvnorm(p,jpinp,jclev,jerr1)
              zrt2=z/rt2
              pz=0.5d0*(1.d0+derf(zrt2))
              zp=dinvnorm(pz,jpinp,jclev,jerr2)
            endif
!
            if(jpinp.eq.2) then
              pbar=1.d0-p
              z=dinvnorm(pbar,jpinp,jclev,jerr1)
              zrt2=z/rt2
              pz=0.5d0*(1.d0+derf(zrt2))
              pbar=1.d0-pz
              zp=dinvnorm(pbar,jpinp,jclev,jerr2)
            endif
!
            if(jpinp.eq.3) then
              alnpbar=dlog(1.d0-p)
              z=dinvnorm(alnpbar,jpinp,jclev,jerr1)
              zrt2=z/rt2
              pz=0.5d0*(1.d0+derf(zrt2))
              alnpbar=dlog(1.d0-pz)
              zp=dinvnorm(alnpbar,jpinp,jclev,jerr2)
            endif
!
            write(*, 312) p, z, pz, zp, jerr1, jerr2
  312       format(/2d20.12/2d20.12,2i4)
          enddo
        enddo
      endif
!
!
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!
!!    testing "dinvnorm" jpinp=3, using z- and ln(1-p) or ln(p)-values
!!    for arbitrily large |z|-values where either p or 1-p underflows
!!
      if(jlogp.eq.1) then
          jpinp=3
!
          write(*, 410) np,jpinp,jclev
  410     format(                                                   &
     &    /' Testing "dinvnorm" for np,jpinp,jclev='                &
     &    /3i8                                                      &
     &    /' ln(p)|z<0 or ln(1-p)|z>0              z je1 je2'       &
     &    )
!
          do ip=0,np
            zp0=zplo+ip*dzp
!
            if(zp0.ge.0.d0) then
              zp0rt2=zp0/rt2
              alnpbarz=dlog(0.5d0)-0.5d0*zp0**2+dlog(derfcx_anl(zp0rt2))
!
              z=dinvnorm(alnpbarz,jpinp,jclev,jerr1)
!
              zrt2=z/rt2
              alnpbar=dlog(0.5d0)-0.5d0*z**2+dlog(derfcx_anl(zrt2))
!
              zp=dinvnorm(alnpbar,jpinp,jclev,jerr2)
!
              alnpz=alnpbarz
              alnp=alnpbar
            else
              zp0rt2=-zp0/rt2
              alnprobz=dlog(0.5d0)-0.5d0*zp0**2+dlog(derfcx_anl(zp0rt2))
!
              z=-dinvnorm(alnprobz,jpinp,jclev,jerr1)
!
              zrt2=-z/rt2
              alnprob=dlog(0.5d0)-0.5d0*z**2+dlog(derfcx_anl(zrt2))
!
              zp=-dinvnorm(alnprob,jpinp,jclev,jerr2)
!
              alnpz=alnprobz
              alnp=alnprob
            endif
!
            write(*, 412) alnp, z, alnpz, zp, jerr1, jerr2
  412       format(/2d20.12/2d20.12,2i4)
          enddo
      endif
!
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!     testing "derfcx_anl"
!
      nz=220
      zlo=-10.d0
      zhi=+100.d0
!
      dz=nz
      dz=(zhi-zlo)/(1.d0*dz)
!
      write(*, 320)
  320 format(/'                   z    (rt(pi)/2)erf(z)'            &
     &       ,' exp(x**2)*[1-erf(z)]      derfcx_anl(z)'            &
     &       /40x                                                   &
     &       ,'           erfcx_as1           erfcx_as2'            &
     &)
!
      do iz=0,nz
        z=zlo+iz*dz
        ez=rtpi_o2*derf(z)
!
        ex2erfc=dexp(z**2)*(1.d0-derf(z))
        erfcx_z=derfcx_anl(z)
!
        oz=1.d0/(dabs(z)+1.d-40)
        erfcx_as1=ortpi*oz
        erfcx_as2=ortpi*oz*(1.d0-0.5d0*oz**2)
!
        write(*, 322) z, ez, ex2erfc, erfcx_z, erfcx_as1, erfcx_as2
  322   format(4d20.12/40x,2d20.12)
      enddo
!
!
      return
      end
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine ts_tgauss
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
      implicit none
!
!     truncated Gaussian RNG Tester
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
      integer nbin, nrand, mrand, jrand, mcmax, ibin, i2sig, n2sig, kr, ir
      integer jerrivn, jerrtg, nerrivn, nerrtg, nerrtg_lo, nerrtg_hi
      integer iseed1, iseed2, jzlohi, jpoiss, jclev
      integer mcount(0:20001), movflo(0:20001), ibin2s(0:20001)
!
      real*8 crand, abin, cbin, pbin, zbin, c2sig, d2sig, dfcount
      real*8 zran, zlo, zhi, dz, odz, ort2, z1, z2, erfz1, erfz2
      real*8 oderf, erflo, erfhi, evzlo, evzhi
      real*8 derf, derfcx_anl, dexp
      real*8 fcount(0:20001), pcount(0:20001)
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!
!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Inputs
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!
      zlo=1000.000000d0
      zhi=1000.050000d0
!
      jclev=2
      jpoiss=1
!
      nbin=500
      nrand=1000000
      mrand=25
      jrand=1
      mcmax=1000000
!
      iseed1=4167
      iseed2=1
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Preps
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
      ort2=sqrt(0.5d0)
      dz=(zhi-zlo)/(1.d0*nbin)
      odz=1.d0/dz
!
      call srandx(iseed1,iseed2,jrand)
!
      do ibin=0,(nbin+1)
        mcount(ibin)=0
        movflo(ibin)=0
      enddo
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Accum. Run RNG
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      nerrivn=0
      nerrtg=0
      nerrtg_lo=0
      nerrtg_hi=0
      do kr=1,mrand
        do ir=1,nrand
          call tgauss(zran,zlo,zhi,jpoiss,jclev,jerrivn,jerrtg)
          if(jerrivn.ne.0) nerrivn=nerrivn+1
          if(jerrtg.ne.0) nerrtg=nerrtg+1
          if(jerrtg.eq.10) nerrtg_lo=nerrtg_lo+1
          if(jerrtg.eq.11) nerrtg_hi=nerrtg_hi+1
!
          if(kr.le.2.and.ir.le.10)                                 &
      &   write(*,*) 'jerrivn,jerrtg,zran=', jerrivn,jerrtg,zran
!
          if(zran.lt.zlo) then
            ibin=0
            goto 19
          endif
          if(zran.ge.zhi) then
            ibin=nbin+1
            goto 19
          endif
!
          abin=(zran-zlo)*odz
          ibin=abin
          ibin=ibin+1
          if(ibin.lt.1) ibin=0
          if(ibin.gt.nbin) ibin=nbin+1
!
   19     continue
          mcount(ibin)=mcount(ibin)+1
          if(mcount(ibin).eq.mcmax) then
            mcount(ibin)=0
            movflo(ibin)=movflo(ibin)+1
          endif
        enddo
      enddo
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Analyze+Output
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
      if(zhi*zlo.le.0.d0) then
        jzlohi=0
        evzlo=1.d0
        evzhi=1.d0
        erflo=derf((zlo*ort2))
        erfhi=derf((zhi*ort2))
        oderf=1.d0/( erfhi - erflo )
      endif
      if(zlo.gt.0.d0) then
        jzlohi=+1
        evzlo=1.d0
        evzhi=dexp((-zhi**2+zlo**2)*0.5d0)
        erflo=      derfcx_anl((zlo*ort2))
        erfhi=evzhi*derfcx_anl((zhi*ort2))
        oderf=1.d0/( erflo - erfhi )
      endif
      if(zhi.lt.0.d0) then
        jzlohi=-1
        evzlo=dexp((-zlo**2+zhi**2)*0.5d0)
        evzhi=1.d0
        erflo=evzlo*derfcx_anl((-zlo*ort2))
        erfhi=      derfcx_anl((-zhi*ort2))
        oderf=1.d0/( erfhi - erflo )
      endif
!
      crand=mrand*nrand
!!    c2sig=crand/nbin
!!    d2sig=2.d0/sqrt(c2sig)
!
!
      write(*,*) '  '
      write(*,*) 'Truncated Gaussian RNG'
      write(*,*) 'zlo, zhi=', zlo,zhi
      write(*,*) 'jpoiss, jclev, oderf, erflo, erfhi='                   &
     &           ,jpoiss, jclev, oderf, erflo, erfhi
      write(*,*) 'nbin,nrand,mrand,jrand,mcmax=',nbin,nrand,mrand,jrand,mcmax
      write(*,*) 'iseed1,iseed2=', iseed1,iseed2
      write(*,*) 'nerrivn,nerrtg, nerrtg_lo, nerrtg_hi=', nerrivn,nerrtg, nerrtg_lo, nerrtg_hi
      write(*,*) ' '
      write(*,*) '  ibin            zbin           count(ibin)'       &
     &          ,'          pcount(ibin)        fcount(ibin)-1'
!
      i2sig=0
      do ibin=0,(nbin+1)
        cbin=mcmax*movflo(ibin)
        cbin=cbin+mcount(ibin)
        pcount(ibin)=cbin/crand
!
        pbin=-1.d0
        d2sig=1.0d20
        fcount(ibin)=-pcount(ibin)
        dfcount=fcount(ibin)
        if(ibin.eq.0) zbin=zlo-dz*0.5d0
        if(ibin.eq.(nbin+1)) zbin=zhi+dz*0.5d0
!
        if(ibin.ge.1.and.ibin.le.nbin) then
          z1=zlo+(ibin-1)*dz
          z2=z1+dz
!
          if(jzlohi.eq.0) then
            pbin=oderf*(derf(z2*ort2)-derf(z1*ort2))
          endif
          if(jzlohi.eq.+1) then
            erfz1=dexp((-z1**2+zlo**2)*0.5d0)*derfcx_anl((z1*ort2))
            erfz2=dexp((-z2**2+zlo**2)*0.5d0)*derfcx_anl((z2*ort2))
            pbin=oderf*(erfz1-erfz2)
          endif
          if(jzlohi.eq.-1) then
            erfz1=dexp((-z1**2+zhi**2)*0.5d0)*derfcx_anl((-z1*ort2))
            erfz2=dexp((-z2**2+zhi**2)*0.5d0)*derfcx_anl((-z2*ort2))
            pbin=oderf*(erfz2-erfz1)
          endif
!
          zbin=0.5d0*(z1+z2)
!
          fcount(ibin)=pcount(ibin)/pbin
          dfcount=fcount(ibin)-1.d0
!
          c2sig=pbin*crand
          d2sig=2.d0/sqrt(c2sig)
        endif
!
        if(dabs(dfcount).le.d2sig.or.                    &
     &  ibin.eq.0.or.ibin.eq.(nbin+1)) then
          write(*,3010) ibin, zbin,cbin,pcount(ibin),dfcount
 3010     format(i6,f16.8,3d22.12)
        else
          i2sig=i2sig+1
          ibin2s(i2sig)=ibin
          write(*,3012) ibin,zbin,cbin,pcount(ibin),dfcount
 3012     format(i6,f16.8,3d22.12,'  2SIG')
        endif
      enddo
      n2sig=i2sig
!
!
      write(*,*) ' '
      write(*,*) ' '
      write(*,*) '2Std.Dev.(SD)==d2sig, n2sig=', d2sig,n2sig
      write(*,*) 'bins with deviation > 2SD:'
      write(*,*)  'i2sig  ibin                 count'    &
     &,'                pcount              fcount-1='
!
      do i2sig=1,n2sig
        ibin=ibin2s(i2sig)
!
        cbin=mcmax*movflo(ibin)
        cbin=cbin+mcount(ibin)
!
        dfcount=fcount(ibin)-1.d0
!
        write(*,3020) i2sig, ibin, cbin, pcount(ibin), dfcount
 3020     format(2i6,3d22.12)
      enddo
!
!
      return
      end
!
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! FINISHED: PACKAGE OF RNGs
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
! DLSODES PACKAGE
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
!-----------------------------------------------------------------------
! Other routines in the DLSODES package.
!
! In addition to Subroutine DLSODES, the DLSODES package includes the
! following subroutines and function routines:
!  DIPREP   acts as an iterface between DLSODES and DPREP, and also does
!           adjusting of work space pointers and work arrays.
!  DPREP    is called by DIPREP to compute sparsity and do sparse matrix
!           preprocessing if MITER = 1 or 2.
!  JGROUP   is called by DPREP to compute groups of Jacobian column
!           indices for use when MITER = 2.
!  ADJLR    adjusts the length of required sparse matrix work space.
!           It is called by DPREP.
!  CNTNZU   is called by DPREP and counts the nonzero elements in the
!           strict upper triangle of J + J-transpose, where J = df/dy.
!  DINTDY   computes an interpolated value of the y vector at t = TOUT.
!  DSTODE   is the core integrator, which does one step of the
!           integration and the associated error control.
!  DCFODE   sets all method coefficients and test constants.
!  DPRJS    computes and preprocesses the Jacobian matrix J = df/dy
!           and the Newton iteration matrix P = I - h*l0*J.
!  DSOLSS   manages solution of linear system in chord iteration.
!  DEWSET   sets the error weight vector EWT before each step.
!  DVNORM   computes the weighted RMS-norm of a vector.
!  DSRCMS   is a user-callable routine to save and restore
!           the contents of the internal Common blocks.
!  ODRV     constructs a reordering of the rows and columns of
!           a matrix by the minimum degree algorithm.  ODRV is a
!           driver routine which calls Subroutines MD, MDI, MDM,
!           MDP, MDU, and SRO.  See Ref. 2 for details.  (The ODRV
!           module has been modified since Ref. 2, however.)
!  CDRV     performs reordering, symbolic factorization, numerical
!           factorization, or linear system solution operations,
!           depending on a path argument ipath.  CDRV is a
!           driver routine which calls Subroutines NROC, NSFC,
!           NNFC, NNSC, and NNTC.  See Ref. 3 for details.
!           DLSODES uses CDRV to solve linear systems in which the
!           coefficient matrix is  P = I - con*J, where I is the
!           identity, con is a scalar, and J is an approximation to
!           the Jacobian df/dy.  Because CDRV deals with rowwise
!           sparsity descriptions, CDRV works with P-transpose, not P.
!  DUMACH   computes the unit roundoff in a machine-independent manner.
!  XERRWD, XSETUN, XSETF, IXSAV, and IUMACH  handle the printing of all
!           error messages and warnings.  XERRWD is machine-dependent.
! Note:  DVNORM, DUMACH, IXSAV, and IUMACH are function routines.
! All the others are subroutines.
!
!-----------------------------------------------------------------------
!DECK DLSODES
      SUBROUTINE DLSODES (NEQ, Y, T, TOUT                               &
     &                   , ITOL, RTOL, ATOL, ITASK                      &
     &                   , ISTATE, IOPT, RWORK, LRW, IWORK, LIW, MF     &
!                        , FDRIV, FDJAC
!
     &                ,time_i_fs,xspec_i                                &
     &                ,vfor,vbak,xspec_min,xspec_max                    &
     &                ,yspec_min_vs,yspec_max_vs                        &
     &                ,wspec_vs_min,wspec_vs_max                        &
     &                ,frlim_vs_min,frlim_vs_max                        &
     &                ,rkfor,rkbak,rkfor2,rkbak2                        &
     &                ,odtime_rl,jkin,jrlim                             &
     &                ,lvfor,lvbak,lvreac                               &
     &                ,iispec,iospec,nipart,nopart                      &
     &                ,hicoop,hocoop                                    &
     &                ,iispec_vs,iospec_vs,nipart_vs,nopart_vs          &
     &                ,gimult_vs,gomult_vs,iivs_vs,iovs_vs              &
     &                ,nspec,nreac,nfs_spec,nvs_spec                    &
     &                ,ispec_fs,ispec_vs,nlim_drv,n_drv,k_drv           &
     &                ,jtevol,jfox,jfix,npulse,nperiod                  &
     &                ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod    &
     &                ,npmspec_x                                        &
     &                ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x)
!
!     EXTERNAL FDRIV, FDJAC
      INTEGER NEQ, ITOL, ITASK, ISTATE, IOPT, LRW, IWORK, LIW, MF
      REAL*8 Y, T, TOUT, RTOL, ATOL, RWORK
      DIMENSION NEQ(*), Y(*), RTOL(*), ATOL(*), RWORK(LRW), IWORK(LIW)
!
! "dRIVS" suppl. arg-list:
      integer                                                           &
     &                 jrlim                                            &
     &                ,nspec                                            &
     &                ,nreac                                            &
     &                ,nfs_spec                                         &
     &                ,nvs_spec                                         &
     &                ,nlim_drv,n_drv,k_drv                             &
     &                ,jtevol                                           &
     &                ,npmspec_x                                        &
     &                ,nspec_x                                          &
     &                ,nreac_x                                          &
     &                ,npart_x                                          &
     &                ,ntime_x                                          &
     &                ,nms_spec_x
!
      integer                                                           &
     &        jkin(1:nreac_x)                                           &
     &       ,lvfor(1:nreac_x)                                          &
     &       ,lvbak(1:nreac_x)                                          &
     &       ,lvreac(1:nreac_x)                                         &
!
     &       ,iispec(1:npart_x,1:nreac_x)                               &
     &       ,iospec(1:npart_x,1:nreac_x)                               &
     &       ,nipart(1:nreac_x)                                         &
     &       ,nopart(1:nreac_x)                                         &
!
     &       ,iispec_vs(1:npart_x,1:nreac_x)                            &
     &       ,iospec_vs(1:npart_x,1:nreac_x)                            &
     &       ,nipart_vs(1:nreac_x)                                      &
     &       ,nopart_vs(1:nreac_x)                                      &
     &       ,iivs_vs(1:npart_x,1:nreac_x)                              &
     &       ,iovs_vs(1:npart_x,1:nreac_x)                              &
!
     &       ,ispec_fs(1:(nspec_x+nms_spec_x))                          &
     &       ,ispec_vs(1:(nspec_x+nms_spec_x))                          &
!
     &       ,jfox(1:nspec_x)                                           &
     &       ,jfix(1:nspec_x)                                           &
     &       ,npulse(1:nspec_x)                                         &
     &       ,nperiod(1:nspec_x)
!
      real*8                                                            &
     &                 time_i_fs                                        &
     &                ,odtime_rl
!
      real*8                                                            &
     &       xspec_i(1:(nspec_x+nms_spec_x),0:3)                        &
     &      ,vfor(1:nreac_x)                                            &
     &      ,vbak(1:nreac_x)                                            &
     &      ,xspec_min(1:nspec_x)                                       &
     &      ,xspec_max(1:nspec_x)                                       &
     &      ,yspec_min_vs(1:nspec_x)                                    &
     &      ,yspec_max_vs(1:nspec_x)                                    &
!
     &      ,wspec_vs_min(1:nspec_x)                                    &
     &      ,wspec_vs_max(1:nspec_x)                                    &
     &      ,frlim_vs_min(1:nspec_x)                                    &
     &      ,frlim_vs_max(1:nspec_x)                                    &
!
     &      ,rkfor(1:nreac_x)                                           &
     &      ,rkbak(1:nreac_x)                                           &
     &      ,rkfor2(1:nreac_x)                                          &
     &      ,rkbak2(1:nreac_x)                                          &
!
     &      ,hicoop(1:npart_x,1:nreac_x)                                &
     &      ,hocoop(1:npart_x,1:nreac_x)                                &
     &      ,gimult_vs(1:npart_x,1:nreac_x)                             &
     &      ,gomult_vs(1:npart_x,1:nreac_x)                             &
!
     &      ,tpulse(1:nspec_x,-2:npmspec_x)                             &
     &      ,cpulse(1:nspec_x,-2:npmspec_x)                             &
     &      ,dtpulse(1:nspec_x,0:npmspec_x)                             &
     &      ,spulse(1:nspec_x,-2:npmspec_x)                             &
     &      ,tperiod(1:nspec_x)                                         &
     &      ,otperiod(1:nspec_x)
! :"dRIVS" suppl. arg-list
!
!-----------------------------------------------------------------------
! This is the 12 November 2003 version of
! DLSODES: Livermore Solver for Ordinary Differential Equations
!          with general Sparse Jacobian matrix.
!
! This version is in real*8.
!
! DLSODES solves the initial value problem for stiff or nonstiff
! systems of first order ODEs,
!     dy/dt = f(t,y) ,  or, in component form,
!     dy(i)/dt = f(i) = f(i,t,y(1),y(2),...,y(NEQ)) (i = 1,...,NEQ).
! DLSODES is a variant of the DLSODE package, and is intended for
! problems in which the Jacobian matrix df/dy has an arbitrary
! sparse structure (when the problem is stiff).
!
! Authors:       Alan C. Hindmarsh
!                Center for Applied Scientific Computing, L-561
!                Lawrence Livermore National Laboratory
!                Livermore, CA 94551
! and
!                Andrew H. Sherman
!                J. S. Nolen and Associates
!                Houston, TX 77084
!-----------------------------------------------------------------------
! References:
! 1.  Alan C. Hindmarsh,  ODEPACK, A Systematized Collection of ODE
!     Solvers, in Scientific Computing, R. S. Stepleman et al. (Eds.),
!     North-Holland, Amsterdam, 1983, pp. 55-64.
!
! 2.  S. C. Eisenstat, M. C. Gursky, M. H. Schultz, and A. H. Sherman,
!     Yale Sparse Matrix Package: I. The Symmetric Codes,
!     Int. J. Num. Meth. Eng., 18 (1982), pp. 1145-1151.
!
! 3.  S. C. Eisenstat, M. C. Gursky, M. H. Schultz, and A. H. Sherman,
!     Yale Sparse Matrix Package: II. The Nonsymmetric Codes,
!     Research Report No. 114, Dept. of Computer Sciences, Yale
!     University, 1977.
!-----------------------------------------------------------------------
! Summary of Usage.
!
! Communication between the user and the DLSODES package, for normal
! situations, is summarized here.  This summary describes only a subset
! of the full set of options available.  See the full description for
! details, including optional communication, nonstandard options,
! and instructions for special situations.  See also the example
! problem (with program and output) following this summary.
!
! A. First provide a subroutine of the form:
!               SUBROUTINE FDRIV (NEQ, T, Y, YDOT)
!               REAL*8 T, Y(*), YDOT(*)
! which supplies the vector function f by loading YDOT(i) with f(i).
!
! B. Next determine (or guess) whether or not the problem is stiff.
! Stiffness occurs when the Jacobian matrix df/dy has an eigenvalue
! whose real part is negative and large in magnitude, compared to the
! reciprocal of the t span of interest.  If the problem is nonstiff,
! use a method flag MF = 10.  If it is stiff, there are two standard
! choices for the method flag, MF = 121 and MF = 222.  In both cases,
! DLSODES requires the Jacobian matrix in some form, and it treats this
! matrix in general sparse form, with sparsity structure determined
! internally.  (For options where the user supplies the sparsity
! structure, see the full description of MF below.)
!
! C. If the problem is stiff, you are encouraged to supply the Jacobian
! directly (MF = 121), but if this is not feasible, DLSODES will
! compute it internally by difference quotients (MF = 222).
! If you are supplying the Jacobian, provide a subroutine of the form:
!               SUBROUTINE FDJAC (NEQ, T, Y, J, IAN, JAN, PDJ)
!               REAL*8 T, Y(*), IAN(*), JAN(*), PDJ(*)
! Here NEQ, T, Y, and J are input arguments, and the FDJAC routine is to
! load the array PDJ (of length NEQ) with the J-th column of df/dy.
! I.e., load PDJ(i) with df(i)/dy(J) for all relevant values of i.
! The arguments IAN and JAN should be ignored for normal situations.
! DLSODES will call the FDJAC routine with J = 1,2,...,NEQ.
! Only nonzero elements need be loaded.  Usually, a crude approximation
! to df/dy, possibly with fewer nonzero elements, will suffice.
!
! D. Write a main program which calls Subroutine DLSODES once for
! each point at which answers are desired.  This should also provide
! for possible use of logical unit 6 for output of error messages by
! DLSODES.  On the first call to DLSODES, supply arguments as follows:
! FDRIV  = name of subroutine for right-hand side vector f.
!          This name must be declared External in calling program.
! NEQ    = number of first order ODEs.
! Y      = array of initial values, of length NEQ.
! T      = the initial value of the independent variable t.
! TOUT   = first point where output is desired (.ne. T).
! ITOL   = 1 or 2 according as ATOL (below) is a scalar or array.
! RTOL   = relative tolerance parameter (scalar).
! ATOL   = absolute tolerance parameter (scalar or array).
!          The estimated local error in Y(i) will be controlled so as
!          to be roughly less (in magnitude) than
!             EWT(i) = RTOL*ABS(Y(i)) + ATOL     if ITOL = 1, or
!             EWT(i) = RTOL*ABS(Y(i)) + ATOL(i)  if ITOL = 2.
!          Thus the local error test passes if, in each component,
!          either the absolute error is less than ATOL (or ATOL(i)),
!          or the relative error is less than RTOL.
!          Use RTOL = 0.0 for pure absolute error control, and
!          use ATOL = 0.0 (or ATOL(i) = 0.0) for pure relative error
!          control.  Caution: actual (global) errors may exceed these
!          local tolerances, so choose them conservatively.
! ITASK  = 1 for normal computation of output values of Y at t = TOUT.
! ISTATE = integer flag (input and output).  Set ISTATE = 1.
! IOPT   = 0 to indicate no optional inputs used.
! RWORK  = real work array of length at least:
!             20 + 16*NEQ            for MF = 10,
!             20 + (2 + 1./LENRAT)*NNZ + (11 + 9./LENRAT)*NEQ
!                                    for MF = 121 or 222,
!          where:
!          NNZ    = the number of nonzero elements in the sparse
!                   Jacobian (if this is unknown, use an estimate), and
!          LENRAT = the real to integer wordlength ratio (usually 1 in
!                   single precision and 2 in real*8).
!          In any case, the required size of RWORK cannot generally
!          be predicted in advance if MF = 121 or 222, and the value
!          above is a rough estimate of a crude lower bound.  Some
!          experimentation with this size may be necessary.
!          (When known, the correct required length is an optional
!          output, available in IWORK(17).)
! LRW    = declared length of RWORK (in user dimension).
! IWORK  = integer work array of length at least 30.
! LIW    = declared length of IWORK (in user dimension).
! FDJAC  = name of subroutine for Jacobian matrix (MF = 121).
!          If used, this name must be declared External in calling
!          program.  If not used, pass a dummy name.
! MF     = method flag.  Standard values are:
!          10  for nonstiff (Adams) method, no Jacobian used
!          121 for stiff (BDF) method, user-supplied sparse Jacobian
!          222 for stiff method, internally generated sparse Jacobian
! Note that the main program must declare arrays Y, RWORK, IWORK,
! and possibly ATOL.
!
! E. The output from the first call (or any call) is:
!      Y = array of computed values of y(t) vector.
!      T = corresponding value of independent variable (normally TOUT).
! ISTATE = 2  if DLSODES was successful, negative otherwise.
!          -1 means excess work done on this call (perhaps wrong MF).
!          -2 means excess accuracy requested (tolerances too small).
!          -3 means illegal input detected (see printed message).
!          -4 means repeated error test failures (check all inputs).
!          -5 means repeated convergence failures (perhaps bad Jacobian
!             supplied or wrong choice of MF or tolerances).
!          -6 means error weight became zero during problem. (Solution
!             component i vanished, and ATOL or ATOL(i) = 0.)
!          -7 means a fatal error return flag came from sparse solver
!             CDRV by way of DPRJS or DSOLSS.  Should never happen.
!          A return with ISTATE = -1, -4, or -5 may result from using
!          an inappropriate sparsity structure, one that is quite
!          different from the initial structure.  Consider calling
!          DLSODES again with ISTATE = 3 to force the structure to be
!          reevaluated.  See the full description of ISTATE below.
!
! F. To continue the integration after a successful return, simply
! reset TOUT and call DLSODES again.  No other parameters need be reset.
!
!-----------------------------------------------------------------------
! Example Problem.
!
! The following is a simple example problem, with the coding
! needed for its solution by DLSODES.  The problem is from chemical
! kinetics, and consists of the following 12 rate equations:
!    dy1/dt  = -rk1*y1
!    dy2/dt  = rk1*y1 + rk11*rk14*y4 + rk19*rk14*y5
!                - rk3*y2*y3 - rk15*y2*y12 - rk2*y2
!    dy3/dt  = rk2*y2 - rk5*y3 - rk3*y2*y3 - rk7*y10*y3
!                + rk11*rk14*y4 + rk12*rk14*y6
!    dy4/dt  = rk3*y2*y3 - rk11*rk14*y4 - rk4*y4
!    dy5/dt  = rk15*y2*y12 - rk19*rk14*y5 - rk16*y5
!    dy6/dt  = rk7*y10*y3 - rk12*rk14*y6 - rk8*y6
!    dy7/dt  = rk17*y10*y12 - rk20*rk14*y7 - rk18*y7
!    dy8/dt  = rk9*y10 - rk13*rk14*y8 - rk10*y8
!    dy9/dt  = rk4*y4 + rk16*y5 + rk8*y6 + rk18*y7
!    dy10/dt = rk5*y3 + rk12*rk14*y6 + rk20*rk14*y7
!                + rk13*rk14*y8 - rk7*y10*y3 - rk17*y10*y12
!                - rk6*y10 - rk9*y10
!    dy11/dt = rk10*y8
!    dy12/dt = rk6*y10 + rk19*rk14*y5 + rk20*rk14*y7
!                - rk15*y2*y12 - rk17*y10*y12
!
! with rk1 = rk5 = 0.1,  rk4 = rk8 = rk16 = rk18 = 2.5,
!      rk10 = 5.0,  rk2 = rk6 = 10.0,  rk14 = 30.0,
!      rk3 = rk7 = rk9 = rk11 = rk12 = rk13 = rk19 = rk20 = 50.0,
!      rk15 = rk17 = 100.0.
!
! The t interval is from 0 to 1000, and the initial conditions
! are y1 = 1, y2 = y3 = ... = y12 = 0.  The problem is stiff.
!
! The following coding solves this problem with DLSODES, using MF = 121
! and printing results at t = .1, 1., 10., 100., 1000.  It uses
! ITOL = 1 and mixed relative/absolute tolerance controls.
! During the run and at the end, statistical quantities of interest
! are printed (see optional outputs in the full description below).
!
!     EXTERNAL FEX, JEX
!     REAL*8 ATOL, RTOL, RWORK, T, TOUT, Y
!     DIMENSION Y(12), RWORK(500), IWORK(30)
!     DATA LRW/500/, LIW/30/
!     NEQ = 12
!     DO 10 I = 1,NEQ
! 10    Y(I) = 0.0D0
!     Y(1) = 1.0D0
!     T = 0.0D0
!     TOUT = 0.1D0
!     ITOL = 1
!     RTOL = 1.0D-4
!     ATOL = 1.0D-6
!     ITASK = 1
!     ISTATE = 1
!     IOPT = 0
!     MF = 121
!     DO 40 IOUT = 1,5
!       CALL DLSODES (FEX, JEX, NEQ, Y, T, TOUT, ITOL, RTOL, ATOL,
!    1     ITASK, ISTATE, IOPT, RWORK, LRW, IWORK, LIW, MF)
!       WRITE(6,30) T,IWORK(11),RWORK(11),(Y(I),I=1,NEQ)
! 30    FORMAT(//' At t =',D11.3,4X,
!    1    ' No. steps =',I5,4X,' Last step =',D11.3/
!    2    '  Y array =  ',4D14.5/13X,4D14.5/13X,4D14.5)
!       IF (ISTATE .LT. 0) GO TO 80
!       TOUT = TOUT*10.0D0
! 40    CONTINUE
!     LENRW = IWORK(17)
!     LENIW = IWORK(18)
!     NST = IWORK(11)
!     NFE = IWORK(12)
!     NJE = IWORK(13)
!     NLU = IWORK(21)
!     NNZ = IWORK(19)
!     NNZLU = IWORK(25) + IWORK(26) + NEQ
!     WRITE (6,70) LENRW,LENIW,NST,NFE,NJE,NLU,NNZ,NNZLU
! 70  FORMAT(//' Required RWORK size =',I4,'   IWORK size =',I4/
!    1   ' No. steps =',I4,'   No. f-s =',I4,'   No. J-s =',I4,
!    2   '   No. LU-s =',I4/' No. of nonzeros in J =',I5,
!    3   '   No. of nonzeros in LU =',I5)
!     STOP
! 80  WRITE(6,90)ISTATE
! 90  FORMAT(///' Error halt.. ISTATE =',I3)
!     STOP
!     END
!
!     SUBROUTINE FEX (NEQ, T, Y, YDOT)
!     REAL*8 T, Y, YDOT
!     REAL*8 RK1, RK2, RK3, RK4, RK5, RK6, RK7, RK8, RK9,
!    1   RK10, RK11, RK12, RK13, RK14, RK15, RK16, RK17
!     DIMENSION Y(12), YDOT(12)
!     DATA RK1/0.1D0/, RK2/10.0D0/, RK3/50.0D0/, RK4/2.5D0/, RK5/0.1D0/,
!    1   RK6/10.0D0/, RK7/50.0D0/, RK8/2.5D0/, RK9/50.0D0/, RK10/5.0D0/,
!    2   RK11/50.0D0/, RK12/50.0D0/, RK13/50.0D0/, RK14/30.0D0/,
!    3   RK15/100.0D0/, RK16/2.5D0/, RK17/100.0D0/, RK18/2.5D0/,
!    4   RK19/50.0D0/, RK20/50.0D0/
!     YDOT(1)  = -RK1*Y(1)
!     YDOT(2)  = RK1*Y(1) + RK11*RK14*Y(4) + RK19*RK14*Y(5)
!    1           - RK3*Y(2)*Y(3) - RK15*Y(2)*Y(12) - RK2*Y(2)
!     YDOT(3)  = RK2*Y(2) - RK5*Y(3) - RK3*Y(2)*Y(3) - RK7*Y(10)*Y(3)
!    1           + RK11*RK14*Y(4) + RK12*RK14*Y(6)
!     YDOT(4)  = RK3*Y(2)*Y(3) - RK11*RK14*Y(4) - RK4*Y(4)
!     YDOT(5)  = RK15*Y(2)*Y(12) - RK19*RK14*Y(5) - RK16*Y(5)
!     YDOT(6)  = RK7*Y(10)*Y(3) - RK12*RK14*Y(6) - RK8*Y(6)
!     YDOT(7)  = RK17*Y(10)*Y(12) - RK20*RK14*Y(7) - RK18*Y(7)
!     YDOT(8)  = RK9*Y(10) - RK13*RK14*Y(8) - RK10*Y(8)
!     YDOT(9)  = RK4*Y(4) + RK16*Y(5) + RK8*Y(6) + RK18*Y(7)
!     YDOT(10) = RK5*Y(3) + RK12*RK14*Y(6) + RK20*RK14*Y(7)
!    1           + RK13*RK14*Y(8) - RK7*Y(10)*Y(3) - RK17*Y(10)*Y(12)
!    2           - RK6*Y(10) - RK9*Y(10)
!     YDOT(11) = RK10*Y(8)
!     YDOT(12) = RK6*Y(10) + RK19*RK14*Y(5) + RK20*RK14*Y(7)
!    1           - RK15*Y(2)*Y(12) - RK17*Y(10)*Y(12)
!     RETURN
!     END
!
!     SUBROUTINE JEX (NEQ, T, Y, J, IA, JA, PDJ)
!     REAL*8 T, Y, PDJ
!     REAL*8 RK1, RK2, RK3, RK4, RK5, RK6, RK7, RK8, RK9,
!    1   RK10, RK11, RK12, RK13, RK14, RK15, RK16, RK17
!     DIMENSION Y(12), IA(*), JA(*), PDJ(12)
!     DATA RK1/0.1D0/, RK2/10.0D0/, RK3/50.0D0/, RK4/2.5D0/, RK5/0.1D0/,
!    1   RK6/10.0D0/, RK7/50.0D0/, RK8/2.5D0/, RK9/50.0D0/, RK10/5.0D0/,
!    2   RK11/50.0D0/, RK12/50.0D0/, RK13/50.0D0/, RK14/30.0D0/,
!    3   RK15/100.0D0/, RK16/2.5D0/, RK17/100.0D0/, RK18/2.5D0/,
!    4   RK19/50.0D0/, RK20/50.0D0/
!     GO TO (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12), J
! 1   PDJ(1) = -RK1
!     PDJ(2) = RK1
!     RETURN
! 2   PDJ(2) = -RK3*Y(3) - RK15*Y(12) - RK2
!     PDJ(3) = RK2 - RK3*Y(3)
!     PDJ(4) = RK3*Y(3)
!     PDJ(5) = RK15*Y(12)
!     PDJ(12) = -RK15*Y(12)
!     RETURN
! 3   PDJ(2) = -RK3*Y(2)
!     PDJ(3) = -RK5 - RK3*Y(2) - RK7*Y(10)
!     PDJ(4) = RK3*Y(2)
!     PDJ(6) = RK7*Y(10)
!     PDJ(10) = RK5 - RK7*Y(10)
!     RETURN
! 4   PDJ(2) = RK11*RK14
!     PDJ(3) = RK11*RK14
!     PDJ(4) = -RK11*RK14 - RK4
!     PDJ(9) = RK4
!     RETURN
! 5   PDJ(2) = RK19*RK14
!     PDJ(5) = -RK19*RK14 - RK16
!     PDJ(9) = RK16
!     PDJ(12) = RK19*RK14
!     RETURN
! 6   PDJ(3) = RK12*RK14
!     PDJ(6) = -RK12*RK14 - RK8
!     PDJ(9) = RK8
!     PDJ(10) = RK12*RK14
!     RETURN
! 7   PDJ(7) = -RK20*RK14 - RK18
!     PDJ(9) = RK18
!     PDJ(10) = RK20*RK14
!     PDJ(12) = RK20*RK14
!     RETURN
! 8   PDJ(8) = -RK13*RK14 - RK10
!     PDJ(10) = RK13*RK14
!     PDJ(11) = RK10
! 9   RETURN
! 10  PDJ(3) = -RK7*Y(3)
!     PDJ(6) = RK7*Y(3)
!     PDJ(7) = RK17*Y(12)
!     PDJ(8) = RK9
!     PDJ(10) = -RK7*Y(3) - RK17*Y(12) - RK6 - RK9
!     PDJ(12) = RK6 - RK17*Y(12)
! 11  RETURN
! 12  PDJ(2) = -RK15*Y(2)
!     PDJ(5) = RK15*Y(2)
!     PDJ(7) = RK17*Y(10)
!     PDJ(10) = -RK17*Y(10)
!     PDJ(12) = -RK15*Y(2) - RK17*Y(10)
!     RETURN
!     END
!
! The output of this program (on a Cray-1 in single precision)
! is as follows:
!
!
! At t =  1.000e-01     No. steps =   12     Last step =  1.515e-02
!  Y array =     9.90050e-01   6.28228e-03   3.65313e-03   7.51934e-07
!                1.12167e-09   1.18458e-09   1.77291e-12   3.26476e-07
!                5.46720e-08   9.99500e-06   4.48483e-08   2.76398e-06
!
!
! At t =  1.000e+00     No. steps =   33     Last step =  7.880e-02
!  Y array =     9.04837e-01   9.13105e-03   8.20622e-02   2.49177e-05
!                1.85055e-06   1.96797e-06   1.46157e-07   2.39557e-05
!                3.26306e-05   7.21621e-04   5.06433e-05   3.05010e-03
!
!
! At t =  1.000e+01     No. steps =   48     Last step =  1.239e+00
!  Y array =     3.67876e-01   3.68958e-03   3.65133e-01   4.48325e-05
!                6.10798e-05   4.33148e-05   5.90211e-05   1.18449e-04
!                3.15235e-03   3.56531e-03   4.15520e-03   2.48741e-01
!
!
! At t =  1.000e+02     No. steps =   91     Last step =  3.764e+00
!  Y array =     4.44981e-05   4.42666e-07   4.47273e-04  -3.53257e-11
!                2.81577e-08  -9.67741e-11   2.77615e-07   1.45322e-07
!                1.56230e-02   4.37394e-06   1.60104e-02   9.52246e-01
!
!
! At t =  1.000e+03     No. steps =  111     Last step =  4.156e+02
!  Y array =    -2.65492e-13   2.60539e-14  -8.59563e-12   6.29355e-14
!               -1.78066e-13   5.71471e-13  -1.47561e-12   4.58078e-15
!                1.56314e-02   1.37878e-13   1.60184e-02   9.52719e-01
!
!
! Required RWORK size = 442   IWORK size =  30
! No. steps = 111   No. f-s = 142   No. J-s =   2   No. LU-s =  20
! No. of nonzeros in J =   44   No. of nonzeros in LU =   50
!
!-----------------------------------------------------------------------
! Full Description of User Interface to DLSODES.
!
! The user interface to DLSODES consists of the following parts.
!
! 1.   The call sequence to Subroutine DLSODES, which is a driver
!      routine for the solver.  This includes descriptions of both
!      the call sequence arguments and of user-supplied routines.
!      Following these descriptions is a description of
!      optional inputs available through the call sequence, and then
!      a description of optional outputs (in the work arrays).
!
! 2.   Descriptions of other routines in the DLSODES package that may be
!      (optionally) called by the user.  These provide the ability to
!      alter error message handling, save and restore the internal
!      Common, and obtain specified derivatives of the solution y(t).
!
! 3.   Descriptions of Common blocks to be declared in overlay
!      or similar environments, or to be saved when doing an interrupt
!      of the problem and continued solution later.
!
! 4.   Description of two routines in the DLSODES package, either of
!      which the user may replace with his/her own version, if desired.
!      These relate to the measurement of errors.
!
!-----------------------------------------------------------------------
! Part 1.  Call Sequence.
!
! The call sequence parameters used for input only are
!     FDRIV, NEQ, TOUT, ITOL, RTOL, ATOL, ITASK, IOPT, LRW, LIW,
!     FDJAC, MF,
! and those used for both input and output are
!     Y, T, ISTATE.
! The work arrays RWORK and IWORK are also used for conditional and
! optional inputs and optional outputs.  (The term output here refers
! to the return from Subroutine DLSODES to the user's calling program.)
!
! The legality of input parameters will be thoroughly checked on the
! initial call for the problem, but not checked thereafter unless a
! change in input parameters is flagged by ISTATE = 3 on input.
!
! The descriptions of the call arguments are as follows.
!
! FDRIV  = the name of the user-supplied subroutine defining the
!          ODE system.  The system must be put in the first-order
!          form dy/dt = f(t,y), where f is a vector-valued function
!          of the scalar t and the vector y.  Subroutine FDRIV is to
!          compute the function f.  It is to have the form
!               SUBROUTINE FDRIV (NEQ, T, Y, YDOT)
!               REAL*8 T, Y(*), YDOT(*)
!          where NEQ, T, and Y are input, and the array YDOT = f(t,y)
!          is output.  Y and YDOT are arrays of length NEQ.
!          Subroutine FDRIV should not alter y(1),...,y(NEQ).
!          FDRIV must be declared External in the calling program.
!
!          Subroutine FDRIV may access user-defined quantities in
!          NEQ(2),... and/or in Y(NEQ(1)+1),... if NEQ is an array
!          (dimensioned in FDRIV) and/or Y has length exceeding NEQ(1).
!          See the descriptions of NEQ and Y below.
!
!          If quantities computed in the FDRIV routine are needed
!          externally to DLSODES, an extra call to FDRIV should be made
!          for this purpose, for consistent and accurate results.
!          If only the derivative dy/dt is needed, use DINTDY instead.
!
! NEQ    = the size of the ODE system (number of first order
!          ordinary differential equations).  Used only for input.
!          NEQ may be decreased, but not increased, during the problem.
!          If NEQ is decreased (with ISTATE = 3 on input), the
!          remaining components of Y should be left undisturbed, if
!          these are to be accessed in FDRIV and/or FDJAC.
!
!          Normally, NEQ is a scalar, and it is generally referred to
!          as a scalar in this user interface description.  However,
!          NEQ may be an array, with NEQ(1) set to the system size.
!          (The DLSODES package accesses only NEQ(1).)  In either case,
!          this parameter is passed as the NEQ argument in all calls
!          to FDRIV and FDJAC.  Hence, if it is an array, locations
!          NEQ(2),... may be used to store other integer data and pass
!          it to FDRIV and/or FDJAC.  Subroutines FDRIV and/or FDJAC must
!          include NEQ in a Dimension statement in that case.
!
! Y      = a real array for the vector of dependent variables, of
!          length NEQ or more.  Used for both input and output on the
!          first call (ISTATE = 1), and only for output on other calls.
!          on the first call, Y must contain the vector of initial
!          values.  On output, Y contains the computed solution vector,
!          evaluated at T.  If desired, the Y array may be used
!          for other purposes between calls to the solver.
!
!          This array is passed as the Y argument in all calls to
!          FDRIV and FDJAC.  Hence its length may exceed
!          NEQ, and locations Y(NEQ+1),... may be used to
!          store other real data and pass it to FDRIV and/or FDJAC.
!          (The DLSODES package accesses only Y(1),...,Y(NEQ).)
!
! T      = the independent variable.  On input, T is used only on the
!          first call, as the initial point of the integration.
!          on output, after each call, T is the value at which a
!          computed solution Y is evaluated (usually the same as TOUT).
!          On an error return, T is the farthest point reached.
!
! TOUT   = the next value of t at which a computed solution is desired.
!          Used only for input.
!
!          When starting the problem (ISTATE = 1), TOUT may be equal
!          to T for one call, then should .ne. T for the next call.
!          For the initial T, an input value of TOUT .ne. T is used
!          in order to determine the direction of the integration
!          (i.e. the algebraic sign of the step sizes) and the rough
!          scale of the problem.  Integration in either direction
!          (forward or backward in t) is permitted.
!
!          If ITASK = 2 or 5 (one-step modes), TOUT is ignored after
!          the first call (i.e. the first call with TOUT .ne. T).
!          Otherwise, TOUT is required on every call.
!
!          If ITASK = 1, 3, or 4, the values of TOUT need not be
!          monotone, but a value of TOUT which backs up is limited
!          to the current internal T interval, whose endpoints are
!          TCUR - HU and TCUR (see optional outputs, below, for
!          TCUR and HU).
!
! ITOL   = an indicator for the type of error control.  See
!          description below under ATOL.  Used only for input.
!
! RTOL   = a relative error tolerance parameter, either a scalar or
!          an array of length NEQ.  See description below under ATOL.
!          Input only.
!
! ATOL   = an absolute error tolerance parameter, either a scalar or
!          an array of length NEQ.  Input only.
!
!             The input parameters ITOL, RTOL, and ATOL determine
!          the error control performed by the solver.  The solver will
!          control the vector E = (E(i)) of estimated local errors
!          in y, according to an inequality of the form
!                      RMS-norm of ( E(i)/EWT(i) )   .le.   1,
!          where       EWT(i) = RTOL(i)*ABS(Y(i)) + ATOL(i),
!          and the RMS-norm (root-mean-square norm) here is
!          RMS-norm(v) = SQRT(sum v(i)**2 / NEQ).  Here EWT = (EWT(i))
!          is a vector of weights which must always be positive, and
!          the values of RTOL and ATOL should all be non-negative.
!          The following table gives the types (scalar/array) of
!          RTOL and ATOL, and the corresponding form of EWT(i).
!
!             ITOL    RTOL       ATOL          EWT(i)
!              1     scalar     scalar     RTOL*ABS(Y(i)) + ATOL
!              2     scalar     array      RTOL*ABS(Y(i)) + ATOL(i)
!              3     array      scalar     RTOL(i)*ABS(Y(i)) + ATOL
!              4     array      array      RTOL(i)*ABS(Y(i)) + ATOL(i)
!
!          When either of these parameters is a scalar, it need not
!          be dimensioned in the user's calling program.
!
!          If none of the above choices (with ITOL, RTOL, and ATOL
!          fixed throughout the problem) is suitable, more general
!          error controls can be obtained by substituting
!          user-supplied routines for the setting of EWT and/or for
!          the norm calculation.  See Part 4 below.
!
!          If global errors are to be estimated by making a repeated
!          run on the same problem with smaller tolerances, then all
!          components of RTOL and ATOL (i.e. of EWT) should be scaled
!          down uniformly.
!
! ITASK  = an index specifying the task to be performed.
!          Input only.  ITASK has the following values and meanings.
!          1  means normal computation of output values of y(t) at
!             t = TOUT (by overshooting and interpolating).
!          2  means take one step only and return.
!          3  means terminate at the first internal mesh point at or
!             beyond t = TOUT and return.
!          4  means normal computation of output values of y(t) at
!             t = TOUT but without overshooting t = TCRIT.
!             TCRIT must be input as RWORK(1).  TCRIT may be equal to
!             or beyond TOUT, but not behind it in the direction of
!             integration.  This option is useful if the problem
!             has a singularity at or beyond t = TCRIT.
!          5  means take one step, without passing TCRIT, and return.
!             TCRIT must be input as RWORK(1).
!
!          Note:  If ITASK = 4 or 5 and the solver reaches TCRIT
!          (within roundoff), it will return T = TCRIT (exactly) to
!          indicate this (unless ITASK = 4 and TOUT comes before TCRIT,
!          in which case answers at t = TOUT are returned first).
!
! ISTATE = an index used for input and output to specify the
!          the state of the calculation.
!
!          On input, the values of ISTATE are as follows.
!          1  means this is the first call for the problem
!             (initializations will be done).  See note below.
!          2  means this is not the first call, and the calculation
!             is to continue normally, with no change in any input
!             parameters except possibly TOUT and ITASK.
!             (If ITOL, RTOL, and/or ATOL are changed between calls
!             with ISTATE = 2, the new values will be used but not
!             tested for legality.)
!          3  means this is not the first call, and the
!             calculation is to continue normally, but with
!             a change in input parameters other than
!             TOUT and ITASK.  Changes are allowed in
!             NEQ, ITOL, RTOL, ATOL, IOPT, LRW, LIW, MF,
!             the conditional inputs IA and JA,
!             and any of the optional inputs except H0.
!             In particular, if MITER = 1 or 2, a call with ISTATE = 3
!             will cause the sparsity structure of the problem to be
!             recomputed (or reread from IA and JA if MOSS = 0).
!          Note:  a preliminary call with TOUT = T is not counted
!          as a first call here, as no initialization or checking of
!          input is done.  (Such a call is sometimes useful for the
!          purpose of outputting the initial conditions.)
!          Thus the first call for which TOUT .ne. T requires
!          ISTATE = 1 on input.
!
!          On output, ISTATE has the following values and meanings.
!           1  means nothing was done; TOUT = T and ISTATE = 1 on input.
!           2  means the integration was performed successfully.
!          -1  means an excessive amount of work (more than MXSTEP
!              steps) was done on this call, before completing the
!              requested task, but the integration was otherwise
!              successful as far as T.  (MXSTEP is an optional input
!              and is normally 500.)  To continue, the user may
!              simply reset ISTATE to a value .gt. 1 and call again
!              (the excess work step counter will be reset to 0).
!              In addition, the user may increase MXSTEP to avoid
!              this error return (see below on optional inputs).
!          -2  means too much accuracy was requested for the precision
!              of the machine being used.  This was detected before
!              completing the requested task, but the integration
!              was successful as far as T.  To continue, the tolerance
!              parameters must be reset, and ISTATE must be set
!              to 3.  The optional output TOLSF may be used for this
!              purpose.  (Note: If this condition is detected before
!              taking any steps, then an illegal input return
!              (ISTATE = -3) occurs instead.)
!          -3  means illegal input was detected, before taking any
!              integration steps.  See written message for details.
!              Note:  If the solver detects an infinite loop of calls
!              to the solver with illegal input, it will cause
!              the run to terminate.
!          -4  means there were repeated error test failures on
!              one attempted step, before completing the requested
!              task, but the integration was successful as far as T.
!              The problem may have a singularity, or the input
!              may be inappropriate.
!          -5  means there were repeated convergence test failures on
!              one attempted step, before completing the requested
!              task, but the integration was successful as far as T.
!              This may be caused by an inaccurate Jacobian matrix,
!              if one is being used.
!          -6  means EWT(i) became zero for some i during the
!              integration.  Pure relative error control (ATOL(i)=0.0)
!              was requested on a variable which has now vanished.
!              The integration was successful as far as T.
!          -7  means a fatal error return flag came from the sparse
!              solver CDRV by way of DPRJS or DSOLSS (numerical
!              factorization or backsolve).  This should never happen.
!              The integration was successful as far as T.
!
!          Note: an error return with ISTATE = -1, -4, or -5 and with
!          MITER = 1 or 2 may mean that the sparsity structure of the
!          problem has changed significantly since it was last
!          determined (or input).  In that case, one can attempt to
!          complete the integration by setting ISTATE = 3 on the next
!          call, so that a new structure determination is done.
!
!          Note:  since the normal output value of ISTATE is 2,
!          it does not need to be reset for normal continuation.
!          Also, since a negative input value of ISTATE will be
!          regarded as illegal, a negative output value requires the
!          user to change it, and possibly other inputs, before
!          calling the solver again.
!
! IOPT   = an integer flag to specify whether or not any optional
!          inputs are being used on this call.  Input only.
!          The optional inputs are listed separately below.
!          IOPT = 0 means no optional inputs are being used.
!                   Default values will be used in all cases.
!          IOPT = 1 means one or more optional inputs are being used.
!
! RWORK  = a work array used for a mixture of real (real*8)
!          and integer work space.
!          The length of RWORK (in real words) must be at least
!             20 + NYH*(MAXORD + 1) + 3*NEQ + LWM    where
!          NYH    = the initial value of NEQ,
!          MAXORD = 12 (if METH = 1) or 5 (if METH = 2) (unless a
!                   smaller value is given as an optional input),
!          LWM = 0                                    if MITER = 0,
!          LWM = 2*NNZ + 2*NEQ + (NNZ+9*NEQ)/LENRAT   if MITER = 1,
!          LWM = 2*NNZ + 2*NEQ + (NNZ+10*NEQ)/LENRAT  if MITER = 2,
!          LWM = NEQ + 2                              if MITER = 3.
!          In the above formulas,
!          NNZ    = number of nonzero elements in the Jacobian matrix.
!          LENRAT = the real to integer wordlength ratio (usually 1 in
!                   single precision and 2 in real*8).
!          (See the MF description for METH and MITER.)
!          Thus if MAXORD has its default value and NEQ is constant,
!          the minimum length of RWORK is:
!             20 + 16*NEQ        for MF = 10,
!             20 + 16*NEQ + LWM  for MF = 11, 111, 211, 12, 112, 212,
!             22 + 17*NEQ        for MF = 13,
!             20 +  9*NEQ        for MF = 20,
!             20 +  9*NEQ + LWM  for MF = 21, 121, 221, 22, 122, 222,
!             22 + 10*NEQ        for MF = 23.
!          If MITER = 1 or 2, the above formula for LWM is only a
!          crude lower bound.  The required length of RWORK cannot
!          be readily predicted in general, as it depends on the
!          sparsity structure of the problem.  Some experimentation
!          may be necessary.
!
!          The first 20 words of RWORK are reserved for conditional
!          and optional inputs and optional outputs.
!
!          The following word in RWORK is a conditional input:
!            RWORK(1) = TCRIT = critical value of t which the solver
!                       is not to overshoot.  Required if ITASK is
!                       4 or 5, and ignored otherwise.  (See ITASK.)
!
! LRW    = the length of the array RWORK, as declared by the user.
!          (This will be checked by the solver.)
!
! IWORK  = an integer work array.  The length of IWORK must be at least
!             31 + NEQ + NNZ   if MOSS = 0 and MITER = 1 or 2, or
!             30               otherwise.
!          (NNZ is the number of nonzero elements in df/dy.)
!
!          In DLSODES, IWORK is used only for conditional and
!          optional inputs and optional outputs.
!
!          The following two blocks of words in IWORK are conditional
!          inputs, required if MOSS = 0 and MITER = 1 or 2, but not
!          otherwise (see the description of MF for MOSS).
!            IWORK(30+j) = IA(j)     (j=1,...,NEQ+1)
!            IWORK(31+NEQ+k) = JA(k) (k=1,...,NNZ)
!          The two arrays IA and JA describe the sparsity structure
!          to be assumed for the Jacobian matrix.  JA contains the row
!          indices where nonzero elements occur, reading in columnwise
!          order, and IA contains the starting locations in JA of the
!          descriptions of columns 1,...,NEQ, in that order, with
!          IA(1) = 1.  Thus, for each column index j = 1,...,NEQ, the
!          values of the row index i in column j where a nonzero
!          element may occur are given by
!            i = JA(k),  where   IA(j) .le. k .lt. IA(j+1).
!          If NNZ is the total number of nonzero locations assumed,
!          then the length of the JA array is NNZ, and IA(NEQ+1) must
!          be NNZ + 1.  Duplicate entries are not allowed.
!
! LIW    = the length of the array IWORK, as declared by the user.
!          (This will be checked by the solver.)
!
! Note:  The work arrays must not be altered between calls to DLSODES
! for the same problem, except possibly for the conditional and
! optional inputs, and except for the last 3*NEQ words of RWORK.
! The latter space is used for internal scratch space, and so is
! available for use by the user outside DLSODES between calls, if
! desired (but not for use by FDRIV or FDJAC).
!
! FDJAC    = name of user-supplied routine (MITER = 1 or MOSS = 1) to
!          compute the Jacobian matrix, df/dy, as a function of
!          the scalar t and the vector y.  It is to have the form
!               SUBROUTINE FDJAC (NEQ, T, Y, J, IAN, JAN, PDJ)
!               REAL*8 T, Y(*), IAN(*), JAN(*), PDJ(*)
!          where NEQ, T, Y, J, IAN, and JAN are input, and the array
!          PDJ, of length NEQ, is to be loaded with column J
!          of the Jacobian on output.  Thus df(i)/dy(J) is to be
!          loaded into PDJ(i) for all relevant values of i.
!          Here T and Y have the same meaning as in Subroutine FDRIV,
!          and J is a column index (1 to NEQ).  IAN and JAN are
!          undefined in calls to FDJAC for structure determination
!          (MOSS = 1).  otherwise, IAN and JAN are structure
!          descriptors, as defined under optional outputs below, and
!          so can be used to determine the relevant row indices i, if
!          desired.
!               FDJAC need not provide df/dy exactly.  A crude
!          approximation (possibly with greater sparsity) will do.
!               In any case, PDJ is preset to zero by the solver,
!          so that only the nonzero elements need be loaded by FDJAC.
!          Calls to FDJAC are made with J = 1,...,NEQ, in that order;
!          each such set of calls is preceded by a
!          call to FDRIV with the same arguments NEQ, T, and Y.
!          Thus to gain some efficiency, intermediate quantities
!          shared by both calculations may be saved in a user
!          Common block by FDRIV and not recomputed by
!          FDJAC, if desired.  FDJAC must not alter its input arguments.
!          FDJAC must be declared External in the calling program.
!               Subroutine FDJAC may access user-defined quantities in
!          NEQ(2),... and/or in Y(NEQ(1)+1),... if NEQ is an array
!          (dimensioned in FDJAC) and/or Y has length exceeding NEQ(1).
!          See the descriptions of NEQ and Y above.
!
! MF     = the method flag.  Used only for input.
!          MF has three decimal digits-- MOSS, METH, MITER--
!             MF = 100*MOSS + 10*METH + MITER.
!          MOSS indicates the method to be used to obtain the sparsity
!          structure of the Jacobian matrix if MITER = 1 or 2:
!            MOSS = 0 means the user has supplied IA and JA
!                     (see descriptions under IWORK above).
!            MOSS = 1 means the user has supplied FDJAC (see below)
!                     and the structure will be obtained from NEQ
!                     initial calls to FDJAC.
!            MOSS = 2 means the structure will be obtained from NEQ+1
!                     initial calls to FDRIV.
!          METH indicates the basic linear multistep method:
!            METH = 1 means the implicit Adams method.
!            METH = 2 means the method based on Backward
!                     Differentiation Formulas (BDFs).
!          MITER indicates the corrector iteration method:
!            MITER = 0 means functional iteration (no Jacobian matrix
!                      is involved).
!            MITER = 1 means chord iteration with a user-supplied
!                      sparse Jacobian, given by Subroutine FDJAC.
!            MITER = 2 means chord iteration with an internally
!                      generated (difference quotient) sparse Jacobian
!                      (using NGP extra calls to FDRIV per df/dy value,
!                      where NGP is an optional output described below.)
!            MITER = 3 means chord iteration with an internally
!                      generated diagonal Jacobian approximation
!                      (using 1 extra call to FDRIV per df/dy
!                      evaluation).
!          If MITER = 1 or MOSS = 1, the user must supply a Subroutine
!          FDJAC (the name is arbitrary) as described above under FDJAC.
!          Otherwise, a dummy argument can be used.
!
!          The standard choices for MF are:
!            MF = 10  for a nonstiff problem,
!            MF = 21 or 22 for a stiff problem with IA/JA supplied
!                     (21 if FDJAC is supplied, 22 if not),
!            MF = 121 for a stiff problem with FDJAC supplied,
!                     but not IA/JA,
!            MF = 222 for a stiff problem with neither IA/JA nor
!                     FDJAC supplied.
!          The sparseness structure can be changed during the
!          problem by making a call to DLSODES with ISTATE = 3.
!-----------------------------------------------------------------------
! Optional Inputs.
!
! The following is a list of the optional inputs provided for in the
! call sequence.  (See also Part 2.)  For each such input variable,
! this table lists its name as used in this documentation, its
! location in the call sequence, its meaning, and the default value.
! The use of any of these inputs requires IOPT = 1, and in that
! case all of these inputs are examined.  A value of zero for any
! of these optional inputs will cause the default value to be used.
! Thus to use a subset of the optional inputs, simply preload
! locations 5 to 10 in RWORK and IWORK to 0.0 and 0 respectively, and
! then set those of interest to nonzero values.
!
! Name    Location      Meaning and Default Value
!
! H0      RWORK(5)  the step size to be attempted on the first step.
!                   The default value is determined by the solver.
!
! HMAX    RWORK(6)  the maximum absolute step size allowed.
!                   The default value is infinite.
!
! HMIN    RWORK(7)  the minimum absolute step size allowed.
!                   The default value is 0.  (This lower bound is not
!                   enforced on the final step before reaching TCRIT
!                   when ITASK = 4 or 5.)
!
! SETH    RWORK(8)  the element threshhold for sparsity determination
!                   when MOSS = 1 or 2.  If the absolute value of
!                   an estimated Jacobian element is .le. SETH, it
!                   will be assumed to be absent in the structure.
!                   The default value of SETH is 0.
!
! MAXORD  IWORK(5)  the maximum order to be allowed.  The default
!                   value is 12 if METH = 1, and 5 if METH = 2.
!                   If MAXORD exceeds the default value, it will
!                   be reduced to the default value.
!                   If MAXORD is changed during the problem, it may
!                   cause the current order to be reduced.
!
! MXSTEP  IWORK(6)  maximum number of (internally defined) steps
!                   allowed during one call to the solver.
!                   The default value is 500.
!
! MXHNIL  IWORK(7)  maximum number of messages printed (per problem)
!                   warning that T + H = T on a step (H = step size).
!                   This must be positive to result in a non-default
!                   value.  The default value is 10.
!-----------------------------------------------------------------------
! Optional Outputs.
!
! As optional additional output from DLSODES, the variables listed
! below are quantities related to the performance of DLSODES
! which are available to the user.  These are communicated by way of
! the work arrays, but also have internal mnemonic names as shown.
! Except where stated otherwise, all of these outputs are defined
! on any successful return from DLSODES, and on any return with
! ISTATE = -1, -2, -4, -5, or -6.  On an illegal input return
! (ISTATE = -3), they will be unchanged from their existing values
! (if any), except possibly for TOLSF, LENRW, and LENIW.
! On any error return, outputs relevant to the error will be defined,
! as noted below.
!
! Name    Location      Meaning
!
! HU      RWORK(11) the step size in t last used (successfully).
!
! HCUR    RWORK(12) the step size to be attempted on the next step.
!
! TCUR    RWORK(13) the current value of the independent variable
!                   which the solver has actually reached, i.e. the
!                   current internal mesh point in t.  On output, TCUR
!                   will always be at least as far as the argument
!                   T, but may be farther (if interpolation was done).
!
! TOLSF   RWORK(14) a tolerance scale factor, greater than 1.0,
!                   computed when a request for too much accuracy was
!                   detected (ISTATE = -3 if detected at the start of
!                   the problem, ISTATE = -2 otherwise).  If ITOL is
!                   left unaltered but RTOL and ATOL are uniformly
!                   scaled up by a factor of TOLSF for the next call,
!                   then the solver is deemed likely to succeed.
!                   (The user may also ignore TOLSF and alter the
!                   tolerance parameters in any other way appropriate.)
!
! NST     IWORK(11) the number of steps taken for the problem so far.
!
! NFE     IWORK(12) the number of f evaluations for the problem so far,
!                   excluding those for structure determination
!                   (MOSS = 2).
!
! NJE     IWORK(13) the number of Jacobian evaluations for the problem
!                   so far, excluding those for structure determination
!                   (MOSS = 1).
!
! NQU     IWORK(14) the method order last used (successfully).
!
! NQCUR   IWORK(15) the order to be attempted on the next step.
!
! IMXER   IWORK(16) the index of the component of largest magnitude in
!                   the weighted local error vector ( E(i)/EWT(i) ),
!                   on an error return with ISTATE = -4 or -5.
!
! LENRW   IWORK(17) the length of RWORK actually required.
!                   This is defined on normal returns and on an illegal
!                   input return for insufficient storage.
!
! LENIW   IWORK(18) the length of IWORK actually required.
!                   This is defined on normal returns and on an illegal
!                   input return for insufficient storage.
!
! NNZ     IWORK(19) the number of nonzero elements in the Jacobian
!                   matrix, including the diagonal (MITER = 1 or 2).
!                   (This may differ from that given by IA(NEQ+1)-1
!                   if MOSS = 0, because of added diagonal entries.)
!
! NGP     IWORK(20) the number of groups of column indices, used in
!                   difference quotient Jacobian aproximations if
!                   MITER = 2.  This is also the number of extra f
!                   evaluations needed for each Jacobian evaluation.
!
! NLU     IWORK(21) the number of sparse LU decompositions for the
!                   problem so far.
!
! LYH     IWORK(22) the base address in RWORK of the history array YH,
!                   described below in this list.
!
! IPIAN   IWORK(23) the base address of the structure descriptor array
!                   IAN, described below in this list.
!
! IPJAN   IWORK(24) the base address of the structure descriptor array
!                   JAN, described below in this list.
!
! NZL     IWORK(25) the number of nonzero elements in the strict lower
!                   triangle of the LU factorization used in the chord
!                   iteration (MITER = 1 or 2).
!
! NZU     IWORK(26) the number of nonzero elements in the strict upper
!                   triangle of the LU factorization used in the chord
!                   iteration (MITER = 1 or 2).
!                   The total number of nonzeros in the factorization
!                   is therefore NZL + NZU + NEQ.
!
! The following four arrays are segments of the RWORK array which
! may also be of interest to the user as optional outputs.
! For each array, the table below gives its internal name,
! its base address, and its description.
! For YH and ACOR, the base addresses are in RWORK (a real array).
! The integer arrays IAN and JAN are to be obtained by declaring an
! integer array IWK and identifying IWK(1) with RWORK(21), using either
! an equivalence statement or a subroutine call.  Then the base
! addresses IPIAN (of IAN) and IPJAN (of JAN) in IWK are to be obtained
! as optional outputs IWORK(23) and IWORK(24), respectively.
! Thus IAN(1) is IWK(IPIAN), etc.
!
! Name    Base Address      Description
!
! IAN    IPIAN (in IWK)  structure descriptor array of size NEQ + 1.
! JAN    IPJAN (in IWK)  structure descriptor array of size NNZ.
!         (see above)    IAN and JAN together describe the sparsity
!                        structure of the Jacobian matrix, as used by
!                        DLSODES when MITER = 1 or 2.
!                        JAN contains the row indices of the nonzero
!                        locations, reading in columnwise order, and
!                        IAN contains the starting locations in JAN of
!                        the descriptions of columns 1,...,NEQ, in
!                        that order, with IAN(1) = 1.  Thus for each
!                        j = 1,...,NEQ, the row indices i of the
!                        nonzero locations in column j are
!                        i = JAN(k),  IAN(j) .le. k .lt. IAN(j+1).
!                        Note that IAN(NEQ+1) = NNZ + 1.
!                        (If MOSS = 0, IAN/JAN may differ from the
!                        input IA/JA because of a different ordering
!                        in each column, and added diagonal entries.)
!
! YH      LYH            the Nordsieck history array, of size NYH by
!          (optional     (NQCUR + 1), where NYH is the initial value
!           output)      of NEQ.  For j = 0,1,...,NQCUR, column j+1
!                        of YH contains HCUR**j/factorial(j) times
!                        the j-th derivative of the interpolating
!                        polynomial currently representing the solution,
!                        evaluated at t = TCUR.  The base address LYH
!                        is another optional output, listed above.
!
! ACOR     LENRW-NEQ+1   array of size NEQ used for the accumulated
!                        corrections on each step, scaled on output
!                        to represent the estimated local error in y
!                        on the last step.  This is the vector E  in
!                        the description of the error control.  It is
!                        defined only on a successful return from
!                        DLSODES.
!
!-----------------------------------------------------------------------
! Part 2.  Other Routines Callable.
!
! The following are optional calls which the user may make to
! gain additional capabilities in conjunction with DLSODES.
! (The routines XSETUN and XSETF are designed to conform to the
! SLATEC error handling package.)
!
!     Form of Call                  Function
!   CALL XSETUN(LUN)          Set the logical unit number, LUN, for
!                             output of messages from DLSODES, if
!                             the default is not desired.
!                             The default value of LUN is 6.
!
!   CALL XSETF(MFLAG)         Set a flag to control the printing of
!                             messages by DLSODES.
!                             MFLAG = 0 means do not print. (Danger:
!                             This risks losing valuable information.)
!                             MFLAG = 1 means print (the default).
!
!                             Either of the above calls may be made at
!                             any time and will take effect immediately.
!
!   CALL DSRCMS(RSAV,ISAV,JOB) saves and restores the contents of
!                             the internal Common blocks used by
!                             DLSODES (see Part 3 below).
!                             RSAV must be a real array of length 224
!                             or more, and ISAV must be an integer
!                             array of length 71 or more.
!                             JOB=1 means save Common into RSAV/ISAV.
!                             JOB=2 means restore Common from RSAV/ISAV.
!                                DSRCMS is useful if one is
!                             interrupting a run and restarting
!                             later, or alternating between two or
!                             more problems solved with DLSODES.
!
!   CALL DINTDY(,,,,,)        Provide derivatives of y, of various
!        (see below)          orders, at a specified point t, if
!                             desired.  It may be called only after
!                             a successful return from DLSODES.
!
! The detailed instructions for using DINTDY are as follows.
! The form of the call is:
!
!   LYH = IWORK(22)
!   CALL DINTDY (T, K, RWORK(LYH), NYH, DKY, IFLAG)
!
! The input parameters are:
!
! T         = value of independent variable where answers are desired
!             (normally the same as the T last returned by DLSODES).
!             For valid results, T must lie between TCUR - HU and TCUR.
!             (See optional outputs for TCUR and HU.)
! K         = integer order of the derivative desired.  K must satisfy
!             0 .le. K .le. NQCUR, where NQCUR is the current order
!             (See optional outputs).  The capability corresponding
!             to K = 0, i.e. computing y(T), is already provided
!             by DLSODES directly.  Since NQCUR .ge. 1, the first
!             derivative dy/dt is always available with DINTDY.
! LYH       = the base address of the history array YH, obtained
!             as an optional output as shown above.
! NYH       = column length of YH, equal to the initial value of NEQ.
!
! The output parameters are:
!
! DKY       = a real array of length NEQ containing the computed value
!             of the K-th derivative of y(t).
! IFLAG     = integer flag, returned as 0 if K and T were legal,
!             -1 if K was illegal, and -2 if T was illegal.
!             On an error return, a message is also written.
!-----------------------------------------------------------------------
! Part 3.  Common Blocks.
!
! If DLSODES is to be used in an overlay situation, the user
! must declare, in the primary overlay, the variables in:
!   (1) the call sequence to DLSODES, and
!   (2) the two internal Common blocks
!         /DLS001/  of length  255  (218 real*8 words
!                      followed by 37 integer words),
!         /DLSS01/  of length  40  (6 real*8 words
!                      followed by 34 integer words),
!
! If DLSODES is used on a system in which the contents of internal
! Common blocks are not preserved between calls, the user should
! declare the above Common blocks in the calling program to insure
! that their contents are preserved.
!
! If the solution of a given problem by DLSODES is to be interrupted
! and then later continued, such as when restarting an interrupted run
! or alternating between two or more problems, the user should save,
! following the return from the last DLSODES call prior to the
! interruption, the contents of the call sequence variables and the
! internal Common blocks, and later restore these values before the
! next DLSODES call for that problem.  To save and restore the Common
! blocks, use Subroutine DSRCMS (see Part 2 above).
!
!-----------------------------------------------------------------------
! Part 4.  Optionally Replaceable Solver Routines.
!
! Below are descriptions of two routines in the DLSODES package which
! relate to the measurement of errors.  Either routine can be
! replaced by a user-supplied version, if desired.  However, since such
! a replacement may have a major impact on performance, it should be
! done only when absolutely necessary, and only with great caution.
! (Note: The means by which the package version of a routine is
! superseded by the user's version may be system-dependent.)
!
! (a) DEWSET.
! The following subroutine is called just before each internal
! integration step, and sets the array of error weights, EWT, as
! described under ITOL/RTOL/ATOL above:
!     Subroutine DEWSET (NEQ, ITOL, RTOL, ATOL, YCUR, EWT)
! where NEQ, ITOL, RTOL, and ATOL are as in the DLSODES call sequence,
! YCUR contains the current dependent variable vector, and
! EWT is the array of weights set by DEWSET.
!
! If the user supplies this subroutine, it must return in EWT(i)
! (i = 1,...,NEQ) a positive quantity suitable for comparing errors
! in y(i) to.  The EWT array returned by DEWSET is passed to the DVNORM
! routine (see below), and also used by DLSODES in the computation
! of the optional output IMXER, the diagonal Jacobian approximation,
! and the increments for difference quotient Jacobians.
!
! In the user-supplied version of DEWSET, it may be desirable to use
! the current values of derivatives of y.  Derivatives up to order NQ
! are available from the history array YH, described above under
! optional outputs.  In DEWSET, YH is identical to the YCUR array,
! extended to NQ + 1 columns with a column length of NYH and scale
! factors of H**j/factorial(j).  On the first call for the problem,
! given by NST = 0, NQ is 1 and H is temporarily set to 1.0.
! NYH is the initial value of NEQ.  The quantities NQ, H, and NST
! can be obtained by including in DEWSET the statements:
!     REAL*8 RLS
!     COMMON /DLS001/ RLS(218),ILS(37)
!     NQ = ILS(33)
!     NST = ILS(34)
!     H = RLS(212)
! Thus, for example, the current value of dy/dt can be obtained as
! YCUR(NYH+i)/H  (i=1,...,NEQ)  (and the division by H is
! unnecessary when NST = 0).
!
! (b) DVNORM.
! The following is a real function routine which computes the weighted
! root-mean-square norm of a vector v:
!     D = DVNORM (N, V, W)
! where
!   N = the length of the vector,
!   V = real array of length N containing the vector,
!   W = real array of length N containing weights,
!   D = SQRT( (1/N) * sum(V(i)*W(i))**2 ).
! DVNORM is called with N = NEQ and with W(i) = 1.0/EWT(i), where
! EWT is as set by Subroutine DEWSET.
!
! If the user supplies this function, it should return a non-negative
! value of DVNORM suitable for use in the error control in DLSODES.
! None of the arguments should be altered by DVNORM.
! For example, a user-supplied DVNORM routine might:
!   -substitute a max-norm of (V(i)*W(i)) for the RMS-norm, or
!   -ignore some components of V in the norm, with the effect of
!    suppressing the error control on those components of y.
!-----------------------------------------------------------------------
!
!***REVISION HISTORY  (YYYYMMDD)
! 19810120  DATE WRITTEN
! 19820315  Upgraded MDI in ODRV package: operates on M + M-transpose.
! 19820426  Numerous revisions in use of work arrays;
!           use wordlength ratio LENRAT; added IPISP & LRAT to Common;
!           added optional outputs IPIAN/IPJAN;
!           numerous corrections to comments.
! 19830503  Added routine CNTNZU; added NZL and NZU to /LSS001/;
!           changed ADJLR call logic; added optional outputs NZL & NZU;
!           revised counter initializations; revised PREP stmt. numbers;
!           corrections to comments throughout.
! 19870320  Corrected jump on test of umax in CDRV routine;
!           added ISTATE = -7 return.
! 19870330  Major update: corrected comments throughout;
!           removed TRET from Common; rewrote EWSET with 4 loops;
!           fixed t test in INTDY; added Cray directives in STODE;
!           in STODE, fixed DELP init. and logic around PJAC call;
!           combined routines to save/restore Common;
!           passed LEVEL = 0 in error message calls (except run abort).
! 20010425  Major update: convert source lines to upper case;
!           added *DECK lines; changed from 1 to * in dummy dimensions;
!           changed names R1MACH/D1MACH to RUMACH/DUMACH;
!           renamed routines for uniqueness across single/double prec.;
!           converted intrinsic names to generic form;
!           removed ILLIN and NTREP (data loaded) from Common;
!           removed all 'own' variables from Common;
!           changed error messages to quoted strings;
!           replaced XERRWV/XERRWD with 1993 revised version;
!           converted prologues, comments, error messages to mixed case;
!           converted arithmetic IF statements to logical IF statements;
!           numerous corrections to prologues and internal comments.
! 20010507  Converted single precision source to real*8.
! 20020502  Corrected declarations in descriptions of user routines.
! 20031105  Restored 'own' variables to Common blocks, to enable
!           interrupt/restart feature.
! 20031112  Added SAVE statements for data-loaded constants.
!
!-----------------------------------------------------------------------
! Other routines in the DLSODES package.
!
! In addition to Subroutine DLSODES, the DLSODES package includes the
! following subroutines and function routines:
!  DIPREP   acts as an iterface between DLSODES and DPREP, and also does
!           adjusting of work space pointers and work arrays.
!  DPREP    is called by DIPREP to compute sparsity and do sparse matrix
!           preprocessing if MITER = 1 or 2.
!  JGROUP   is called by DPREP to compute groups of Jacobian column
!           indices for use when MITER = 2.
!  ADJLR    adjusts the length of required sparse matrix work space.
!           It is called by DPREP.
!  CNTNZU   is called by DPREP and counts the nonzero elements in the
!           strict upper triangle of J + J-transpose, where J = df/dy.
!  DINTDY   computes an interpolated value of the y vector at t = TOUT.
!  DSTODE   is the core integrator, which does one step of the
!           integration and the associated error control.
!  DCFODE   sets all method coefficients and test constants.
!  DPRJS    computes and preprocesses the Jacobian matrix J = df/dy
!           and the Newton iteration matrix P = I - h*l0*J.
!  DSOLSS   manages solution of linear system in chord iteration.
!  DEWSET   sets the error weight vector EWT before each step.
!  DVNORM   computes the weighted RMS-norm of a vector.
!  DSRCMS   is a user-callable routine to save and restore
!           the contents of the internal Common blocks.
!  ODRV     constructs a reordering of the rows and columns of
!           a matrix by the minimum degree algorithm.  ODRV is a
!           driver routine which calls Subroutines MD, MDI, MDM,
!           MDP, MDU, and SRO.  See Ref. 2 for details.  (The ODRV
!           module has been modified since Ref. 2, however.)
!  CDRV     performs reordering, symbolic factorization, numerical
!           factorization, or linear system solution operations,
!           depending on a path argument ipath.  CDRV is a
!           driver routine which calls Subroutines NROC, NSFC,
!           NNFC, NNSC, and NNTC.  See Ref. 3 for details.
!           DLSODES uses CDRV to solve linear systems in which the
!           coefficient matrix is  P = I - con*J, where I is the
!           identity, con is a scalar, and J is an approximation to
!           the Jacobian df/dy.  Because CDRV deals with rowwise
!           sparsity descriptions, CDRV works with P-transpose, not P.
!  DUMACH   computes the unit roundoff in a machine-independent manner.
!  XERRWD, XSETUN, XSETF, IXSAV, and IUMACH  handle the printing of all
!           error messages and warnings.  XERRWD is machine-dependent.
! Note:  DVNORM, DUMACH, IXSAV, and IUMACH are function routines.
! All the others are subroutines.
!
!-----------------------------------------------------------------------
!
!     EXTERNAL DPRJS, DSOLSS
!
      REAL*8 DUMACH, DVNORM
      INTEGER INIT, MXSTEP, MXHNIL, NHNIL, NSLAST, NYH, IOWNS,          &
     &   ICF, IERPJ, IERSL, JCUR, JSTART, KFLAG, L,                     &
     &   LYH, LEWT, LACOR, LSAVF, LWM, LIWM, METH, MITER,               &
     &   MAXORD, MAXCOR, MSBP, MXNCF, N, NQ, NST, NFE, NJE, NQU
      INTEGER IPLOST, IESP, ISTATC, IYS, IBA, IBIAN, IBJAN, IBJGP,      &
     &   IPIAN, IPJAN, IPJGP, IPIGP, IPR, IPC, IPIC, IPISP, IPRSP, IPA, &
     &   LENYH, LENYHM, LENWK, LREQ, LRAT, LREST, LWMIN, MOSS, MSBJ,    &
     &   NSLJ, NGP, NLU, NNZ, NSP, NZL, NZU
      INTEGER I, I1, I2, IFLAG, IMAX, IMUL, IMXER, IPFLAG, IPGO, IREM,  &
     &   J, KGO, LENRAT, LENYHT, LENIW, LENRW, LF0, LIA, LJA,           &
     &   LRTEM, LWTEM, LYHD, LYHN, MF1, MORD, MXHNL0, MXSTP0, NCOLM
      REAL*8 ROWNS,                                                     &
     &   CCMAX, EL0, H, HMIN, HMXI, HU, RC, TN, UROUND
      REAL*8 CON0, CONMIN, CCMXJ, PSMALL, RBIG, SETH
      REAL*8 ATOLI, AYI, BIG, EWTI, H0, HMAX, HMX, RH, RTOLI,           &
     &   TCRIT, TDIST, TNEXT, TOL, TOLSF, TP, SIZE, SUM, W0
      DIMENSION MORD(2)
      LOGICAL IHIT
      CHARACTER*60 MSG
      SAVE LENRAT, MORD, MXSTP0, MXHNL0
!-----------------------------------------------------------------------
! The following two internal Common blocks contain
! (a) variables which are local to any subroutine but whose values must
!     be preserved between calls to the routine ("own" variables), and
! (b) variables which are communicated between subroutines.
! The block DLS001 is declared in subroutines DLSODES, DIPREP, DPREP,
! DINTDY, DSTODE, DPRJS, and DSOLSS.
! The block DLSS01 is declared in subroutines DLSODES, DIPREP, DPREP,
! DPRJS, and DSOLSS.
! Groups of variables are replaced by dummy arrays in the Common
! declarations in routines where those variables are not used.
!-----------------------------------------------------------------------
      COMMON /DLS001/ ROWNS(209),                                       &
     &   CCMAX, EL0, H, HMIN, HMXI, HU, RC, TN, UROUND,                 &
     &   INIT, MXSTEP, MXHNIL, NHNIL, NSLAST, NYH, IOWNS(6),            &
     &   ICF, IERPJ, IERSL, JCUR, JSTART, KFLAG, L,                     &
     &   LYH, LEWT, LACOR, LSAVF, LWM, LIWM, METH, MITER,               &
     &   MAXORD, MAXCOR, MSBP, MXNCF, N, NQ, NST, NFE, NJE, NQU
!
      COMMON /DLSS01/ CON0, CONMIN, CCMXJ, PSMALL, RBIG, SETH,          &
     &   IPLOST, IESP, ISTATC, IYS, IBA, IBIAN, IBJAN, IBJGP,           &
     &   IPIAN, IPJAN, IPJGP, IPIGP, IPR, IPC, IPIC, IPISP, IPRSP, IPA, &
     &   LENYH, LENYHM, LENWK, LREQ, LRAT, LREST, LWMIN, MOSS, MSBJ,    &
     &   NSLJ, NGP, NLU, NNZ, NSP, NZL, NZU
!
      DATA MORD(1),MORD(2)/12,5/, MXSTP0/500/, MXHNL0/10/
!-----------------------------------------------------------------------
! In the Data statement below, set LENRAT equal to the ratio of
! the wordlength for a real number to that for an integer.  Usually,
! LENRAT = 1 for single precision and 2 for real*8.  If the
! true ratio is not an integer, use the next smaller integer (.ge. 1).
!-----------------------------------------------------------------------
      DATA LENRAT/2/
!
!
!-----------------------------------------------------------------------
! Block ZA.
! Initial suppl. input variables for FDRIV
!c    nvs_spec=NEQ(1)
      NEQ(1)=nvs_spec
!
!-----------------------------------------------------------------------
! Block A.
! This code block is executed on every call.
! It tests ISTATE and ITASK for legality and branches appropriately.
! If ISTATE .gt. 1 but the flag INIT shows that initialization has
! not yet been done, an error return occurs.
! If ISTATE = 1 and TOUT = T, return immediately.
!-----------------------------------------------------------------------
      IF (ISTATE .LT. 1 .OR. ISTATE .GT. 3) GO TO 601
      IF (ITASK .LT. 1 .OR. ITASK .GT. 5) GO TO 602
      IF (ISTATE .EQ. 1) GO TO 10
      IF (INIT .EQ. 0) GO TO 603
      IF (ISTATE .EQ. 2) GO TO 200
      GO TO 20
 10   INIT = 0
      IF (TOUT .EQ. T) RETURN
!-----------------------------------------------------------------------
! Block B.
! The next code block is executed for the initial call (ISTATE = 1),
! or for a continuation call with parameter changes (ISTATE = 3).
! It contains checking of all inputs and various initializations.
! If ISTATE = 1, the final setting of work space pointers, the matrix
! preprocessing, and other initializations are done in Block C.
!
! First check legality of the non-optional inputs NEQ, ITOL, IOPT,
! MF, ML, and MU.
!-----------------------------------------------------------------------
 20   IF (NEQ(1) .LE. 0) GO TO 604
      IF (ISTATE .EQ. 1) GO TO 25
      IF (NEQ(1) .GT. N) GO TO 605
 25   N = NEQ(1)
      IF (ITOL .LT. 1 .OR. ITOL .GT. 4) GO TO 606
      IF (IOPT .LT. 0 .OR. IOPT .GT. 1) GO TO 607
      MOSS = MF/100
      MF1 = MF - 100*MOSS
      METH = MF1/10
      MITER = MF1 - 10*METH
      IF (MOSS .LT. 0 .OR. MOSS .GT. 2) GO TO 608
      IF (METH .LT. 1 .OR. METH .GT. 2) GO TO 608
      IF (MITER .LT. 0 .OR. MITER .GT. 3) GO TO 608
      IF (MITER .EQ. 0 .OR. MITER .EQ. 3) MOSS = 0
! Next process and check the optional inputs. --------------------------
      IF (IOPT .EQ. 1) GO TO 40
      MAXORD = MORD(METH)
      MXSTEP = MXSTP0
      MXHNIL = MXHNL0
      IF (ISTATE .EQ. 1) H0 = 0.0D0
      HMXI = 0.0D0
      HMIN = 0.0D0
      SETH = 0.0D0
      GO TO 60
 40   MAXORD = IWORK(5)
      IF (MAXORD .LT. 0) GO TO 611
      IF (MAXORD .EQ. 0) MAXORD = 100
      MAXORD = MIN(MAXORD,MORD(METH))
      MXSTEP = IWORK(6)
      IF (MXSTEP .LT. 0) GO TO 612
      IF (MXSTEP .EQ. 0) MXSTEP = MXSTP0
      MXHNIL = IWORK(7)
      IF (MXHNIL .LT. 0) GO TO 613
      IF (MXHNIL .EQ. 0) MXHNIL = MXHNL0
      IF (ISTATE .NE. 1) GO TO 50
      H0 = RWORK(5)
      IF ((TOUT - T)*H0 .LT. 0.0D0) GO TO 614
 50   HMAX = RWORK(6)
      IF (HMAX .LT. 0.0D0) GO TO 615
      HMXI = 0.0D0
      IF (HMAX .GT. 0.0D0) HMXI = 1.0D0/HMAX
      HMIN = RWORK(7)
      IF (HMIN .LT. 0.0D0) GO TO 616
      SETH = RWORK(8)
      IF (SETH .LT. 0.0D0) GO TO 609
! Check RTOL and ATOL for legality. ------------------------------------
 60   RTOLI = RTOL(1)
      ATOLI = ATOL(1)
      DO 65 I = 1,N
        IF (ITOL .GE. 3) RTOLI = RTOL(I)
        IF (ITOL .EQ. 2 .OR. ITOL .EQ. 4) ATOLI = ATOL(I)
        IF (RTOLI .LT. 0.0D0) GO TO 619
        IF (ATOLI .LT. 0.0D0) GO TO 620
 65     CONTINUE
!-----------------------------------------------------------------------
! Compute required work array lengths, as far as possible, and test
! these against LRW and LIW.  Then set tentative pointers for work
! arrays.  Pointers to RWORK/IWORK segments are named by prefixing L to
! the name of the segment.  E.g., the segment YH starts at RWORK(LYH).
! Segments of RWORK (in order) are denoted  WM, YH, SAVF, EWT, ACOR.
! If MITER = 1 or 2, the required length of the matrix work space WM
! is not yet known, and so a crude minimum value is used for the
! initial tests of LRW and LIW, and YH is temporarily stored as far
! to the right in RWORK as possible, to leave the maximum amount
! of space for WM for matrix preprocessing.  Thus if MITER = 1 or 2
! and MOSS .ne. 2, some of the segments of RWORK are temporarily
! omitted, as they are not needed in the preprocessing.  These
! omitted segments are: ACOR if ISTATE = 1, EWT and ACOR if ISTATE = 3
! and MOSS = 1, and SAVF, EWT, and ACOR if ISTATE = 3 and MOSS = 0.
!-----------------------------------------------------------------------
      LRAT = LENRAT
      IF (ISTATE .EQ. 1) NYH = N
      LWMIN = 0
      IF (MITER .EQ. 1) LWMIN = 4*N + 10*N/LRAT
      IF (MITER .EQ. 2) LWMIN = 4*N + 11*N/LRAT
      IF (MITER .EQ. 3) LWMIN = N + 2
      LENYH = (MAXORD+1)*NYH
      LREST = LENYH + 3*N
      LENRW = 20 + LWMIN + LREST
      IWORK(17) = LENRW
      LENIW = 30
      IF (MOSS .EQ. 0 .AND. MITER .NE. 0 .AND. MITER .NE. 3)            &
     &   LENIW = LENIW + N + 1
      IWORK(18) = LENIW
      IF (LENRW .GT. LRW) GO TO 617
      IF (LENIW .GT. LIW) GO TO 618
      LIA = 31
      IF (MOSS .EQ. 0 .AND. MITER .NE. 0 .AND. MITER .NE. 3)            &
     &   LENIW = LENIW + IWORK(LIA+N) - 1
      IWORK(18) = LENIW
      IF (LENIW .GT. LIW) GO TO 618
      LJA = LIA + N + 1
      LIA = MIN(LIA,LIW)
      LJA = MIN(LJA,LIW)
      LWM = 21
      IF (ISTATE .EQ. 1) NQ = 1
      NCOLM = MIN(NQ+1,MAXORD+2)
      LENYHM = NCOLM*NYH
      LENYHT = LENYH
      IF (MITER .EQ. 1 .OR. MITER .EQ. 2) LENYHT = LENYHM
      IMUL = 2
      IF (ISTATE .EQ. 3) IMUL = MOSS
      IF (MOSS .EQ. 2) IMUL = 3
      LRTEM = LENYHT + IMUL*N
      LWTEM = LWMIN
      IF (MITER .EQ. 1 .OR. MITER .EQ. 2) LWTEM = LRW - 20 - LRTEM
      LENWK = LWTEM
      LYHN = LWM + LWTEM
      LSAVF = LYHN + LENYHT
      LEWT = LSAVF + N
      LACOR = LEWT + N
      ISTATC = ISTATE
      IF (ISTATE .EQ. 1) GO TO 100
!-----------------------------------------------------------------------
! ISTATE = 3.  Move YH to its new location.
! Note that only the part of YH needed for the next step, namely
! MIN(NQ+1,MAXORD+2) columns, is actually moved.
! A temporary error weight array EWT is loaded if MOSS = 2.
! Sparse matrix processing is done in DIPREP/DPREP if MITER = 1 or 2.
! If MAXORD was reduced below NQ, then the pointers are finally set
! so that SAVF is identical to YH(*,MAXORD+2).
!-----------------------------------------------------------------------
      LYHD = LYH - LYHN
      IMAX = LYHN - 1 + LENYHM
! Move YH.  Move right if LYHD < 0; move left if LYHD > 0. -------------
      IF (LYHD .LT. 0) THEN
        DO 72 I = LYHN,IMAX
          J = IMAX + LYHN - I
 72       RWORK(J) = RWORK(J+LYHD)
      ENDIF
      IF (LYHD .GT. 0) THEN
        DO 76 I = LYHN,IMAX
 76       RWORK(I) = RWORK(I+LYHD)
      ENDIF
 80   LYH = LYHN
      IWORK(22) = LYH
      IF (MITER .EQ. 0 .OR. MITER .EQ. 3) GO TO 92
      IF (MOSS .NE. 2) GO TO 85
! Temporarily load EWT if MITER = 1 or 2 and MOSS = 2. -----------------
      CALL DEWSET (N, ITOL, RTOL, ATOL, RWORK(LYH), RWORK(LEWT))
      DO 82 I = 1,N
        IF (RWORK(I+LEWT-1) .LE. 0.0D0) GO TO 621
 82     RWORK(I+LEWT-1) = 1.0D0/RWORK(I+LEWT-1)
 85   CONTINUE
! DIPREP and DPREP do sparse matrix preprocessing if MITER = 1 or 2. ---
      LSAVF = MIN(LSAVF,LRW)
      LEWT = MIN(LEWT,LRW)
      LACOR = MIN(LACOR,LRW)
      CALL DIPREP (NEQ, Y, RWORK, IWORK(LIA),IWORK(LJA), IPFLAG         &
!    1       , FDRIV, FDJAC
!
     &                ,time_i_fs,xspec_i                                &
     &                ,vfor,vbak,xspec_min,xspec_max                    &
     &                ,yspec_min_vs,yspec_max_vs                        &
     &                ,wspec_vs_min,wspec_vs_max                        &
     &                ,frlim_vs_min,frlim_vs_max                        &
     &                ,rkfor,rkbak,rkfor2,rkbak2                        &
     &                ,odtime_rl,jkin,jrlim                             &
     &                ,lvfor,lvbak,lvreac                               &
     &                ,iispec,iospec,nipart,nopart                      &
     &                ,hicoop,hocoop                                    &
     &                ,iispec_vs,iospec_vs,nipart_vs,nopart_vs          &
     &                ,gimult_vs,gomult_vs,iivs_vs,iovs_vs              &
     &                ,nspec,nreac,nfs_spec,nvs_spec                    &
     &                ,ispec_fs,ispec_vs,nlim_drv,n_drv,k_drv           &
     &                ,jtevol,jfox,jfix,npulse,nperiod                  &
     &                ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod    &
     &                ,npmspec_x                                        &
     &                ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x)
!
      LENRW = LWM - 1 + LENWK + LREST
      IWORK(17) = LENRW
      IF (IPFLAG .NE. -1) IWORK(23) = IPIAN
      IF (IPFLAG .NE. -1) IWORK(24) = IPJAN
      IPGO = -IPFLAG + 1
      GO TO (90, 628, 629, 630, 631, 632, 633), IPGO
 90   IWORK(22) = LYH
      IF (LENRW .GT. LRW) GO TO 617
! Set flag to signal parameter changes to DSTODE. ----------------------
 92   JSTART = -1
      IF (N .EQ. NYH) GO TO 200
! NEQ was reduced.  Zero part of YH to avoid undefined references. -----
      I1 = LYH + L*NYH
      I2 = LYH + (MAXORD + 1)*NYH - 1
      IF (I1 .GT. I2) GO TO 200
      DO 95 I = I1,I2
 95     RWORK(I) = 0.0D0
      GO TO 200
!-----------------------------------------------------------------------
! Block C.
! The next block is for the initial call only (ISTATE = 1).
! It contains all remaining initializations,
! the initial call to FDRIV,
! the sparse matrix preprocessing (MITER = 1 or 2), and the
! calculation of the initial step size.
! The error weights in EWT are inverted after being loaded.
!-----------------------------------------------------------------------
 100  CONTINUE
      LYH = LYHN
      IWORK(22) = LYH
      TN = T
      NST = 0
      H = 1.0D0
      NNZ = 0
      NGP = 0
      NZL = 0
      NZU = 0
! Load the initial value vector in YH. ---------------------------------
      DO 105 I = 1,N
 105    RWORK(I+LYH-1) = Y(I)
! Initial call to FDRIV.  (LF0 points to YH(*,2).) -------------------------
      LF0 = LYH + NYH
!     CALL FDRIV (NEQ, T, Y, RWORK(LF0))
!     NEQ(1)-->nvs_spec, T-->time_xr, Y-->xspec, YDOT-->vspec
      CALL drivs(T,Y,RWORK(LF0)                                         &
     &                ,time_i_fs,xspec_i                                &
     &                ,vfor,vbak,xspec_min,xspec_max                    &
     &                ,yspec_min_vs,yspec_max_vs                        &
     &                ,wspec_vs_min,wspec_vs_max                        &
     &                ,frlim_vs_min,frlim_vs_max                        &
     &                ,rkfor,rkbak,rkfor2,rkbak2                        &
     &                ,odtime_rl,jkin,jrlim                             &
     &                ,lvfor,lvbak,lvreac                               &
     &                ,iispec,iospec,nipart,nopart                      &
     &                ,hicoop,hocoop                                    &
     &                ,iispec_vs,iospec_vs,nipart_vs,nopart_vs          &
     &                ,gimult_vs,gomult_vs,iivs_vs,iovs_vs              &
     &                ,nspec,nreac,nfs_spec,nvs_spec                    &
     &                ,ispec_fs,ispec_vs,nlim_drv,n_drv,k_drv           &
     &                ,jtevol,jfox,jfix,npulse,nperiod                  &
     &                ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod    &
     &                ,npmspec_x                                        &
     &                ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x)
      NFE = 1
! Load and invert the EWT array.  (H is temporarily set to 1.0.) -------
      CALL DEWSET (N, ITOL, RTOL, ATOL, RWORK(LYH), RWORK(LEWT))
      DO 110 I = 1,N
        IF (RWORK(I+LEWT-1) .LE. 0.0D0) GO TO 621
 110    RWORK(I+LEWT-1) = 1.0D0/RWORK(I+LEWT-1)
      IF (MITER .EQ. 0 .OR. MITER .EQ. 3) GO TO 120
! DIPREP and DPREP do sparse matrix preprocessing if MITER = 1 or 2. ---
      LACOR = MIN(LACOR,LRW)
      CALL DIPREP (NEQ, Y, RWORK, IWORK(LIA),IWORK(LJA), IPFLAG         &
!    1       , FDRIV, FDJAC
!
     &                ,time_i_fs,xspec_i                                &
     &                ,vfor,vbak,xspec_min,xspec_max                    &
     &                ,yspec_min_vs,yspec_max_vs                        &
     &                ,wspec_vs_min,wspec_vs_max                        &
     &                ,frlim_vs_min,frlim_vs_max                        &
     &                ,rkfor,rkbak,rkfor2,rkbak2                        &
     &                ,odtime_rl,jkin,jrlim                             &
     &                ,lvfor,lvbak,lvreac                               &
     &                ,iispec,iospec,nipart,nopart                      &
     &                ,hicoop,hocoop                                    &
     &                ,iispec_vs,iospec_vs,nipart_vs,nopart_vs          &
     &                ,gimult_vs,gomult_vs,iivs_vs,iovs_vs              &
     &                ,nspec,nreac,nfs_spec,nvs_spec                    &
     &                ,ispec_fs,ispec_vs,nlim_drv,n_drv,k_drv           &
     &                ,jtevol,jfox,jfix,npulse,nperiod                  &
     &                ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod    &
     &                ,npmspec_x                                        &
     &                ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x)
!
      LENRW = LWM - 1 + LENWK + LREST
      IWORK(17) = LENRW
      IF (IPFLAG .NE. -1) IWORK(23) = IPIAN
      IF (IPFLAG .NE. -1) IWORK(24) = IPJAN
      IPGO = -IPFLAG + 1
      GO TO (115, 628, 629, 630, 631, 632, 633), IPGO
 115  IWORK(22) = LYH
      IF (LENRW .GT. LRW) GO TO 617
! Check TCRIT for legality (ITASK = 4 or 5). ---------------------------
 120  CONTINUE
      IF (ITASK .NE. 4 .AND. ITASK .NE. 5) GO TO 125
      TCRIT = RWORK(1)
      IF ((TCRIT - TOUT)*(TOUT - T) .LT. 0.0D0) GO TO 625
      IF (H0 .NE. 0.0D0 .AND. (T + H0 - TCRIT)*H0 .GT. 0.0D0)           &
     &   H0 = TCRIT - T
! Initialize all remaining parameters. ---------------------------------
 125  UROUND = DUMACH()
      JSTART = 0
      IF (MITER .NE. 0) RWORK(LWM) = SQRT(UROUND)
      MSBJ = 50
      NSLJ = 0
      CCMXJ = 0.2D0
      PSMALL = 1000.0D0*UROUND
      RBIG = 0.01D0/PSMALL
      NHNIL = 0
      NJE = 0
      NLU = 0
      NSLAST = 0
      HU = 0.0D0
      NQU = 0
      CCMAX = 0.3D0
      MAXCOR = 3
      MSBP = 20
      MXNCF = 10
!-----------------------------------------------------------------------
! The coding below computes the step size, H0, to be attempted on the
! first step, unless the user has supplied a value for this.
! First check that TOUT - T differs significantly from zero.
! A scalar tolerance quantity TOL is computed, as MAX(RTOL(i))
! if this is positive, or MAX(ATOL(i)/ABS(Y(i))) otherwise, adjusted
! so as to be between 100*UROUND and 1.0E-3.
! Then the computed value H0 is given by..
!                                      NEQ
!   H0**2 = TOL / ( w0**-2 + (1/NEQ) * Sum ( f(i)/ywt(i) )**2  )
!                                       1
! where   w0     = MAX ( ABS(T), ABS(TOUT) ),
!         f(i)   = i-th component of initial value of f,
!         ywt(i) = EWT(i)/TOL  (a weight for y(i)).
! The sign of H0 is inferred from the initial values of TOUT and T.
! ABS(H0) is made .le. ABS(TOUT-T) in any case.
!-----------------------------------------------------------------------
      LF0 = LYH + NYH
      IF (H0 .NE. 0.0D0) GO TO 180
      TDIST = ABS(TOUT - T)
      W0 = MAX(ABS(T),ABS(TOUT))
      IF (TDIST .LT. 2.0D0*UROUND*W0) GO TO 622
      TOL = RTOL(1)
      IF (ITOL .LE. 2) GO TO 140
      DO 130 I = 1,N
 130    TOL = MAX(TOL,RTOL(I))
 140  IF (TOL .GT. 0.0D0) GO TO 160
      ATOLI = ATOL(1)
      DO 150 I = 1,N
        IF (ITOL .EQ. 2 .OR. ITOL .EQ. 4) ATOLI = ATOL(I)
        AYI = ABS(Y(I))
        IF (AYI .NE. 0.0D0) TOL = MAX(TOL,ATOLI/AYI)
 150    CONTINUE
 160  TOL = MAX(TOL,100.0D0*UROUND)
      TOL = MIN(TOL,0.001D0)
      SUM = DVNORM (N, RWORK(LF0), RWORK(LEWT))
      SUM = 1.0D0/(TOL*W0*W0) + TOL*SUM**2
      H0 = 1.0D0/SQRT(SUM)
      H0 = MIN(H0,TDIST)
      H0 = SIGN(H0,TOUT-T)
! Adjust H0 if necessary to meet HMAX bound. ---------------------------
 180  RH = ABS(H0)*HMXI
      IF (RH .GT. 1.0D0) H0 = H0/RH
! Load H with H0 and scale YH(*,2) by H0. ------------------------------
      H = H0
      DO 190 I = 1,N
 190    RWORK(I+LF0-1) = H0*RWORK(I+LF0-1)
      GO TO 270
!-----------------------------------------------------------------------
! Block D.
! The next code block is for continuation calls only (ISTATE = 2 or 3)
! and is to check termination conditions before taking a step.
!-----------------------------------------------------------------------
 200  NSLAST = NST
      GO TO (210, 250, 220, 230, 240), ITASK
 210  IF ((TN - TOUT)*H .LT. 0.0D0) GO TO 250
      CALL DINTDY (TOUT, 0, RWORK(LYH), NYH, Y, IFLAG)
      IF (IFLAG .NE. 0) GO TO 627
      T = TOUT
      GO TO 420
 220  TP = TN - HU*(1.0D0 + 100.0D0*UROUND)
      IF ((TP - TOUT)*H .GT. 0.0D0) GO TO 623
      IF ((TN - TOUT)*H .LT. 0.0D0) GO TO 250
      GO TO 400
 230  TCRIT = RWORK(1)
      IF ((TN - TCRIT)*H .GT. 0.0D0) GO TO 624
      IF ((TCRIT - TOUT)*H .LT. 0.0D0) GO TO 625
      IF ((TN - TOUT)*H .LT. 0.0D0) GO TO 245
      CALL DINTDY (TOUT, 0, RWORK(LYH), NYH, Y, IFLAG)
      IF (IFLAG .NE. 0) GO TO 627
      T = TOUT
      GO TO 420
 240  TCRIT = RWORK(1)
      IF ((TN - TCRIT)*H .GT. 0.0D0) GO TO 624
 245  HMX = ABS(TN) + ABS(H)
      IHIT = ABS(TN - TCRIT) .LE. 100.0D0*UROUND*HMX
      IF (IHIT) GO TO 400
      TNEXT = TN + H*(1.0D0 + 4.0D0*UROUND)
      IF ((TNEXT - TCRIT)*H .LE. 0.0D0) GO TO 250
      H = (TCRIT - TN)*(1.0D0 - 4.0D0*UROUND)
      IF (ISTATE .EQ. 2) JSTART = -2
!-----------------------------------------------------------------------
! Block E.
! The next block is normally executed for all calls and contains
! the call to the one-step core integrator DSTODE.
!
! This is a looping point for the integration steps.
!
! First check for too many steps being taken, update EWT (if not at
! start of problem), check for too much accuracy being requested, and
! check for H below the roundoff level in T.
!-----------------------------------------------------------------------
 250  CONTINUE
      IF ((NST-NSLAST) .GE. MXSTEP) GO TO 500
      CALL DEWSET (N, ITOL, RTOL, ATOL, RWORK(LYH), RWORK(LEWT))
      DO 260 I = 1,N
        IF (RWORK(I+LEWT-1) .LE. 0.0D0) GO TO 510
 260    RWORK(I+LEWT-1) = 1.0D0/RWORK(I+LEWT-1)
 270  TOLSF = UROUND*DVNORM (N, RWORK(LYH), RWORK(LEWT))
      IF (TOLSF .LE. 1.0D0) GO TO 280
      TOLSF = TOLSF*2.0D0
      IF (NST .EQ. 0) GO TO 626
      GO TO 520
 280  IF ((TN + H) .NE. TN) GO TO 290
      NHNIL = NHNIL + 1
      IF (NHNIL .GT. MXHNIL) GO TO 290
      MSG = 'DLSODES- Warning..Internal T (=R1) and H (=R2) are'
      CALL XERRWD (MSG, 50, 101, 0, 0, 0, 0, 0, 0.0D0, 0.0D0)
      MSG='      such that in the machine, T + H = T on the next step  '
      CALL XERRWD (MSG, 60, 101, 0, 0, 0, 0, 0, 0.0D0, 0.0D0)
      MSG = '     (H = step size). Solver will continue anyway.'
      CALL XERRWD (MSG, 50, 101, 0, 0, 0, 0, 2, TN, H)
      IF (NHNIL .LT. MXHNIL) GO TO 290
      MSG = 'DLSODES- Above warning has been issued I1 times.  '
      CALL XERRWD (MSG, 50, 102, 0, 0, 0, 0, 0, 0.0D0, 0.0D0)
      MSG = '     It will not be issued again for this problem.'
      CALL XERRWD (MSG, 50, 102, 0, 1, MXHNIL, 0, 0, 0.0D0, 0.0D0)
 290  CONTINUE
!-----------------------------------------------------------------------
      CALL DSTODE (NEQ, Y, RWORK(LYH), NYH, RWORK(LYH), RWORK(LEWT)     &
     &   , RWORK(LSAVF), RWORK(LACOR), RWORK(LWM), RWORK(LWM)           &
!    2   , FDRIV, FDJAC
!    1   , DPRJS, DSOLSS
!
     &                ,time_i_fs,xspec_i                                &
     &                ,vfor,vbak,xspec_min,xspec_max                    &
     &                ,yspec_min_vs,yspec_max_vs                        &
     &                ,wspec_vs_min,wspec_vs_max                        &
     &                ,frlim_vs_min,frlim_vs_max                        &
     &                ,rkfor,rkbak,rkfor2,rkbak2                        &
     &                ,odtime_rl,jkin,jrlim                             &
     &                ,lvfor,lvbak,lvreac                               &
     &                ,iispec,iospec,nipart,nopart                      &
     &                ,hicoop,hocoop                                    &
     &                ,iispec_vs,iospec_vs,nipart_vs,nopart_vs          &
     &                ,gimult_vs,gomult_vs,iivs_vs,iovs_vs              &
     &                ,nspec,nreac,nfs_spec,nvs_spec                    &
     &                ,ispec_fs,ispec_vs,nlim_drv,n_drv,k_drv           &
     &                ,jtevol,jfox,jfix,npulse,nperiod                  &
     &                ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod    &
     &                ,npmspec_x                                        &
     &                ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x)
!
      KGO = 1 - KFLAG
      GO TO (300, 530, 540, 550), KGO
!-----------------------------------------------------------------------
! Block F.
! The following block handles the case of a successful return from the
! core integrator (KFLAG = 0).  Test for termination conditions.
!-----------------------------------------------------------------------
 300  INIT = 1
      GO TO (310, 400, 330, 340, 350), ITASK
! ITASK = 1.  if TOUT has been reached, interpolate. -------------------
 310  IF ((TN - TOUT)*H .LT. 0.0D0) GO TO 250
      CALL DINTDY (TOUT, 0, RWORK(LYH), NYH, Y, IFLAG)
      T = TOUT
      GO TO 420
! ITASK = 3.  Jump to exit if TOUT was reached. ------------------------
 330  IF ((TN - TOUT)*H .GE. 0.0D0) GO TO 400
      GO TO 250
! ITASK = 4.  See if TOUT or TCRIT was reached.  Adjust H if necessary.
 340  IF ((TN - TOUT)*H .LT. 0.0D0) GO TO 345
      CALL DINTDY (TOUT, 0, RWORK(LYH), NYH, Y, IFLAG)
      T = TOUT
      GO TO 420
 345  HMX = ABS(TN) + ABS(H)
      IHIT = ABS(TN - TCRIT) .LE. 100.0D0*UROUND*HMX
      IF (IHIT) GO TO 400
      TNEXT = TN + H*(1.0D0 + 4.0D0*UROUND)
      IF ((TNEXT - TCRIT)*H .LE. 0.0D0) GO TO 250
      H = (TCRIT - TN)*(1.0D0 - 4.0D0*UROUND)
      JSTART = -2
      GO TO 250
! ITASK = 5.  See if TCRIT was reached and jump to exit. ---------------
 350  HMX = ABS(TN) + ABS(H)
      IHIT = ABS(TN - TCRIT) .LE. 100.0D0*UROUND*HMX
!-----------------------------------------------------------------------
! Block G.
! The following block handles all successful returns from DLSODES.
! If ITASK .ne. 1, Y is loaded from YH and T is set accordingly.
! ISTATE is set to 2, and the optional outputs are loaded into the
! work arrays before returning.
!-----------------------------------------------------------------------
 400  DO 410 I = 1,N
 410    Y(I) = RWORK(I+LYH-1)
      T = TN
      IF (ITASK .NE. 4 .AND. ITASK .NE. 5) GO TO 420
      IF (IHIT) T = TCRIT
 420  ISTATE = 2
      RWORK(11) = HU
      RWORK(12) = H
      RWORK(13) = TN
      IWORK(11) = NST
      IWORK(12) = NFE
      IWORK(13) = NJE
      IWORK(14) = NQU
      IWORK(15) = NQ
      IWORK(19) = NNZ
      IWORK(20) = NGP
      IWORK(21) = NLU
      IWORK(25) = NZL
      IWORK(26) = NZU
      RETURN
!-----------------------------------------------------------------------
! Block H.
! The following block handles all unsuccessful returns other than
! those for illegal input.  First the error message routine is called.
! If there was an error test or convergence test failure, IMXER is set.
! Then Y is loaded from YH and T is set to TN.
! The optional outputs are loaded into the work arrays before returning.
!-----------------------------------------------------------------------
! The maximum number of steps was taken before reaching TOUT. ----------
 500  MSG = 'DLSODES- At current T (=R1), MXSTEP (=I1) steps   '
      CALL XERRWD (MSG, 50, 201, 0, 0, 0, 0, 0, 0.0D0, 0.0D0)
      MSG = '      taken on this call before reaching TOUT     '
      CALL XERRWD (MSG, 50, 201, 0, 1, MXSTEP, 0, 1, TN, 0.0D0)
      ISTATE = -1
      GO TO 580
! EWT(i) .le. 0.0 for some i (not at start of problem). ----------------
 510  EWTI = RWORK(LEWT+I-1)
      MSG = 'DLSODES- At T (=R1), EWT(I1) has become R2 .le. 0.'
      CALL XERRWD (MSG, 50, 202, 0, 1, I, 0, 2, TN, EWTI)
      ISTATE = -6
      GO TO 580
! Too much accuracy requested for machine precision. -------------------
 520  MSG = 'DLSODES- At T (=R1), too much accuracy requested  '
      CALL XERRWD (MSG, 50, 203, 0, 0, 0, 0, 0, 0.0D0, 0.0D0)
      MSG = '      for precision of machine..  See TOLSF (=R2) '
      CALL XERRWD (MSG, 50, 203, 0, 0, 0, 0, 2, TN, TOLSF)
      RWORK(14) = TOLSF
      ISTATE = -2
      GO TO 580
! KFLAG = -1.  Error test failed repeatedly or with ABS(H) = HMIN. -----
 530  MSG = 'DLSODES- At T(=R1) and step size H(=R2), the error'
      CALL XERRWD (MSG, 50, 204, 0, 0, 0, 0, 0, 0.0D0, 0.0D0)
      MSG = '      test failed repeatedly or with ABS(H) = HMIN'
      CALL XERRWD (MSG, 50, 204, 0, 0, 0, 0, 2, TN, H)
      ISTATE = -4
      GO TO 560
! KFLAG = -2.  Convergence failed repeatedly or with ABS(H) = HMIN. ----
 540  MSG = 'DLSODES- At T (=R1) and step size H (=R2), the    '
      CALL XERRWD (MSG, 50, 205, 0, 0, 0, 0, 0, 0.0D0, 0.0D0)
      MSG = '      corrector convergence failed repeatedly     '
      CALL XERRWD (MSG, 50, 205, 0, 0, 0, 0, 0, 0.0D0, 0.0D0)
      MSG = '      or with ABS(H) = HMIN   '
      CALL XERRWD (MSG, 30, 205, 0, 0, 0, 0, 2, TN, H)
      ISTATE = -5
      GO TO 560
! KFLAG = -3.  Fatal error flag returned by DPRJS or DSOLSS (CDRV). ----
 550  MSG = 'DLSODES- At T (=R1) and step size H (=R2), a fatal'
      CALL XERRWD (MSG, 50, 207, 0, 0, 0, 0, 0, 0.0D0, 0.0D0)
      MSG = '      error flag was returned by CDRV (by way of  '
      CALL XERRWD (MSG, 50, 207, 0, 0, 0, 0, 0, 0.0D0, 0.0D0)
      MSG = '      Subroutine DPRJS or DSOLSS)       '
      CALL XERRWD (MSG, 40, 207, 0, 0, 0, 0, 2, TN, H)
      ISTATE = -7
      GO TO 580
! Compute IMXER if relevant. -------------------------------------------
 560  BIG = 0.0D0
      IMXER = 1
      DO 570 I = 1,N
        SIZE = ABS(RWORK(I+LACOR-1)*RWORK(I+LEWT-1))
        IF (BIG .GE. SIZE) GO TO 570
        BIG = SIZE
        IMXER = I
 570    CONTINUE
      IWORK(16) = IMXER
! Set Y vector, T, and optional outputs. -------------------------------
 580  DO 590 I = 1,N
 590    Y(I) = RWORK(I+LYH-1)
      T = TN
      RWORK(11) = HU
      RWORK(12) = H
      RWORK(13) = TN
      IWORK(11) = NST
      IWORK(12) = NFE
      IWORK(13) = NJE
      IWORK(14) = NQU
      IWORK(15) = NQ
      IWORK(19) = NNZ
      IWORK(20) = NGP
      IWORK(21) = NLU
      IWORK(25) = NZL
      IWORK(26) = NZU
      RETURN
!-----------------------------------------------------------------------
! Block I.
! The following block handles all error returns due to illegal input
! (ISTATE = -3), as detected before calling the core integrator.
! First the error message routine is called.  If the illegal input
! is a negative ISTATE, the run is aborted (apparent infinite loop).
!-----------------------------------------------------------------------
 601  MSG = 'DLSODES- ISTATE (=I1) illegal.'
      CALL XERRWD (MSG, 30, 1, 0, 1, ISTATE, 0, 0, 0.0D0, 0.0D0)
      IF (ISTATE .LT. 0) GO TO 800
      GO TO 700
 602  MSG = 'DLSODES- ITASK (=I1) illegal. '
      CALL XERRWD (MSG, 30, 2, 0, 1, ITASK, 0, 0, 0.0D0, 0.0D0)
      GO TO 700
 603  MSG = 'DLSODES- ISTATE.gt.1 but DLSODES not initialized. '
      CALL XERRWD (MSG, 50, 3, 0, 0, 0, 0, 0, 0.0D0, 0.0D0)
      GO TO 700
 604  MSG = 'DLSODES- NEQ (=I1) .lt. 1     '
      CALL XERRWD (MSG, 30, 4, 0, 1, NEQ(1), 0, 0, 0.0D0, 0.0D0)
      GO TO 700
 605  MSG = 'DLSODES- ISTATE = 3 and NEQ increased (I1 to I2). '
      CALL XERRWD (MSG, 50, 5, 0, 2, N, NEQ(1), 0, 0.0D0, 0.0D0)
      GO TO 700
 606  MSG = 'DLSODES- ITOL (=I1) illegal.  '
      CALL XERRWD (MSG, 30, 6, 0, 1, ITOL, 0, 0, 0.0D0, 0.0D0)
      GO TO 700
 607  MSG = 'DLSODES- IOPT (=I1) illegal.  '
      CALL XERRWD (MSG, 30, 7, 0, 1, IOPT, 0, 0, 0.0D0, 0.0D0)
      GO TO 700
 608  MSG = 'DLSODES- MF (=I1) illegal.    '
      CALL XERRWD (MSG, 30, 8, 0, 1, MF, 0, 0, 0.0D0, 0.0D0)
      GO TO 700
 609  MSG = 'DLSODES- SETH (=R1) .lt. 0.0  '
      CALL XERRWD (MSG, 30, 9, 0, 0, 0, 0, 1, SETH, 0.0D0)
      GO TO 700
 611  MSG = 'DLSODES- MAXORD (=I1) .lt. 0  '
      CALL XERRWD (MSG, 30, 11, 0, 1, MAXORD, 0, 0, 0.0D0, 0.0D0)
      GO TO 700
 612  MSG = 'DLSODES- MXSTEP (=I1) .lt. 0  '
      CALL XERRWD (MSG, 30, 12, 0, 1, MXSTEP, 0, 0, 0.0D0, 0.0D0)
      GO TO 700
 613  MSG = 'DLSODES- MXHNIL (=I1) .lt. 0  '
      CALL XERRWD (MSG, 30, 13, 0, 1, MXHNIL, 0, 0, 0.0D0, 0.0D0)
      GO TO 700
 614  MSG = 'DLSODES- TOUT (=R1) behind T (=R2)      '
      CALL XERRWD (MSG, 40, 14, 0, 0, 0, 0, 2, TOUT, T)
      MSG = '      Integration direction is given by H0 (=R1)  '
      CALL XERRWD (MSG, 50, 14, 0, 0, 0, 0, 1, H0, 0.0D0)
      GO TO 700
 615  MSG = 'DLSODES- HMAX (=R1) .lt. 0.0  '
      CALL XERRWD (MSG, 30, 15, 0, 0, 0, 0, 1, HMAX, 0.0D0)
      GO TO 700
 616  MSG = 'DLSODES- HMIN (=R1) .lt. 0.0  '
      CALL XERRWD (MSG, 30, 16, 0, 0, 0, 0, 1, HMIN, 0.0D0)
      GO TO 700
 617  MSG = 'DLSODES- RWORK length is insufficient to proceed. '
      CALL XERRWD (MSG, 50, 17, 0, 0, 0, 0, 0, 0.0D0, 0.0D0)
      MSG='        Length needed is .ge. LENRW (=I1), exceeds LRW (=I2)'
      CALL XERRWD (MSG, 60, 17, 0, 2, LENRW, LRW, 0, 0.0D0, 0.0D0)
      GO TO 700
 618  MSG = 'DLSODES- IWORK length is insufficient to proceed. '
      CALL XERRWD (MSG, 50, 18, 0, 0, 0, 0, 0, 0.0D0, 0.0D0)
      MSG='        Length needed is .ge. LENIW (=I1), exceeds LIW (=I2)'
      CALL XERRWD (MSG, 60, 18, 0, 2, LENIW, LIW, 0, 0.0D0, 0.0D0)
      GO TO 700
 619  MSG = 'DLSODES- RTOL(I1) is R1 .lt. 0.0        '
      CALL XERRWD (MSG, 40, 19, 0, 1, I, 0, 1, RTOLI, 0.0D0)
      GO TO 700
 620  MSG = 'DLSODES- ATOL(I1) is R1 .lt. 0.0        '
      CALL XERRWD (MSG, 40, 20, 0, 1, I, 0, 1, ATOLI, 0.0D0)
      GO TO 700
 621  EWTI = RWORK(LEWT+I-1)
      MSG = 'DLSODES- EWT(I1) is R1 .le. 0.0         '
      CALL XERRWD (MSG, 40, 21, 0, 1, I, 0, 1, EWTI, 0.0D0)
      GO TO 700
 622  MSG='DLSODES- TOUT(=R1) too close to T(=R2) to start integration.'
      CALL XERRWD (MSG, 60, 22, 0, 0, 0, 0, 2, TOUT, T)
      GO TO 700
 623  MSG='DLSODES- ITASK = I1 and TOUT (=R1) behind TCUR - HU (= R2)  '
      CALL XERRWD (MSG, 60, 23, 0, 1, ITASK, 0, 2, TOUT, TP)
      GO TO 700
 624  MSG='DLSODES- ITASK = 4 or 5 and TCRIT (=R1) behind TCUR (=R2)   '
      CALL XERRWD (MSG, 60, 24, 0, 0, 0, 0, 2, TCRIT, TN)
      GO TO 700
 625  MSG='DLSODES- ITASK = 4 or 5 and TCRIT (=R1) behind TOUT (=R2)   '
      CALL XERRWD (MSG, 60, 25, 0, 0, 0, 0, 2, TCRIT, TOUT)
      GO TO 700
 626  MSG = 'DLSODES- At start of problem, too much accuracy   '
      CALL XERRWD (MSG, 50, 26, 0, 0, 0, 0, 0, 0.0D0, 0.0D0)
      MSG='      requested for precision of machine..  See TOLSF (=R1) '
      CALL XERRWD (MSG, 60, 26, 0, 0, 0, 0, 1, TOLSF, 0.0D0)
      RWORK(14) = TOLSF
      GO TO 700
 627  MSG = 'DLSODES- Trouble in DINTDY.  ITASK = I1, TOUT = R1'
      CALL XERRWD (MSG, 50, 27, 0, 1, ITASK, 0, 1, TOUT, 0.0D0)
      GO TO 700
 628  MSG='DLSODES- RWORK length insufficient (for Subroutine DPREP).  '
      CALL XERRWD (MSG, 60, 28, 0, 0, 0, 0, 0, 0.0D0, 0.0D0)
      MSG='        Length needed is .ge. LENRW (=I1), exceeds LRW (=I2)'
      CALL XERRWD (MSG, 60, 28, 0, 2, LENRW, LRW, 0, 0.0D0, 0.0D0)
      GO TO 700
 629  MSG='DLSODES- RWORK length insufficient (for Subroutine JGROUP). '
      CALL XERRWD (MSG, 60, 29, 0, 0, 0, 0, 0, 0.0D0, 0.0D0)
      MSG='        Length needed is .ge. LENRW (=I1), exceeds LRW (=I2)'
      CALL XERRWD (MSG, 60, 29, 0, 2, LENRW, LRW, 0, 0.0D0, 0.0D0)
      GO TO 700
 630  MSG='DLSODES- RWORK length insufficient (for Subroutine ODRV).   '
      CALL XERRWD (MSG, 60, 30, 0, 0, 0, 0, 0, 0.0D0, 0.0D0)
      MSG='        Length needed is .ge. LENRW (=I1), exceeds LRW (=I2)'
      CALL XERRWD (MSG, 60, 30, 0, 2, LENRW, LRW, 0, 0.0D0, 0.0D0)
      GO TO 700
 631  MSG='DLSODES- Error from ODRV in Yale Sparse Matrix Package.     '
      CALL XERRWD (MSG, 60, 31, 0, 0, 0, 0, 0, 0.0D0, 0.0D0)
      IMUL = (IYS - 1)/N
      IREM = IYS - IMUL*N
      MSG='      At T (=R1), ODRV returned error flag = I1*NEQ + I2.   '
      CALL XERRWD (MSG, 60, 31, 0, 2, IMUL, IREM, 1, TN, 0.0D0)
      GO TO 700
 632  MSG='DLSODES- RWORK length insufficient (for Subroutine CDRV).   '
      CALL XERRWD (MSG, 60, 32, 0, 0, 0, 0, 0, 0.0D0, 0.0D0)
      MSG='        Length needed is .ge. LENRW (=I1), exceeds LRW (=I2)'
      CALL XERRWD (MSG, 60, 32, 0, 2, LENRW, LRW, 0, 0.0D0, 0.0D0)
      GO TO 700
 633  MSG='DLSODES- Error from CDRV in Yale Sparse Matrix Package.     '
      CALL XERRWD (MSG, 60, 33, 0, 0, 0, 0, 0, 0.0D0, 0.0D0)
      IMUL = (IYS - 1)/N
      IREM = IYS - IMUL*N
      MSG='      At T (=R1), CDRV returned error flag = I1*NEQ + I2.   '
      CALL XERRWD (MSG, 60, 33, 0, 2, IMUL, IREM, 1, TN, 0.0D0)
      IF (IMUL .EQ. 2) THEN
      MSG='        Duplicate entry in sparsity structure descriptors.  '
      CALL XERRWD (MSG, 60, 33, 0, 0, 0, 0, 0, 0.0D0, 0.0D0)
      ENDIF
      IF (IMUL .EQ. 3 .OR. IMUL .EQ. 6) THEN
      MSG='        Insufficient storage for NSFC (called by CDRV).     '
      CALL XERRWD (MSG, 60, 33, 0, 0, 0, 0, 0, 0.0D0, 0.0D0)
      ENDIF
!
 700  ISTATE = -3
      RETURN
!
 800  MSG = 'DLSODES- Run aborted.. apparent infinite loop.    '
      CALL XERRWD (MSG, 50, 303, 2, 0, 0, 0, 0, 0.0D0, 0.0D0)
      RETURN
!----------------------- END OF SUBR. DLSODES ---------------------
      END
!
!*DECK DCFODE
      SUBROUTINE DCFODE (METH, ELCO, TESCO)
!***BEGIN PROLOGUE  DCFODE
!***SUBSIDIARY
!***PURPOSE  Set ODE integrator coefficients.
!***TYPE      REAL*8 (SCFODE-S, DCFODE-D)
!***AUTHOR  Hindmarsh, Alan C., (LLNL)
!***DESCRIPTION
!
!  DCFODE is called by the integrator routine to set coefficients
!  needed there.  The coefficients for the current method, as
!  given by the value of METH, are set for all orders and saved.
!  The maximum order assumed here is 12 if METH = 1 and 5 if METH = 2.
!  (A smaller value of the maximum order is also allowed.)
!  DCFODE is called once at the beginning of the problem,
!  and is not called again unless and until METH is changed.
!
!  The ELCO array contains the basic method coefficients.
!  The coefficients el(i), 1 .le. i .le. nq+1, for the method of
!  order nq are stored in ELCO(i,nq).  They are given by a genetrating
!  polynomial, i.e.,
!      l(x) = el(1) + el(2)*x + ... + el(nq+1)*x**nq.
!  For the implicit Adams methods, l(x) is given by
!      dl/dx = (x+1)*(x+2)*...*(x+nq-1)/factorial(nq-1),    l(-1) = 0.
!  For the BDF methods, l(x) is given by
!      l(x) = (x+1)*(x+2)* ... *(x+nq)/K,
!  where         K = factorial(nq)*(1 + 1/2 + ... + 1/nq).
!
!  The TESCO array contains test constants used for the
!  local error test and the selection of step size and/or order.
!  At order nq, TESCO(k,nq) is used for the selection of step
!  size at order nq - 1 if k = 1, at order nq if k = 2, and at order
!  nq + 1 if k = 3.
!
!***SEE ALSO  DLSODE
!***ROUTINES CALLED  (NONE)
!***REVISION HISTORY  (YYMMDD)
!   791129  DATE WRITTEN
!   890501  Modified prologue to SLATEC/LDOC format.  (FNF)
!   890503  Minor cosmetic changes.  (FNF)
!   930809  Renamed to allow single/real*8 versions. (ACH)
!***END PROLOGUE  DCFODE
!**End
      INTEGER METH
      INTEGER I, IB, NQ, NQM1, NQP1
      REAL*8 ELCO, TESCO
      REAL*8 AGAMQ, FNQ, FNQM1, PC, PINT, RAGQ,                         &
     &   RQFAC, RQ1FAC, TSIGN, XPIN
      DIMENSION ELCO(13,12), TESCO(3,12)
      DIMENSION PC(12)
!
!***FIRST EXECUTABLE STATEMENT  DCFODE
      GO TO (100, 200), METH
!
 100  ELCO(1,1) = 1.0D0
      ELCO(2,1) = 1.0D0
      TESCO(1,1) = 0.0D0
      TESCO(2,1) = 2.0D0
      TESCO(1,2) = 1.0D0
      TESCO(3,12) = 0.0D0
      PC(1) = 1.0D0
      RQFAC = 1.0D0
      DO 140 NQ = 2,12
!-----------------------------------------------------------------------
! The PC array will contain the coefficients of the polynomial
!     p(x) = (x+1)*(x+2)*...*(x+nq-1).
! Initially, p(x) = 1.
!-----------------------------------------------------------------------
        RQ1FAC = RQFAC
        RQFAC = RQFAC/NQ
        NQM1 = NQ - 1
        FNQM1 = NQM1
        NQP1 = NQ + 1
! Form coefficients of p(x)*(x+nq-1). ----------------------------------
        PC(NQ) = 0.0D0
        DO 110 IB = 1,NQM1
          I = NQP1 - IB
 110      PC(I) = PC(I-1) + FNQM1*PC(I)
        PC(1) = FNQM1*PC(1)
! Compute integral, -1 to 0, of p(x) and x*p(x). -----------------------
        PINT = PC(1)
        XPIN = PC(1)/2.0D0
        TSIGN = 1.0D0
        DO 120 I = 2,NQ
          TSIGN = -TSIGN
          PINT = PINT + TSIGN*PC(I)/I
 120      XPIN = XPIN + TSIGN*PC(I)/(I+1)
! Store coefficients in ELCO and TESCO. --------------------------------
        ELCO(1,NQ) = PINT*RQ1FAC
        ELCO(2,NQ) = 1.0D0
        DO 130 I = 2,NQ
 130      ELCO(I+1,NQ) = RQ1FAC*PC(I)/I
        AGAMQ = RQFAC*XPIN
        RAGQ = 1.0D0/AGAMQ
        TESCO(2,NQ) = RAGQ
        IF (NQ .LT. 12) TESCO(1,NQP1) = RAGQ*RQFAC/NQP1
        TESCO(3,NQM1) = RAGQ
 140    CONTINUE
      RETURN
!
 200  PC(1) = 1.0D0
      RQ1FAC = 1.0D0
      DO 230 NQ = 1,5
!-----------------------------------------------------------------------
! The PC array will contain the coefficients of the polynomial
!     p(x) = (x+1)*(x+2)*...*(x+nq).
! Initially, p(x) = 1.
!-----------------------------------------------------------------------
        FNQ = NQ
        NQP1 = NQ + 1
! Form coefficients of p(x)*(x+nq). ------------------------------------
        PC(NQP1) = 0.0D0
        DO 210 IB = 1,NQ
          I = NQ + 2 - IB
 210      PC(I) = PC(I-1) + FNQ*PC(I)
        PC(1) = FNQ*PC(1)
! Store coefficients in ELCO and TESCO. --------------------------------
        DO 220 I = 1,NQP1
 220      ELCO(I,NQ) = PC(I)/PC(2)
        ELCO(2,NQ) = 1.0D0
        TESCO(1,NQ) = RQ1FAC
        TESCO(2,NQ) = NQP1/ELCO(1,NQ)
        TESCO(3,NQ) = (NQ+2)/ELCO(1,NQ)
        RQ1FAC = RQ1FAC/FNQ
 230    CONTINUE
      RETURN
!----------------------- END OF SUBR. DCFODE ----------------------
      END
!
!*DECK DINTDY
      SUBROUTINE DINTDY (T, K, YH, NYH, DKY, IFLAG)
!***BEGIN PROLOGUE  DINTDY
!***SUBSIDIARY
!***PURPOSE  Interpolate solution derivatives.
!***TYPE      REAL*8 (SINTDY-S, DINTDY-D)
!***AUTHOR  Hindmarsh, Alan C., (LLNL)
!***DESCRIPTION
!
!  DINTDY computes interpolated values of the K-th derivative of the
!  dependent variable vector y, and stores it in DKY.  This routine
!  is called within the package with K = 0 and T = TOUT, but may
!  also be called by the user for any K up to the current order.
!  (See detailed instructions in the usage documentation.)
!
!  The computed values in DKY are gotten by interpolation using the
!  Nordsieck history array YH.  This array corresponds uniquely to a
!  vector-valued polynomial of degree NQCUR or less, and DKY is set
!  to the K-th derivative of this polynomial at T.
!  The formula for DKY is:
!               q
!   DKY(i)  =  sum  c(j,K) * (T - tn)**(j-K) * h**(-j) * YH(i,j+1)
!              j=K
!  where  c(j,K) = j*(j-1)*...*(j-K+1), q = NQCUR, tn = TCUR, h = HCUR.
!  The quantities  nq = NQCUR, l = nq+1, N = NEQ, tn, and h are
!  communicated by COMMON.  The above sum is done in reverse order.
!  IFLAG is returned negative if either K or T is out of bounds.
!
!***SEE ALSO  DLSODE
!***ROUTINES CALLED  XERRWD
!***COMMON BLOCKS    DLS001
!***REVISION HISTORY  (YYMMDD)
!   791129  DATE WRITTEN
!   890501  Modified prologue to SLATEC/LDOC format.  (FNF)
!   890503  Minor cosmetic changes.  (FNF)
!   930809  Renamed to allow single/real*8 versions. (ACH)
!   010418  Reduced size of Common block /DLS001/. (ACH)
!   031105  Restored 'own' variables to Common block /DLS001/, to
!           enable interrupt/restart feature. (ACH)
!***END PROLOGUE  DINTDY
!**End
      INTEGER K, NYH, IFLAG
      REAL*8 T, YH, DKY
      DIMENSION YH(NYH,*), DKY(*)
      INTEGER IOWND, IOWNS,                                             &
     &   ICF, IERPJ, IERSL, JCUR, JSTART, KFLAG, L,                     &
     &   LYH, LEWT, LACOR, LSAVF, LWM, LIWM, METH, MITER,               &
     &   MAXORD, MAXCOR, MSBP, MXNCF, N, NQ, NST, NFE, NJE, NQU
      REAL*8 ROWNS,                                                     &
     &   CCMAX, EL0, H, HMIN, HMXI, HU, RC, TN, UROUND
      COMMON /DLS001/ ROWNS(209),                                       &
     &   CCMAX, EL0, H, HMIN, HMXI, HU, RC, TN, UROUND,                 &
     &   IOWND(6), IOWNS(6),                                            &
     &   ICF, IERPJ, IERSL, JCUR, JSTART, KFLAG, L,                     &
     &   LYH, LEWT, LACOR, LSAVF, LWM, LIWM, METH, MITER,               &
     &   MAXORD, MAXCOR, MSBP, MXNCF, N, NQ, NST, NFE, NJE, NQU
      INTEGER I, IC, J, JB, JB2, JJ, JJ1, JP1
      REAL*8 C, R, S, TP
      CHARACTER*80 MSG
!
!***FIRST EXECUTABLE STATEMENT  DINTDY
      IFLAG = 0
      IF (K .LT. 0 .OR. K .GT. NQ) GO TO 80
      TP = TN - HU -  100.0D0*UROUND*(TN + HU)
      IF ((T-TP)*(T-TN) .GT. 0.0D0) GO TO 90
!
      S = (T - TN)/H
      IC = 1
      IF (K .EQ. 0) GO TO 15
      JJ1 = L - K
      DO 10 JJ = JJ1,NQ
 10     IC = IC*JJ
 15   C = IC
      DO 20 I = 1,N
 20     DKY(I) = C*YH(I,L)
      IF (K .EQ. NQ) GO TO 55
      JB2 = NQ - K
      DO 50 JB = 1,JB2
        J = NQ - JB
        JP1 = J + 1
        IC = 1
        IF (K .EQ. 0) GO TO 35
        JJ1 = JP1 - K
        DO 30 JJ = JJ1,J
 30       IC = IC*JJ
 35     C = IC
        DO 40 I = 1,N
 40       DKY(I) = C*YH(I,JP1) + S*DKY(I)
 50     CONTINUE
      IF (K .EQ. 0) RETURN
 55   R = H**(-K)
      DO 60 I = 1,N
 60     DKY(I) = R*DKY(I)
      RETURN
!
 80   MSG = 'DINTDY-  K (=I1) illegal      '
      CALL XERRWD (MSG, 30, 51, 0, 1, K, 0, 0, 0.0D0, 0.0D0)
      IFLAG = -1
      RETURN
 90   MSG = 'DINTDY-  T (=R1) illegal      '
      CALL XERRWD (MSG, 30, 52, 0, 0, 0, 0, 1, T, 0.0D0)
      MSG='      T not in interval TCUR - HU (= R1) to TCUR (=R2)      '
      CALL XERRWD (MSG, 60, 52, 0, 0, 0, 0, 2, TP, TN)
      IFLAG = -2
      RETURN
!----------------------- END OF SUBR. DINTDY ----------------------
      END
!
!*DECK DSTODE
      SUBROUTINE DSTODE (NEQ, Y, YH, NYH, YH1, EWT, SAVF, ACOR          &
     &   , WM, IWM                                                      &
!    :   , FDRIV, FDJAC
!    :   , PJAC, SLVS
!
     &                ,time_i_fs,xspec_i                                &
     &                ,vfor,vbak,xspec_min,xspec_max                    &
     &                ,yspec_min_vs,yspec_max_vs                        &
     &                ,wspec_vs_min,wspec_vs_max                        &
     &                ,frlim_vs_min,frlim_vs_max                        &
     &                ,rkfor,rkbak,rkfor2,rkbak2                        &
     &                ,odtime_rl,jkin,jrlim                             &
     &                ,lvfor,lvbak,lvreac                               &
     &                ,iispec,iospec,nipart,nopart                      &
     &                ,hicoop,hocoop                                    &
     &                ,iispec_vs,iospec_vs,nipart_vs,nopart_vs          &
     &                ,gimult_vs,gomult_vs,iivs_vs,iovs_vs              &
     &                ,nspec,nreac,nfs_spec,nvs_spec                    &
     &                ,ispec_fs,ispec_vs,nlim_drv,n_drv,k_drv           &
     &                ,jtevol,jfox,jfix,npulse,nperiod                  &
     &                ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod    &
     &                ,npmspec_x                                        &
     &                ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x)
!
!***BEGIN PROLOGUE  DSTODE
!***SUBSIDIARY
!***PURPOSE  Performs one step of an ODEPACK integration.
!***TYPE      REAL*8 (SSTODE-S, DSTODE-D)
!***AUTHOR  Hindmarsh, Alan C., (LLNL)
!***DESCRIPTION
!
!  DSTODE performs one step of the integration of an initial value
!  problem for a system of ordinary differential equations.
!  Note:  DSTODE is independent of the value of the iteration method
!  indicator MITER, when this is .ne. 0, and hence is independent
!  of the type of chord method used, or the Jacobian structure.
!  Communication with DSTODE is done with the following variables:
!
!  NEQ    = integer array containing problem size in NEQ(1), and
!           passed as the NEQ argument in all calls
!           to FDRIV and FDJAC.
!  Y      = an array of length .ge. N used as the Y argument in
!           all calls to FDRIV and FDJAC.
!  YH     = an NYH by LMAX array containing the dependent variables
!           and their approximate scaled derivatives, where
!           LMAX = MAXORD + 1.  YH(i,j+1) contains the approximate
!           j-th derivative of y(i), scaled by h**j/factorial(j)
!           (j = 0,1,...,NQ).  on entry for the first step, the first
!           two columns of YH must be set from the initial values.
!  NYH    = a constant integer .ge. N, the first dimension of YH.
!  YH1    = a one-dimensional array occupying the same space as YH.
!  EWT    = an array of length N containing multiplicative weights
!           for local error measurements.  Local errors in Y(i) are
!           compared to 1.0/EWT(i) in various error tests.
!  SAVF   = an array of working storage, of length N.
!           Also used for input of YH(*,MAXORD+2) when JSTART = -1
!           and MAXORD .lt. the current order NQ.
!  ACOR   = a work array of length N, used for the accumulated
!           corrections.  On a successful return, ACOR(i) contains
!           the estimated one-step local error in Y(i).
!  WM,IWM = real and integer work arrays associated with matrix
!           operations in chord iteration (MITER .ne. 0).
!  PJAC   = name of routine to evaluate and preprocess Jacobian matrix
!           and P = I - h*el0*FDJAC, if a chord method is being used.
!  SLVS   = name of routine to solve linear system in chord iteration.
!  CCMAX  = maximum relative change in h*el0 before PJAC is called.
!  H      = the step size to be attempted on the next step.
!           H is altered by the error control algorithm during the
!           problem.  H can be either positive or negative, but its
!           sign must remain constant throughout the problem.
!  HMIN   = the minimum absolute value of the step size h to be used.
!  HMXI   = inverse of the maximum absolute value of h to be used.
!           HMXI = 0.0 is allowed and corresponds to an infinite hmax.
!           HMIN and HMXI may be changed at any time, but will not
!           take effect until the next change of h is considered.
!  TN     = the independent variable. TN is updated on each step taken.
!  JSTART = an integer used for input only, with the following
!           values and meanings:
!                0  perform the first step.
!            .gt.0  take a new step continuing from the last.
!               -1  take the next step with a new value of H, MAXORD,
!                     N, METH, MITER, and/or matrix parameters.
!               -2  take the next step with a new value of H,
!                     but with other inputs unchanged.
!           On return, JSTART is set to 1 to facilitate continuation.
!  KFLAG  = a completion code with the following meanings:
!                0  the step was succesful.
!               -1  the requested error could not be achieved.
!               -2  corrector convergence could not be achieved.
!               -3  fatal error in PJAC or SLVS.
!           A return with KFLAG = -1 or -2 means either
!           abs(H) = HMIN or 10 consecutive failures occurred.
!           On a return with KFLAG negative, the values of TN and
!           the YH array are as of the beginning of the last
!           step, and H is the last step size attempted.
!  MAXORD = the maximum order of integration method to be allowed.
!  MAXCOR = the maximum number of corrector iterations allowed.
!  MSBP   = maximum number of steps between PJAC calls (MITER .gt. 0).
!  MXNCF  = maximum number of convergence failures allowed.
!  METH/MITER = the method flags.  See description in driver.
!  N      = the number of first-order differential equations.
!  The values of CCMAX, H, HMIN, HMXI, TN, JSTART, KFLAG, MAXORD,
!  MAXCOR, MSBP, MXNCF, METH, MITER, and N are communicated via COMMON.
!
!***SEE ALSO  DLSODE
!***ROUTINES CALLED  DCFODE, DVNORM
!***COMMON BLOCKS    DLS001
!***REVISION HISTORY  (YYMMDD)
!   791129  DATE WRITTEN
!   890501  Modified prologue to SLATEC/LDOC format.  (FNF)
!   890503  Minor cosmetic changes.  (FNF)
!   930809  Renamed to allow single/real*8 versions. (ACH)
!   010418  Reduced size of Common block /DLS001/. (ACH)
!   031105  Restored 'own' variables to Common block /DLS001/, to
!           enable interrupt/restart feature. (ACH)
!***END PROLOGUE  DSTODE
!**End
!
!     EXTERNAL FDRIV, FDJAC
!    1       , PJAC, SLVS
      INTEGER NEQ, NYH, IWM
      REAL*8 Y, YH, YH1, EWT, SAVF, ACOR, WM
      DIMENSION NEQ(*), Y(*), YH(NYH,*), YH1(*), EWT(*), SAVF(*),       &
     &   ACOR(*), WM(*), IWM(*)
      INTEGER IOWND, IALTH, IPUP, LMAX, MEO, NQNYH, NSLP,               &
     &   ICF, IERPJ, IERSL, JCUR, JSTART, KFLAG, L,                     &
     &   LYH, LEWT, LACOR, LSAVF, LWM, LIWM, METH, MITER,               &
     &   MAXORD, MAXCOR, MSBP, MXNCF, N, NQ, NST, NFE, NJE, NQU
      INTEGER I, I1, IREDO, IRET, J, JB, M, NCF, NEWQ
      REAL*8 CONIT, CRATE, EL, ELCO, HOLD, RMAX, TESCO,                 &
     &   CCMAX, EL0, H, HMIN, HMXI, HU, RC, TN, UROUND
      REAL*8 DCON, DDN, DEL, DELP, DSM, DUP, EXDN, EXSM, EXUP,          &
     &   R, RH, RHDN, RHSM, RHUP, TOLD, DVNORM
      COMMON /DLS001/ CONIT, CRATE, EL(13), ELCO(13,12),                &
     &   HOLD, RMAX, TESCO(3,12),                                       &
     &   CCMAX, EL0, H, HMIN, HMXI, HU, RC, TN, UROUND,                 &
     &   IOWND(6), IALTH, IPUP, LMAX, MEO, NQNYH, NSLP,                 &
     &   ICF, IERPJ, IERSL, JCUR, JSTART, KFLAG, L,                     &
     &   LYH, LEWT, LACOR, LSAVF, LWM, LIWM, METH, MITER,               &
     &   MAXORD, MAXCOR, MSBP, MXNCF, N, NQ, NST, NFE, NJE, NQU
!
! "dRIVS" suppl. arg-list:
      integer                                                           &
     &                 jrlim                                            &
     &                ,nspec                                            &
     &                ,nreac                                            &
     &                ,nfs_spec                                         &
     &                ,nvs_spec                                         &
     &                ,nlim_drv,n_drv,k_drv                             &
     &                ,jtevol                                           &
     &                ,npmspec_x                                        &
     &                ,nspec_x                                          &
     &                ,nreac_x                                          &
     &                ,npart_x                                          &
     &                ,ntime_x                                          &
     &                ,nms_spec_x
!
      integer                                                           &
     &        jkin(1:nreac_x)                                           &
     &       ,lvfor(1:nreac_x)                                          &
     &       ,lvbak(1:nreac_x)                                          &
     &       ,lvreac(1:nreac_x)                                         &
!
     &       ,iispec(1:npart_x,1:nreac_x)                               &
     &       ,iospec(1:npart_x,1:nreac_x)                               &
     &       ,nipart(1:nreac_x)                                         &
     &       ,nopart(1:nreac_x)                                         &
!
     &       ,iispec_vs(1:npart_x,1:nreac_x)                            &
     &       ,iospec_vs(1:npart_x,1:nreac_x)                            &
     &       ,nipart_vs(1:nreac_x)                                      &
     &       ,nopart_vs(1:nreac_x)                                      &
     &       ,iivs_vs(1:npart_x,1:nreac_x)                              &
     &       ,iovs_vs(1:npart_x,1:nreac_x)                              &
!
     &       ,ispec_fs(1:(nspec_x+nms_spec_x))                          &
     &       ,ispec_vs(1:(nspec_x+nms_spec_x))                          &
!
     &       ,jfox(1:nspec_x)                                           &
     &       ,jfix(1:nspec_x)                                           &
     &       ,npulse(1:nspec_x)                                         &
     &       ,nperiod(1:nspec_x)
!
      real*8                                                            &
     &                 time_i_fs                                        &
     &                ,odtime_rl
!
      real*8                                                            &
     &       xspec_i(1:(nspec_x+nms_spec_x),0:3)                        &
     &      ,vfor(1:nreac_x)                                            &
     &      ,vbak(1:nreac_x)                                            &
     &      ,xspec_min(1:nspec_x)                                       &
     &      ,xspec_max(1:nspec_x)                                       &
     &      ,yspec_min_vs(1:nspec_x)                                    &
     &      ,yspec_max_vs(1:nspec_x)                                    &
!
     &      ,wspec_vs_min(1:nspec_x)                                    &
     &      ,wspec_vs_max(1:nspec_x)                                    &
     &      ,frlim_vs_min(1:nspec_x)                                    &
     &      ,frlim_vs_max(1:nspec_x)                                    &
!
     &      ,rkfor(1:nreac_x)                                           &
     &      ,rkbak(1:nreac_x)                                           &
     &      ,rkfor2(1:nreac_x)                                          &
     &      ,rkbak2(1:nreac_x)                                          &
!
     &      ,hicoop(1:npart_x,1:nreac_x)                                &
     &      ,hocoop(1:npart_x,1:nreac_x)                                &
     &      ,gimult_vs(1:npart_x,1:nreac_x)                             &
     &      ,gomult_vs(1:npart_x,1:nreac_x)                             &
!
     &      ,tpulse(1:nspec_x,-2:npmspec_x)                             &
     &      ,cpulse(1:nspec_x,-2:npmspec_x)                             &
     &      ,dtpulse(1:nspec_x,0:npmspec_x)                             &
     &      ,spulse(1:nspec_x,-2:npmspec_x)                             &
     &      ,tperiod(1:nspec_x)                                         &
     &      ,otperiod(1:nspec_x)
! :"dRIVS" suppl. arg-list
!
!
!***FIRST EXECUTABLE STATEMENT  DSTODE
      KFLAG = 0
      TOLD = TN
      NCF = 0
      IERPJ = 0
      IERSL = 0
      JCUR = 0
      ICF = 0
      DELP = 0.0D0
      IF (JSTART .GT. 0) GO TO 200
      IF (JSTART .EQ. -1) GO TO 100
      IF (JSTART .EQ. -2) GO TO 160
!-----------------------------------------------------------------------
! On the first call, the order is set to 1, and other variables are
! initialized.  RMAX is the maximum ratio by which H can be increased
! in a single step.  It is initially 1.E4 to compensate for the small
! initial H, but then is normally equal to 10.  If a failure
! occurs (in corrector convergence or error test), RMAX is set to 2
! for the next increase.
!-----------------------------------------------------------------------
      LMAX = MAXORD + 1
      NQ = 1
      L = 2
      IALTH = 2
      RMAX = 10000.0D0
      RC = 0.0D0
      EL0 = 1.0D0
      CRATE = 0.7D0
      HOLD = H
      MEO = METH
      NSLP = 0
      IPUP = MITER
      IRET = 3
      GO TO 140
!-----------------------------------------------------------------------
! The following block handles preliminaries needed when JSTART = -1.
! IPUP is set to MITER to force a matrix update.
! If an order increase is about to be considered (IALTH = 1),
! IALTH is reset to 2 to postpone consideration one more step.
! If the caller has changed METH, DCFODE is called to reset
! the coefficients of the method.
! If the caller has changed MAXORD to a value less than the current
! order NQ, NQ is reduced to MAXORD, and a new H chosen accordingly.
! If H is to be changed, YH must be rescaled.
! If H or METH is being changed, IALTH is reset to L = NQ + 1
! to prevent further changes in H for that many steps.
!-----------------------------------------------------------------------
 100  IPUP = MITER
      LMAX = MAXORD + 1
      IF (IALTH .EQ. 1) IALTH = 2
      IF (METH .EQ. MEO) GO TO 110
      CALL DCFODE (METH, ELCO, TESCO)
      MEO = METH
      IF (NQ .GT. MAXORD) GO TO 120
      IALTH = L
      IRET = 1
      GO TO 150
 110  IF (NQ .LE. MAXORD) GO TO 160
 120  NQ = MAXORD
      L = LMAX
      DO 125 I = 1,L
 125    EL(I) = ELCO(I,NQ)
      NQNYH = NQ*NYH
      RC = RC*EL(1)/EL0
      EL0 = EL(1)
      CONIT = 0.5D0/(NQ+2)
      DDN = DVNORM (N, SAVF, EWT)/TESCO(1,L)
      EXDN = 1.0D0/L
      RHDN = 1.0D0/(1.3D0*DDN**EXDN + 0.0000013D0)
      RH = MIN(RHDN,1.0D0)
      IREDO = 3
      IF (H .EQ. HOLD) GO TO 170
      RH = MIN(RH,ABS(H/HOLD))
      H = HOLD
      GO TO 175
!-----------------------------------------------------------------------
! DCFODE is called to get all the integration coefficients for the
! current METH.  Then the EL vector and related constants are reset
! whenever the order NQ is changed, or at the start of the problem.
!-----------------------------------------------------------------------
 140  CALL DCFODE (METH, ELCO, TESCO)
 150  DO 155 I = 1,L
 155    EL(I) = ELCO(I,NQ)
      NQNYH = NQ*NYH
      RC = RC*EL(1)/EL0
      EL0 = EL(1)
      CONIT = 0.5D0/(NQ+2)
      GO TO (160, 170, 200), IRET
!-----------------------------------------------------------------------
! If H is being changed, the H ratio RH is checked against
! RMAX, HMIN, and HMXI, and the YH array rescaled.  IALTH is set to
! L = NQ + 1 to prevent a change of H for that many steps, unless
! forced by a convergence or error test failure.
!-----------------------------------------------------------------------
 160  IF (H .EQ. HOLD) GO TO 200
      RH = H/HOLD
      H = HOLD
      IREDO = 3
      GO TO 175
 170  RH = MAX(RH,HMIN/ABS(H))
 175  RH = MIN(RH,RMAX)
      RH = RH/MAX(1.0D0,ABS(H)*HMXI*RH)
      R = 1.0D0
      DO 180 J = 2,L
        R = R*RH
        DO 180 I = 1,N
 180      YH(I,J) = YH(I,J)*R
      H = H*RH
      RC = RC*RH
      IALTH = L
      IF (IREDO .EQ. 0) GO TO 690
!-----------------------------------------------------------------------
! This section computes the predicted values by effectively
! multiplying the YH array by the Pascal Triangle matrix.
! RC is the ratio of new to old values of the coefficient  H*EL(1).
! When RC differs from 1 by more than CCMAX, IPUP is set to MITER
! to force PJAC to be called, if a Jacobian is involved.
! In any case, PJAC is called at least every MSBP steps.
!-----------------------------------------------------------------------
 200  IF (ABS(RC-1.0D0) .GT. CCMAX) IPUP = MITER
      IF (NST .GE. NSLP+MSBP) IPUP = MITER
      TN = TN + H
      I1 = NQNYH + 1
      DO 215 JB = 1,NQ
        I1 = I1 - NYH
!dir$ ivdep
        DO 210 I = I1,NQNYH
 210      YH1(I) = YH1(I) + YH1(I+NYH)
 215    CONTINUE
!-----------------------------------------------------------------------
! Up to MAXCOR corrector iterations are taken.  A convergence test is
! made on the R.M.S. norm of each correction, weighted by the error
! weight vector EWT.  The sum of the corrections is accumulated in the
! vector ACOR(i).  The YH array is not altered in the corrector loop.
!-----------------------------------------------------------------------
 220  M = 0
      DO 230 I = 1,N
 230    Y(I) = YH(I,1)
!     CALL FDRIV (NEQ, TN, Y, SAVF)
!     NEQ(1)-->nvs_spec, TN-->time_xr, Y-->xspec, YDOT-->vspec
      CALL drivs(TN,Y,SAVF                                              &
     &                ,time_i_fs,xspec_i                                &
     &                ,vfor,vbak,xspec_min,xspec_max                    &
     &                ,yspec_min_vs,yspec_max_vs                        &
     &                ,wspec_vs_min,wspec_vs_max                        &
     &                ,frlim_vs_min,frlim_vs_max                        &
     &                ,rkfor,rkbak,rkfor2,rkbak2                        &
     &                ,odtime_rl,jkin,jrlim                             &
     &                ,lvfor,lvbak,lvreac                               &
     &                ,iispec,iospec,nipart,nopart                      &
     &                ,hicoop,hocoop                                    &
     &                ,iispec_vs,iospec_vs,nipart_vs,nopart_vs          &
     &                ,gimult_vs,gomult_vs,iivs_vs,iovs_vs              &
     &                ,nspec,nreac,nfs_spec,nvs_spec                    &
     &                ,ispec_fs,ispec_vs,nlim_drv,n_drv,k_drv           &
     &                ,jtevol,jfox,jfix,npulse,nperiod                  &
     &                ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod    &
     &                ,npmspec_x                                        &
     &                ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x)
      NFE = NFE + 1
      IF (IPUP .LE. 0) GO TO 250
!-----------------------------------------------------------------------
! If indicated, the matrix P = I - h*el(1)*J is reevaluated and
! preprocessed before starting the corrector iteration.  IPUP is set
! to 0 as an indicator that this has been done.
!-----------------------------------------------------------------------
!     CALL PJAC (NEQ, Y, YH, NYH, EWT, ACOR, SAVF,
!    1       WM, IWM, FDRIV, FDJAC)
      CALL DPRJS (NEQ, Y, YH, NYH, EWT, ACOR, SAVF                      &
     &     , WM, IWM                                                    &
!    1     , FDRIV, FDJAC
!
     &                ,time_i_fs,xspec_i                                &
     &                ,vfor,vbak,xspec_min,xspec_max                    &
     &                ,yspec_min_vs,yspec_max_vs                        &
     &                ,wspec_vs_min,wspec_vs_max                        &
     &                ,frlim_vs_min,frlim_vs_max                        &
     &                ,rkfor,rkbak,rkfor2,rkbak2                        &
     &                ,odtime_rl,jkin,jrlim                             &
     &                ,lvfor,lvbak,lvreac                               &
     &                ,iispec,iospec,nipart,nopart                      &
     &                ,hicoop,hocoop                                    &
     &                ,iispec_vs,iospec_vs,nipart_vs,nopart_vs          &
     &                ,gimult_vs,gomult_vs,iivs_vs,iovs_vs              &
     &                ,nspec,nreac,nfs_spec,nvs_spec                    &
     &                ,ispec_fs,ispec_vs,nlim_drv,n_drv,k_drv           &
     &                ,jtevol,jfox,jfix,npulse,nperiod                  &
     &                ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod    &
     &                ,npmspec_x                                        &
     &                ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x)
!
      IPUP = 0
      RC = 1.0D0
      NSLP = NST
      CRATE = 0.7D0
      IF (IERPJ .NE. 0) GO TO 430
 250  DO 260 I = 1,N
 260    ACOR(I) = 0.0D0
 270  IF (MITER .NE. 0) GO TO 350
!-----------------------------------------------------------------------
! In the case of functional iteration, update Y directly from
! the result of the last function evaluation.
!-----------------------------------------------------------------------
      DO 290 I = 1,N
        SAVF(I) = H*SAVF(I) - YH(I,2)
 290    Y(I) = SAVF(I) - ACOR(I)
      DEL = DVNORM (N, Y, EWT)
      DO 300 I = 1,N
        Y(I) = YH(I,1) + EL(1)*SAVF(I)
 300    ACOR(I) = SAVF(I)
      GO TO 400
!-----------------------------------------------------------------------
! In the case of the chord method, compute the corrector error,
! and solve the linear system with that as right-hand side and
! P as coefficient matrix.
!-----------------------------------------------------------------------
 350  DO 360 I = 1,N
 360    Y(I) = H*SAVF(I) - (YH(I,2) + ACOR(I))
!
!     CALL SLVS (WM, IWM, Y, SAVF)
      CALL DSOLSS (WM, IWM, Y, SAVF)
      IF (IERSL .LT. 0) GO TO 430
      IF (IERSL .GT. 0) GO TO 410
      DEL = DVNORM (N, Y, EWT)
      DO 380 I = 1,N
        ACOR(I) = ACOR(I) + Y(I)
 380    Y(I) = YH(I,1) + EL(1)*ACOR(I)
!-----------------------------------------------------------------------
! Test for convergence.  If M.gt.0, an estimate of the convergence
! rate constant is stored in CRATE, and this is used in the test.
!-----------------------------------------------------------------------
 400  IF (M .NE. 0) CRATE = MAX(0.2D0*CRATE,DEL/DELP)
      DCON = DEL*MIN(1.0D0,1.5D0*CRATE)/(TESCO(2,NQ)*CONIT)
      IF (DCON .LE. 1.0D0) GO TO 450
      M = M + 1
      IF (M .EQ. MAXCOR) GO TO 410
      IF (M .GE. 2 .AND. DEL .GT. 2.0D0*DELP) GO TO 410
      DELP = DEL
!     CALL FDRIV (NEQ, TN, Y, SAVF)
!     NEQ(1)-->nvs_spec, TN-->time_xr, Y-->xspec, YDOT-->vspec
      CALL drivs(TN,Y,SAVF                                              &
     &                ,time_i_fs,xspec_i                                &
     &                ,vfor,vbak,xspec_min,xspec_max                    &
     &                ,yspec_min_vs,yspec_max_vs                        &
     &                ,wspec_vs_min,wspec_vs_max                        &
     &                ,frlim_vs_min,frlim_vs_max                        &
     &                ,rkfor,rkbak,rkfor2,rkbak2                        &
     &                ,odtime_rl,jkin,jrlim                             &
     &                ,lvfor,lvbak,lvreac                               &
     &                ,iispec,iospec,nipart,nopart                      &
     &                ,hicoop,hocoop                                    &
     &                ,iispec_vs,iospec_vs,nipart_vs,nopart_vs          &
     &                ,gimult_vs,gomult_vs,iivs_vs,iovs_vs              &
     &                ,nspec,nreac,nfs_spec,nvs_spec                    &
     &                ,ispec_fs,ispec_vs,nlim_drv,n_drv,k_drv           &
     &                ,jtevol,jfox,jfix,npulse,nperiod                  &
     &                ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod    &
     &                ,npmspec_x                                        &
     &                ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x)
      NFE = NFE + 1
      GO TO 270
!-----------------------------------------------------------------------
! The corrector iteration failed to converge.
! If MITER .ne. 0 and the Jacobian is out of date, PJAC is called for
! the next try.  Otherwise the YH array is retracted to its values
! before prediction, and H is reduced, if possible.  If H cannot be
! reduced or MXNCF failures have occurred, exit with KFLAG = -2.
!-----------------------------------------------------------------------
 410  IF (MITER .EQ. 0 .OR. JCUR .EQ. 1) GO TO 430
      ICF = 1
      IPUP = MITER
      GO TO 220
 430  ICF = 2
      NCF = NCF + 1
      RMAX = 2.0D0
      TN = TOLD
      I1 = NQNYH + 1
      DO 445 JB = 1,NQ
        I1 = I1 - NYH
!dir$ ivdep
        DO 440 I = I1,NQNYH
 440      YH1(I) = YH1(I) - YH1(I+NYH)
 445    CONTINUE
      IF (IERPJ .LT. 0 .OR. IERSL .LT. 0) GO TO 680
      IF (ABS(H) .LE. HMIN*1.00001D0) GO TO 670
      IF (NCF .EQ. MXNCF) GO TO 670
      RH = 0.25D0
      IPUP = MITER
      IREDO = 1
      GO TO 170
!-----------------------------------------------------------------------
! The corrector has converged.  JCUR is set to 0
! to signal that the Jacobian involved may need updating later.
! The local error test is made and control passes to statement 500
! if it fails.
!-----------------------------------------------------------------------
 450  JCUR = 0
      IF (M .EQ. 0) DSM = DEL/TESCO(2,NQ)
      IF (M .GT. 0) DSM = DVNORM (N, ACOR, EWT)/TESCO(2,NQ)
      IF (DSM .GT. 1.0D0) GO TO 500
!-----------------------------------------------------------------------
! After a successful step, update the YH array.
! Consider changing H if IALTH = 1.  Otherwise decrease IALTH by 1.
! If IALTH is then 1 and NQ .lt. MAXORD, then ACOR is saved for
! use in a possible order increase on the next step.
! If a change in H is considered, an increase or decrease in order
! by one is considered also.  A change in H is made only if it is by a
! factor of at least 1.1.  If not, IALTH is set to 3 to prevent
! testing for that many steps.
!-----------------------------------------------------------------------
      KFLAG = 0
      IREDO = 0
      NST = NST + 1
      HU = H
      NQU = NQ
      DO 470 J = 1,L
        DO 470 I = 1,N
 470      YH(I,J) = YH(I,J) + EL(J)*ACOR(I)
      IALTH = IALTH - 1
      IF (IALTH .EQ. 0) GO TO 520
      IF (IALTH .GT. 1) GO TO 700
      IF (L .EQ. LMAX) GO TO 700
      DO 490 I = 1,N
 490    YH(I,LMAX) = ACOR(I)
      GO TO 700
!-----------------------------------------------------------------------
! The error test failed.  KFLAG keeps track of multiple failures.
! Restore TN and the YH array to their previous values, and prepare
! to try the step again.  Compute the optimum step size for this or
! one lower order.  After 2 or more failures, H is forced to decrease
! by a factor of 0.2 or less.
!-----------------------------------------------------------------------
 500  KFLAG = KFLAG - 1
      TN = TOLD
      I1 = NQNYH + 1
      DO 515 JB = 1,NQ
        I1 = I1 - NYH
!dir$ ivdep
        DO 510 I = I1,NQNYH
 510      YH1(I) = YH1(I) - YH1(I+NYH)
 515    CONTINUE
      RMAX = 2.0D0
      IF (ABS(H) .LE. HMIN*1.00001D0) GO TO 660
      IF (KFLAG .LE. -3) GO TO 640
      IREDO = 2
      RHUP = 0.0D0
      GO TO 540
!-----------------------------------------------------------------------
! Regardless of the success or failure of the step, factors
! RHDN, RHSM, and RHUP are computed, by which H could be multiplied
! at order NQ - 1, order NQ, or order NQ + 1, respectively.
! In the case of failure, RHUP = 0.0 to avoid an order increase.
! The largest of these is determined and the new order chosen
! accordingly.  If the order is to be increased, we compute one
! additional scaled derivative.
!-----------------------------------------------------------------------
 520  RHUP = 0.0D0
      IF (L .EQ. LMAX) GO TO 540
      DO 530 I = 1,N
 530    SAVF(I) = ACOR(I) - YH(I,LMAX)
      DUP = DVNORM (N, SAVF, EWT)/TESCO(3,NQ)
      EXUP = 1.0D0/(L+1)
      RHUP = 1.0D0/(1.4D0*DUP**EXUP + 0.0000014D0)
 540  EXSM = 1.0D0/L
      RHSM = 1.0D0/(1.2D0*DSM**EXSM + 0.0000012D0)
      RHDN = 0.0D0
      IF (NQ .EQ. 1) GO TO 560
      DDN = DVNORM (N, YH(1,L), EWT)/TESCO(1,NQ)
      EXDN = 1.0D0/NQ
      RHDN = 1.0D0/(1.3D0*DDN**EXDN + 0.0000013D0)
 560  IF (RHSM .GE. RHUP) GO TO 570
      IF (RHUP .GT. RHDN) GO TO 590
      GO TO 580
 570  IF (RHSM .LT. RHDN) GO TO 580
      NEWQ = NQ
      RH = RHSM
      GO TO 620
 580  NEWQ = NQ - 1
      RH = RHDN
      IF (KFLAG .LT. 0 .AND. RH .GT. 1.0D0) RH = 1.0D0
      GO TO 620
 590  NEWQ = L
      RH = RHUP
      IF (RH .LT. 1.1D0) GO TO 610
      R = EL(L)/L
      DO 600 I = 1,N
 600    YH(I,NEWQ+1) = ACOR(I)*R
      GO TO 630
 610  IALTH = 3
      GO TO 700
 620  IF ((KFLAG .EQ. 0) .AND. (RH .LT. 1.1D0)) GO TO 610
      IF (KFLAG .LE. -2) RH = MIN(RH,0.2D0)
!-----------------------------------------------------------------------
! If there is a change of order, reset NQ, l, and the coefficients.
! In any case H is reset according to RH and the YH array is rescaled.
! Then exit from 690 if the step was OK, or redo the step otherwise.
!-----------------------------------------------------------------------
      IF (NEWQ .EQ. NQ) GO TO 170
 630  NQ = NEWQ
      L = NQ + 1
      IRET = 2
      GO TO 150
!-----------------------------------------------------------------------
! Control reaches this section if 3 or more failures have occured.
! If 10 failures have occurred, exit with KFLAG = -1.
! It is assumed that the derivatives that have accumulated in the
! YH array have errors of the wrong order.  Hence the first
! derivative is recomputed, and the order is set to 1.  Then
! H is reduced by a factor of 10, and the step is retried,
! until it succeeds or H reaches HMIN.
!-----------------------------------------------------------------------
 640  IF (KFLAG .EQ. -10) GO TO 660
      RH = 0.1D0
      RH = MAX(HMIN/ABS(H),RH)
      H = H*RH
      DO 645 I = 1,N
 645    Y(I) = YH(I,1)
!     CALL FDRIV (NEQ, TN, Y, SAVF)
!     NEQ(1)-->nvs_spec, TN-->time_xr, Y-->xspec, YDOT-->vspec
      CALL drivs(TN,Y,SAVF                                              &
     &                ,time_i_fs,xspec_i                                &
     &                ,vfor,vbak,xspec_min,xspec_max                    &
     &                ,yspec_min_vs,yspec_max_vs                        &
     &                ,wspec_vs_min,wspec_vs_max                        &
     &                ,frlim_vs_min,frlim_vs_max                        &
     &                ,rkfor,rkbak,rkfor2,rkbak2                        &
     &                ,odtime_rl,jkin,jrlim                             &
     &                ,lvfor,lvbak,lvreac                               &
     &                ,iispec,iospec,nipart,nopart                      &
     &                ,hicoop,hocoop                                    &
     &                ,iispec_vs,iospec_vs,nipart_vs,nopart_vs          &
     &                ,gimult_vs,gomult_vs,iivs_vs,iovs_vs              &
     &                ,nspec,nreac,nfs_spec,nvs_spec                    &
     &                ,ispec_fs,ispec_vs,nlim_drv,n_drv,k_drv           &
     &                ,jtevol,jfox,jfix,npulse,nperiod                  &
     &                ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod    &
     &                ,npmspec_x                                        &
     &                ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x)
      NFE = NFE + 1
      DO 650 I = 1,N
 650    YH(I,2) = H*SAVF(I)
      IPUP = MITER
      IALTH = 5
      IF (NQ .EQ. 1) GO TO 200
      NQ = 1
      L = 2
      IRET = 3
      GO TO 150
!-----------------------------------------------------------------------
! All returns are made through this section.  H is saved in HOLD
! to allow the caller to change H on the next step.
!-----------------------------------------------------------------------
 660  KFLAG = -1
      GO TO 720
 670  KFLAG = -2
      GO TO 720
 680  KFLAG = -3
      GO TO 720
 690  RMAX = 10.0D0
 700  R = 1.0D0/TESCO(2,NQU)
      DO 710 I = 1,N
 710    ACOR(I) = ACOR(I)*R
 720  HOLD = H
      JSTART = 1
      RETURN
!----------------------- END OF SUBR. DSTODE ----------------------
      END
!
!*DECK DEWSET
      SUBROUTINE DEWSET (N, ITOL, RTOL, ATOL, YCUR, EWT)
!***BEGIN PROLOGUE  DEWSET
!***SUBSIDIARY
!***PURPOSE  Set error weight vector.
!***TYPE      REAL*8 (SEWSET-S, DEWSET-D)
!***AUTHOR  Hindmarsh, Alan C., (LLNL)
!***DESCRIPTION
!
!  This subroutine sets the error weight vector EWT according to
!      EWT(i) = RTOL(i)*ABS(YCUR(i)) + ATOL(i),  i = 1,...,N,
!  with the subscript on RTOL and/or ATOL possibly replaced by 1 above,
!  depending on the value of ITOL.
!
!***SEE ALSO  DLSODE
!***ROUTINES CALLED  (NONE)
!***REVISION HISTORY  (YYMMDD)
!   791129  DATE WRITTEN
!   890501  Modified prologue to SLATEC/LDOC format.  (FNF)
!   890503  Minor cosmetic changes.  (FNF)
!   930809  Renamed to allow single/real*8 versions. (ACH)
!***END PROLOGUE  DEWSET
!**End
      INTEGER N, ITOL
      INTEGER I
      REAL*8 RTOL, ATOL, YCUR, EWT
      DIMENSION RTOL(*), ATOL(*), YCUR(N), EWT(N)
!
!***FIRST EXECUTABLE STATEMENT  DEWSET
      GO TO (10, 20, 30, 40), ITOL
 10   CONTINUE
      DO 15 I = 1,N
 15     EWT(I) = RTOL(1)*ABS(YCUR(I)) + ATOL(1)
      RETURN
!
 20   CONTINUE
      DO 25 I = 1,N
 25     EWT(I) = RTOL(1)*ABS(YCUR(I)) + ATOL(I)
      RETURN
!
 30   CONTINUE
      DO 35 I = 1,N
 35     EWT(I) = RTOL(I)*ABS(YCUR(I)) + ATOL(1)
      RETURN
 40   CONTINUE
      DO 45 I = 1,N
 45     EWT(I) = RTOL(I)*ABS(YCUR(I)) + ATOL(I)
      RETURN
!----------------------- END OF SUBR. DEWSET ----------------------
      END
!
!*DECK DIPREP
      SUBROUTINE DIPREP (NEQ, Y, RWORK, IA, JA, IPFLAG                  &
!                        , FDRIV, FDJAC
!
     &                ,time_i_fs,xspec_i                                &
     &                ,vfor,vbak,xspec_min,xspec_max                    &
     &                ,yspec_min_vs,yspec_max_vs                        &
     &                ,wspec_vs_min,wspec_vs_max                        &
     &                ,frlim_vs_min,frlim_vs_max                        &
     &                ,rkfor,rkbak,rkfor2,rkbak2                        &
     &                ,odtime_rl,jkin,jrlim                             &
     &                ,lvfor,lvbak,lvreac                               &
     &                ,iispec,iospec,nipart,nopart                      &
     &                ,hicoop,hocoop                                    &
     &                ,iispec_vs,iospec_vs,nipart_vs,nopart_vs          &
     &                ,gimult_vs,gomult_vs,iivs_vs,iovs_vs              &
     &                ,nspec,nreac,nfs_spec,nvs_spec                    &
     &                ,ispec_fs,ispec_vs,nlim_drv,n_drv,k_drv           &
     &                ,jtevol,jfox,jfix,npulse,nperiod                  &
     &                ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod    &
     &                ,npmspec_x                                        &
     &                ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x)
!
!     EXTERNAL FDRIV, FDJAC
      INTEGER NEQ, IA, JA, IPFLAG
      REAL*8 Y, RWORK
      DIMENSION NEQ(*), Y(*), RWORK(*), IA(*), JA(*)
      INTEGER IOWND, IOWNS,                                             &
     &   ICF, IERPJ, IERSL, JCUR, JSTART, KFLAG, L,                     &
     &   LYH, LEWT, LACOR, LSAVF, LWM, LIWM, METH, MITER,               &
     &   MAXORD, MAXCOR, MSBP, MXNCF, N, NQ, NST, NFE, NJE, NQU
      INTEGER IPLOST, IESP, ISTATC, IYS, IBA, IBIAN, IBJAN, IBJGP,      &
     &   IPIAN, IPJAN, IPJGP, IPIGP, IPR, IPC, IPIC, IPISP, IPRSP, IPA, &
     &   LENYH, LENYHM, LENWK, LREQ, LRAT, LREST, LWMIN, MOSS, MSBJ,    &
     &   NSLJ, NGP, NLU, NNZ, NSP, NZL, NZU
      REAL*8 ROWNS,                                                     &
     &   CCMAX, EL0, H, HMIN, HMXI, HU, RC, TN, UROUND
      REAL*8 RLSS
      COMMON /DLS001/ ROWNS(209),                                       &
     &   CCMAX, EL0, H, HMIN, HMXI, HU, RC, TN, UROUND,                 &
     &   IOWND(6), IOWNS(6),                                            &
     &   ICF, IERPJ, IERSL, JCUR, JSTART, KFLAG, L,                     &
     &   LYH, LEWT, LACOR, LSAVF, LWM, LIWM, METH, MITER,               &
     &   MAXORD, MAXCOR, MSBP, MXNCF, N, NQ, NST, NFE, NJE, NQU
      COMMON /DLSS01/ RLSS(6),                                          &
     &   IPLOST, IESP, ISTATC, IYS, IBA, IBIAN, IBJAN, IBJGP,           &
     &   IPIAN, IPJAN, IPJGP, IPIGP, IPR, IPC, IPIC, IPISP, IPRSP, IPA, &
     &   LENYH, LENYHM, LENWK, LREQ, LRAT, LREST, LWMIN, MOSS, MSBJ,    &
     &   NSLJ, NGP, NLU, NNZ, NSP, NZL, NZU
      INTEGER I, IMAX, LEWTN, LYHD, LYHN
!
! "dRIVS" suppl. arg-list:
      integer                                                           &
     &                 jrlim                                            &
     &                ,nspec                                            &
     &                ,nreac                                            &
     &                ,nfs_spec                                         &
     &                ,nvs_spec                                         &
     &                ,nlim_drv,n_drv,k_drv                             &
     &                ,jtevol                                           &
     &                ,npmspec_x                                        &
     &                ,nspec_x                                          &
     &                ,nreac_x                                          &
     &                ,npart_x                                          &
     &                ,ntime_x                                          &
     &                ,nms_spec_x
!
      integer                                                           &
     &        jkin(1:nreac_x)                                           &
     &       ,lvfor(1:nreac_x)                                          &
     &       ,lvbak(1:nreac_x)                                          &
     &       ,lvreac(1:nreac_x)                                         &
!
     &       ,iispec(1:npart_x,1:nreac_x)                               &
     &       ,iospec(1:npart_x,1:nreac_x)                               &
     &       ,nipart(1:nreac_x)                                         &
     &       ,nopart(1:nreac_x)                                         &
!
     &       ,iispec_vs(1:npart_x,1:nreac_x)                            &
     &       ,iospec_vs(1:npart_x,1:nreac_x)                            &
     &       ,nipart_vs(1:nreac_x)                                      &
     &       ,nopart_vs(1:nreac_x)                                      &
     &       ,iivs_vs(1:npart_x,1:nreac_x)                              &
     &       ,iovs_vs(1:npart_x,1:nreac_x)                              &
!
     &       ,ispec_fs(1:(nspec_x+nms_spec_x))                          &
     &       ,ispec_vs(1:(nspec_x+nms_spec_x))                          &
!
     &       ,jfox(1:nspec_x)                                           &
     &       ,jfix(1:nspec_x)                                           &
     &       ,npulse(1:nspec_x)                                         &
     &       ,nperiod(1:nspec_x)
!
      real*8                                                            &
     &                 time_i_fs                                        &
     &                ,odtime_rl
!
      real*8                                                            &
     &       xspec_i(1:(nspec_x+nms_spec_x),0:3)                        &
     &      ,vfor(1:nreac_x)                                            &
     &      ,vbak(1:nreac_x)                                            &
     &      ,xspec_min(1:nspec_x)                                       &
     &      ,xspec_max(1:nspec_x)                                       &
     &      ,yspec_min_vs(1:nspec_x)                                    &
     &      ,yspec_max_vs(1:nspec_x)                                    &
!
     &      ,wspec_vs_min(1:nspec_x)                                    &
     &      ,wspec_vs_max(1:nspec_x)                                    &
     &      ,frlim_vs_min(1:nspec_x)                                    &
     &      ,frlim_vs_max(1:nspec_x)                                    &
!
     &      ,rkfor(1:nreac_x)                                           &
     &      ,rkbak(1:nreac_x)                                           &
     &      ,rkfor2(1:nreac_x)                                          &
     &      ,rkbak2(1:nreac_x)                                          &
!
     &      ,hicoop(1:npart_x,1:nreac_x)                                &
     &      ,hocoop(1:npart_x,1:nreac_x)                                &
     &      ,gimult_vs(1:npart_x,1:nreac_x)                             &
     &      ,gomult_vs(1:npart_x,1:nreac_x)                             &
!
     &      ,tpulse(1:nspec_x,-2:npmspec_x)                             &
     &      ,cpulse(1:nspec_x,-2:npmspec_x)                             &
     &      ,dtpulse(1:nspec_x,0:npmspec_x)                             &
     &      ,spulse(1:nspec_x,-2:npmspec_x)                             &
     &      ,tperiod(1:nspec_x)                                         &
     &      ,otperiod(1:nspec_x)
! :"dRIVS" suppl. arg-list
!
!-----------------------------------------------------------------------
! This routine serves as an interface between the driver and
! Subroutine DPREP.  It is called only if MITER is 1 or 2.
! Tasks performed here are:
!  * call DPREP,
!  * reset the required WM segment length LENWK,
!  * move YH back to its final location (following WM in RWORK),
!  * reset pointers for YH, SAVF, EWT, and ACOR, and
!  * move EWT to its new position if ISTATE = 1.
! IPFLAG is an output error indication flag.  IPFLAG = 0 if there was
! no trouble, and IPFLAG is the value of the DPREP error flag IPPER
! if there was trouble in Subroutine DPREP.
!-----------------------------------------------------------------------
      IPFLAG = 0
! Call DPREP to do matrix preprocessing operations. --------------------
      CALL DPREP (NEQ, Y, RWORK(LYH), RWORK(LSAVF), RWORK(LEWT)         &
     &   , RWORK(LACOR), IA, JA, RWORK(LWM), RWORK(LWM), IPFLAG         &
!    1   , FDRIV, FDJAC
!
     &                ,time_i_fs,xspec_i                                &
     &                ,vfor,vbak,xspec_min,xspec_max                    &
     &                ,yspec_min_vs,yspec_max_vs                        &
     &                ,wspec_vs_min,wspec_vs_max                        &
     &                ,frlim_vs_min,frlim_vs_max                        &
     &                ,rkfor,rkbak,rkfor2,rkbak2                        &
     &                ,odtime_rl,jkin,jrlim                             &
     &                ,lvfor,lvbak,lvreac                               &
     &                ,iispec,iospec,nipart,nopart                      &
     &                ,hicoop,hocoop                                    &
     &                ,iispec_vs,iospec_vs,nipart_vs,nopart_vs          &
     &                ,gimult_vs,gomult_vs,iivs_vs,iovs_vs              &
     &                ,nspec,nreac,nfs_spec,nvs_spec                    &
     &                ,ispec_fs,ispec_vs,nlim_drv,n_drv,k_drv           &
     &                ,jtevol,jfox,jfix,npulse,nperiod                  &
     &                ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod    &
     &                ,npmspec_x                                        &
     &                ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x)
!
      LENWK = MAX(LREQ,LWMIN)
      IF (IPFLAG .LT. 0) RETURN
! If DPREP was successful, move YH to end of required space for WM. ----
      LYHN = LWM + LENWK
      IF (LYHN .GT. LYH) RETURN
      LYHD = LYH - LYHN
      IF (LYHD .EQ. 0) GO TO 20
      IMAX = LYHN - 1 + LENYHM
      DO 10 I = LYHN,IMAX
 10     RWORK(I) = RWORK(I+LYHD)
      LYH = LYHN
! Reset pointers for SAVF, EWT, and ACOR. ------------------------------
 20   LSAVF = LYH + LENYH
      LEWTN = LSAVF + N
      LACOR = LEWTN + N
      IF (ISTATC .EQ. 3) GO TO 40
! If ISTATE = 1, move EWT (left) to its new position. ------------------
      IF (LEWTN .GT. LEWT) RETURN
      DO 30 I = 1,N
 30     RWORK(I+LEWTN-1) = RWORK(I+LEWT-1)
 40   LEWT = LEWTN
      RETURN
!----------------------- END OF SUBR. DIPREP ----------------------
      END
!
!*DECK DPREP
      SUBROUTINE DPREP (NEQ, Y, YH, SAVF, EWT, FTEM, IA, JA             &
     &                  , WK, IWK, IPPER                                &
!    1                  , FDRIV, FDJAC
!
     &                ,time_i_fs,xspec_i                                &
     &                ,vfor,vbak,xspec_min,xspec_max                    &
     &                ,yspec_min_vs,yspec_max_vs                        &
     &                ,wspec_vs_min,wspec_vs_max                        &
     &                ,frlim_vs_min,frlim_vs_max                        &
     &                ,rkfor,rkbak,rkfor2,rkbak2                        &
     &                ,odtime_rl,jkin,jrlim                             &
     &                ,lvfor,lvbak,lvreac                               &
     &                ,iispec,iospec,nipart,nopart                      &
     &                ,hicoop,hocoop                                    &
     &                ,iispec_vs,iospec_vs,nipart_vs,nopart_vs          &
     &                ,gimult_vs,gomult_vs,iivs_vs,iovs_vs              &
     &                ,nspec,nreac,nfs_spec,nvs_spec                    &
     &                ,ispec_fs,ispec_vs,nlim_drv,n_drv,k_drv           &
     &                ,jtevol,jfox,jfix,npulse,nperiod                  &
     &                ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod    &
     &                ,npmspec_x                                        &
     &                ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x)
!
!     EXTERNAL FDRIV, FDJAC
!
      INTEGER NEQ, IA, JA, IWK, IPPER
      REAL*8 Y, YH, SAVF, EWT, FTEM, WK
      DIMENSION NEQ(*), Y(*), YH(*), SAVF(*), EWT(*), FTEM(*),          &
     &   IA(*), JA(*), WK(*), IWK(*)
      INTEGER IOWND, IOWNS,                                             &
     &   ICF, IERPJ, IERSL, JCUR, JSTART, KFLAG, L,                     &
     &   LYH, LEWT, LACOR, LSAVF, LWM, LIWM, METH, MITER,               &
     &   MAXORD, MAXCOR, MSBP, MXNCF, N, NQ, NST, NFE, NJE, NQU
      INTEGER IPLOST, IESP, ISTATC, IYS, IBA, IBIAN, IBJAN, IBJGP,      &
     &   IPIAN, IPJAN, IPJGP, IPIGP, IPR, IPC, IPIC, IPISP, IPRSP, IPA, &
     &   LENYH, LENYHM, LENWK, LREQ, LRAT, LREST, LWMIN, MOSS, MSBJ,    &
     &   NSLJ, NGP, NLU, NNZ, NSP, NZL, NZU
      REAL*8 ROWNS,                                                     &
     &   CCMAX, EL0, H, HMIN, HMXI, HU, RC, TN, UROUND
      REAL*8 CON0, CONMIN, CCMXJ, PSMALL, RBIG, SETH
      COMMON /DLS001/ ROWNS(209),                                       &
     &   CCMAX, EL0, H, HMIN, HMXI, HU, RC, TN, UROUND,                 &
     &   IOWND(6), IOWNS(6),                                            &
     &   ICF, IERPJ, IERSL, JCUR, JSTART, KFLAG, L,                     &
     &   LYH, LEWT, LACOR, LSAVF, LWM, LIWM, METH, MITER,               &
     &   MAXORD, MAXCOR, MSBP, MXNCF, N, NQ, NST, NFE, NJE, NQU
      COMMON /DLSS01/ CON0, CONMIN, CCMXJ, PSMALL, RBIG, SETH,          &
     &   IPLOST, IESP, ISTATC, IYS, IBA, IBIAN, IBJAN, IBJGP,           &
     &   IPIAN, IPJAN, IPJGP, IPIGP, IPR, IPC, IPIC, IPISP, IPRSP, IPA, &
     &   LENYH, LENYHM, LENWK, LREQ, LRAT, LREST, LWMIN, MOSS, MSBJ,    &
     &   NSLJ, NGP, NLU, NNZ, NSP, NZL, NZU
      INTEGER I, IBR, IER, IPIL, IPIU, IPTT1, IPTT2, J, JFOUND, K,      &
     &   KNEW, KMAX, KMIN, LDIF, LENIGP, LIWK, MAXG, NP1, NZSUT
      REAL*8 DQ, DYJ, ERWT, FAC, YJ
!
! "dRIVS" suppl. arg-list:
      integer                                                           &
     &                 jrlim                                            &
     &                ,nspec                                            &
     &                ,nreac                                            &
     &                ,nfs_spec                                         &
     &                ,nvs_spec                                         &
     &                ,nlim_drv,n_drv,k_drv                             &
     &                ,jtevol                                           &
     &                ,npmspec_x                                        &
     &                ,nspec_x                                          &
     &                ,nreac_x                                          &
     &                ,npart_x                                          &
     &                ,ntime_x                                          &
     &                ,nms_spec_x
!
      integer                                                           &
     &        jkin(1:nreac_x)                                           &
     &       ,lvfor(1:nreac_x)                                          &
     &       ,lvbak(1:nreac_x)                                          &
     &       ,lvreac(1:nreac_x)                                         &
!
     &       ,iispec(1:npart_x,1:nreac_x)                               &
     &       ,iospec(1:npart_x,1:nreac_x)                               &
     &       ,nipart(1:nreac_x)                                         &
     &       ,nopart(1:nreac_x)                                         &
!
     &       ,iispec_vs(1:npart_x,1:nreac_x)                            &
     &       ,iospec_vs(1:npart_x,1:nreac_x)                            &
     &       ,nipart_vs(1:nreac_x)                                      &
     &       ,nopart_vs(1:nreac_x)                                      &
     &       ,iivs_vs(1:npart_x,1:nreac_x)                              &
     &       ,iovs_vs(1:npart_x,1:nreac_x)                              &
!
     &       ,ispec_fs(1:(nspec_x+nms_spec_x))                          &
     &       ,ispec_vs(1:(nspec_x+nms_spec_x))                          &
!
     &       ,jfox(1:nspec_x)                                           &
     &       ,jfix(1:nspec_x)                                           &
     &       ,npulse(1:nspec_x)                                         &
     &       ,nperiod(1:nspec_x)
!
      real*8                                                            &
     &                 time_i_fs                                        &
     &                ,odtime_rl
!
      real*8                                                            &
     &       xspec_i(1:(nspec_x+nms_spec_x),0:3)                        &
     &      ,vfor(1:nreac_x)                                            &
     &      ,vbak(1:nreac_x)                                            &
     &      ,xspec_min(1:nspec_x)                                       &
     &      ,xspec_max(1:nspec_x)                                       &
     &      ,yspec_min_vs(1:nspec_x)                                    &
     &      ,yspec_max_vs(1:nspec_x)                                    &
!
     &      ,wspec_vs_min(1:nspec_x)                                    &
     &      ,wspec_vs_max(1:nspec_x)                                    &
     &      ,frlim_vs_min(1:nspec_x)                                    &
     &      ,frlim_vs_max(1:nspec_x)                                    &
!
     &      ,rkfor(1:nreac_x)                                           &
     &      ,rkbak(1:nreac_x)                                           &
     &      ,rkfor2(1:nreac_x)                                          &
     &      ,rkbak2(1:nreac_x)                                          &
!
     &      ,hicoop(1:npart_x,1:nreac_x)                                &
     &      ,hocoop(1:npart_x,1:nreac_x)                                &
     &      ,gimult_vs(1:npart_x,1:nreac_x)                             &
     &      ,gomult_vs(1:npart_x,1:nreac_x)                             &
!
     &      ,tpulse(1:nspec_x,-2:npmspec_x)                             &
     &      ,cpulse(1:nspec_x,-2:npmspec_x)                             &
     &      ,dtpulse(1:nspec_x,0:npmspec_x)                             &
     &      ,spulse(1:nspec_x,-2:npmspec_x)                             &
     &      ,tperiod(1:nspec_x)                                         &
     &      ,otperiod(1:nspec_x)
! :"dRIVS" suppl. arg-list
!
!-----------------------------------------------------------------------
! This routine performs preprocessing related to the sparse linear
! systems that must be solved if MITER = 1 or 2.
! The operations that are performed here are:
!  * compute sparseness structure of Jacobian according to MOSS,
!  * compute grouping of column indices (MITER = 2),
!  * compute a new ordering of rows and columns of the matrix,
!  * reorder JA corresponding to the new ordering,
!  * perform a symbolic LU factorization of the matrix, and
!  * set pointers for segments of the IWK/WK array.
! In addition to variables described previously, DPREP uses the
! following for communication:
! YH     = the history array.  Only the first column, containing the
!          current Y vector, is used.  Used only if MOSS .ne. 0.
! SAVF   = a work array of length NEQ, used only if MOSS .ne. 0.
! EWT    = array of length NEQ containing (inverted) error weights.
!          Used only if MOSS = 2 or if ISTATE = MOSS = 1.
! FTEM   = a work array of length NEQ, identical to ACOR in the driver,
!          used only if MOSS = 2.
! WK     = a real work array of length LENWK, identical to WM in
!          the driver.
! IWK    = integer work array, assumed to occupy the same space as WK.
! LENWK  = the length of the work arrays WK and IWK.
! ISTATC = a copy of the driver input argument ISTATE (= 1 on the
!          first call, = 3 on a continuation call).
! IYS    = flag value from ODRV or CDRV.
! IPPER  = output error flag with the following values and meanings:
!          0  no error.
!         -1  insufficient storage for internal structure pointers.
!         -2  insufficient storage for JGROUP.
!         -3  insufficient storage for ODRV.
!         -4  other error flag from ODRV (should never occur).
!         -5  insufficient storage for CDRV.
!         -6  other error flag from CDRV.
!-----------------------------------------------------------------------
      IBIAN = LRAT*2
      IPIAN = IBIAN + 1
      NP1 = N + 1
      IPJAN = IPIAN + NP1
      IBJAN = IPJAN - 1
      LIWK = LENWK*LRAT
      IF (IPJAN+N-1 .GT. LIWK) GO TO 210
      IF (MOSS .EQ. 0) GO TO 30
!
      IF (ISTATC .EQ. 3) GO TO 20
! ISTATE = 1 and MOSS .ne. 0.  Perturb Y for structure determination. --
!
!
      DO 10 I = 1,N
        ERWT = 1.0D0/EWT(I)
        FAC = 1.0D0 + 1.0D0/(I + 1.0D0)
        Y(I) = Y(I) + FAC*SIGN(ERWT,Y(I))
!
!
 10     CONTINUE
      GO TO (70, 100), MOSS
!
 20   CONTINUE
! ISTATE = 3 and MOSS .ne. 0.  Load Y from YH(*,1). --------------------
      DO 25 I = 1,N
 25     Y(I) = YH(I)
      GO TO (70, 100), MOSS
!
! MOSS = 0.  Process user's IA,JA.  Add diagonal entries if necessary. -
 30   KNEW = IPJAN
      KMIN = IA(1)
      IWK(IPIAN) = 1
      DO 60 J = 1,N
        JFOUND = 0
        KMAX = IA(J+1) - 1
        IF (KMIN .GT. KMAX) GO TO 45
        DO 40 K = KMIN,KMAX
          I = JA(K)
          IF (I .EQ. J) JFOUND = 1
          IF (KNEW .GT. LIWK) GO TO 210
          IWK(KNEW) = I
          KNEW = KNEW + 1
 40       CONTINUE
        IF (JFOUND .EQ. 1) GO TO 50
 45     IF (KNEW .GT. LIWK) GO TO 210
        IWK(KNEW) = J
        KNEW = KNEW + 1
 50     IWK(IPIAN+J) = KNEW + 1 - IPJAN
        KMIN = KMAX + 1
 60     CONTINUE
      GO TO 140
!
! MOSS = 1.  Compute structure from user-supplied
!   Jacobian routine FDJAC.
 70   CONTINUE
! A dummy call to FDRIV allows user to create temporaries
!   for use in FDJAC. --
!     CALL FDRIV (NEQ, TN, Y, SAVF)
!     NEQ(1)-->nvs_spec, TN-->time_xr, Y-->xspec, YDOT-->vspec
      CALL drivs(TN,Y,SAVF                                              &
     &                ,time_i_fs,xspec_i                                &
     &                ,vfor,vbak,xspec_min,xspec_max                    &
     &                ,yspec_min_vs,yspec_max_vs                        &
     &                ,wspec_vs_min,wspec_vs_max                        &
     &                ,frlim_vs_min,frlim_vs_max                        &
     &                ,rkfor,rkbak,rkfor2,rkbak2                        &
     &                ,odtime_rl,jkin,jrlim                             &
     &                ,lvfor,lvbak,lvreac                               &
     &                ,iispec,iospec,nipart,nopart                      &
     &                ,hicoop,hocoop                                    &
     &                ,iispec_vs,iospec_vs,nipart_vs,nopart_vs          &
     &                ,gimult_vs,gomult_vs,iivs_vs,iovs_vs              &
     &                ,nspec,nreac,nfs_spec,nvs_spec                    &
     &                ,ispec_fs,ispec_vs,nlim_drv,n_drv,k_drv           &
     &                ,jtevol,jfox,jfix,npulse,nperiod                  &
     &                ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod    &
     &                ,npmspec_x                                        &
     &                ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x)
      K = IPJAN
      IWK(IPIAN) = 1
      DO 90 J = 1,N
        IF (K .GT. LIWK) GO TO 210
        IWK(K) = J
        K = K + 1
        DO 75 I = 1,N
 75       SAVF(I) = 0.0D0
!       CALL FDJAC (NEQ, TN, Y, J, IWK(IPIAN), IWK(IPJAN), SAVF)
        CALL djacs(NEQ, TN, Y, J, IWK(IPIAN), IWK(IPJAN), SAVF)
        DO 80 I = 1,N
          IF (ABS(SAVF(I)) .LE. SETH) GO TO 80
          IF (I .EQ. J) GO TO 80
          IF (K .GT. LIWK) GO TO 210
          IWK(K) = I
          K = K + 1
 80       CONTINUE
        IWK(IPIAN+J) = K + 1 - IPJAN
 90     CONTINUE
      GO TO 140
!
! MOSS = 2.  Compute structure from results of N + 1 calls to F. -------
 100  K = IPJAN
      IWK(IPIAN) = 1
!     CALL FDRIV (NEQ, TN, Y, SAVF)
!     NEQ(1)-->nvs_spec, TN-->time_xr, Y-->xspec, YDOT-->vspec
      CALL drivs(TN,Y,SAVF                                              &
     &                ,time_i_fs,xspec_i                                &
     &                ,vfor,vbak,xspec_min,xspec_max                    &
     &                ,yspec_min_vs,yspec_max_vs                        &
     &                ,wspec_vs_min,wspec_vs_max                        &
     &                ,frlim_vs_min,frlim_vs_max                        &
     &                ,rkfor,rkbak,rkfor2,rkbak2                        &
     &                ,odtime_rl,jkin,jrlim                             &
     &                ,lvfor,lvbak,lvreac                               &
     &                ,iispec,iospec,nipart,nopart                      &
     &                ,hicoop,hocoop                                    &
     &                ,iispec_vs,iospec_vs,nipart_vs,nopart_vs          &
     &                ,gimult_vs,gomult_vs,iivs_vs,iovs_vs              &
     &                ,nspec,nreac,nfs_spec,nvs_spec                    &
     &                ,ispec_fs,ispec_vs,nlim_drv,n_drv,k_drv           &
     &                ,jtevol,jfox,jfix,npulse,nperiod                  &
     &                ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod    &
     &                ,npmspec_x                                        &
     &                ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x)
      DO 120 J = 1,N
        IF (K .GT. LIWK) GO TO 210
        IWK(K) = J
        K = K + 1
        YJ = Y(J)
        ERWT = 1.0D0/EWT(J)
        DYJ = SIGN(ERWT,YJ)
        Y(J) = YJ + DYJ
!       CALL FDRIV (NEQ, TN, Y, FTEM)
!       NEQ(1)-->nvs_spec, TN-->time_xr, Y-->xspec, YDOT-->vspec
!
        CALL drivs(TN,Y,FTEM                                            &
     &                ,time_i_fs,xspec_i                                &
     &                ,vfor,vbak,xspec_min,xspec_max                    &
     &                ,yspec_min_vs,yspec_max_vs                        &
     &                ,wspec_vs_min,wspec_vs_max                        &
     &                ,frlim_vs_min,frlim_vs_max                        &
     &                ,rkfor,rkbak,rkfor2,rkbak2                        &
     &                ,odtime_rl,jkin,jrlim                             &
     &                ,lvfor,lvbak,lvreac                               &
     &                ,iispec,iospec,nipart,nopart                      &
     &                ,hicoop,hocoop                                    &
     &                ,iispec_vs,iospec_vs,nipart_vs,nopart_vs          &
     &                ,gimult_vs,gomult_vs,iivs_vs,iovs_vs              &
     &                ,nspec,nreac,nfs_spec,nvs_spec                    &
     &                ,ispec_fs,ispec_vs,nlim_drv,n_drv,k_drv           &
     &                ,jtevol,jfox,jfix,npulse,nperiod                  &
     &                ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod    &
     &                ,npmspec_x                                        &
     &                ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x)
        Y(J) = YJ
        DO 110 I = 1,N
          DQ = (FTEM(I) - SAVF(I))/DYJ
          IF (ABS(DQ) .LE. SETH) GO TO 110
          IF (I .EQ. J) GO TO 110
          IF (K .GT. LIWK) GO TO 210
          IWK(K) = I
          K = K + 1
 110      CONTINUE
        IWK(IPIAN+J) = K + 1 - IPJAN
 120    CONTINUE
!
 140  CONTINUE
      IF (MOSS .EQ. 0 .OR. ISTATC .NE. 1) GO TO 150
! If ISTATE = 1 and MOSS .ne. 0, restore Y from YH. --------------------
      DO 145 I = 1,N
 145    Y(I) = YH(I)
 150  NNZ = IWK(IPIAN+N) - 1
      LENIGP = 0
      IPIGP = IPJAN + NNZ
      IF (MITER .NE. 2) GO TO 160
!
! Compute grouping of column indices (MITER = 2). ----------------------
      MAXG = NP1
      IPJGP = IPJAN + NNZ
      IBJGP = IPJGP - 1
      IPIGP = IPJGP + N
      IPTT1 = IPIGP + NP1
      IPTT2 = IPTT1 + N
      LREQ = IPTT2 + N - 1
      IF (LREQ .GT. LIWK) GO TO 220
      CALL JGROUP (N, IWK(IPIAN), IWK(IPJAN), MAXG, NGP, IWK(IPIGP),    &
     &   IWK(IPJGP), IWK(IPTT1), IWK(IPTT2), IER)
      IF (IER .NE. 0) GO TO 220
      LENIGP = NGP + 1
!
! Compute new ordering of rows/columns of Jacobian. --------------------
 160  IPR = IPIGP + LENIGP
      IPC = IPR
      IPIC = IPC + N
      IPISP = IPIC + N
      IPRSP = (IPISP - 2)/LRAT + 2
      IESP = LENWK + 1 - IPRSP
      IF (IESP .LT. 0) GO TO 230
      IBR = IPR - 1
      DO 170 I = 1,N
 170    IWK(IBR+I) = I
      NSP = LIWK + 1 - IPISP
      CALL ODRV (N, IWK(IPIAN), IWK(IPJAN), WK, IWK(IPR), IWK(IPIC),    &
     &   NSP, IWK(IPISP), 1, IYS)
      IF (IYS .EQ. 11*N+1) GO TO 240
      IF (IYS .NE. 0) GO TO 230
!
! Reorder JAN and do symbolic LU factorization of matrix. --------------
      IPA = LENWK + 1 - NNZ
      NSP = IPA - IPRSP
      LREQ = MAX(12*N/LRAT, 6*N/LRAT+2*N+NNZ) + 3
      LREQ = LREQ + IPRSP - 1 + NNZ
      IF (LREQ .GT. LENWK) GO TO 250
      IBA = IPA - 1
      DO 180 I = 1,NNZ
 180    WK(IBA+I) = 0.0D0
      IPISP = LRAT*(IPRSP - 1) + 1
      CALL CDRV (N,IWK(IPR),IWK(IPC),IWK(IPIC),IWK(IPIAN),IWK(IPJAN),   &
     &   WK(IPA),WK(IPA),WK(IPA),NSP,IWK(IPISP),WK(IPRSP),IESP,5,IYS)
      LREQ = LENWK - IESP
      IF (IYS .EQ. 10*N+1) GO TO 250
      IF (IYS .NE. 0) GO TO 260
      IPIL = IPISP
      IPIU = IPIL + 2*N + 1
      NZU = IWK(IPIL+N) - IWK(IPIL)
      NZL = IWK(IPIU+N) - IWK(IPIU)
      IF (LRAT .GT. 1) GO TO 190
      CALL ADJLR (N, IWK(IPISP), LDIF)
      LREQ = LREQ + LDIF
 190  CONTINUE
      IF (LRAT .EQ. 2 .AND. NNZ .EQ. N) LREQ = LREQ + 1
      NSP = NSP + LREQ - LENWK
      IPA = LREQ + 1 - NNZ
      IBA = IPA - 1
      IPPER = 0
      RETURN
!
 210  IPPER = -1
      LREQ = 2 + (2*N + 1)/LRAT
      LREQ = MAX(LENWK+1,LREQ)
      RETURN
!
 220  IPPER = -2
      LREQ = (LREQ - 1)/LRAT + 1
      RETURN
!
 230  IPPER = -3
      CALL CNTNZU (N, IWK(IPIAN), IWK(IPJAN), NZSUT)
      LREQ = LENWK - IESP + (3*N + 4*NZSUT - 1)/LRAT + 1
      RETURN
!
 240  IPPER = -4
      RETURN
!
 250  IPPER = -5
      RETURN
!
 260  IPPER = -6
      LREQ = LENWK
      RETURN
!----------------------- END OF SUBR. DPREP -----------------------
      END
!
!*DECK JGROUP
      SUBROUTINE JGROUP (N,IA,JA,MAXG,NGRP,IGP,JGP,INCL,JDONE,IER)
      INTEGER N, IA, JA, MAXG, NGRP, IGP, JGP, INCL, JDONE, IER
      DIMENSION IA(*), JA(*), IGP(*), JGP(*), INCL(*), JDONE(*)
!-----------------------------------------------------------------------
! This subroutine constructs groupings of the column indices of
! the Jacobian matrix, used in the numerical evaluation of the
! Jacobian by finite differences.
!
! Input:
! N      = the order of the matrix.
! IA,JA  = sparse structure descriptors of the matrix by rows.
! MAXG   = length of available storage in the IGP array.
!
! Output:
! NGRP   = number of groups.
! JGP    = array of length N containing the column indices by groups.
! IGP    = pointer array of length NGRP + 1 to the locations in JGP
!          of the beginning of each group.
! IER    = error indicator.  IER = 0 if no error occurred, or 1 if
!          MAXG was insufficient.
!
! INCL and JDONE are working arrays of length N.
!-----------------------------------------------------------------------
      INTEGER I, J, K, KMIN, KMAX, NCOL, NG
!
      IER = 0
      DO 10 J = 1,N
 10     JDONE(J) = 0
      NCOL = 1
      DO 60 NG = 1,MAXG
        IGP(NG) = NCOL
        DO 20 I = 1,N
 20       INCL(I) = 0
        DO 50 J = 1,N
! Reject column J if it is already in a group.--------------------------
          IF (JDONE(J) .EQ. 1) GO TO 50
          KMIN = IA(J)
          KMAX = IA(J+1) - 1
          DO 30 K = KMIN,KMAX
! Reject column J if it overlaps any column already in this group.------
            I = JA(K)
            IF (INCL(I) .EQ. 1) GO TO 50
 30         CONTINUE
! Accept column J into group NG.----------------------------------------
          JGP(NCOL) = J
          NCOL = NCOL + 1
          JDONE(J) = 1
          DO 40 K = KMIN,KMAX
            I = JA(K)
 40         INCL(I) = 1
 50       CONTINUE
! Stop if this group is empty (grouping is complete).-------------------
        IF (NCOL .EQ. IGP(NG)) GO TO 70
 60     CONTINUE
! Error return if not all columns were chosen (MAXG too small).---------
      IF (NCOL .LE. N) GO TO 80
      NG = MAXG
 70   NGRP = NG - 1
      RETURN
 80   IER = 1
      RETURN
!----------------------- END OF SUBR. JGROUP ----------------------
      END
!
!*DECK ADJLR
      SUBROUTINE ADJLR (N, ISP, LDIF)
      INTEGER N, ISP, LDIF
      DIMENSION ISP(*)
!-----------------------------------------------------------------------
! This routine computes an adjustment, LDIF, to the required
! integer storage space in IWK (sparse matrix work space).
! It is called only if the word length ratio is LRAT = 1.
! This is to account for the possibility that the symbolic LU phase
! may require more storage than the numerical LU and solution phases.
!-----------------------------------------------------------------------
      INTEGER IP, JLMAX, JUMAX, LNFC, LSFC, NZLU
!
      IP = 2*N + 1
! Get JLMAX = IJL(N) and JUMAX = IJU(N) (sizes of JL and JU). ----------
      JLMAX = ISP(IP)
      JUMAX = ISP(IP+IP)
! NZLU = (size of L) + (size of U) = (IL(N+1)-IL(1)) + (IU(N+1)-IU(1)).
      NZLU = ISP(N+1) - ISP(1) + ISP(IP+N+1) - ISP(IP+1)
      LSFC = 12*N + 3 + 2*MAX(JLMAX,JUMAX)
      LNFC = 9*N + 2 + JLMAX + JUMAX + NZLU
      LDIF = MAX(0, LSFC - LNFC)
      RETURN
!----------------------- END OF SUBR. ADJLR -----------------------
      END
!
!*DECK CNTNZU
      SUBROUTINE CNTNZU (N, IA, JA, NZSUT)
      INTEGER N, IA, JA, NZSUT
      DIMENSION IA(*), JA(*)
!-----------------------------------------------------------------------
! This routine counts the number of nonzero elements in the strict
! upper triangle of the matrix M + M(transpose), where the sparsity
! structure of M is given by pointer arrays IA and JA.
! This is needed to compute the storage requirements for the
! sparse matrix reordering operation in ODRV.
!-----------------------------------------------------------------------
      INTEGER II, JJ, J, JMIN, JMAX, K, KMIN, KMAX, NUM
!
      NUM = 0
      DO 50 II = 1,N
        JMIN = IA(II)
        JMAX = IA(II+1) - 1
        IF (JMIN .GT. JMAX) GO TO 50
        DO 40 J = JMIN,JMAX
          IF (JA(J) - II) 10, 40, 30
 10       JJ =JA(J)
          KMIN = IA(JJ)
          KMAX = IA(JJ+1) - 1
          IF (KMIN .GT. KMAX) GO TO 30
          DO 20 K = KMIN,KMAX
            IF (JA(K) .EQ. II) GO TO 40
 20         CONTINUE
 30       NUM = NUM + 1
 40       CONTINUE
 50     CONTINUE
      NZSUT = NUM
      RETURN
!----------------------- END OF SUBR. CNTNZU ----------------------
      END
!
!*DECK DPRJS
      SUBROUTINE DPRJS (NEQ, Y, YH, NYH, EWT, FTEM                      &
     &             , SAVF, WK, IWK                                      &
!    1             , FDRIV, FDJAC
!
     &                ,time_i_fs,xspec_i                                &
     &                ,vfor,vbak,xspec_min,xspec_max                    &
     &                ,yspec_min_vs,yspec_max_vs                        &
     &                ,wspec_vs_min,wspec_vs_max                        &
     &                ,frlim_vs_min,frlim_vs_max                        &
     &                ,rkfor,rkbak,rkfor2,rkbak2                        &
     &                ,odtime_rl,jkin,jrlim                             &
     &                ,lvfor,lvbak,lvreac                               &
     &                ,iispec,iospec,nipart,nopart                      &
     &                ,hicoop,hocoop                                    &
     &                ,iispec_vs,iospec_vs,nipart_vs,nopart_vs          &
     &                ,gimult_vs,gomult_vs,iivs_vs,iovs_vs              &
     &                ,nspec,nreac,nfs_spec,nvs_spec                    &
     &                ,ispec_fs,ispec_vs,nlim_drv,n_drv,k_drv           &
     &                ,jtevol,jfox,jfix,npulse,nperiod                  &
     &                ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod    &
     &                ,npmspec_x                                        &
     &                ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x)
!
!     EXTERNAL FDRIV, FDJAC
      INTEGER NEQ, NYH, IWK
      REAL*8 Y, YH, EWT, FTEM, SAVF, WK
      DIMENSION NEQ(*), Y(*), YH(NYH,*), EWT(*), FTEM(*), SAVF(*),      &
     &   WK(*), IWK(*)
      INTEGER IOWND, IOWNS,                                             &
     &   ICF, IERPJ, IERSL, JCUR, JSTART, KFLAG, L,                     &
     &   LYH, LEWT, LACOR, LSAVF, LWM, LIWM, METH, MITER,               &
     &   MAXORD, MAXCOR, MSBP, MXNCF, N, NQ, NST, NFE, NJE, NQU
      INTEGER IPLOST, IESP, ISTATC, IYS, IBA, IBIAN, IBJAN, IBJGP,      &
     &   IPIAN, IPJAN, IPJGP, IPIGP, IPR, IPC, IPIC, IPISP, IPRSP, IPA, &
     &   LENYH, LENYHM, LENWK, LREQ, LRAT, LREST, LWMIN, MOSS, MSBJ,    &
     &   NSLJ, NGP, NLU, NNZ, NSP, NZL, NZU
      REAL*8 ROWNS,                                                     &
     &   CCMAX, EL0, H, HMIN, HMXI, HU, RC, TN, UROUND
      REAL*8 CON0, CONMIN, CCMXJ, PSMALL, RBIG, SETH
      COMMON /DLS001/ ROWNS(209),                                       &
     &   CCMAX, EL0, H, HMIN, HMXI, HU, RC, TN, UROUND,                 &
     &   IOWND(6), IOWNS(6),                                            &
     &   ICF, IERPJ, IERSL, JCUR, JSTART, KFLAG, L,                     &
     &   LYH, LEWT, LACOR, LSAVF, LWM, LIWM, METH, MITER,               &
     &   MAXORD, MAXCOR, MSBP, MXNCF, N, NQ, NST, NFE, NJE, NQU
      COMMON /DLSS01/ CON0, CONMIN, CCMXJ, PSMALL, RBIG, SETH,          &
     &   IPLOST, IESP, ISTATC, IYS, IBA, IBIAN, IBJAN, IBJGP,           &
     &   IPIAN, IPJAN, IPJGP, IPIGP, IPR, IPC, IPIC, IPISP, IPRSP, IPA, &
     &   LENYH, LENYHM, LENWK, LREQ, LRAT, LREST, LWMIN, MOSS, MSBJ,    &
     &   NSLJ, NGP, NLU, NNZ, NSP, NZL, NZU
      INTEGER I, IMUL, J, JJ, JOK, JMAX, JMIN, K, KMAX, KMIN, NG
      REAL*8 CON, DI, FAC, HL0, PIJ, R, R0, RCON, RCONT,                &
     &   SRUR, DVNORM
!-----------------------------------------------------------------------
! DPRJS is called to compute and process the matrix
! P = I - H*EL(1)*J , where J is an approximation to the Jacobian.
! J is computed by columns, either by the user-supplied routine FDJAC
! if MITER = 1, or by finite differencing if MITER = 2.
! if MITER = 3, a diagonal approximation to J is used.
! if MITER = 1 or 2, and if the existing value of the Jacobian
! (as contained in P) is considered acceptable, then a new value of
! P is reconstructed from the old value.  In any case, when MITER
! is 1 or 2, the P matrix is subjected to LU decomposition in CDRV.
! P and its LU decomposition are stored (separately) in WK.
!
! In addition to variables described previously, communication
! with DPRJS uses the following:
! Y     = array containing predicted values on entry.
! FTEM  = work array of length N (ACOR in DSTODE).
! SAVF  = array containing f evaluated at predicted y.
! WK    = real work space for matrices.  On output it contains the
!         inverse diagonal matrix if MITER = 3, and P and its sparse
!         LU decomposition if MITER is 1 or 2.
!         Storage of matrix elements starts at WK(3).
!         WK also contains the following matrix-related data:
!         WK(1) = SQRT(UROUND), used in numerical Jacobian increments.
!         WK(2) = H*EL0, saved for later use if MITER = 3.
! IWK   = integer work space for matrix-related data, assumed to
!         be equivalenced to WK.  In addition, WK(IPRSP) and IWK(IPISP)
!         are assumed to have identical locations.
! EL0   = EL(1) (input).
! IERPJ = output error flag (in Common).
!       = 0 if no error.
!       = 1  if zero pivot found in CDRV.
!       = 2  if a singular matrix arose with MITER = 3.
!       = -1 if insufficient storage for CDRV (should not occur here).
!       = -2 if other error found in CDRV (should not occur here).
! JCUR  = output flag showing status of (approximate) Jacobian matrix:
!          = 1 to indicate that the Jacobian is now current, or
!          = 0 to indicate that a saved value was used.
! This routine also uses other variables in Common.
!
! "dRIVS" suppl. arg-list:
      integer                                                           &
     &                 jrlim                                            &
     &                ,nspec                                            &
     &                ,nreac                                            &
     &                ,nfs_spec                                         &
     &                ,nvs_spec                                         &
     &                ,nlim_drv,n_drv,k_drv                             &
     &                ,jtevol                                           &
     &                ,npmspec_x                                        &
     &                ,nspec_x                                          &
     &                ,nreac_x                                          &
     &                ,npart_x                                          &
     &                ,ntime_x                                          &
     &                ,nms_spec_x
!
      integer                                                           &
     &        jkin(1:nreac_x)                                           &
     &       ,lvfor(1:nreac_x)                                          &
     &       ,lvbak(1:nreac_x)                                          &
     &       ,lvreac(1:nreac_x)                                         &
!
     &       ,iispec(1:npart_x,1:nreac_x)                               &
     &       ,iospec(1:npart_x,1:nreac_x)                               &
     &       ,nipart(1:nreac_x)                                         &
     &       ,nopart(1:nreac_x)                                         &
!
     &       ,iispec_vs(1:npart_x,1:nreac_x)                            &
     &       ,iospec_vs(1:npart_x,1:nreac_x)                            &
     &       ,nipart_vs(1:nreac_x)                                      &
     &       ,nopart_vs(1:nreac_x)                                      &
     &       ,iivs_vs(1:npart_x,1:nreac_x)                              &
     &       ,iovs_vs(1:npart_x,1:nreac_x)                              &
!
     &       ,ispec_fs(1:(nspec_x+nms_spec_x))                          &
     &       ,ispec_vs(1:(nspec_x+nms_spec_x))                          &
!
     &       ,jfox(1:nspec_x)                                           &
     &       ,jfix(1:nspec_x)                                           &
     &       ,npulse(1:nspec_x)                                         &
     &       ,nperiod(1:nspec_x)
!
      real*8                                                            &
     &                 time_i_fs                                        &
     &                ,odtime_rl
!
      real*8                                                            &
     &       xspec_i(1:(nspec_x+nms_spec_x),0:3)                        &
     &      ,vfor(1:nreac_x)                                            &
     &      ,vbak(1:nreac_x)                                            &
     &      ,xspec_min(1:nspec_x)                                       &
     &      ,xspec_max(1:nspec_x)                                       &
     &      ,yspec_min_vs(1:nspec_x)                                    &
     &      ,yspec_max_vs(1:nspec_x)                                    &
!
     &      ,wspec_vs_min(1:nspec_x)                                    &
     &      ,wspec_vs_max(1:nspec_x)                                    &
     &      ,frlim_vs_min(1:nspec_x)                                    &
     &      ,frlim_vs_max(1:nspec_x)                                    &
!
     &      ,rkfor(1:nreac_x)                                           &
     &      ,rkbak(1:nreac_x)                                           &
     &      ,rkfor2(1:nreac_x)                                          &
     &      ,rkbak2(1:nreac_x)                                          &
!
     &      ,hicoop(1:npart_x,1:nreac_x)                                &
     &      ,hocoop(1:npart_x,1:nreac_x)                                &
     &      ,gimult_vs(1:npart_x,1:nreac_x)                             &
     &      ,gomult_vs(1:npart_x,1:nreac_x)                             &
!
     &      ,tpulse(1:nspec_x,-2:npmspec_x)                             &
     &      ,cpulse(1:nspec_x,-2:npmspec_x)                             &
     &      ,dtpulse(1:nspec_x,0:npmspec_x)                             &
     &      ,spulse(1:nspec_x,-2:npmspec_x)                             &
     &      ,tperiod(1:nspec_x)                                         &
     &      ,otperiod(1:nspec_x)
! :"dRIVS" suppl. arg-list
!
!-----------------------------------------------------------------------
      HL0 = H*EL0
      CON = -HL0
      IF (MITER .EQ. 3) GO TO 300
! See whether J should be reevaluated (JOK = 0) or not (JOK = 1). ------
      JOK = 1
      IF (NST .EQ. 0 .OR. NST .GE. NSLJ+MSBJ) JOK = 0
      IF (ICF .EQ. 1 .AND. ABS(RC - 1.0D0) .LT. CCMXJ) JOK = 0
      IF (ICF .EQ. 2) JOK = 0
      IF (JOK .EQ. 1) GO TO 250
!
! MITER = 1 or 2, and the Jacobian is to be reevaluated. ---------------
 20   JCUR = 1
      NJE = NJE + 1
      NSLJ = NST
      IPLOST = 0
      CONMIN = ABS(CON)
      GO TO (100, 200), MITER
!
! If MITER = 1, caLL FDJAC, multiply by scalar, and add identity. -------
 100  CONTINUE
      KMIN = IWK(IPIAN)
      DO 130 J = 1, N
        KMAX = IWK(IPIAN+J) - 1
        DO 110 I = 1,N
 110      FTEM(I) = 0.0D0
!       CALL FDJAC (NEQ, TN, Y, J, IWK(IPIAN), IWK(IPJAN), FTEM)
        CALL djacs(NEQ, TN, Y, J, IWK(IPIAN), IWK(IPJAN), FTEM)
        DO 120 K = KMIN, KMAX
          I = IWK(IBJAN+K)
          WK(IBA+K) = FTEM(I)*CON
          IF (I .EQ. J) WK(IBA+K) = WK(IBA+K) + 1.0D0
 120      CONTINUE
        KMIN = KMAX + 1
 130    CONTINUE
      GO TO 290
!
! If MITER = 2, make NGP calls to FDRIV to approximate J and P.
 200  CONTINUE
      FAC = DVNORM(N, SAVF, EWT)
      R0 = 1000.0D0 * ABS(H) * UROUND * N * FAC
      IF (R0 .EQ. 0.0D0) R0 = 1.0D0
      SRUR = WK(1)
      JMIN = IWK(IPIGP)
      DO 240 NG = 1,NGP
        JMAX = IWK(IPIGP+NG) - 1
        DO 210 J = JMIN,JMAX
          JJ = IWK(IBJGP+J)
          R = MAX(SRUR*ABS(Y(JJ)),R0/EWT(JJ))
 210      Y(JJ) = Y(JJ) + R
!       CALL FDRIV (NEQ, TN, Y, FTEM)
!       NEQ(1)-->nvs_spec, TN-->time_xr, Y-->xspec, YDOT-->vspec
        CALL drivs(TN,Y,FTEM                                            &
     &                ,time_i_fs,xspec_i                                &
     &                ,vfor,vbak,xspec_min,xspec_max                    &
     &                ,yspec_min_vs,yspec_max_vs                        &
     &                ,wspec_vs_min,wspec_vs_max                        &
     &                ,frlim_vs_min,frlim_vs_max                        &
     &                ,rkfor,rkbak,rkfor2,rkbak2                        &
     &                ,odtime_rl,jkin,jrlim                             &
     &                ,lvfor,lvbak,lvreac                               &
     &                ,iispec,iospec,nipart,nopart                      &
     &                ,hicoop,hocoop                                    &
     &                ,iispec_vs,iospec_vs,nipart_vs,nopart_vs          &
     &                ,gimult_vs,gomult_vs,iivs_vs,iovs_vs              &
     &                ,nspec,nreac,nfs_spec,nvs_spec                    &
     &                ,ispec_fs,ispec_vs,nlim_drv,n_drv,k_drv           &
     &                ,jtevol,jfox,jfix,npulse,nperiod                  &
     &                ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod    &
     &                ,npmspec_x                                        &
     &                ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x)
        DO 230 J = JMIN,JMAX
          JJ = IWK(IBJGP+J)
          Y(JJ) = YH(JJ,1)
          R = MAX(SRUR*ABS(Y(JJ)),R0/EWT(JJ))
          FAC = -HL0/R
          KMIN =IWK(IBIAN+JJ)
          KMAX =IWK(IBIAN+JJ+1) - 1
          DO 220 K = KMIN,KMAX
            I = IWK(IBJAN+K)
            WK(IBA+K) = (FTEM(I) - SAVF(I))*FAC
            IF (I .EQ. JJ) WK(IBA+K) = WK(IBA+K) + 1.0D0
 220        CONTINUE
 230      CONTINUE
        JMIN = JMAX + 1
 240    CONTINUE
      NFE = NFE + NGP
      GO TO 290
!
! If JOK = 1, reconstruct new P from old P. ----------------------------
 250  JCUR = 0
      RCON = CON/CON0
      RCONT = ABS(CON)/CONMIN
      IF (RCONT .GT. RBIG .AND. IPLOST .EQ. 1) GO TO 20
      KMIN = IWK(IPIAN)
      DO 275 J = 1,N
        KMAX = IWK(IPIAN+J) - 1
        DO 270 K = KMIN,KMAX
          I = IWK(IBJAN+K)
          PIJ = WK(IBA+K)
          IF (I .NE. J) GO TO 260
          PIJ = PIJ - 1.0D0
          IF (ABS(PIJ) .GE. PSMALL) GO TO 260
            IPLOST = 1
            CONMIN = MIN(ABS(CON0),CONMIN)
 260      PIJ = PIJ*RCON
          IF (I .EQ. J) PIJ = PIJ + 1.0D0
          WK(IBA+K) = PIJ
 270      CONTINUE
        KMIN = KMAX + 1
 275    CONTINUE
!
! Do numerical factorization of P matrix. ------------------------------
 290  NLU = NLU + 1
      CON0 = CON
      IERPJ = 0
      DO 295 I = 1,N
 295    FTEM(I) = 0.0D0
      CALL CDRV (N,IWK(IPR),IWK(IPC),IWK(IPIC),IWK(IPIAN),IWK(IPJAN),   &
     &   WK(IPA),FTEM,FTEM,NSP,IWK(IPISP),WK(IPRSP),IESP,2,IYS)
      IF (IYS .EQ. 0) RETURN
      IMUL = (IYS - 1)/N
      IERPJ = -2
      IF (IMUL .EQ. 8) IERPJ = 1
      IF (IMUL .EQ. 10) IERPJ = -1
      RETURN
!
! If MITER = 3, construct a diagonal approximation to J and P. ---------
 300  CONTINUE
      JCUR = 1
      NJE = NJE + 1
      WK(2) = HL0
      IERPJ = 0
      R = EL0*0.1D0
      DO 310 I = 1,N
 310    Y(I) = Y(I) + R*(H*SAVF(I) - YH(I,2))
!     CALL FDRIV (NEQ, TN, Y, WK(3))
!     NEQ(1)-->nvs_spec, TN-->time_xr, Y-->xspec, YDOT-->vspec
      CALL drivs(TN,Y,WK(3)                                             &
     &                ,time_i_fs,xspec_i                                &
     &                ,vfor,vbak,xspec_min,xspec_max                    &
     &                ,yspec_min_vs,yspec_max_vs                        &
     &                ,wspec_vs_min,wspec_vs_max                        &
     &                ,frlim_vs_min,frlim_vs_max                        &
     &                ,rkfor,rkbak,rkfor2,rkbak2                        &
     &                ,odtime_rl,jkin,jrlim                             &
     &                ,lvfor,lvbak,lvreac                               &
     &                ,iispec,iospec,nipart,nopart                      &
     &                ,hicoop,hocoop                                    &
     &                ,iispec_vs,iospec_vs,nipart_vs,nopart_vs          &
     &                ,gimult_vs,gomult_vs,iivs_vs,iovs_vs              &
     &                ,nspec,nreac,nfs_spec,nvs_spec                    &
     &                ,ispec_fs,ispec_vs,nlim_drv,n_drv,k_drv           &
     &                ,jtevol,jfox,jfix,npulse,nperiod                  &
     &                ,tpulse,cpulse,dtpulse,spulse,tperiod,otperiod    &
     &                ,npmspec_x                                        &
     &                ,nspec_x,nreac_x,npart_x,ntime_x,nms_spec_x)
      NFE = NFE + 1
      DO 320 I = 1,N
        R0 = H*SAVF(I) - YH(I,2)
        DI = 0.1D0*R0 - H*(WK(I+2) - SAVF(I))
        WK(I+2) = 1.0D0
        IF (ABS(R0) .LT. UROUND/EWT(I)) GO TO 320
        IF (ABS(DI) .EQ. 0.0D0) GO TO 330
        WK(I+2) = 0.1D0*R0/DI
 320    CONTINUE
      RETURN
 330  IERPJ = 2
      RETURN
!----------------------- END OF SUBR. DPRJS -----------------------
      END
!
!*DECK DSOLSS
      SUBROUTINE DSOLSS (WK, IWK, X, TEM)
      INTEGER IWK
      REAL*8 WK, X, TEM
      DIMENSION WK(*), IWK(*), X(*), TEM(*)
      INTEGER IOWND, IOWNS,                                             &
     &   ICF, IERPJ, IERSL, JCUR, JSTART, KFLAG, L,                     &
     &   LYH, LEWT, LACOR, LSAVF, LWM, LIWM, METH, MITER,               &
     &   MAXORD, MAXCOR, MSBP, MXNCF, N, NQ, NST, NFE, NJE, NQU
      INTEGER IPLOST, IESP, ISTATC, IYS, IBA, IBIAN, IBJAN, IBJGP,      &
     &   IPIAN, IPJAN, IPJGP, IPIGP, IPR, IPC, IPIC, IPISP, IPRSP, IPA, &
     &   LENYH, LENYHM, LENWK, LREQ, LRAT, LREST, LWMIN, MOSS, MSBJ,    &
     &   NSLJ, NGP, NLU, NNZ, NSP, NZL, NZU
      REAL*8 ROWNS,                                                     &
     &   CCMAX, EL0, H, HMIN, HMXI, HU, RC, TN, UROUND
      REAL*8 RLSS
      COMMON /DLS001/ ROWNS(209),                                       &
     &   CCMAX, EL0, H, HMIN, HMXI, HU, RC, TN, UROUND,                 &
     &   IOWND(6), IOWNS(6),                                            &
     &   ICF, IERPJ, IERSL, JCUR, JSTART, KFLAG, L,                     &
     &   LYH, LEWT, LACOR, LSAVF, LWM, LIWM, METH, MITER,               &
     &   MAXORD, MAXCOR, MSBP, MXNCF, N, NQ, NST, NFE, NJE, NQU
      COMMON /DLSS01/ RLSS(6),                                          &
     &   IPLOST, IESP, ISTATC, IYS, IBA, IBIAN, IBJAN, IBJGP,           &
     &   IPIAN, IPJAN, IPJGP, IPIGP, IPR, IPC, IPIC, IPISP, IPRSP, IPA, &
     &   LENYH, LENYHM, LENWK, LREQ, LRAT, LREST, LWMIN, MOSS, MSBJ,    &
     &   NSLJ, NGP, NLU, NNZ, NSP, NZL, NZU
      INTEGER I
      REAL*8 DI, HL0, PHL0, R
!-----------------------------------------------------------------------
! This routine manages the solution of the linear system arising from
! a chord iteration.  It is called if MITER .ne. 0.
! If MITER is 1 or 2, it calls CDRV to accomplish this.
! If MITER = 3 it updates the coefficient H*EL0 in the diagonal
! matrix, and then computes the solution.
! communication with DSOLSS uses the following variables:
! WK    = real work space containing the inverse diagonal matrix if
!         MITER = 3 and the LU decomposition of the matrix otherwise.
!         Storage of matrix elements starts at WK(3).
!         WK also contains the following matrix-related data:
!         WK(1) = SQRT(UROUND) (not used here),
!         WK(2) = HL0, the previous value of H*EL0, used if MITER = 3.
! IWK   = integer work space for matrix-related data, assumed to
!         be equivalenced to WK.  In addition, WK(IPRSP) and IWK(IPISP)
!         are assumed to have identical locations.
! X     = the right-hand side vector on input, and the solution vector
!         on output, of length N.
! TEM   = vector of work space of length N, not used in this version.
! IERSL = output flag (in Common).
!         IERSL = 0  if no trouble occurred.
!         IERSL = -1 if CDRV returned an error flag (MITER = 1 or 2).
!                    This should never occur and is considered fatal.
!         IERSL = 1  if a singular matrix arose with MITER = 3.
! This routine also uses other variables in Common.
!-----------------------------------------------------------------------
      IERSL = 0
      GO TO (100, 100, 300), MITER
 100  CALL CDRV (N,IWK(IPR),IWK(IPC),IWK(IPIC),IWK(IPIAN),IWK(IPJAN), &
     &   WK(IPA),X,X,NSP,IWK(IPISP),WK(IPRSP),IESP,4,IERSL)
      IF (IERSL .NE. 0) IERSL = -1
      RETURN
!
 300  PHL0 = WK(2)
      HL0 = H*EL0
      WK(2) = HL0
      IF (HL0 .EQ. PHL0) GO TO 330
      R = HL0/PHL0
      DO 320 I = 1,N
        DI = 1.0D0 - R*(1.0D0 - 1.0D0/WK(I+2))
        IF (ABS(DI) .EQ. 0.0D0) GO TO 390
 320    WK(I+2) = 1.0D0/DI
 330  DO 340 I = 1,N
 340    X(I) = WK(I+2)*X(I)
      RETURN
 390  IERSL = 1
      RETURN
!
!----------------------- END OF SUBR. DSOLSS ----------------------
      END
!
!*DECK DSRCMS
      SUBROUTINE DSRCMS (RSAV, ISAV, JOB)
!-----------------------------------------------------------------------
! This routine saves or restores (depending on JOB) the contents of
! the Common blocks DLS001, DLSS01, which are used
! internally by one or more ODEPACK solvers.
!
! RSAV = real array of length 224 or more.
! ISAV = integer array of length 71 or more.
! JOB  = flag indicating to save or restore the Common blocks:
!        JOB  = 1 if Common is to be saved (written to RSAV/ISAV)
!        JOB  = 2 if Common is to be restored (read from RSAV/ISAV)
!        A call with JOB = 2 presumes a prior call with JOB = 1.
!-----------------------------------------------------------------------
      INTEGER ISAV, JOB
      INTEGER ILS, ILSS
      INTEGER I, LENILS, LENISS, LENRLS, LENRSS
      REAL*8 RSAV,   RLS, RLSS
      DIMENSION RSAV(*), ISAV(*)
      SAVE LENRLS, LENILS, LENRSS, LENISS
      COMMON /DLS001/ RLS(218), ILS(37)
      COMMON /DLSS01/ RLSS(6), ILSS(34)
      DATA LENRLS/218/, LENILS/37/, LENRSS/6/, LENISS/34/
!
      IF (JOB .EQ. 2) GO TO 100
      DO 10 I = 1,LENRLS
 10     RSAV(I) = RLS(I)
      DO 15 I = 1,LENRSS
 15     RSAV(LENRLS+I) = RLSS(I)
!
      DO 20 I = 1,LENILS
 20     ISAV(I) = ILS(I)
      DO 25 I = 1,LENISS
 25     ISAV(LENILS+I) = ILSS(I)
!
      RETURN
!
 100  CONTINUE
      DO 110 I = 1,LENRLS
 110     RLS(I) = RSAV(I)
      DO 115 I = 1,LENRSS
 115     RLSS(I) = RSAV(LENRLS+I)
!
      DO 120 I = 1,LENILS
 120     ILS(I) = ISAV(I)
      DO 125 I = 1,LENISS
 125     ILSS(I) = ISAV(LENILS+I)
!
      RETURN
!----------------------- END OF SUBR. DSRCMS ----------------------
      END
!
!*DECK ODRV
      SUBROUtine ODRV                                                   &
     &     (n, ia,ja,a, p,ip, nsp,isp, path, flag)
!                                                                 5/2/83
!***********************************************************************
!  ODRV -- driver for sparse matrix reordering routines
!***********************************************************************
!
!  description
!
!    ODRV finds a minimum degree ordering of the rows and columns
!    of a matrix m stored in (ia,ja,a) format (see below).  for the
!    reordered matrix, the work and storage required to perform
!    gaussian elimination is (usually) significantly less.
!
!    note.. ODRV and its subordinate routines have been modified to
!    compute orderings for general matrices, not necessarily having any
!    symmetry.  the miminum degree ordering is computed for the
!    structure of the symmetric matrix  m + m-transpose.
!    modifications to the original ODRV module have been made in
!    the coding in subroutine mdi, and in the initial comments in
!    subroutines ODRV and md.
!
!    if only the nonzero entries in the upper triangle of m are being
!    stored, then ODRV symmetrically reorders (ia,ja,a), (optionally)
!    with the diagonal entries placed first in each row.  this is to
!    ensure that if m(i,j) will be in the upper triangle of m with
!    respect to the new ordering, then m(i,j) is stored in row i (and
!    thus m(j,i) is not stored),  whereas if m(i,j) will be in the
!    strict lower triangle of m, then m(j,i) is stored in row j (and
!    thus m(i,j) is not stored).
!
!
!  storage of sparse matrices
!
!    the nonzero entries of the matrix m are stored row-by-row in the
!    array a.  to identify the individual nonzero entries in each row,
!    we need to know in which column each entry lies.  these column
!    indices are stored in the array ja.  i.e., if  a(k) = m(i,j),  then
!    ja(k) = j.  to identify the individual rows, we need to know where
!    each row starts.  these row pointers are stored in the array ia.
!    i.e., if m(i,j) is the first nonzero entry (stored) in the i-th row
!    and  a(k) = m(i,j),  then  ia(i) = k.  moreover, ia(n+1) points to
!    the first location following the last element in the last row.
!    thus, the number of entries in the i-th row is  ia(i+1) - ia(i),
!    the nonzero entries in the i-th row are stored consecutively in
!
!            a(ia(i)),  a(ia(i)+1),  ..., a(ia(i+1)-1),
!
!    and the corresponding column indices are stored consecutively in
!
!            ja(ia(i)), ja(ia(i)+1), ..., ja(ia(i+1)-1).
!
!    when the coefficient matrix is symmetric, only the nonzero entries
!    in the upper triangle need be stored.  for example, the matrix
!
!             ( 1  0  2  3  0 )
!             ( 0  4  0  0  0 )
!         m = ( 2  0  5  6  0 )
!             ( 3  0  6  7  8 )
!             ( 0  0  0  8  9 )
!
!    could be stored as
!
!            - 1  2  3  4  5  6  7  8  9 10 11 12 13
!         ---+--------------------------------------
!         ia - 1  4  5  8 12 14
!         ja - 1  3  4  2  1  3  4  1  3  4  5  4  5
!          a - 1  2  3  4  2  5  6  3  6  7  8  8  9
!
!    or (symmetrically) as
!
!            - 1  2  3  4  5  6  7  8  9
!         ---+--------------------------
!         ia - 1  4  5  7  9 10
!         ja - 1  3  4  2  3  4  4  5  5
!          a - 1  2  3  4  5  6  7  8  9          .
!
!
!  parameters
!
!    n    - order of the matrix
!
!    ia   - integer one-dimensional array containing pointers to delimit
!           rows in ja and a.  dimension = n+1
!
!    ja   - integer one-dimensional array containing the column indices
!           corresponding to the elements of a.  dimension = number of
!           nonzero entries in (the upper triangle of) m
!
!    a    - real one-dimensional array containing the nonzero entries in
!           (the upper triangle of) m, stored by rows.  dimension =
!           number of nonzero entries in (the upper triangle of) m
!
!    p    - integer one-dimensional array used to return the permutation
!           of the rows and columns of m corresponding to the minimum
!           degree ordering.  dimension = n
!
!    ip   - integer one-dimensional array used to return the inverse of
!           the permutation returned in p.  dimension = n
!
!    nsp  - declared dimension of the one-dimensional array isp.  nsp
!           must be at least  3n+4k,  where k is the number of nonzeroes
!           in the strict upper triangle of m
!
!    isp  - integer one-dimensional array used for working storage.
!           dimension = nsp
!
!    path - integer path specification.  values and their meanings are -
!             1  find minimum degree ordering only
!             2  find minimum degree ordering and reorder symmetrically
!                  stored matrix (used when only the nonzero entries in
!                  the upper triangle of m are being stored)
!             3  reorder symmetrically stored matrix as specified by
!                  input permutation (used when an ordering has already
!                  been determined and only the nonzero entries in the
!                  upper triangle of m are being stored)
!             4  same as 2 but put diagonal entries at start of each row
!             5  same as 3 but put diagonal entries at start of each row
!
!    flag - integer error flag.  values and their meanings are -
!               0    no errors detected
!              9n+k  insufficient storage in md
!             10n+1  insufficient storage in ODRV
!             11n+1  illegal path specification
!
!
!  conversion from real to real*8
!
!    change the real declarations in ODRV and sro to real*8
!    declarations.
!
!-----------------------------------------------------------------------
!
      integer  ia(*), ja(*),  p(*), ip(*),  isp(*),  path,  flag,       &
     &   v, l, head,  tmp, q
!...  real  a(*)
      real*8  a(*)
      logical  dflag
!
!----initialize error flag and validate path specification
      flag = 0
      if (path.lt.1 .or. 5.lt.path)  go to 111
!
!----allocate storage and find minimum degree ordering
      if ((path-1) * (path-2) * (path-4) .ne. 0)  go to 1
        max = (nsp-n)/2
        v    = 1
        l    = v     +  max
        head = l     +  max
        next = head  +  n
        if (max.lt.n)  go to 110
!
        call  md                                                        &
     &     (n, ia,ja, max,isp(v),isp(l), isp(head),p,ip, isp(v), flag)
        if (flag.ne.0)  go to 100
!
!----allocate storage and symmetrically reorder matrix
   1  if ((path-2) * (path-3) * (path-4) * (path-5) .ne. 0)  go to 2
        tmp = (nsp+1) -      n
        q   = tmp     - (ia(n+1)-1)
        if (q.lt.1)  go to 110
!
        dflag = path.eq.4 .or. path.eq.5
        call sro                                                        &
     &     (n,  ip,  ia, ja, a,  isp(tmp),  isp(q),  dflag)
!
   2  return
!
! ** error -- error detected in md
 100  return
! ** error -- insufficient storage
 110  flag = 10*n + 1
      return
! ** error -- illegal path specified
 111  flag = 11*n + 1
      return
      END
!
      SUBROUtine md                                                     &
     &     (n, ia,ja, max, v,l, head,last,next, mark, flag)
!***********************************************************************
!  md -- minimum degree algorithm (based on element model)
!***********************************************************************
!
!  description
!
!    md finds a minimum degree ordering of the rows and columns of a
!    general sparse matrix m stored in (ia,ja,a) format.
!    when the structure of m is nonsymmetric, the ordering is that
!    obtained for the symmetric matrix  m + m-transpose.
!
!
!  additional parameters
!
!    max  - declared dimension of the one-dimensional arrays v and l.
!           max must be at least  n+2k,  where k is the number of
!           nonzeroes in the strict upper triangle of m + m-transpose
!
!    v    - integer one-dimensional work array.  dimension = max
!
!    l    - integer one-dimensional work array.  dimension = max
!
!    head - integer one-dimensional work array.  dimension = n
!
!    last - integer one-dimensional array used to return the permutation
!           of the rows and columns of m corresponding to the minimum
!           degree ordering.  dimension = n
!
!    next - integer one-dimensional array used to return the inverse of
!           the permutation returned in last.  dimension = n
!
!    mark - integer one-dimensional work array (may be the same as v).
!           dimension = n
!
!    flag - integer error flag.  values and their meanings are -
!             0     no errors detected
!             9n+k  insufficient storage in md
!
!
!  definitions of internal parameters
!
!    ---------+---------------------------------------------------------
!    v(s)     - value field of list entry
!    ---------+---------------------------------------------------------
!    l(s)     - link field of list entry  (0 =) end of list)
!    ---------+---------------------------------------------------------
!    l(vi)    - pointer to element list of uneliminated vertex vi
!    ---------+---------------------------------------------------------
!    l(ej)    - pointer to boundary list of active element ej
!    ---------+---------------------------------------------------------
!    head(d)  - vj =) vj head of d-list d
!             -  0 =) no vertex in d-list d
!
!
!             -                  vi uneliminated vertex
!             -          vi in ek           -       vi not in ek
!    ---------+-----------------------------+---------------------------
!    next(vi) - undefined but nonnegative   - vj =) vj next in d-list
!             -                             -  0 =) vi tail of d-list
!    ---------+-----------------------------+---------------------------
!    last(vi) - (not set until mdp)         - -d =) vi head of d-list d
!             --vk =) compute degree        - vj =) vj last in d-list
!             - ej =) vi prototype of ej    -  0 =) vi not in any d-list
!             -  0 =) do not compute degree -
!    ---------+-----------------------------+---------------------------
!    mark(vi) - mark(vk)                    - nonneg. tag .lt. mark(vk)
!
!
!             -                   vi eliminated vertex
!             -      ei active element      -           otherwise
!    ---------+-----------------------------+---------------------------
!    next(vi) - -j =) vi was j-th vertex    - -j =) vi was j-th vertex
!             -       to be eliminated      -       to be eliminated
!    ---------+-----------------------------+---------------------------
!    last(vi) -  m =) size of ei = m        - undefined
!    ---------+-----------------------------+---------------------------
!    mark(vi) - -m =) overlap count of ei   - undefined
!             -       with ek = m           -
!             - otherwise nonnegative tag   -
!             -       .lt. mark(vk)         -
!
!-----------------------------------------------------------------------
!
      integer  ia(*), ja(*),  v(*), l(*),  head(*), last(*), next(*),   &
     &   mark(*),  flag,  tag, dmin, vk,ek, tail
      equivalence  (vk,ek)
!
!----initialization
      tag = 0
      call  mdi                                                         &
     &   (n, ia,ja, max,v,l, head,last,next, mark,tag, flag)
      if (flag.ne.0)  return
!
      k = 0
      dmin = 1
!
!----while  k .lt. n  do
   1  if (k.ge.n)  go to 4
!
!------search for vertex of minimum degree
   2    if (head(dmin).gt.0)  go to 3
          dmin = dmin + 1
          go to 2
!
!------remove vertex vk of minimum degree from degree list
   3    vk = head(dmin)
        head(dmin) = next(vk)
        if (head(dmin).gt.0)  last(head(dmin)) = -dmin
!
!------number vertex vk, adjust tag, and tag vk
        k = k+1
        next(vk) = -k
        last(ek) = dmin - 1
        tag = tag + last(ek)
        mark(vk) = tag
!
!------form element ek from uneliminated neighbors of vk
        call  mdm                                                       &
     &     (vk,tail, v,l, last,next, mark)
!
!------purge inactive elements and do mass elimination
        call  mdp                                                       &
     &     (k,ek,tail, v,l, head,last,next, mark)
!
!------update degrees of uneliminated vertices in ek
        call  mdu                                                       &
     &     (ek,dmin, v,l, head,last,next, mark)
!
        go to 1
!
!----generate inverse permutation from permutation
   4  do 5 k=1,n
        next(k) = -next(k)
   5    last(next(k)) = k
!
      return
      END
!
      SUBROUtine mdi                                                    &
     &     (n, ia,ja, max,v,l, head,last,next, mark,tag, flag)
!***********************************************************************
!  mdi -- initialization
!***********************************************************************
      integer  ia(*), ja(*),  v(*), l(*),  head(*), last(*), next(*),   &
     &   mark(*), tag,  flag,  sfs, vi,dvi, vj
!
!----initialize degrees, element lists, and degree lists
      do 1 vi=1,n
        mark(vi) = 1
        l(vi) = 0
   1    head(vi) = 0
      sfs = n+1
!
!----create nonzero structure
!----for each nonzero entry a(vi,vj)
      do 6 vi=1,n
        jmin = ia(vi)
        jmax = ia(vi+1) - 1
        if (jmin.gt.jmax)  go to 6
        do 5 j=jmin,jmax
          vj = ja(j)
          if (vj-vi) 2, 5, 4
!
!------if a(vi,vj) is in strict lower triangle
!------check for previous occurrence of a(vj,vi)
   2      lvk = vi
          kmax = mark(vi) - 1
          if (kmax .eq. 0) go to 4
          do 3 k=1,kmax
            lvk = l(lvk)
            if (v(lvk).eq.vj) go to 5
   3        continue
!----for unentered entries a(vi,vj)
   4        if (sfs.ge.max)  go to 101
!
!------enter vj in element list for vi
            mark(vi) = mark(vi) + 1
            v(sfs) = vj
            l(sfs) = l(vi)
            l(vi) = sfs
            sfs = sfs+1
!
!------enter vi in element list for vj
            mark(vj) = mark(vj) + 1
            v(sfs) = vi
            l(sfs) = l(vj)
            l(vj) = sfs
            sfs = sfs+1
   5      continue
   6    continue
!
!----create degree lists and initialize mark vector
      do 7 vi=1,n
        dvi = mark(vi)
        next(vi) = head(dvi)
        head(dvi) = vi
        last(vi) = -dvi
        nextvi = next(vi)
        if (nextvi.gt.0)  last(nextvi) = vi
   7    mark(vi) = tag
!
      return
!
! ** error-  insufficient storage
 101  flag = 9*n + vi
      return
      END
!
      SUBROUtine mdm                                                    &
     &     (vk,tail, v,l, last,next, mark)
!***********************************************************************
!  mdm -- form element from uneliminated neighbors of vk
!***********************************************************************
      integer  vk, tail,  v(*), l(*),   last(*), next(*),   mark(*),    &
     &   tag, s,ls,vs,es, b,lb,vb, blp,blpmax
      equivalence  (vs, es)
!
!----initialize tag and list of uneliminated neighbors
      tag = mark(vk)
      tail = vk
!
!----for each vertex/element vs/es in element list of vk
      ls = l(vk)
   1  s = ls
      if (s.eq.0)  go to 5
        ls = l(s)
        vs = v(s)
        if (next(vs).lt.0)  go to 2
!
!------if vs is uneliminated vertex, then tag and append to list of
!------uneliminated neighbors
          mark(vs) = tag
          l(tail) = s
          tail = s
          go to 4
!
!------if es is active element, then ...
!--------for each vertex vb in boundary list of element es
   2      lb = l(es)
          blpmax = last(es)
          do 3 blp=1,blpmax
            b = lb
            lb = l(b)
            vb = v(b)
!
!----------if vb is un-tagged vertex, then tag and append to list of
!----------uneliminated neighbors
            if (mark(vb).ge.tag)  go to 3
              mark(vb) = tag
              l(tail) = b
              tail = b
   3        continue
!
!--------mark es inactive
          mark(es) = tag
!
   4    go to 1
!
!----terminate list of uneliminated neighbors
   5  l(tail) = 0
!
      return
      END
!
      SUBROUtine mdp                                                    &
     &     (k,ek,tail, v,l, head,last,next, mark)
!***********************************************************************
!  mdp -- purge inactive elements and do mass elimination
!***********************************************************************
      integer  ek, tail,  v(*), l(*),  head(*), last(*), next(*),       &
     &   mark(*),  tag, free, li,vi,lvi,evi, s,ls,es, ilp,ilpmax
!
!----initialize tag
      tag = mark(ek)
!
!----for each vertex vi in ek
      li = ek
      ilpmax = last(ek)
      if (ilpmax.le.0)  go to 12
      do 11 ilp=1,ilpmax
        i = li
        li = l(i)
        vi = v(li)
!
!------remove vi from degree list
        if (last(vi).eq.0)  go to 3
          if (last(vi).gt.0)  go to 1
            head(-last(vi)) = next(vi)
            go to 2
   1        next(last(vi)) = next(vi)
   2      if (next(vi).gt.0)  last(next(vi)) = last(vi)
!
!------remove inactive items from element list of vi
   3    ls = vi
   4    s = ls
        ls = l(s)
        if (ls.eq.0)  go to 6
          es = v(ls)
          if (mark(es).lt.tag)  go to 5
            free = ls
            l(s) = l(ls)
            ls = s
   5      go to 4
!
!------if vi is interior vertex, then remove from list and eliminate
   6    lvi = l(vi)
        if (lvi.ne.0)  go to 7
          l(i) = l(li)
          li = i
!
          k = k+1
          next(vi) = -k
          last(ek) = last(ek) - 1
          go to 11
!
!------else ...
!--------classify vertex vi
   7      if (l(lvi).ne.0)  go to 9
            evi = v(lvi)
            if (next(evi).ge.0)  go to 9
              if (mark(evi).lt.0)  go to 8
!
!----------if vi is prototype vertex, then mark as such, initialize
!----------overlap count for corresponding element, and move vi to end
!----------of boundary list
                last(vi) = evi
                mark(evi) = -1
                l(tail) = li
                tail = li
                l(i) = l(li)
                li = i
                go to 10
!
!----------else if vi is duplicate vertex, then mark as such and adjust
!----------overlap count for corresponding element
   8            last(vi) = 0
                mark(evi) = mark(evi) - 1
                go to 10
!
!----------else mark vi to compute degree
   9            last(vi) = -ek
!
!--------insert ek in element list of vi
  10      v(free) = ek
          l(free) = l(vi)
          l(vi) = free
  11    continue
!
!----terminate boundary list
  12  l(tail) = 0
!
      return
      END
!
      SUBROUtine mdu                                                    &
     &     (ek,dmin, v,l, head,last,next, mark)
!***********************************************************************
!  mdu -- update degrees of uneliminated vertices in ek
!***********************************************************************
      integer  ek, dmin,  v(*), l(*),  head(*), last(*), next(*),       &
     &   mark(*),  tag, vi,evi,dvi, s,vs,es, b,vb, ilp,ilpmax,          &
     &   blp,blpmax
      equivalence  (vs, es)
!
!----initialize tag
      tag = mark(ek) - last(ek)
!
!----for each vertex vi in ek
      i = ek
      ilpmax = last(ek)
      if (ilpmax.le.0)  go to 11
      do 10 ilp=1,ilpmax
        i = l(i)
        vi = v(i)
        if (last(vi))  1, 10, 8
!
!------if vi neither prototype nor duplicate vertex, then merge elements
!------to compute degree
   1      tag = tag + 1
          dvi = last(ek)
!
!--------for each vertex/element vs/es in element list of vi
          s = l(vi)
   2      s = l(s)
          if (s.eq.0)  go to 9
            vs = v(s)
            if (next(vs).lt.0)  go to 3
!
!----------if vs is uneliminated vertex, then tag and adjust degree
              mark(vs) = tag
              dvi = dvi + 1
              go to 5
!
!----------if es is active element, then expand
!------------check for outmatched vertex
   3          if (mark(es).lt.0)  go to 6
!
!------------for each vertex vb in es
              b = es
              blpmax = last(es)
              do 4 blp=1,blpmax
                b = l(b)
                vb = v(b)
!
!--------------if vb is un-tagged, then tag and adjust degree
                if (mark(vb).ge.tag)  go to 4
                  mark(vb) = tag
                  dvi = dvi + 1
   4            continue
!
   5        go to 2
!
!------else if vi is outmatched vertex, then adjust overlaps but do not
!------compute degree
   6      last(vi) = 0
          mark(es) = mark(es) - 1
   7      s = l(s)
          if (s.eq.0)  go to 10
            es = v(s)
            if (mark(es).lt.0)  mark(es) = mark(es) - 1
            go to 7
!
!------else if vi is prototype vertex, then calculate degree by
!------inclusion/exclusion and reset overlap count
   8      evi = last(vi)
          dvi = last(ek) + last(evi) + mark(evi)
          mark(evi) = 0
!
!------insert vi in appropriate degree list
   9    next(vi) = head(dvi)
        head(dvi) = vi
        last(vi) = -dvi
        if (next(vi).gt.0)  last(next(vi)) = vi
        if (dvi.lt.dmin)  dmin = dvi
!
  10    continue
!
  11  return
      END
!
      SUBROUtine sro                                                    &
     &     (n, ip, ia,ja,a, q, r, dflag)
!***********************************************************************
!  sro -- symmetric reordering of sparse symmetric matrix
!***********************************************************************
!
!  description
!
!    the nonzero entries of the matrix m are assumed to be stored
!    symmetrically in (ia,ja,a) format (i.e., not both m(i,j) and m(j,i)
!    are stored if i ne j).
!
!    sro does not rearrange the order of the rows, but does move
!    nonzeroes from one row to another to ensure that if m(i,j) will be
!    in the upper triangle of m with respect to the new ordering, then
!    m(i,j) is stored in row i (and thus m(j,i) is not stored),  whereas
!    if m(i,j) will be in the strict lower triangle of m, then m(j,i) is
!    stored in row j (and thus m(i,j) is not stored).
!
!
!  additional parameters
!
!    q     - integer one-dimensional work array.  dimension = n
!
!    r     - integer one-dimensional work array.  dimension = number of
!            nonzero entries in the upper triangle of m
!
!    dflag - logical variable.  if dflag = .true., then store nonzero
!            diagonal elements at the beginning of the row
!
!-----------------------------------------------------------------------
!
      integer  ip(*),  ia(*), ja(*),  q(*), r(*)
!...  real  a(*),  ak
      real*8  a(*),  ak
      logical  dflag
!
!
!--phase 1 -- find row in which to store each nonzero
!----initialize count of nonzeroes to be stored in each row
      do 1 i=1,n
  1     q(i) = 0
!
!----for each nonzero element a(j)
      do 3 i=1,n
        jmin = ia(i)
        jmax = ia(i+1) - 1
        if (jmin.gt.jmax)  go to 3
        do 2 j=jmin,jmax
!
!--------find row (=r(j)) and column (=ja(j)) in which to store a(j) ...
          k = ja(j)
          if (ip(k).lt.ip(i))  ja(j) = i
          if (ip(k).ge.ip(i))  k = i
          r(j) = k
!
!--------... and increment count of nonzeroes (=q(r(j)) in that row
  2       q(k) = q(k) + 1
  3     continue
!
!
!--phase 2 -- find new ia and permutation to apply to (ja,a)
!----determine pointers to delimit rows in permuted (ja,a)
      do 4 i=1,n
        ia(i+1) = ia(i) + q(i)
  4     q(i) = ia(i+1)
!
!----determine where each (ja(j),a(j)) is stored in permuted (ja,a)
!----for each nonzero element (in reverse order)
      ilast = 0
      jmin = ia(1)
      jmax = ia(n+1) - 1
      j = jmax
      do 6 jdummy=jmin,jmax
        i = r(j)
        if (.not.dflag .or. ja(j).ne.i .or. i.eq.ilast)  go to 5
!
!------if dflag, then put diagonal nonzero at beginning of row
          r(j) = ia(i)
          ilast = i
          go to 6
!
!------put (off-diagonal) nonzero in last unused location in row
  5       q(i) = q(i) - 1
          r(j) = q(i)
!
  6     j = j-1
!
!
!--phase 3 -- permute (ja,a) to upper triangular form (wrt new ordering)
      do 8 j=jmin,jmax
  7     if (r(j).eq.j)  go to 8
          k = r(j)
          r(j) = r(k)
          r(k) = k
          jak = ja(k)
          ja(k) = ja(j)
          ja(j) = jak
          ak = a(k)
          a(k) = a(j)
          a(j) = ak
          go to 7
  8     continue
!
      return
      END
!
!*DECK CDRV
      SUBROUtine CDRV                                                   &
     &     (n, r,c,ic, ia,ja,a, b, z, nsp,isp,rsp,esp, path, flag)
!*** subroutine CDRV
!*** driver for subroutines for solving sparse nonsymmetric systems of
!       linear equations (compressed pointer storage)
!
!
!    parameters
!    class abbreviations are--
!       n - integer variable
!       f - real variable
!       v - supplies a value to the driver
!       r - returns a result from the driver
!       i - used internally by the driver
!       a - array
!
! class - parameter
! ------+----------
!       -
!         the nonzero entries of the coefficient matrix m are stored
!    row-by-row in the array a.  to identify the individual nonzero
!    entries in each row, we need to know in which column each entry
!    lies.  the column indices which correspond to the nonzero entries
!    of m are stored in the array ja.  i.e., if  a(k) = m(i,j),  then
!    ja(k) = j.  in addition, we need to know where each row starts and
!    how long it is.  the index positions in ja and a where the rows of
!    m begin are stored in the array ia.  i.e., if m(i,j) is the first
!    nonzero entry (stored) in the i-th row and a(k) = m(i,j),  then
!    ia(i) = k.  moreover, the index in ja and a of the first location
!    following the last element in the last row is stored in ia(n+1).
!    thus, the number of entries in the i-th row is given by
!    ia(i+1) - ia(i),  the nonzero entries of the i-th row are stored
!    consecutively in
!            a(ia(i)),  a(ia(i)+1),  ..., a(ia(i+1)-1),
!    and the corresponding column indices are stored consecutively in
!            ja(ia(i)), ja(ia(i)+1), ..., ja(ia(i+1)-1).
!    for example, the 5 by 5 matrix
!                ( 1. 0. 2. 0. 0.)
!                ( 0. 3. 0. 0. 0.)
!            m = ( 0. 4. 5. 6. 0.)
!                ( 0. 0. 0. 7. 0.)
!                ( 0. 0. 0. 8. 9.)
!    would be stored as
!               - 1  2  3  4  5  6  7  8  9
!            ---+--------------------------
!            ia - 1  3  4  7  8 10
!            ja - 1  3  2  2  3  4  4  4  5
!             a - 1. 2. 3. 4. 5. 6. 7. 8. 9.         .
!
! nv    - n     - number of variables/equations.
! fva   - a     - nonzero entries of the coefficient matrix m, stored
!       -           by rows.
!       -           size = number of nonzero entries in m.
! nva   - ia    - pointers to delimit the rows in a.
!       -           size = n+1.
! nva   - ja    - column numbers corresponding to the elements of a.
!       -           size = size of a.
! fva   - b     - right-hand side b.  b and z can the same array.
!       -           size = n.
! fra   - z     - solution x.  b and z can be the same array.
!       -           size = n.
!
!         the rows and columns of the original matrix m can be
!    reordered (e.g., to reduce fillin or ensure numerical stability)
!    before calling the driver.  if no reordering is done, then set
!    r(i) = c(i) = ic(i) = i  for i=1,...,n.  the solution z is returned
!    in the original order.
!         if the columns have been reordered (i.e.,  c(i).ne.i  for some
!    i), then the driver will call a subroutine (nroc) which rearranges
!    each row of ja and a, leaving the rows in the original order, but
!    placing the elements of each row in increasing order with respect
!    to the new ordering.  if  path.ne.1,  then nroc is assumed to have
!    been called already.
!
! nva   - r     - ordering of the rows of m.
!       -           size = n.
! nva   - c     - ordering of the columns of m.
!       -           size = n.
! nva   - ic    - inverse of the ordering of the columns of m.  i.e.,
!       -           ic(c(i)) = i  for i=1,...,n.
!       -           size = n.
!
!         the solution of the system of linear equations is divided into
!    three stages --
!      nsfc -- the matrix m is processed symbolically to determine where
!               fillin will occur during the numeric factorization.
!      nnfc -- the matrix m is factored numerically into the product ldu
!               of a unit lower triangular matrix l, a diagonal matrix
!               d, and a unit upper triangular matrix u, and the system
!               mx = b  is solved.
!      nnsc -- the linear system  mx = b  is solved using the ldu
!  or           factorization from nnfc.
!      nntc -- the transposed linear system  mt x = b  is solved using
!               the ldu factorization from nnf.
!    for several systems whose coefficient matrices have the same
!    nonzero structure, nsfc need be done only once (for the first
!    system).  then nnfc is done once for each additional system.  for
!    several systems with the same coefficient matrix, nsfc and nnfc
!    need be done only once (for the first system).  then nnsc or nntc
!    is done once for each additional right-hand side.
!
! nv    - path  - path specification.  values and their meanings are --
!       -           1  perform nroc, nsfc, and nnfc.
!       -           2  perform nnfc only  (nsfc is assumed to have been
!       -               done in a manner compatible with the storage
!       -               allocation used in the driver).
!       -           3  perform nnsc only  (nsfc and nnfc are assumed to
!       -               have been done in a manner compatible with the
!       -               storage allocation used in the driver).
!       -           4  perform nntc only  (nsfc and nnfc are assumed to
!       -               have been done in a manner compatible with the
!       -               storage allocation used in the driver).
!       -           5  perform nroc and nsfc.
!
!         various errors are detected by the driver and the individual
!    subroutines.
!
! nr    - flag  - error flag.  values and their meanings are --
!       -             0     no errors detected
!       -             n+k   null row in a  --  row = k
!       -            2n+k   duplicate entry in a  --  row = k
!       -            3n+k   insufficient storage in nsfc  --  row = k
!       -            4n+1   insufficient storage in nnfc
!       -            5n+k   null pivot  --  row = k
!       -            6n+k   insufficient storage in nsfc  --  row = k
!       -            7n+1   insufficient storage in nnfc
!       -            8n+k   zero pivot  --  row = k
!       -           10n+1   insufficient storage in CDRV
!       -           11n+1   illegal path specification
!
!         working storage is needed for the factored form of the matrix
!    m plus various temporary vectors.  the arrays isp and rsp should be
!    equivalenced.  integer storage is allocated from the beginning of
!    isp and real storage from the end of rsp.
!
! nv    - nsp   - declared dimension of rsp.  nsp generally must
!       -           be larger than  8n+2 + 2k  (where  k = (number of
!       -           nonzero entries in m)).
! nvira - isp   - integer working storage divided up into various arrays
!       -           needed by the subroutines.  isp and rsp should be
!       -           equivalenced.
!       -           size = lratio*nsp.
! fvira - rsp   - real working storage divided up into various arrays
!       -           needed by the subroutines.  isp and rsp should be
!       -           equivalenced.
!       -           size = nsp.
! nr    - esp   - if sufficient storage was available to perform the
!       -           symbolic factorization (nsfc), then esp is set to
!       -           the amount of excess storage provided (negative if
!       -           insufficient storage was available to perform the
!       -           numeric factorization (nnfc)).
!
!
!  conversion to real*8
!
!    to convert these routines for real*8 arrays..
!    (1) use the real*8 declarations in place of the real
!    declarations in each subprogram, as given in comment cards.
!    (2) change the data-loaded value of the integer  lratio
!    in subroutine CDRV, as indicated below.
!    (3) change e0 to d0 in the constants in statement number 10
!    in subroutine nnfc and the line following that.
!
      integer  r(*), c(*), ic(*),  ia(*), ja(*),  isp(*), esp,  path,   &
     &   flag,  d, u, q, row, tmp, ar,  umax
!     real  a(*), b(*), z(*), rsp(*)
      real*8  a(*), b(*), z(*), rsp(*)
!
!  set lratio equal to the ratio between the length of floating point
!  and integer array data.  e. g., lratio = 1 for (real, integer),
!  lratio = 2 for (real*8, integer)
!
      data lratio/2/
!
      if (path.lt.1 .or. 5.lt.path)  go to 111
!******initialize and divide up temporary storage  *******************
      il   = 1
      ijl  = il  + (n+1)
      iu   = ijl +   n
      iju  = iu  + (n+1)
      irl  = iju +   n
      jrl  = irl +   n
      jl   = jrl +   n
!
!  ******  reorder a if necessary, call nsfc if flag is set  ***********
      if ((path-1) * (path-5) .ne. 0)  go to 5
        max = (lratio*nsp + 1 - jl) - (n+1) - 5*n
        jlmax = max/2
        q     = jl   + jlmax
        ira   = q    + (n+1)
        jra   = ira  +   n
        irac  = jra  +   n
        iru   = irac +   n
        jru   = iru  +   n
        jutmp = jru  +   n
        jumax = lratio*nsp  + 1 - jutmp
        esp = max/lratio
        if (jlmax.le.0 .or. jumax.le.0)  go to 110
!
        do 1 i=1,n
          if (c(i).ne.i)  go to 2
    1     continue
        go to 3
    2   ar = nsp + 1 - n
        call  nroc                                                      &
     &     (n, ic, ia,ja,a, isp(il), rsp(ar), isp(iu), flag)
        if (flag.ne.0)  go to 100
!
    3   call  nsfc     &
     &     (n, r, ic, ia,ja,                                            &
     &      jlmax, isp(il), isp(jl), isp(ijl),                          &
     &      jumax, isp(iu), isp(jutmp), isp(iju),                       &
     &      isp(q), isp(ira), isp(jra), isp(irac),                      &
     &      isp(irl), isp(jrl), isp(iru), isp(jru),  flag)
        if(flag .ne. 0)  go to 100
!  ******  move ju next to jl  *****************************************
        jlmax = isp(ijl+n-1)
        ju    = jl + jlmax
        jumax = isp(iju+n-1)
        if (jumax.le.0)  go to 5
        do 4 j=1,jumax
   4      isp(ju+j-1) = isp(jutmp+j-1)
!
!  ******  call remaining subroutines  *********************************
   5  jlmax = isp(ijl+n-1)
      ju    = jl  + jlmax
      jumax = isp(iju+n-1)
      l     = (ju + jumax - 2 + lratio)  /  lratio    +    1
      lmax  = isp(il+n) - 1
      d     = l   + lmax
      u     = d   + n
      row   = nsp + 1 - n
      tmp   = row - n
      umax  = tmp - u
      esp   = umax - (isp(iu+n) - 1)
!
      if ((path-1) * (path-2) .ne. 0)  go to 6
        if (umax.lt.0)  go to 110
        call nnfc                                                       &
     &     (n,  r, c, ic,  ia, ja, a, z, b,                             &
     &      lmax, isp(il), isp(jl), isp(ijl), rsp(l),  rsp(d),          &
     &      umax, isp(iu), isp(ju), isp(iju), rsp(u),                   &
     &      rsp(row), rsp(tmp),  isp(irl), isp(jrl),  flag)
        if(flag .ne. 0)  go to 100
!
   6  if ((path-3) .ne. 0)  go to 7
        call nnsc                                                       &
     &     (n,  r, c,  isp(il), isp(jl), isp(ijl), rsp(l),              &
     &      rsp(d),    isp(iu), isp(ju), isp(iju), rsp(u),              &
     &      z, b,  rsp(tmp))
!
   7  if ((path-4) .ne. 0)  go to 8
        call nntc                                                       &
     &     (n,  r, c,  isp(il), isp(jl), isp(ijl), rsp(l),              &
     &      rsp(d),    isp(iu), isp(ju), isp(iju), rsp(u),              &
     &      z, b,  rsp(tmp))
   8  return
!
! ** error.. error detected in nroc, nsfc, nnfc, or nnsc
 100  return
! ** error.. insufficient storage
 110  flag = 10*n + 1
      return
! ** error.. illegal path specification
 111  flag = 11*n + 1
      return
      END
!
      SUBROUtine nroc (n, ic, ia, ja, a, jar, ar, p, flag)
!
!       ----------------------------------------------------------------
!
!               yale sparse matrix package - nonsymmetric codes
!                    solving the system of equations mx = b
!
!    i.   calling sequences
!         the coefficient matrix can be processed by an ordering routine
!    (e.g., to reduce fillin or ensure numerical stability) before using
!    the remaining subroutines.  if no reordering is done, then set
!    r(i) = c(i) = ic(i) = i  for i=1,...,n.  if an ordering subroutine
!    is used, then nroc should be used to reorder the coefficient matrix
!    the calling sequence is --
!        (       (matrix ordering))
!        (nroc   (matrix reordering))
!         nsfc   (symbolic factorization to determine where fillin will
!                  occur during numeric factorization)
!         nnfc   (numeric factorization into product ldu of unit lower
!                  triangular matrix l, diagonal matrix d, and unit
!                  upper triangular matrix u, and solution of linear
!                  system)
!         nnsc   (solution of linear system for additional right-hand
!                  side using ldu factorization from nnfc)
!    (if only one system of equations is to be solved, then the
!    subroutine trk should be used.)
!
!    ii.  storage of sparse matrices
!         the nonzero entries of the coefficient matrix m are stored
!    row-by-row in the array a.  to identify the individual nonzero
!    entries in each row, we need to know in which column each entry
!    lies.  the column indices which correspond to the nonzero entries
!    of m are stored in the array ja.  i.e., if  a(k) = m(i,j),  then
!    ja(k) = j.  in addition, we need to know where each row starts and
!    how long it is.  the index positions in ja and a where the rows of
!    m begin are stored in the array ia.  i.e., if m(i,j) is the first
!    (leftmost) entry in the i-th row and  a(k) = m(i,j),  then
!    ia(i) = k.  moreover, the index in ja and a of the first location
!    following the last element in the last row is stored in ia(n+1).
!    thus, the number of entries in the i-th row is given by
!    ia(i+1) - ia(i),  the nonzero entries of the i-th row are stored
!    consecutively in
!            a(ia(i)),  a(ia(i)+1),  ..., a(ia(i+1)-1),
!    and the corresponding column indices are stored consecutively in
!            ja(ia(i)), ja(ia(i)+1), ..., ja(ia(i+1)-1).
!    for example, the 5 by 5 matrix
!                ( 1. 0. 2. 0. 0.)
!                ( 0. 3. 0. 0. 0.)
!            m = ( 0. 4. 5. 6. 0.)
!                ( 0. 0. 0. 7. 0.)
!                ( 0. 0. 0. 8. 9.)
!    would be stored as
!               - 1  2  3  4  5  6  7  8  9
!            ---+--------------------------
!            ia - 1  3  4  7  8 10
!            ja - 1  3  2  2  3  4  4  4  5
!             a - 1. 2. 3. 4. 5. 6. 7. 8. 9.         .
!
!         the strict upper (lower) triangular portion of the matrix
!    u (l) is stored in a similar fashion using the arrays  iu, ju, u
!    (il, jl, l)  except that an additional array iju (ijl) is used to
!    compress storage of ju (jl) by allowing some sequences of column
!    (row) indices to used for more than one row (column)  (n.b., l is
!    stored by columns).  iju(k) (ijl(k)) points to the starting
!    location in ju (jl) of entries for the kth row (column).
!    compression in ju (jl) occurs in two ways.  first, if a row
!    (column) i was merged into the current row (column) k, and the
!    number of elements merged in from (the tail portion of) row
!    (column) i is the same as the final length of row (column) k, then
!    the kth row (column) and the tail of row (column) i are identical
!    and iju(k) (ijl(k)) points to the start of the tail.  second, if
!    some tail portion of the (k-1)st row (column) is identical to the
!    head of the kth row (column), then iju(k) (ijl(k)) points to the
!    start of that tail portion.  for example, the nonzero structure of
!    the strict upper triangular part of the matrix
!            d 0 x x x
!            0 d 0 x x
!            0 0 d x 0
!            0 0 0 d x
!            0 0 0 0 d
!    would be represented as
!                - 1 2 3 4 5 6
!            ----+------------
!             iu - 1 4 6 7 8 8
!             ju - 3 4 5 4
!            iju - 1 2 4 3           .
!    the diagonal entries of l and u are assumed to be equal to one and
!    are not stored.  the array d contains the reciprocals of the
!    diagonal entries of the matrix d.
!
!    iii. additional storage savings
!         in nsfc, r and ic can be the same array in the calling
!    sequence if no reordering of the coefficient matrix has been done.
!         in nnfc, r, c, and ic can all be the same array if no
!    reordering has been done.  if only the rows have been reordered,
!    then c and ic can be the same array.  if the row and column
!    orderings are the same, then r and c can be the same array.  z and
!    row can be the same array.
!         in nnsc or nntc, r and c can be the same array if no
!    reordering has been done or if the row and column orderings are the
!    same.  z and b can be the same array.  however, then b will be
!    destroyed.
!
!    iv.  parameters
!         following is a list of parameters to the programs.  names are
!    uniform among the various subroutines.  class abbreviations are --
!       n - integer variable
!       f - real variable
!       v - supplies a value to a subroutine
!       r - returns a result from a subroutine
!       i - used internally by a subroutine
!       a - array
!
! class - parameter
! ------+----------
! fva   - a     - nonzero entries of the coefficient matrix m, stored
!       -           by rows.
!       -           size = number of nonzero entries in m.
! fva   - b     - right-hand side b.
!       -           size = n.
! nva   - c     - ordering of the columns of m.
!       -           size = n.
! fvra  - d     - reciprocals of the diagonal entries of the matrix d.
!       -           size = n.
! nr    - flag  - error flag.  values and their meanings are --
!       -            0     no errors detected
!       -            n+k   null row in a  --  row = k
!       -           2n+k   duplicate entry in a  --  row = k
!       -           3n+k   insufficient storage for jl  --  row = k
!       -           4n+1   insufficient storage for l
!       -           5n+k   null pivot  --  row = k
!       -           6n+k   insufficient storage for ju  --  row = k
!       -           7n+1   insufficient storage for u
!       -           8n+k   zero pivot  --  row = k
! nva   - ia    - pointers to delimit the rows of a.
!       -           size = n+1.
! nvra  - ijl   - pointers to the first element in each column in jl,
!       -           used to compress storage in jl.
!       -           size = n.
! nvra  - iju   - pointers to the first element in each row in ju, used
!       -           to compress storage in ju.
!       -           size = n.
! nvra  - il    - pointers to delimit the columns of l.
!       -           size = n+1.
! nvra  - iu    - pointers to delimit the rows of u.
!       -           size = n+1.
! nva   - ja    - column numbers corresponding to the elements of a.
!       -           size = size of a.
! nvra  - jl    - row numbers corresponding to the elements of l.
!       -           size = jlmax.
! nv    - jlmax - declared dimension of jl.  jlmax must be larger than
!       -           the number of nonzeros in the strict lower triangle
!       -           of m plus fillin minus compression.
! nvra  - ju    - column numbers corresponding to the elements of u.
!       -           size = jumax.
! nv    - jumax - declared dimension of ju.  jumax must be larger than
!       -           the number of nonzeros in the strict upper triangle
!       -           of m plus fillin minus compression.
! fvra  - l     - nonzero entries in the strict lower triangular portion
!       -           of the matrix l, stored by columns.
!       -           size = lmax.
! nv    - lmax  - declared dimension of l.  lmax must be larger than
!       -           the number of nonzeros in the strict lower triangle
!       -           of m plus fillin  (il(n+1)-1 after nsfc).
! nv    - n     - number of variables/equations.
! nva   - r     - ordering of the rows of m.
!       -           size = n.
! fvra  - u     - nonzero entries in the strict upper triangular portion
!       -           of the matrix u, stored by rows.
!       -           size = umax.
! nv    - umax  - declared dimension of u.  umax must be larger than
!       -           the number of nonzeros in the strict upper triangle
!       -           of m plus fillin  (iu(n+1)-1 after nsfc).
! fra   - z     - solution x.
!       -           size = n.
!
!       ----------------------------------------------------------------
!
!*** subroutine nroc
!*** reorders rows of a, leaving row order unchanged
!
!
!       input parameters.. n, ic, ia, ja, a
!       output parameters.. ja, a, flag
!
!       parameters used internally..
! nia   - p     - at the kth step, p is a linked list of the reordered
!       -           column indices of the kth row of a.  p(n+1) points
!       -           to the first entry in the list.
!       -           size = n+1.
! nia   - jar   - at the kth step,jar contains the elements of the
!       -           reordered column indices of a.
!       -           size = n.
! fia   - ar    - at the kth step, ar contains the elements of the
!       -           reordered row of a.
!       -           size = n.
!
      integer  ic(*), ia(*), ja(*), jar(*), p(*), flag
!     real  a(*), ar(*)
      real*8  a(*), ar(*)
!
!  ******  for each nonempty row  *******************************
      do 5 k=1,n
        jmin = ia(k)
        jmax = ia(k+1) - 1
        if(jmin .gt. jmax) go to 5
        p(n+1) = n + 1
!  ******  insert each element in the list  *********************
        do 3 j=jmin,jmax
          newj = ic(ja(j))
          i = n + 1
   1      if(p(i) .ge. newj) go to 2
            i = p(i)
            go to 1
   2      if(p(i) .eq. newj) go to 102
          p(newj) = p(i)
          p(i) = newj
          jar(newj) = ja(j)
          ar(newj) = a(j)
   3      continue
!  ******  replace old row in ja and a  *************************
        i = n + 1
        do 4 j=jmin,jmax
          i = p(i)
          ja(j) = jar(i)
   4      a(j) = ar(i)
   5    continue
      flag = 0
      return
!
! ** error.. duplicate entry in a
 102  flag = n + k
      return
      END
!
      SUBROUtine nsfc                                                   &
     &      (n, r, ic, ia,ja, jlmax,il,jl,ijl, jumax,iu,ju,iju,         &
     &       q, ira,jra, irac, irl,jrl, iru,jru, flag)
!*** subroutine nsfc
!*** symbolic ldu-factorization of nonsymmetric sparse matrix
!      (compressed pointer storage)
!
!
!       input variables.. n, r, ic, ia, ja, jlmax, jumax.
!       output variables.. il, jl, ijl, iu, ju, iju, flag.
!
!       parameters used internally..
! nia   - q     - suppose  m*  is the result of reordering  m.  if
!       -           processing of the ith row of  m*  (hence the ith
!       -           row of  u) is being done,  q(j)  is initially
!       -           nonzero if  m*(i,j) is nonzero (j.ge.i).  since
!       -           values need not be stored, each entry points to the
!       -           next nonzero and  q(n+1)  points to the first.  n+1
!       -           indicates the end of the list.  for example, if n=9
!       -           and the 5th row of  m*  is
!       -              0 x x 0 x 0 0 x 0
!       -           then  q  will initially be
!       -              a a a a 8 a a 10 5           (a - arbitrary).
!       -           as the algorithm proceeds, other elements of  q
!       -           are inserted in the list because of fillin.
!       -           q  is used in an analogous manner to compute the
!       -           ith column of  l.
!       -           size = n+1.
! nia   - ira,  - vectors used to find the columns of  m.  at the kth
! nia   - jra,      step of the factorization,  irac(k)  points to the
! nia   - irac      head of a linked list in  jra  of row indices i
!       -           such that i .ge. k and  m(i,k)  is nonzero.  zero
!       -           indicates the end of the list.  ira(i)  (i.ge.k)
!       -           points to the smallest j such that j .ge. k and
!       -           m(i,j)  is nonzero.
!       -           size of each = n.
! nia   - irl,  - vectors used to find the rows of  l.  at the kth step
! nia   - jrl       of the factorization,  jrl(k)  points to the head
!       -           of a linked list in  jrl  of column indices j
!       -           such j .lt. k and  l(k,j)  is nonzero.  zero
!       -           indicates the end of the list.  irl(j)  (j.lt.k)
!       -           points to the smallest i such that i .ge. k and
!       -           l(i,j)  is nonzero.
!       -           size of each = n.
! nia   - iru,  - vectors used in a manner analogous to  irl and jrl
! nia   - jru       to find the columns of  u.
!       -           size of each = n.
!
!  internal variables..
!    jlptr - points to the last position used in  jl.
!    juptr - points to the last position used in  ju.
!    jmin,jmax - are the indices in  a or u  of the first and last
!                elements to be examined in a given row.
!                for example,  jmin=ia(k), jmax=ia(k+1)-1.
!
      integer cend, qm, rend, rk, vj
      integer ia(*), ja(*), ira(*), jra(*), il(*), jl(*), ijl(*)
      integer iu(*), ju(*), iju(*), irl(*), jrl(*), iru(*), jru(*)
      integer r(*), ic(*), q(*), irac(*), flag
!
!  ******  initialize pointers  ****************************************
      np1 = n + 1
      jlmin = 1
      jlptr = 0
      il(1) = 1
      jumin = 1
      juptr = 0
      iu(1) = 1
      do 1 k=1,n
        irac(k) = 0
        jra(k) = 0
        jrl(k) = 0
   1    jru(k) = 0
!  ******  initialize column pointers for a  ***************************
      do 2 k=1,n
        rk = r(k)
        iak = ia(rk)
        if (iak .ge. ia(rk+1))  go to 101
        jaiak = ic(ja(iak))
        if (jaiak .gt. k)  go to 105
        jra(k) = irac(jaiak)
        irac(jaiak) = k
   2    ira(k) = iak
!
!  ******  for each column of l and row of u  **************************
      do 41 k=1,n
!
!  ******  initialize q for computing kth column of l  *****************
        q(np1) = np1
        luk = -1
!  ******  by filling in kth column of a  ******************************
        vj = irac(k)
        if (vj .eq. 0)  go to 5
   3      qm = np1
   4      m = qm
          qm =  q(m)
          if (qm .lt. vj)  go to 4
          if (qm .eq. vj)  go to 102
            luk = luk + 1
            q(m) = vj
            q(vj) = qm
            vj = jra(vj)
            if (vj .ne. 0)  go to 3
!  ******  link through jru  *******************************************
   5    lastid = 0
        lasti = 0
        ijl(k) = jlptr
        i = k
   6      i = jru(i)
          if (i .eq. 0)  go to 10
          qm = np1
          jmin = irl(i)
          jmax = ijl(i) + il(i+1) - il(i) - 1
          long = jmax - jmin
          if (long .lt. 0)  go to 6
          jtmp = jl(jmin)
          if (jtmp .ne. k)  long = long + 1
          if (jtmp .eq. k)  r(i) = -r(i)
          if (lastid .ge. long)  go to 7
            lasti = i
            lastid = long
!  ******  and merge the corresponding columns into the kth column  ****
   7      do 9 j=jmin,jmax
            vj = jl(j)
   8        m = qm
            qm = q(m)
            if (qm .lt. vj)  go to 8
            if (qm .eq. vj)  go to 9
              luk = luk + 1
              q(m) = vj
              q(vj) = qm
              qm = vj
   9        continue
            go to 6
!  ******  lasti is the longest column merged into the kth  ************
!  ******  see if it equals the entire kth column  *********************
  10    qm = q(np1)
        if (qm .ne. k)  go to 105
        if (luk .eq. 0)  go to 17
        if (lastid .ne. luk)  go to 11
!  ******  if so, jl can be compressed  ********************************
        irll = irl(lasti)
        ijl(k) = irll + 1
        if (jl(irll) .ne. k)  ijl(k) = ijl(k) - 1
        go to 17
!  ******  if not, see if kth column can overlap the previous one  *****
  11    if (jlmin .gt. jlptr)  go to 15
        qm = q(qm)
        do 12 j=jlmin,jlptr
          if (jl(j) - qm)  12, 13, 15
  12      continue
        go to 15
  13    ijl(k) = j
        do 14 i=j,jlptr
          if (jl(i) .ne. qm)  go to 15
          qm = q(qm)
          if (qm .gt. n)  go to 17
  14      continue
        jlptr = j - 1
!  ******  move column indices from q to jl, update vectors  ***********
  15    jlmin = jlptr + 1
        ijl(k) = jlmin
        if (luk .eq. 0)  go to 17
        jlptr = jlptr + luk
        if (jlptr .gt. jlmax)  go to 103
          qm = q(np1)
          do 16 j=jlmin,jlptr
            qm = q(qm)
  16        jl(j) = qm
  17    irl(k) = ijl(k)
        il(k+1) = il(k) + luk
!
!  ******  initialize q for computing kth row of u  ********************
        q(np1) = np1
        luk = -1
!  ******  by filling in kth row of reordered a  ***********************
        rk = r(k)
        jmin = ira(k)
        jmax = ia(rk+1) - 1
        if (jmin .gt. jmax)  go to 20
        do 19 j=jmin,jmax
          vj = ic(ja(j))
          qm = np1
  18      m = qm
          qm = q(m)
          if (qm .lt. vj)  go to 18
          if (qm .eq. vj)  go to 102
            luk = luk + 1
            q(m) = vj
            q(vj) = qm
  19      continue
!  ******  link through jrl,  ******************************************
  20    lastid = 0
        lasti = 0
        iju(k) = juptr
        i = k
        i1 = jrl(k)
  21      i = i1
          if (i .eq. 0)  go to 26
          i1 = jrl(i)
          qm = np1
          jmin = iru(i)
          jmax = iju(i) + iu(i+1) - iu(i) - 1
          long = jmax - jmin
          if (long .lt. 0)  go to 21
          jtmp = ju(jmin)
          if (jtmp .eq. k)  go to 22
!  ******  update irl and jrl, *****************************************
            long = long + 1
            cend = ijl(i) + il(i+1) - il(i)
            irl(i) = irl(i) + 1
            if (irl(i) .ge. cend)  go to 22
              j = jl(irl(i))
              jrl(i) = jrl(j)
              jrl(j) = i
  22      if (lastid .ge. long)  go to 23
            lasti = i
            lastid = long
!  ******  and merge the corresponding rows into the kth row  **********
  23      do 25 j=jmin,jmax
            vj = ju(j)
  24        m = qm
            qm = q(m)
            if (qm .lt. vj)  go to 24
            if (qm .eq. vj)  go to 25
              luk = luk + 1
              q(m) = vj
              q(vj) = qm
              qm = vj
  25        continue
          go to 21
!  ******  update jrl(k) and irl(k)  ***********************************
  26    if (il(k+1) .le. il(k))  go to 27
          j = jl(irl(k))
          jrl(k) = jrl(j)
          jrl(j) = k
!  ******  lasti is the longest row merged into the kth  ***************
!  ******  see if it equals the entire kth row  ************************
  27    qm = q(np1)
        if (qm .ne. k)  go to 105
        if (luk .eq. 0)  go to 34
        if (lastid .ne. luk)  go to 28
!  ******  if so, ju can be compressed  ********************************
        irul = iru(lasti)
        iju(k) = irul + 1
        if (ju(irul) .ne. k)  iju(k) = iju(k) - 1
        go to 34
!  ******  if not, see if kth row can overlap the previous one  ********
  28    if (jumin .gt. juptr)  go to 32
        qm = q(qm)
        do 29 j=jumin,juptr
          if (ju(j) - qm)  29, 30, 32
  29      continue
        go to 32
  30    iju(k) = j
        do 31 i=j,juptr
          if (ju(i) .ne. qm)  go to 32
          qm = q(qm)
          if (qm .gt. n)  go to 34
  31      continue
        juptr = j - 1
!  ******  move row indices from q to ju, update vectors  **************
  32    jumin = juptr + 1
        iju(k) = jumin
        if (luk .eq. 0)  go to 34
        juptr = juptr + luk
        if (juptr .gt. jumax)  go to 106
          qm = q(np1)
          do 33 j=jumin,juptr
            qm = q(qm)
  33        ju(j) = qm
  34    iru(k) = iju(k)
        iu(k+1) = iu(k) + luk
!
!  ******  update iru, jru  ********************************************
        i = k
  35      i1 = jru(i)
          if (r(i) .lt. 0)  go to 36
          rend = iju(i) + iu(i+1) - iu(i)
          if (iru(i) .ge. rend)  go to 37
            j = ju(iru(i))
            jru(i) = jru(j)
            jru(j) = i
            go to 37
  36      r(i) = -r(i)
  37      i = i1
          if (i .eq. 0)  go to 38
          iru(i) = iru(i) + 1
          go to 35
!
!  ******  update ira, jra, irac  **************************************
  38    i = irac(k)
        if (i .eq. 0)  go to 41
  39      i1 = jra(i)
          ira(i) = ira(i) + 1
          if (ira(i) .ge. ia(r(i)+1))  go to 40
          irai = ira(i)
          jairai = ic(ja(irai))
          if (jairai .gt. i)  go to 40
          jra(i) = irac(jairai)
          irac(jairai) = i
  40      i = i1
          if (i .ne. 0)  go to 39
  41    continue
!
      ijl(n) = jlptr
      iju(n) = juptr
      flag = 0
      return
!
! ** error.. null row in a
 101  flag = n + rk
      return
! ** error.. duplicate entry in a
 102  flag = 2*n + rk
      return
! ** error.. insufficient storage for jl
 103  flag = 3*n + k
      return
! ** error.. null pivot
 105  flag = 5*n + k
      return
! ** error.. insufficient storage for ju
 106  flag = 6*n + k
      return
      END
!
      SUBROUtine nnfc                                                   &
     &     (n, r,c,ic, ia,ja,a, z, b,                                   &
     &      lmax,il,jl,ijl,l, d, umax,iu,ju,iju,u,                      &
     &      row, tmp, irl,jrl, flag)
!*** subroutine nnfc
!*** numerical ldu-factorization of sparse nonsymmetric matrix and
!      solution of system of linear equations (compressed pointer
!      storage)
!
!
!       input variables..  n, r, c, ic, ia, ja, a, b,
!                          il, jl, ijl, lmax, iu, ju, iju, umax
!       output variables.. z, l, d, u, flag
!
!       parameters used internally..
! nia   - irl,  - vectors used to find the rows of  l.  at the kth step
! nia   - jrl       of the factorization,  jrl(k)  points to the head
!       -           of a linked list in  jrl  of column indices j
!       -           such j .lt. k and  l(k,j)  is nonzero.  zero
!       -           indicates the end of the list.  irl(j)  (j.lt.k)
!       -           points to the smallest i such that i .ge. k and
!       -           l(i,j)  is nonzero.
!       -           size of each = n.
! fia   - row   - holds intermediate values in calculation of  u and l.
!       -           size = n.
! fia   - tmp   - holds new right-hand side  b*  for solution of the
!       -           equation ux = b*.
!       -           size = n.
!
!  internal variables..
!    jmin, jmax - indices of the first and last positions in a row to
!      be examined.
!    sum - used in calculating  tmp.
!
      integer rk,umax
      integer  r(*), c(*), ic(*), ia(*), ja(*), il(*), jl(*), ijl(*)
      integer  iu(*), ju(*), iju(*), irl(*), jrl(*), flag
!     real  a(*), l(*), d(*), u(*), z(*), b(*), row(*)
!     real tmp(*), lki, sum, dk
      real*8  a(*), l(*), d(*), u(*), z(*), b(*), row(*)
      real*8  tmp(*), lki, sum, dk
!
!  ******  initialize pointers and test storage  ***********************
      if(il(n+1)-1 .gt. lmax) go to 104
      if(iu(n+1)-1 .gt. umax) go to 107
      do 1 k=1,n
        irl(k) = il(k)
        jrl(k) = 0
   1    continue
!
!  ******  for each row  ***********************************************
      do 19 k=1,n
!  ******  reverse jrl and zero row where kth row of l will fill in  ***
        row(k) = 0
        i1 = 0
        if (jrl(k) .eq. 0) go to 3
        i = jrl(k)
   2    i2 = jrl(i)
        jrl(i) = i1
        i1 = i
        row(i) = 0
        i = i2
        if (i .ne. 0) go to 2
!  ******  set row to zero where u will fill in  ***********************
   3    jmin = iju(k)
        jmax = jmin + iu(k+1) - iu(k) - 1
        if (jmin .gt. jmax) go to 5
        do 4 j=jmin,jmax
   4      row(ju(j)) = 0
!  ******  place kth row of a in row  **********************************
   5    rk = r(k)
        jmin = ia(rk)
        jmax = ia(rk+1) - 1
        do 6 j=jmin,jmax
          row(ic(ja(j))) = a(j)
   6      continue
!  ******  initialize sum, and link through jrl  ***********************
        sum = b(rk)
        i = i1
        if (i .eq. 0) go to 10
!  ******  assign the kth row of l and adjust row, sum  ****************
   7      lki = -row(i)
!  ******  if l is not required, then comment out the following line  **
          l(irl(i)) = -lki
          sum = sum + lki * tmp(i)
          jmin = iu(i)
          jmax = iu(i+1) - 1
          if (jmin .gt. jmax) go to 9
          mu = iju(i) - jmin
          do 8 j=jmin,jmax
   8        row(ju(mu+j)) = row(ju(mu+j)) + lki * u(j)
   9      i = jrl(i)
          if (i .ne. 0) go to 7
!
!  ******  assign kth row of u and diagonal d, set tmp(k)  *************
  10    if (row(k) .eq. 0.0d0) go to 108
        dk = 1.0d0 / row(k)
        d(k) = dk
        tmp(k) = sum * dk
        if (k .eq. n) go to 19
        jmin = iu(k)
        jmax = iu(k+1) - 1
        if (jmin .gt. jmax)  go to 12
        mu = iju(k) - jmin
        do 11 j=jmin,jmax
  11      u(j) = row(ju(mu+j)) * dk
  12    continue
!
!  ******  update irl and jrl, keeping jrl in decreasing order  ********
        i = i1
        if (i .eq. 0) go to 18
  14    irl(i) = irl(i) + 1
        i1 = jrl(i)
        if (irl(i) .ge. il(i+1)) go to 17
        ijlb = irl(i) - il(i) + ijl(i)
        j = jl(ijlb)
  15    if (i .gt. jrl(j)) go to 16
          j = jrl(j)
          go to 15
  16    jrl(i) = jrl(j)
        jrl(j) = i
  17    i = i1
        if (i .ne. 0) go to 14
  18    if (irl(k) .ge. il(k+1)) go to 19
        j = jl(ijl(k))
        jrl(k) = jrl(j)
        jrl(j) = k
  19    continue
!
!  ******  solve  ux = tmp  by back substitution  **********************
      k = n
      do 22 i=1,n
        sum =  tmp(k)
        jmin = iu(k)
        jmax = iu(k+1) - 1
        if (jmin .gt. jmax)  go to 21
        mu = iju(k) - jmin
        do 20 j=jmin,jmax
  20      sum = sum - u(j) * tmp(ju(mu+j))
  21    tmp(k) =  sum
        z(c(k)) =  sum
  22    k = k-1
      flag = 0
      return
!
! ** error.. insufficient storage for l
 104  flag = 4*n + 1
      return
! ** error.. insufficient storage for u
 107  flag = 7*n + 1
      return
! ** error.. zero pivot
 108  flag = 8*n + k
      return
      END
!
      SUBROUtine nnsc                                                   &
     &     (n, r, c, il, jl, ijl, l, d, iu, ju, iju, u, z, b, tmp)
!*** subroutine nnsc
!*** numerical solution of sparse nonsymmetric system of linear
!      equations given ldu-factorization (compressed pointer storage)
!
!
!       input variables..  n, r, c, il, jl, ijl, l, d, iu, ju, iju, u, b
!       output variables.. z
!
!       parameters used internally..
! fia   - tmp   - temporary vector which gets result of solving  ly = b.
!       -           size = n.
!
!  internal variables..
!    jmin, jmax - indices of the first and last positions in a row of
!      u or l  to be used.
!
      integer r(*), c(*), il(*), jl(*), ijl(*), iu(*), ju(*), iju(*)
!     real l(*), d(*), u(*), b(*), z(*), tmp(*), tmpk, sum
      real*8  l(*), d(*), u(*), b(*), z(*), tmp(*), tmpk,sum
!
!  ******  set tmp to reordered b  *************************************
      do 1 k=1,n
   1    tmp(k) = b(r(k))
!  ******  solve  ly = b  by forward substitution  *********************
      do 3 k=1,n
        jmin = il(k)
        jmax = il(k+1) - 1
        tmpk = -d(k) * tmp(k)
        tmp(k) = -tmpk
        if (jmin .gt. jmax) go to 3
        ml = ijl(k) - jmin
        do 2 j=jmin,jmax
   2      tmp(jl(ml+j)) = tmp(jl(ml+j)) + tmpk * l(j)
   3    continue
!  ******  solve  ux = y  by back substitution  ************************
      k = n
      do 6 i=1,n
        sum = -tmp(k)
        jmin = iu(k)
        jmax = iu(k+1) - 1
        if (jmin .gt. jmax) go to 5
        mu = iju(k) - jmin
        do 4 j=jmin,jmax
   4      sum = sum + u(j) * tmp(ju(mu+j))
   5    tmp(k) = -sum
        z(c(k)) = -sum
        k = k - 1
   6    continue
      return
      END
!
      SUBROUtine nntc                                                   &
     &     (n, r, c, il, jl, ijl, l, d, iu, ju, iju, u, z, b, tmp)
!*** subroutine nntc
!*** numeric solution of the transpose of a sparse nonsymmetric system
!      of linear equations given lu-factorization (compressed pointer
!      storage)
!
!
!       input variables..  n, r, c, il, jl, ijl, l, d, iu, ju, iju, u, b
!       output variables.. z
!
!       parameters used internally..
! fia   - tmp   - temporary vector which gets result of solving ut y = b
!       -           size = n.
!
!  internal variables..
!    jmin, jmax - indices of the first and last positions in a row of
!      u or l  to be used.
!
      integer r(*), c(*), il(*), jl(*), ijl(*), iu(*), ju(*), iju(*)
!     real l(*), d(*), u(*), b(*), z(*), tmp(*), tmpk,sum
      real*8 l(*), d(*), u(*), b(*), z(*), tmp(*), tmpk,sum
!
!  ******  set tmp to reordered b  *************************************
      do 1 k=1,n
   1    tmp(k) = b(c(k))
!  ******  solve  ut y = b  by forward substitution  *******************
      do 3 k=1,n
        jmin = iu(k)
        jmax = iu(k+1) - 1
        tmpk = -tmp(k)
        if (jmin .gt. jmax) go to 3
        mu = iju(k) - jmin
        do 2 j=jmin,jmax
   2      tmp(ju(mu+j)) = tmp(ju(mu+j)) + tmpk * u(j)
   3    continue
!  ******  solve  lt x = y  by back substitution  **********************
      k = n
      do 6 i=1,n
        sum = -tmp(k)
        jmin = il(k)
        jmax = il(k+1) - 1
        if (jmin .gt. jmax) go to 5
        ml = ijl(k) - jmin
        do 4 j=jmin,jmax
   4      sum = sum + l(j) * tmp(jl(ml+j))
   5    tmp(k) = -sum * d(k)
        z(r(k)) = tmp(k)
        k = k - 1
   6    continue
      return
      END
!
!*DECK XERRWD
      SUBROUTINE XERRWD (MSG, NMES, NERR, LEVEL, NI                     &
     &             , I1, I2, NR, R1, R2)
!***BEGIN PROLOGUE  XERRWD
!***SUBSIDIARY
!***PURPOSE  Write error message with values.
!***CATEGORY  R3C
!***TYPE      REAL*8 (XERRWV-S, XERRWD-D)
!***AUTHOR  Hindmarsh, Alan C., (LLNL)
!***DESCRIPTION
!
!  Subroutines XERRWD, XSETF, XSETUN, and the function routine IXSAV,
!  as given here, constitute a simplified version of the SLATEC error
!  handling package.
!
!  All arguments are input arguments.
!
!  MSG    = The message (character array).
!  NMES   = The length of MSG (number of characters).
!  NERR   = The error number (not used).
!  LEVEL  = The error level..
!           0 or 1 means recoverable (control returns to caller).
!           2 means fatal (run is aborted--see note below).
!  NI     = Number of integers (0, 1, or 2) to be printed with message.
!  I1,I2  = Integers to be printed, depending on NI.
!  NR     = Number of reals (0, 1, or 2) to be printed with message.
!  R1,R2  = Reals to be printed, depending on NR.
!
!  Note..  this routine is machine-dependent and specialized for use
!  in limited context, in the following ways..
!  1. The argument MSG is assumed to be of type CHARACTER, and
!     the message is printed with a format of (1X,A).
!  2. The message is assumed to take only one line.
!     Multi-line messages are generated by repeated calls.
!  3. If LEVEL = 2, control passes to the statement   STOP
!     to abort the run.  This statement may be machine-dependent.
!  4. R1 and R2 are assumed to be in real*8 and are printed
!     in D21.13 format.
!
!***ROUTINES CALLED  IXSAV
!***REVISION HISTORY  (YYMMDD)
!   920831  DATE WRITTEN
!   921118  Replaced MFLGSV/LUNSAV by IXSAV. (ACH)
!   930329  Modified prologue to SLATEC format. (FNF)
!   930407  Changed MSG from CHARACTER*1 array to variable. (FNF)
!   930922  Minor cosmetic change. (FNF)
!***END PROLOGUE  XERRWD
!
!*Internal Notes:
!
! For a different default logical unit number, IXSAV (or a subsidiary
! routine that it calls) will need to be modified.
! For a different run-abort command, change the statement following
! statement 100 at the end.
!-----------------------------------------------------------------------
! Subroutines called by XERRWD.. None
! Function routine called by XERRWD.. IXSAV
!-----------------------------------------------------------------------
!**End
!
!  Declare arguments.
!
      REAL*8 R1, R2
      INTEGER NMES, NERR, LEVEL, NI, I1, I2, NR
      CHARACTER*(*) MSG
!
!  Declare local variables.
!
      INTEGER LUNIT, IXSAV, MESFLG
!
!  Get logical unit number and message print flag.
!
!***FIRST EXECUTABLE STATEMENT  XERRWD
      LUNIT = IXSAV (1, 0, .FALSE.)
      MESFLG = IXSAV (2, 0, .FALSE.)
      IF (MESFLG .EQ. 0) GO TO 100
!
!  Write the message.
!
      WRITE (LUNIT,10)  MSG
 10   FORMAT(1X,A)
      IF (NI .EQ. 1) WRITE (LUNIT, 20) I1
 20   FORMAT(6X,'In above message,  I1 =',I10)
      IF (NI .EQ. 2) WRITE (LUNIT, 30) I1,I2
 30   FORMAT(6X,'In above message,  I1 =',I10,3X,'I2 =',I10)
      IF (NR .EQ. 1) WRITE (LUNIT, 40) R1
 40   FORMAT(6X,'In above message,  R1 =',D21.13)
      IF (NR .EQ. 2) WRITE (LUNIT, 50) R1,R2
 50   FORMAT(6X,'In above,  R1 =',D21.13,3X,'R2 =',D21.13)
!
!  Abort the run if LEVEL = 2.
!
 100  IF (LEVEL .NE. 2) RETURN
      close(31)
      STOP
!----------------------- END OF SUBR. XERRWD ----------------------
      END
!
!*DECK XSETF
      SUBROUTINE XSETF (MFLAG)
!***BEGIN PROLOGUE  XSETF
!***PURPOSE  Reset the error print control flag.
!***CATEGORY  R3A
!***TYPE      ALL (XSETF-A)
!***KEYWORDS  ERROR CONTROL
!***AUTHOR  Hindmarsh, Alan C., (LLNL)
!***DESCRIPTION
!
!   XSETF sets the error print control flag to MFLAG:
!      MFLAG=1 means print all messages (the default).
!      MFLAG=0 means no printing.
!
!***SEE ALSO  XERRWD, XERRWV
!***REFERENCES  (NONE)
!***ROUTINES CALLED  IXSAV
!***REVISION HISTORY  (YYMMDD)
!   921118  DATE WRITTEN
!   930329  Added SLATEC format prologue. (FNF)
!   930407  Corrected SEE ALSO section. (FNF)
!   930922  Made user-callable, and other cosmetic changes. (FNF)
!***END PROLOGUE  XSETF
!
! Subroutines called by XSETF.. None
! Function routine called by XSETF.. IXSAV
!-----------------------------------------------------------------------
!**End
      INTEGER MFLAG, JUNK, IXSAV
!
!***FIRST EXECUTABLE STATEMENT  XSETF
      IF (MFLAG .EQ. 0 .OR. MFLAG .EQ. 1) JUNK = IXSAV (2,MFLAG,.TRUE.)
      RETURN
!----------------------- END OF SUBR. XSETF -----------------------
      END
!
!*DECK XSETUN
      SUBROUTINE XSETUN (LUN)
!***BEGIN PROLOGUE  XSETUN
!***PURPOSE  Reset the logical unit number for error messages.
!***CATEGORY  R3B
!***TYPE      ALL (XSETUN-A)
!***KEYWORDS  ERROR CONTROL
!***DESCRIPTION
!
!   XSETUN sets the logical unit number for error messages to LUN.
!
!***AUTHOR  Hindmarsh, Alan C., (LLNL)
!***SEE ALSO  XERRWD, XERRWV
!***REFERENCES  (NONE)
!***ROUTINES CALLED  IXSAV
!***REVISION HISTORY  (YYMMDD)
!   921118  DATE WRITTEN
!   930329  Added SLATEC format prologue. (FNF)
!   930407  Corrected SEE ALSO section. (FNF)
!   930922  Made user-callable, and other cosmetic changes. (FNF)
!***END PROLOGUE  XSETUN
!
! Subroutines called by XSETUN.. None
! Function routine called by XSETUN.. IXSAV
!-----------------------------------------------------------------------
!**End
      INTEGER LUN, JUNK, IXSAV
!
!***FIRST EXECUTABLE STATEMENT  XSETUN
      IF (LUN .GT. 0) JUNK = IXSAV (1,LUN,.TRUE.)
      RETURN
!----------------------- END OF SUBR. XSETUN ----------------------
      END
!
!*DECK DUMACH
      REAL*8 FUNCTION DUMACH ()
!***BEGIN PROLOGUE  DUMACH
!***PURPOSE  Compute the unit roundoff of the machine.
!***CATEGORY  R1
!***TYPE      REAL*8 (RUMACH-S, DUMACH-D)
!***KEYWORDS  MACHINE CONSTANTS
!***AUTHOR  Hindmarsh, Alan C., (LLNL)
!***DESCRIPTION
! *Usage:
!        REAL*8  A, DUMACH
!        A = DUMACH()
!
! *Function Return Values:
!     A : the unit roundoff of the machine.
!
! *Description:
!     The unit roundoff is defined as the smallest positive machine
!     number u such that  1.0 + u .ne. 1.0.  This is computed by DUMACH
!     in a machine-independent manner.
!
!***REFERENCES  (NONE)
!***ROUTINES CALLED  DUMSUM
!***REVISION HISTORY  (YYYYMMDD)
!   19930216  DATE WRITTEN
!   19930818  Added SLATEC-format prologue.  (FNF)
!   20030707  Added DUMSUM to force normal storage of COMP.  (ACH)
!***END PROLOGUE  DUMACH
!
      REAL*8 U, COMP, ONE
!***FIRST EXECUTABLE STATEMENT  DUMACH
      ONE=1.0D0
      U = 1.0D0
 10   U = U*0.5D0
      CALL DUMSUM(ONE, U, COMP)
      IF (COMP .NE. 1.0D0) GO TO 10
!
      DUMACH = U*2.0D0
! foregoing def. of DUMACH can sometimes lead to "divide-by-zero"
! failures; therefore increasing DUMACH by factor 1000.:
!     DUMACH = U*2.0D3
! ...doesn't help! restoring original setting!
!
      RETURN
!----------------------- End of Function DUMACH ------------------------
      END
      SUBROUTINE DUMSUM(A,B,C)
!     Routine to force normal storing of A + B, for DUMACH.
      REAL*8 A, B, C
      C = A + B
      RETURN
      END
!
!*DECK DVNORM
      REAL*8 FUNCTION DVNORM (N, V, W)
!***BEGIN PROLOGUE  DVNORM
!***SUBSIDIARY
!***PURPOSE  Weighted root-mean-square vector norm.
!***TYPE      REAL*8 (SVNORM-S, DVNORM-D)
!***AUTHOR  Hindmarsh, Alan C., (LLNL)
!***DESCRIPTION
!
!  This function routine computes the weighted root-mean-square norm
!  of the vector of length N contained in the array V, with weights
!  contained in the array W of length N:
!    DVNORM = SQRT( (1/N) * SUM( V(i)*W(i) )**2 )
!
!***SEE ALSO  DLSODE
!***ROUTINES CALLED  (NONE)
!***REVISION HISTORY  (YYMMDD)
!   791129  DATE WRITTEN
!   890501  Modified prologue to SLATEC/LDOC format.  (FNF)
!   890503  Minor cosmetic changes.  (FNF)
!   930809  Renamed to allow single/real*8 versions. (ACH)
!***END PROLOGUE  DVNORM
!**End
      INTEGER N,   I
      REAL*8 V, W,   SUM
      DIMENSION V(N), W(N)
!
!***FIRST EXECUTABLE STATEMENT  DVNORM
      SUM = 0.0D0
      DO 10 I = 1,N
 10     SUM = SUM + (V(I)*W(I))**2
      DVNORM = SQRT(SUM/N)
      RETURN
!----------------------- END OF FUNCTION DVNORM ------------------------
      END
!
!*DECK IXSAV
      INTEGER FUNCTION IXSAV (IPAR, IVALUE, ISET)
!***BEGIN PROLOGUE  IXSAV
!***SUBSIDIARY
!***PURPOSE  Save and recall error message control parameters.
!***CATEGORY  R3C
!***TYPE      ALL (IXSAV-A)
!***AUTHOR  Hindmarsh, Alan C., (LLNL)
!***DESCRIPTION
!
!  IXSAV saves and recalls one of two error message parameters:
!    LUNIT, the logical unit number to which messages are printed, and
!    MESFLG, the message print flag.
!  This is a modification of the SLATEC library routine J4SAVE.
!
!  Saved local variables..
!   LUNIT  = Logical unit number for messages.  The default is obtained
!            by a call to IUMACH (may be machine-dependent).
!   MESFLG = Print control flag..
!            1 means print all messages (the default).
!            0 means no printing.
!
!  On input..
!    IPAR   = Parameter indicator (1 for LUNIT, 2 for MESFLG).
!    IVALUE = The value to be set for the parameter, if ISET = .TRUE.
!    ISET   = Logical flag to indicate whether to read or write.
!             If ISET = .TRUE., the parameter will be given
!             the value IVALUE.  If ISET = .FALSE., the parameter
!             will be unchanged, and IVALUE is a dummy argument.
!
!  On return..
!    IXSAV = The (old) value of the parameter.
!
!***SEE ALSO  XERRWD, XERRWV
!***ROUTINES CALLED  IUMACH
!***REVISION HISTORY  (YYMMDD)
!   921118  DATE WRITTEN
!   930329  Modified prologue to SLATEC format. (FNF)
!   930915  Added IUMACH call to get default output unit.  (ACH)
!   930922  Minor cosmetic changes. (FNF)
!   010425  Type declaration for IUMACH added. (ACH)
!***END PROLOGUE  IXSAV
!
! Subroutines called by IXSAV.. None
! Function routine called by IXSAV.. IUMACH
!-----------------------------------------------------------------------
!**End
      LOGICAL ISET
      INTEGER IPAR, IVALUE
!-----------------------------------------------------------------------
      INTEGER IUMACH, LUNIT, MESFLG
!-----------------------------------------------------------------------
! The following Fortran-77 declaration is to cause the values of the
! listed (local) variables to be saved between calls to this routine.
!-----------------------------------------------------------------------
      SAVE LUNIT, MESFLG
      DATA LUNIT/-1/, MESFLG/1/
!
!***FIRST EXECUTABLE STATEMENT  IXSAV
      IF (IPAR .EQ. 1) THEN
        IF (LUNIT .EQ. -1) LUNIT = IUMACH()
        IXSAV = LUNIT
        IF (ISET) LUNIT = IVALUE
        ENDIF
!
      IF (IPAR .EQ. 2) THEN
        IXSAV = MESFLG
        IF (ISET) MESFLG = IVALUE
        ENDIF
!
      RETURN
!----------------------- End of Function IXSAV -------------------------
      END
!
!*DECK IUMACH
      INTEGER FUNCTION IUMACH()
!***BEGIN PROLOGUE  IUMACH
!***PURPOSE  Provide standard output unit number.
!***CATEGORY  R1
!***TYPE      INTEGER (IUMACH-I)
!***KEYWORDS  MACHINE CONSTANTS
!***AUTHOR  Hindmarsh, Alan C., (LLNL)
!***DESCRIPTION
! *Usage:
!        INTEGER  LOUT, IUMACH
!        LOUT = IUMACH()
!
! *Function Return Values:
!     LOUT : the standard logical unit for Fortran output.
!
!***REFERENCES  (NONE)
!***ROUTINES CALLED  (NONE)
!***REVISION HISTORY  (YYMMDD)
!   930915  DATE WRITTEN
!   930922  Made user-callable, and other cosmetic changes. (FNF)
!***END PROLOGUE  IUMACH
!
!*Internal Notes:
!  The built-in value of 6 is standard on a wide range of Fortran
!  systems.  This may be machine-dependent.
!**End
!***FIRST EXECUTABLE STATEMENT  IUMACH
      IUMACH = 6
!
      RETURN
!----------------------- End of Function IUMACH ------------------------
      END
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
! FINISHED: DLSODES PACKAGE
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
